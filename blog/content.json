{"meta":{"title":"Hepsilion","subtitle":"Hepsilion的博客","description":"Hepsilion的博客","author":"Hepsilion","url":"https://hepsilion.github.io"},"pages":[{"title":"About","date":"2017-05-29T07:13:28.924Z","updated":"2017-04-12T15:14:25.000Z","comments":true,"path":"about/index.html","permalink":"https://hepsilion.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2017-06-01T12:36:04.113Z","updated":"2017-06-01T12:36:04.113Z","comments":true,"path":"home/index.html","permalink":"https://hepsilion.github.io/home/index.html","excerpt":"","text":"博客说明目前本博客主要记录了我前一段时间在牛客网刷题过程中遇到的一些知识点，包含：我经常出错的、我认为易错的、我经常做到的、我容易忘记的题目，以及为保持内容相对完整性而加入的内容等。部分内容均来自牛客网中题目下方别人的评论，部分内容来自于网络上别人的博客，还有一部分内容来自书籍。 由于本人水平有限，目前该博客中的内容相对简单，未来我希望能够加入一些具有更多价值含量的东西，例如机器学习、深度学习或者比较酷炫的项目说明等。如果朋友你觉得下面的内容都太简单的话，还请多多包涵。 由于时间原因，我只是加之前记录的东西添加在该博客当中，而没有检查所有内容的正确性与完整性。如果有人在看下面这些知识点的过程中，发现存在错误的地方，还请帮忙指正，谢谢。 内容分类1. 计算机基础 数据结构 已整理 操作系统 计算机网络 已整理 计算机组成原理 数据库系统概念 已整理 Linux 软件工程 软件测试 信息安全 2. 算法算法 3. Java基础 已整理 01-Java概述 02-基础语法 03-面向对象编程 04-异常处理 05-数组 06-常用类 07-容器 08-流 09-多线程 10-网络编程 11-反射 12-JDBC Java基础全部 4. Java WebJava Web 5. C/C++C/C++ 6. 环境配置环境配置 并发设计模式"},{"title":"Categories","date":"2017-05-28T07:45:09.167Z","updated":"2017-04-12T15:14:25.000Z","comments":true,"path":"categories/index.html","permalink":"https://hepsilion.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-05-28T07:45:09.170Z","updated":"2017-04-12T15:14:25.000Z","comments":true,"path":"tags/index.html","permalink":"https://hepsilion.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Docker-Hadoop-Helloworld","slug":"Docker-Hadoop-Helloworld","date":"2017-05-28T14:48:12.000Z","updated":"2017-05-28T14:49:46.120Z","comments":true,"path":"2017/05/28/Docker-Hadoop-Helloworld/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/Docker-Hadoop-Helloworld/","excerpt":"使用Docker在本地搭建Hadoop分布式集群本文档参考http://tashan10.com/yong-dockerda-jian-hadoopwei-fen-bu-shi-ji-qun/。","text":"使用Docker在本地搭建Hadoop分布式集群本文档参考http://tashan10.com/yong-dockerda-jian-hadoopwei-fen-bu-shi-ji-qun/。 一、 Docker安装二、构建含有Java运行环境的ubuntu镜像1. 下载ubuntu镜像使用如下命令从Docker仓库中获取ubuntu的最新镜像。 SimontekiMacBook-Pro:~ liu$ docker pull ubuntu 镜像下载完成后，使用命令docker images可以查看本地所有镜像。 SimontekiMacBook-Pro:~ liu$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest f49eec89601e 4 weeks ago 129 MB SimontekiMacBook-Pro:~ liu$ 2. 启动容器下面，我们以ubuntu镜像作为基准镜像，构建包含Java运行环境的ubuntu镜像。 先使用如下命令启动一个容器： SimontekiMacBook-Pro:~ liu$ docker run -ti ubuntu root@52573ef1de5d:/# 可以看到容器几乎瞬间就启动起来了，比虚拟机不知快了多少倍！ 3. Java安装依次执行下面命令安装Java root@52573ef1de5d:/# apt-get update root@52573ef1de5d:/# apt-get install software-properties-common python-software-properties root@52573ef1de5d:/# add-apt-repository ppa:webupd8team/java root@52573ef1de5d:/# apt-get update root@52573ef1de5d:/# apt-get install oracle-java7-installer root@52573ef1de5d:/# java -version 注意：这里安装的Java7(JDK1.7)，如需其他版本请自行修改apt-get install oracle-java7-installer命令，例如命令apt-get install oracle-java6-installer将安装JDK1.6 4. 保存镜像复本现在可以将装好Java的容器保存为一个镜像副本，将来需要的时候可以在此复本基础上构建其他镜像。 先退出上面启动的容器，将上面的容器保存为镜像ubuntu:java，然后使用docker images命令，发现ubuntu:java已保存为本地镜像。 root@52573ef1de5d:/# exit exit SimontekiMacBook-Pro:~ liu$ docker commit -m &quot;java install&quot; 52573ef1de5d ubuntu:java sha256:21716d1532e71a207cd80bcea8579e646a73d6e688ec0984562c92cdbc6296f4 SimontekiMacBook-Pro:~ liu$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu java 21716d1532e7 About a minute ago 791 MB ubuntu latest f49eec89601e 4 weeks ago 129 MB SimontekiMacBook-Pro:~ liu$ 上面命令中52573ef1de5d为之前启动的容器的ID, ubuntu:java是为复本镜像的标识，ubuntu为仓库名，java是Tag。 如何获取容器ID： 在使用到容器的ID却不知道时，可以使用下面两个方法找到容器的ID： 启动容器后，命令行中用户名@后面的那一串字符时当前启动的容器的ID，因此上面启动的容器的ID为52573ef1de5d。这个方法只在容器启动并且没有指定hostname时才能用。 使用docker ps列出所有正在运行的容器，在命令结果中查看对应容器的ID。 三、 构建含有Hadoop运行环境的ubuntu镜像下面，我们以包含Java运行环境的ubuntu镜像作为基准镜像，构建包含Hadoop运行环境的ubuntu镜像。 1. 启动容器使用刚刚已经安装了Java的容器镜像启动一个容器： SimontekiMacBook-Pro:~ liu$ docker run -ti ubuntu:java root@aac699216bce:/# 装有Java的ubuntu容器启动成功了，现在我们开始安装Hadoop。 这里，我们直接使用wget下载安装文件。 2. 安装wget使用如下命令安装wget。 root@aac699216bce:/# apt-get install -y wget 3. 下载并解压安装Hadoop文件使用如下命令下载并解压安装Hadoop。 root@aac699216bce:/# cd ~ root@aac699216bce:~# mkdir software root@aac699216bce:~# cd software root@aac699216bce:~/software# mkdir apache root@aac699216bce:~/software# cd apache/ root@aac699216bce:~/software/apache# mkdir hadoop root@aac699216bce:~/software/apache# cd hadoop/ root@aac699216bce:~/software/apache/hadoop# wget http://mirrors.sonic.net/apache/hadoop/common/hadoop-2.6.0/hadoop-2.6.0.tar.gz root@aac699216bce:~/software/apache/hadoop# tar zxvf hadoop-2.6.0.tar.gz 注意：这里我们安装的Hadoop版本是2.6.0 4. 配置环境变量由于我们使用apt-get安装java，不知道java装在什么地方，使用如下命令查看Java安装目录 root@aac699216bce:~/software/apache/hadoop# update-alternatives --config java There is only one alternative in link group java (providing /usr/bin/java): /usr/lib/jvm/java-7-oracle/jre/bin/java Nothing to configure. root@aac699216bce:~/software/apache/hadoop# 修改~/.bashrc文件，在文件末尾加入下面配置信息： export JAVA_HOME=/usr/lib/jvm/java-7-oracle export HADOOP_HOME=/root/software/apache/hadoop/hadoop-2.6.0 export HADOOP_CONFIG_HOME=$HADOOP_HOME/etc/hadoop export PATH=$PATH:$HADOOP_HOME/bin export PATH=$PATH:$HADOOP_HOME/sbin 5. 配置Hadoop下面，我们开始修改Hadoop的配置文件：core-site.xml、hdfs-site.xml、mapred-site.xml和hadoop-env.sh。 (1) 创建目录开始配置之前，执行下面命令，创建三个目录 root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0# mkdir tmp root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0# cd tmp/ root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0/tmp# pwd /root/software/apache/hadoop/hadoop-2.6.0/tmp root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0/tmp# cd .. root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0# mkdir namenode root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0# cd namenode/ root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0/namenode# pwd /root/software/apache/hadoop/hadoop-2.6.0/namenode root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0/namenode# cd .. root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0# mkdir datanode root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0# cd datanode/ root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0/datanode# pwd /root/software/apache/hadoop/hadoop-2.6.0/datanode tmp：作为Hadoop的临时目录 namenode：作为NameNode的存放目录 datanode：作为DataNode的存放目录 (2) core-site.xml配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt; &lt;!--Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file. --&gt; &lt;!-- Put site-specific property overrides in this file. --&gt; &lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/root/soft/apache/hadoop/hadoop-2.6.0/tmp&lt;/value&gt; &lt;description&gt;A base for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://master:9000&lt;/value&gt; &lt;final&gt;true&lt;/final&gt; &lt;description&gt; The name of the default file system. A URI whose scheme and authority determine the FileSystem implementation. The uri&apos;s scheme determines the config property (fs.SCHEME.impl) naming the FileSystem implementation class. The uri&apos;s authority is used to determine the host, port, etc. for a filesystem. &lt;/description&gt; &lt;/property&gt; &lt;/configuration&gt; 注意： hadoop.tmp.dir配置项值即为此前命令中创建的tmp目录路径。 fs.default.name配置为hdfs://master:9000，指向的是Master节点的主机（后续做集群配置时，需要配置这个节点，先写在这里） (3) hdfs-site.xml配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt; &lt;!-- Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file. --&gt; &lt;!-- Put site-specific property overrides in this file. --&gt; &lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;2&lt;/value&gt; &lt;final&gt;true&lt;/final&gt; &lt;description&gt;Default block replication. The actual number of replications can be specified when the file is created. The default is used if replication is not specified in create time. &lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;/root/software/apache/hadoop/hadoop-2.6.0/namenode&lt;/value&gt; &lt;final&gt;true&lt;/final&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;/root/software/apache/hadoop/hadoop-2.6.0/datanode&lt;/value&gt; &lt;final&gt;true&lt;/final&gt; &lt;/property&gt; &lt;/configuration&gt; 注意： 我们后续搭建集群环境时，将配置一个master节点和两个slave节点，所以dfs.replication配置为2。 dfs.namenode.name.dir和dfs.datanode.data.dir分别配置为之前创建的NameNode和DataNode的目录路径。 (4) mapred-site.xml配置 创建mapred-site.xml文件 cp mapred-site.xml.template mapred-site.xml 配置mapref-site.xml文件 &lt;?xml version=&quot;1.0&quot;?&gt; &lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt; &lt;!-- Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file. --&gt; &lt;!-- Put site-specific property overrides in this file. --&gt; &lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapred.job.tracker&lt;/name&gt; &lt;value&gt;master:9001&lt;/value&gt; &lt;description&gt;The host and port that the MapReduce job tracker runs at. If &quot;local&quot;, then jobs are run in-process as a single map and reduce task. &lt;/description&gt; &lt;/property&gt; &lt;/configuration&gt; 这里只有一个配置项mapred.job.tracker，我们指向master节点机器。 (5) 修改hadoop-env.sh配置修改如下配置： # The java implementation to use. export JAVA_HOME=/usr/lib/jvm/java-7-oracle 6. 安装SSH搭建集群环境，自然少不了使用SSH，这可以实现无密码访问，访问集群机器的时候很方便。 root@aac699216bce:~# apt-get install ssh 7. 生成访问密钥root@aac699216bce:~# cd ~/ root@aac699216bce:~# ssh-keygen -t rsa -P &apos;&apos; -f ~/.ssh/id_dsa Generating public/private rsa key pair. Created directory &apos;/root/.ssh&apos;. Your identification has been saved in /root/.ssh/id_dsa. Your public key has been saved in /root/.ssh/id_dsa.pub. The key fingerprint is: SHA256:SO6qH6zwvNUKDqVWDYcexe7OQBJ3Jy5vd/mZlF6FiWM root@aac699216bce The key&apos;s randomart image is: +---[RSA 2048]----+ | .. | | . .o+ . | | o++.+ . o | | ..o== . E o . | | +o+.o S o o . | | o.o * . o o . | |+.. O + . + + | |.* + * = | | B++ | +----[SHA256]-----+ root@aac699216bce:~# cd .ssh root@aac699216bce:~/.ssh# cat id_dsa.pub &gt;&gt; authorized_keys 注意： 这里思路是直接将密钥生成后写入镜像，免得在每个容器里面再单独生成一次，还要相互拷贝公钥，比较麻烦。当然这只是学习使用，实际操作时，应该不会这么搞，因为这样所有容器的密钥都是一样的！！ 8. 保存镜像我们将安装好Hadoop的镜像保存为一个镜像副本ubuntu:hadoop，然后使用docker images命令，发现ubuntu:hadoop已保存为本地镜像。 root@aac699216bce:~# exit exit SimontekiMacBook-Pro:~ liu$ docker commit -m &quot;hadoop install&quot; aac699216bce ubuntu:hadoop sha256:b6c13157056ff28c5b8703991bd1c4ba993bc7a3fae17547bff82eedae571529 SimontekiMacBook-Pro:~ liu$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu hadoop b6c13157056f 18 seconds ago 1.35 GB ubuntu java 21716d1532e7 About an hour ago 791 MB ubuntu latest f49eec89601e 4 weeks ago 129 MB 四、 搭建Hadoop分布式集群按照hadoop集群的基本要求，集群中至少需要有3个结点，其中一个为master结点，主要是用于运行hadoop集群中的namenode、secondorynamenode和jobtracker(新版本名字变了)任务；另外两个结点均为slave结点，其中一个节点作为冗余节点。 1. 启动容器打开三个命令行，每个命令行各启动一个容器，其中一个容器作为master节点，另外两个容器作为slave节点。 ####(1)启动master容器 SimontekiMacBook-Pro:~ liu$ docker run -ti -d -p 50070:50070 -h master ubuntu:hadoop d13443e6f6e3575beee69e9cc51f0569067dc0b96fb24a756578aa610ce3310c 这里使用镜像创建容器时，将容器的50070端口映射为本地的50070端口，便于后面可以直接在本地浏览器访问集群的状态。 使用docker ps查看启动的master容器对应的ID，然后使用下面命令进入master容器。 SimontekiMacBook-Pro:~ liu$ docker attach d13443e6f6e3 root@master:/# (2)启动slave1容器SimontekiMacBook-Pro:~ liu$ docker run -ti -h slave1 ubuntu:hadoop Missing privilege separation directory: /var/run/sshd root@slave1:/# (3)启动slave2容器SimontekiMacBook-Pro:~ liu$ docker run -ti -h slave2 ubuntu:hadoop Missing privilege separation directory: /var/run/sshd root@slave2:/# 2. 配置hosts(1)查看各节点ip由于在不同的网络环境下，容器获取的ip可能不一样，例如本机三个容器获取的ip分别如下： master: 172.17.0.2 slave1: 172.17.0.3 slave2: 172.17.0.4 (2)修改各节点的hosts文件根据(1)中查看得到的各节点ip配置hosts文件 172.17.0.2 master 172.17.0.3 slave1 172.17.0.4 slave2 (3)配置slaves下面配置哪些节点是slave。 较老版本的Hadoop中有一个masters文件和一个slaves文件，但新版本中只有slaves文件了。 在master节点容器中执行如下命令打开slaves配置文件： root@master:~/software/apache/hadoop/hadoop-2.6.0/etc/hadoop# vim slaves 将所有slave节点的hostname写入该文件： slave1 slave2 3. 启动Hadoop(1)启动SSH服务在每个节点上之下下面命令，启动SSH服务，实现无密码访问。 master节点 root@master:~/software/apache/hadoop/hadoop-2.6.0/etc/hadoop# /etc/init.d/ssh start * Starting OpenBSD Secure Shell server sshd [ OK ] root@master:~/software/apache/hadoop/hadoop-2.6.0/etc/hadoop# slave1节点 root@slave1:~# /etc/init.d/ssh start * Starting OpenBSD Secure Shell server sshd [ OK ] root@slave1:~# slave2节点 root@slave2:~# /etc/init.d/ssh start * Starting OpenBSD Secure Shell server sshd [ OK ] root@slave2:~# (2)格式化 namenoderoot@master:~/software/apache/hadoop/hadoop-2.6.0/bin# ./hadoop namenode -format (3)启动hadoop在master节点上执行start-all.sh命令，启动Hadoop root@master:~/software/apache/hadoop/hadoop-2.6.0/sbin# ./start-all.sh This script is Deprecated. Instead use start-dfs.sh and start-yarn.sh Starting namenodes on [master] master: starting namenode, logging to /root/software/apache/hadoop/hadoop-2.6.0/logs/hadoop-root-namenode-master.out slave2: starting datanode, logging to /root/software/apache/hadoop/hadoop-2.6.0/logs/hadoop-root-datanode-slave2.out slave1: starting datanode, logging to /root/software/apache/hadoop/hadoop-2.6.0/logs/hadoop-root-datanode-slave1.out Starting secondary namenodes [0.0.0.0] 0.0.0.0: starting secondarynamenode, logging to /root/software/apache/hadoop/hadoop-2.6.0/logs/hadoop-root-secondarynamenode-master.out starting yarn daemons starting resourcemanager, logging to /root/software/apache/hadoop/hadoop-2.6.0/logs/yarn--resourcemanager-master.out slave1: starting nodemanager, logging to /root/software/apache/hadoop/hadoop-2.6.0/logs/yarn-root-nodemanager-slave1.out slave2: starting nodemanager, logging to /root/software/apache/hadoop/hadoop-2.6.0/logs/yarn-root-nodemanager-slave2.out root@master:~/software/apache/hadoop/hadoop-2.6.0/sbin# 如果看到如下信息，则说明启动成功了。 在个节点上执行jps命令，结果如下： master节点 root@master:~/software/apache/hadoop/hadoop-2.6.0/sbin# jps 2149 Jps 1887 ResourceManager 1560 NameNode 1736 SecondaryNameNode root@master:~/software/apache/hadoop/hadoop-2.6.0/sbin# slave1节点 root@slave1:~# jps 352 DataNode 454 NodeManager 569 Jps slave2节点 root@slave2:~# jps 252 DataNode 354 NodeManager 469 Jps 下面，我们在master节点上通过命令hdfs dfsadmin -report查看DataNode是否正常启动 root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# ./hdfs dfsadmin -report Configured Capacity: 134743154688 (125.49 GB) Present Capacity: 117625421824 (109.55 GB) DFS Remaining: 117625372672 (109.55 GB) DFS Used: 49152 (48 KB) DFS Used%: 0.00% Under replicated blocks: 0 Blocks with corrupt replicas: 0 Missing blocks: 0 ------------------------------------------------- Live datanodes (2): Name: 172.17.0.4:50010 (slave2) Hostname: slave2 Decommission Status : Normal Configured Capacity: 67371577344 (62.74 GB) DFS Used: 24576 (24 KB) Non DFS Used: 8558866432 (7.97 GB) DFS Remaining: 58812686336 (54.77 GB) DFS Used%: 0.00% DFS Remaining%: 87.30% Configured Cache Capacity: 0 (0 B) Cache Used: 0 (0 B) Cache Remaining: 0 (0 B) Cache Used%: 100.00% Cache Remaining%: 0.00% Xceivers: 1 Last contact: Wed Feb 22 12:58:22 UTC 2017 Name: 172.17.0.3:50010 (slave1) Hostname: slave1 Decommission Status : Normal Configured Capacity: 67371577344 (62.74 GB) DFS Used: 24576 (24 KB) Non DFS Used: 8558866432 (7.97 GB) DFS Remaining: 58812686336 (54.77 GB) DFS Used%: 0.00% DFS Remaining%: 87.30% Configured Cache Capacity: 0 (0 B) Cache Used: 0 (0 B) Cache Remaining: 0 (0 B) Cache Used%: 100.00% Cache Remaining%: 0.00% Xceivers: 1 Last contact: Wed Feb 22 12:58:22 UTC 2017 root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# 还可以通过Web页面http://127.0.0.1:50070/看到查看DataNode和NameNode的状态。 4. WordCount实例(1) 创建本地单词文件words.txtroot@master:~/software/apache/hadoop/hadoop-2.6.0/bin# touch words.txt root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# 在words.txt文件中写入单词。 （2）将单词文件words.txt上传到到hdfs上root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# ./hdfs dfs -ls / root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# ./hdfs dfs -put words.txt / root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# ./hdfs dfs -ls / Found 1 items -rw-r--r-- 2 root supergroup 1763 2017-02-22 14:42 /words.txt root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# (3) 执行wordcount程序root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# ./hadoop jar ../share/ hadoop/mapreduce/hadoop-mapreduce-examples-2.6.0.jar wordcount /words.txt /out (4) 查看结果root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# ./hdfs dfs -text /out/part-r-00000","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://hepsilion.github.io/categories/环境配置/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hepsilion.github.io/tags/docker/"},{"name":"hadoop","slug":"hadoop","permalink":"https://hepsilion.github.io/tags/hadoop/"}],"keywords":[{"name":"环境配置","slug":"环境配置","permalink":"https://hepsilion.github.io/categories/环境配置/"}]},{"title":"C plus plus","slug":"C-plus-plus","date":"2017-05-28T11:03:50.000Z","updated":"2017-05-28T11:04:33.544Z","comments":true,"path":"2017/05/28/C-plus-plus/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/C-plus-plus/","excerpt":"C++","text":"C++ 一、概述二、基础语法整型一般我们把short称为短整型，把int称为整型，把long称为长整型，把long long称为超长整型。以unsigned开头的那些整数类型统称为无符号整型。例如：我们称unsigned short为无符号短整型，以此类推。 问：https://www.nowcoder.com/profile/7404313/test/8046125/55536?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8046125/23331?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8078490/15721?onlyWrong=0 问：求一个整数二进制表示中1的个数int fun(int x){ int countx = 0; while(x){ countx++; x = x &amp; (x – 1); } return countx; ｝ 问：forkhttps://www.nowcoder.com/profile/7404313/test/7993780/1023?onlyWrong=0 问：各种数据类型的大小(单位Bytes) 32位系统 64位系统 char 1 1 short 2 2 int 4 4 指针 4 8 long 4 8 float 4 4 double 8 8 long long 8 问：一道题目的分析(y^(x^y)&amp;-(x","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://hepsilion.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://hepsilion.github.io/tags/C/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://hepsilion.github.io/categories/C-C/"}]},{"title":"Probability Theory","slug":"Probability-Theory","date":"2017-05-28T11:02:06.000Z","updated":"2017-05-28T11:02:42.408Z","comments":true,"path":"2017/05/28/Probability-Theory/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/Probability-Theory/","excerpt":"概率论与数理统计","text":"概率论与数理统计 问：全概率和后验概率案例： https://www.nowcoder.com/profile/7404313/test/7971904/14885?onlyWrong=0","categories":[{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://hepsilion.github.io/categories/概率论与数理统计/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"https://hepsilion.github.io/tags/概率论/"},{"name":"数理统计","slug":"数理统计","permalink":"https://hepsilion.github.io/tags/数理统计/"}],"keywords":[{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://hepsilion.github.io/categories/概率论与数理统计/"}]},{"title":"信息安全总结","slug":"信息安全总结","date":"2017-05-28T11:01:20.000Z","updated":"2017-05-31T03:18:01.069Z","comments":true,"path":"2017/05/28/信息安全总结/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/信息安全总结/","excerpt":"信息安全","text":"信息安全 问：计算机病毒计算机病毒实质上是一种特殊的计算机程序，一般具有寄生性、破坏性、传染性、潜伏性和隐蔽性 问：加密算法是双向的，摘要算法是单向的摘要算法是单向的，即明文可以通过摘要算法生成摘要结果，但反之则不能通过摘要结果还原成明文，所以不可逆；加密算法是双向的，即可以从明文通过加密算法生成密文，反之也可以通过解密算法将密文还原成明文，所以可逆。 对称加密算法 DES 3DES AES：高级加密标准，是下一代的加密算法标准，速度快，安全级别高。 AES的区块长度固定为128比特，密钥长度则可以是128、192或256比特。 Blowfish：BlowFish算法用来加密64Bit长度的字符串，它使用两个盒，一个是unsigned long pbox[18]，一个是unsigned long sbox[4*256]。 Twofish IDEA RC6 CAST5 Serpent 攻击DES最有效方法是密钥穷举攻击，因为它使用56位密钥过短，已经被高级加密标准如AES所替代 非对称加密算法 DHA(差异哈希算法) RSA：TLS/SSL协议中RSA的公钥长度一般为1024或2048位，它的安全性依赖于大数分解。 EIGamal DSA：数字签名算法，是一种标准的DSS(数字签名标准)。 ECC 信息摘要算法 MD5 SHA1 SHA512 CRC-32 问：RSAhttps://www.nowcoder.com/profile/7404313/test/8122789/46253?onlyWrong=0 问：MD5摘要算法，不是加密算法MD5即Message-Digest Algorithm 5(信息-摘要算法5)，用于确保信息传输完整一致，是计算机广泛使用的杂凑算法之一(又译摘要算法、哈希算法)，主流编程语言普遍已有MD5实现。将数据(如汉字)运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。 MD5算法具有以下特点： 压缩性：任意长度的数据，算出的MD5值长度都是固定的。 容易计算：从原数据计算出MD5值很容易。 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。 弱抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据(即伪造数据)是非常困难的。 强抗碰撞：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。 MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式(就是把一个任意长度的字节串变换成一定长的十六进制数字串)。除了MD5以外，其中比较有名的还有SHA-1、RIPEMD以及Haval等。 注意：由于MD5是单向不可逆的，所以不可以解密，不能用来对文本进行加密，只能用来签名，校验数据的完整性 问：HttpsHTTP协议通常承载于TCP协议之上，有时也承载于TLS(安全传输层协议)或SSL(安全套接层协议Secure Sockets Layer)协议层之上，这个时候，就成了我们常说的HTTPS。 问：常见的攻击方法 Vulnerability scan，缺陷/弱点扫描 SQL Injection，SQL注入攻击 Drive-by downloading Brute force，暴力破解 问：实现防火墙的主流技术(1) 包过滤技术 包过滤是最早使用的一种防火墙技术，包过滤技术工作的地方就是各种基于TCP/IP协议的数据报文进出的通道，它把这两层作为数据监控的对象，对每个数据包的头部、协议、地址、端口、类型等信息进行分析，并与预先设定好的防火墙过滤规则(Filtering Rule)进行核对，一旦发现某个包的某个或多个部分与过滤规则匹配并且条件为”阻止”的时候，这个包就会被丢弃。 (2) 应用代理技术 由于包过滤技术无法提供完善的数据保护措施，而且一些特殊的报文攻击仅仅使用过滤的方法并不能消除危害(如SYN攻击、ICMP洪水等)，因此人们需要一种更全面的防火墙保护技术，在这样的需求背景下，采用”应用代理”(Application Proxy)技术的防火墙诞生了。一个完整的代理设备包含一个服务端和客户端，服务端接收来自用户的请求，调用自身的客户端模拟一个基于用户请求的连接到目标服务器，再把目标服务器返回的数据转发给用户，完成一次代理工作过程。应用级网关和代理服务器技术都是是应用代理技术实现防火墙。 (3) 状态检测技术 这种防火墙技术通过一种被称为”状态监视”的模块，在不影响网络安全正常工作的前提下采用抽取相关数据的方法对网络通信的各个层次实行监测，并根据各种过滤规则作出安全决策。 问：能加强家用路由器的网络安全的措施 将wifi加密方式从wep改为wpa2 关闭wan管理端口 关闭upnp 配置MAC地址绑定 升级路由器固件 问：交换机攻击交换机攻击主要有以下5种类型： vlan跳跃攻击 生成树攻击 mac表洪水攻击 arp攻击 vtp攻击 问：DNS欺骗的方式hosts文件篡改， 本机DNS服务器IP地址篡改，DNS通讯包篡改 https://www.nowcoder.com/profile/7404313/test/8122845/15110?onlyWrong=0","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"信息安全","slug":"信息安全","permalink":"https://hepsilion.github.io/tags/信息安全/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"软件测试总结","slug":"软件测试总结","date":"2017-05-28T11:00:19.000Z","updated":"2017-05-31T03:17:47.329Z","comments":true,"path":"2017/05/28/软件测试总结/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/软件测试总结/","excerpt":"软件测试","text":"软件测试 软件测试软件测试的对象包括源程序、目标程序、数据及相关文档 单元测试(Unit Testing)单元测试(unit testing)，是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如C语言中单元指一个函数，Java里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。 单元测试能发现约80%的软件缺陷。 测试用例测试用例(Test Case)是为测试设计的数据，由测试输入数据和与之对应的预期输出结果两部分组成 https://www.nowcoder.com/profile/7404313/test/8133610/55464?onlyWrong=0 瀑布模型中的软件测试按照瀑布模型的阶段划分，软件测试可以分为单元测试，集成测试，系统测试。 系统测试：压力测试，功能测试，安全测试，性能测试 集成测试：接口测试 内测和公测内侧是开发人员与用户、测试人员一起进行的，而公测是仅有用户参与的 黑盒测试黑盒测试是对软件已经实现的功能是否满足需求进行测试和验证，黑盒测试完全不考虑程序内部的逻辑结构和内部特性，只根据程序的需求和功能规格说明，检查程序的功能是否符合它的功能说明 白盒测试https://www.nowcoder.com/profile/7404313/test/8133610/55176?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133610/26144?onlyWrong=0 软件测试的步骤单元测试、集成测试、确认测试和系统测试 https://www.nowcoder.com/profile/7404313/test/8133610/3137?onlyWrong=0 alpha测试与beta测试的区别https://www.nowcoder.com/profile/7404313/test/8133610/14374?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133610/4480?onlyWrong=0 软件验收测试的合格通过准则https://www.nowcoder.com/profile/7404313/test/8133610/56351?onlyWrong=0 负载测试，容量测试和强度测试https://www.nowcoder.com/profile/7404313/test/8133610/14375?onlyWrong=0 ###集成测试的过程 https://www.nowcoder.com/profile/7404313/test/8133610/14368?onlyWrong=0 测试设计员的职责测试设计人员主要负责设计测试用例以及设计测试过程。 测试工具https://www.nowcoder.com/profile/7404313/test/8133610/14488?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133610/14491?onlyWrong=0","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://hepsilion.github.io/tags/软件工程/"},{"name":"软件测试","slug":"软件测试","permalink":"https://hepsilion.github.io/tags/软件测试/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"Concurrency","slug":"Concurrency","date":"2017-05-28T10:59:30.000Z","updated":"2017-05-28T10:59:57.497Z","comments":true,"path":"2017/05/28/Concurrency/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/Concurrency/","excerpt":"并发","text":"并发 问：并发与并行两个线程并发执行以下代码，假设a是全局变量，初始为1，那么执行完下列语句后的输出可能为：3 2，2 3，3 3和2 2 void foo(){ ++a; printf(&quot;%d &quot;,a); } 解释还不是特别清楚 https://www.nowcoder.com/profile/7404313/test/8115789/3939?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8120272/3356 https://www.nowcoder.com/profile/7404313/test/8120272/4607?onlyWrong=0 问：进程同步为禁止两个进程同时进入临界区，同步机制应该遵循一下基本准则： 空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。 忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待。 有限等待：对要求访问临界资源的进程，应保证能在有限的时间内进入临界区。 让权等待：当进程不能进入自己的临界区时，应立即释放处理机，防止进程忙等待。 问：死锁死锁产生的原因 系统资源的竞争，资源出现循环等待 https://www.nowcoder.com/profile/7404313/test/8067759/14356?onlyWrong=0 死锁产生的必要条件 互斥条件：一个资源在一段时间内仅为一个进程所占有，此时若有其他进程请求该资源，则请求进程只能等待。 不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放。 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不妨。 循环等待条件：存在一种资源的进程循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。即存在一个处于等待状态的进程集合{P1, P2, …, Pn}，其中Pi等待的资源被P(i+1)占有，Pn等待的资源被P0占有。 死锁的处理策略 (1) 死锁预防：破坏产生死锁的四个必要条件中的一个或几个，防止发生死锁。 (2) 死锁避免：死锁避免同样属于事先预防的策略，但并不是事先采取某种限制措施破坏死锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。 银行家算法是最著名的死锁避免算法。 (3) 死锁检测 问：共享内存共享内存是进程间通信的一种方式。尽管每个进程都有自己的内存地址，但是不同的进程可以同时将同一个内存页面映射到自己的地址空间中，所有进程都可以访问共享内存中的地址，从而达到共享内存的目的。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。共享内存并未提供同步机制，也就是说，在第一个进程结束对共享内存的写操作之前，并无自动机制可以阻止第二个进程开始对它进行读取。所以我们通常需要使用像信号量这样的同步机制来限制对共享内存的访问。 其他问：无锁化编程https://www.nowcoder.com/profile/7404313/test/8120272/4043?onlyWrong=0","categories":[{"name":"并发","slug":"并发","permalink":"https://hepsilion.github.io/categories/并发/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://hepsilion.github.io/tags/并发/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"https://hepsilion.github.io/categories/并发/"}]},{"title":"Design Pattern","slug":"Design-Pattern","date":"2017-05-28T10:58:37.000Z","updated":"2017-05-28T10:59:01.808Z","comments":true,"path":"2017/05/28/Design-Pattern/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/Design-Pattern/","excerpt":"设计模式","text":"设计模式 https://www.nowcoder.com/profile/7404313/test/8114731/1063?onlyWrong=0 策略模式https://www.nowcoder.com/profile/7404313/test/8114731/3006?onlyWrong=0 观察者模式https://www.nowcoder.com/profile/7404313/test/8114731/4716?onlyWrong=0","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://hepsilion.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://hepsilion.github.io/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"https://hepsilion.github.io/categories/设计模式/"}]},{"title":"软件工程总结","slug":"软件工程总结","date":"2017-05-28T10:57:43.000Z","updated":"2017-05-31T03:17:33.579Z","comments":true,"path":"2017/05/28/软件工程总结/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/软件工程总结/","excerpt":"软件工程","text":"软件工程 本文档总结软件工程的一些知识，侧重于了解。 问：计算机软件计算机软件指的是计算机系统中与硬件相互依赖的另一部分，包括程序、数据和有关的文档。 问：软件危机的主要原因缺乏好的开发方法和手段；软件本身特点；开发效率低。 软件生命周期软件生命周期分为3个阶段：软件定义阶段、软件开发阶段 (1) 软件定义阶段，任务是确定软件开发工作必须完成的目标，确定工程的可行性； (2) 软件开发阶段，任务是具体完成设计和实现定义阶段所定义的软件，通常包括总体设计、详细设计、编码和测试； (3) 软件维护阶段，任务是使软件在运行中持久地满足用户的需要。 https://www.nowcoder.com/profile/7404313/test/8130955/3131?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8130955/55220?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8130955/57997?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/58141?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/57880?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/57923?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/58000?onlyWrong=0 结构化方法软件需求分析工具结构化分析的常用工具有数据流图、数据字典、判定树和判定表 https://www.nowcoder.com/profile/7404313/test/8133296/3129?onlyWrong=0 问：软件设计的主要任务https://www.nowcoder.com/profile/7404313/test/8133296/3133 软件设计，包括软件的结构设计、数据设计、接口设计和过程设计。 结构设计 ：定义软件系统各主要部件之间的关系； 数据设计 ：将模型转换成数据结构的定义； 接口设计 ：软件内部，软件和操作系统间及软件和人之间如何通信； 过程设计 ：系统结构部件转换成软件的过程描述。 面向过程的系统采用的集成策略对面向过程的系统采用的集成策略有自顶向下(也就是先整体再局部)和自底向上(也就是先局部再整体)两种 问：软件工程的三要素方法(开发方法)、工具(支持方法的工具)、过程(管理过程)。 问：软件需求分析阶段的主要工作需求分析是软件生命周期的一个重要阶段，它的基本任务是准确地回答”系统必须做什么”这个问题，它的主要工作分为4个方面，分别为需求获取、需求分析、编写需求规格说明书及需求评审。 需求获取是通过和用户的接触初步确定系统的功能； 需求分析的任务是确定系统必须完成哪些工作，也就是对目标系统提出完整、准确、清晰、具体的要求； 在需求分析阶段结束以前，系统分析员应该写出需求规格说明书； 需求评审是根据需求规格说明书来严格审查和验证需求分析的结果。 问：软件需求规格说明软件需求规格说明应重点描述软件的目标，包括软件的功能需求、性能需求、外部接口、属性及约束条件等。 功能需求是软件需求规格说明，给出软件要执行什么功能的详尽描述。 性能需求是指定量的描述软件系统应满足的具体性能需求，即各种软件功能的速度、响应时间、恢复时间。 外部接口指软件如何与人、系统的硬件及其他硬件和其他软件进行交互。 属性是指与软件有关的质量属性，如正确性、可用性、可靠性、安全性、可维护性等。 约束条件包括影响软件实现的各种设计约束，如使用的标准、编程语言、数据库完整性方针、资源限制、运行环境等方面的要求。 https://www.nowcoder.com/profile/7404313/test/8129910/58186?onlyWrong=0 问：软件需求规格说明书的作用软件需求规格说明书的编制是为了使用户和软件开发者双方对该软件的初始规定有一个共同的理解，使之成为整个开发工作的基础。软件需求规格说明书包含硬件、功能、性能、输入输出、接口界面、警示信息、保密安全、数据与数据库、文档和法规的要求。 软件规格说明书是开发软件的方向，程序员要根椐需求规格说明书去开发软件，作用在于便于用户、开发人员进行理解和交流，反映出用户问题的结构，可以作为软件开发工作的基础和依据，并作为确认测试和验收的依据。但不包括软件设计的依据。 https://www.nowcoder.com/profile/7404313/test/8114731/3132 https://www.nowcoder.com/profile/7404313/test/8133214/3132?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133296/58071?onlyWrong=0 软件设计软件设计是软件工程的重要阶段，是一个把软件需求转换为软件表示的过程。软件设计的基本目标是用比较抽象概括的方式确定目标系统如何完成预定的任务，即解决软件“怎么做”的问题。 面向数据流的设计方法在面向数据流的设计方法中，一般把数据流图中的数据划分变换流和事务流。 (1) 交换流：信息沿输入通路进入系统，同时由外部形式变换为内部形式，进入系统的信息通过变换中心，经加工处理以后再沿输出通路变换成外部形式离开软件系统。 (2) 事务流：沿传入路径进入系统，由外部形式变换为内部形式后到达事务中心，事务中心根据数据项计值结果从若干动作路径中选定一条执行。有这样形状的成为事务流。 关联、聚合和组合https://www.nowcoder.com/profile/7404313/test/8130955/15073?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8130955/15866?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/55300?onlyWrong=0 问：软件开发模型https://www.nowcoder.com/profile/7404313/test/8114731/56412?onlyWrong=0 快速原型法https://www.nowcoder.com/profile/7404313/test/8129910/4441#summary https://www.nowcoder.com/profile/7404313/test/8133214/4441?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/2232?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133296/4436?onlyWrong=0 问：瀑布模型瀑布模型，提供一种结构化的、自顶向下的软件开发方法，是所有软件生命周期模型的基础。 https://www.nowcoder.com/profile/7404313/test/8129910/4443?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8130955/4442?onlyWrong=0 问：演化模型演化模型，针对实现不能完整定义需求的软件项目，利用迭代的思想，使软件逐步开发、逐步完善的机制，产品需求分解成多组，分批循环开发。 问：螺旋模型螺旋模型，遵从瀑布模型，迭代和风险驱动的开发过程，将瀑布模型的多个阶段转化到多个迭代过程中，适合大型系统的开发。过程：需求、架构、设计、开发、测试。 https://www.nowcoder.com/profile/7404313/test/8130955/4444?onlyWrong=0 螺旋模型是一种演化软件开发过程模型，它兼顾了快速原型的迭代特征以及瀑布模型的系统化与严格监控。螺旋模型最大的特点在于引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。同时，在每个迭代阶段构建原型是螺旋模型用以减小风险的途径。螺旋模型更适合大型的昂贵的系统级的软件应用。 问：喷泉模型喷泉模型，主要用于面向对象软件技术开发项目，特点是各项活动之间没有明显界限。过程为：分析、设计、实现、确认、维护和演化。 问：软件设计中模块划分应遵循的准则 高内聚低偶合：指功能集中模块化，低耦合只模块之间相互影响尽量小，改动一个模块不影响另一个模块或者尽可能减少影响 模块大小规模适当 模块的依赖关系适当等 https://www.nowcoder.com/profile/7404313/test/8129910/57922?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8130955/22264?onlyWrong=0 E-R模型向关系模型的转换的规则https://www.nowcoder.com/profile/7404313/test/8133214/4462?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/57907?onlyWrong=0 代码评审代码评审也称代码复查，是指通过阅读代码来检查源代码与编码标准的符合性以及代码质量的活动。 问：结构化程序设计的原则自顶向下、逐步求精、模块化、限制使用goto语句 维护性的特性https://www.nowcoder.com/profile/7404313/test/8129910/2231?onlyWrong=0 软件实施活动的进入准则需求工件已经被基线化，详细设计工件已经被基线化，构架工件已经被基线化 问：在数据流图中，用标有名字的箭头表示数据流。在程序流程图中，用标有名字的箭头表示控制流。 问：模型驱动开发技术过程建模 数据建模 对象建模。 工厂模式是比较常用的设计模式，它遵循了设计原则中的开放-封闭原则。https://www.nowcoder.com/profile/7404313/test/8129910/55299 其他系统软件中主要包括操作系统，语言处理程序和实用程序。 层次模型、网状模型和关系模型不知道考什么 https://www.nowcoder.com/profile/7404313/test/8129910/2277?onlyWrong=0 B/S架构软件与C/S架构软件的区别C/S又称Client/Server或客户/服务器模式。服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix或 SQL Server。客户端需要安装专用的客户端软件。 B/S是Brower/Server的缩写，客户机上只要安装一个浏览器（Browser），如Netscape Navigator或Internet Explorer，服务器安装Oracle、Sybase、Informix或 SQL Server等数据库。浏览器通过Web Server 同数据库进行数据交互。 https://www.nowcoder.com/profile/7404313/test/8129910/15285?onlyWrong=0 面向对象的五大原则https://www.nowcoder.com/profile/7404313/test/8066549/14362?onlyWrong=0 问：设计模式设计模式主要分三个类型：创建型、结构型和行为型。 创建型模式：社会化的分工越来越细，自然在软件设计方面也是如此，因此对象的创建和对象的使用分开也就成为了必然趋势。因为对象的创建会消耗掉系统的很多资源，所以单独对对象的创建进行研究，从而能够高效地创建对象就是创建型模式要探讨的问题。这里有6个具体的创建型模式可供研究，它们分别是：抽象工厂模式、工厂方法模式、建造者模式、原型模式、单例模式。 (0) 简单工厂模式 https://www.nowcoder.com/profile/7404313/test/8133214/25215?onlyWrong=0 (1) 抽象工厂模式(Abstract Factory)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。 (2) 工厂方法模式(Factory Method)：定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类。 (3) 建造模式(Builder)：将一个复杂对象的构建与他的表示相分离，使得同样的构建过程可以创建不同的表示。 (4) 原型模式(Prototype)：用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象。 (5) 单例模式(Singleton)：保证一个类只有一个实例，并提供一个访问它的全局访问点 结构型模式：在解决了对象的创建问题之后，对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点，因为如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等。对象结构的设计很容易体现出设计人员水平的高低，这里有7个具体的结构型模式可供研究，它们分别是：外观模式、适配器模式、代理模式、装饰器模式、桥接模式、组合模式、享元模式。 (6) 外观模式(Facade)：为子系统中的一组接口提供一致的界面，fa?ade提供了一高层接口，这个接口使得子系统更容易使用。 (7) 适配器模式(Adapter)：将一类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作那些类可以一起工作。 (8) 代理模式(Proxy)：为其他对象提供一种代理以控制对这个对象的访问 (9) 装饰器模式(Decorator)：动态地给一个对象增加一些额外的职责，就增加的功能来说，Decorator模式相比生成子类更加灵活。 (10) 桥接模式(Bridge)：将抽象部分与它的实现部分相分离，使他们可以独立的变化。 (11) 组合模式(Composite)：将对象组合成树形结构以表示部分整体的关系，Composite使得用户对单个对象和组合对象的使用具有一致性。 (12) 享元模式(Flyweight) 行为型模式：在对象的结构和对象的创建问题都解决了之后，就剩下对象的行为问题了，如果对象的行为设计的好，那么对象的行为就会更清晰，它们之间的协作效率就会提高，这里有11个具体的行为型模式可供研究，它们分别是：模板方法模式、观察者模式、状态模式、策略模式、责任链模式、命令模式、访问者模式、中介者模式、备忘录模式、迭代器模式、解释器模式。 (13) 模板方法模式(Template Method)：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可以重定义该算法得某些特定步骤。 (14) 观察者模式(Observer)：定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新。 (15) 状态模式(State)：允许对象在其内部状态改变时改变他的行为。对象看起来似乎改变了他的类。 (16) 策略模式(Strategy)：定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们的客户。 (17) 责任链模式(Chain of Responsibility)：使多个对象都有机会处理请求，从而避免请求的送发者和接收者之间的耦合关系 (18) 命令模式(Command)：将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。 (19) 访问者模式(Visitor)：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作。 (20) 中介者模式(Mediator)：用一个中介对象封装一些列的对象交互。 (21) 备忘录模式(Memento)：在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 (22) 迭代器模式(Iterator)：提供一个方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示。 (23) 解释器模式(Interpreter)：给定一个语言，定义他的文法的一个表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 https://www.nowcoder.com/profile/7404313/test/8129910/15064?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8129910/25593?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8129910/25465?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8130955/3006?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/55299?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/1063?onlyWrong=0 工厂方法模式https://www.nowcoder.com/profile/7404313/test/8133214/1466?onlyWrong=0 装饰器模式https://www.nowcoder.com/profile/7404313/test/8130955/50973?onlyWrong=0 策略模式https://www.nowcoder.com/profile/7404313/test/8133296/3006?onlyWrong=0 MVChttps://www.nowcoder.com/profile/7404313/test/8130955/45212?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8130955/1331?onlyWrong=0 名词辨析：CAD、CAI、CAM、CASE CAD(Computer Aided Design)：计算机辅助设计，指利用计算机及其图形设备帮助设计人员进行设计工作。 CAI(Computer Aided Instruction)：计算机辅助教学，是在计算机辅助下进行的各种教学活动，以对话方式与学生讨论教学内容、安排教学进程、进行教学训练的方法与技术。 CAM(Computer Aided Manufacturing)：计算机辅助制造 ，是将计算机应用于制造生产过程的过程或系统。 CASE(Computer Aided Software Engineering):计算机辅助软件工程，用来辅助软件开发、运行、维护、管理、支持等过程中的活动的软件称为软件开发工具。 在面向对象方法中，对象有如下一些基本特点：标识唯一性、分类性、多态性、封装性、模块独立性好。DAO模式DAO的本质是提供数据访问接口 https://www.nowcoder.com/profile/7404313/test/8129910/15008?onlyWrong=0 值对象模式https://www.nowcoder.com/profile/7404313/test/8133214/15007?onlyWrong=0 可维护性https://www.nowcoder.com/profile/7404313/test/8130955/2231?onlyWrong=0 游戏软件和通用软件https://www.nowcoder.com/profile/7404313/test/8130955/14553?onlyWrong=0 模型驱动开发技术过程建模、数据建模、对象建模。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://hepsilion.github.io/tags/软件工程/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"Linux总结","slug":"Linux总结","date":"2017-05-28T10:56:37.000Z","updated":"2017-05-31T03:16:17.020Z","comments":true,"path":"2017/05/28/Linux总结/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/Linux总结/","excerpt":"Linux","text":"Linux 一、 进程管理问：Linux进程间的通信方式Linux进程间通信方式有：消息队列，命名管道，信号量，共享内存，套接字等，临界区不能用于Linux中的进程间通信。 https://www.nowcoder.com/profile/7404313/test/8067759/1034?onlyWrong=0 问：终止一个前台进程可能用到的命令和操作终止一个前台进程用Ctrl+C； 暂停一个前台进程用Ctrl+Z； 终止一个后台进程： 使用kill命令； 或使用fg命令将后台进程变为前台进程，然后Ctrl+C。 问：ps问：jobs显示系统进程 二、 存储管理问：freefree是系统自带的、常用的监控工具，用于显示已使用物理内存和交换空间，相对于top命令，free可以更简洁的查看内存的使用情况。 三、 文件管理问：Linux文件目录/bin 二进制执行文件，也就是命令文件 /etc 下存放的是配置文件 /dev 存放是时外部设备文件，硬盘，usb等 /lib 存放的是库文件 问：常用文件介绍 /etc/resolv.conf DNS解析的设置文件 /etc/dhcpd.conf DHCP的设置文件 /etc/gateways 网络路由的设置文件(建立动态路由需要用到) /etc/mail.rc 邮件服务的设置文件 /etc/hosts hosts文件是Linux系统上一个负责ip地址与域名快速解析的文件，以ascii格式保存在/etc/目录下。hosts文件包含了ip地址与主机名之间的映射，还包括主机的别名。在没有域名解析服务器的情况下，系统上的所有网络程序都通过查询该文件来解析对应于某个主机名的ip地址，否则就需要使用dns服务程序来解决。通过可以将常用的域名和ip地址映射加入到hosts文件中，实现快速方便的访问。 /etc/hostname 主机名设置文件 /etc/fstab 系统分区的配置文件，开机后系统会自动挂载文件中指定的设备 https://www.nowcoder.com/profile/7404313/test/8343455/22114?onlyWrong=0 /proc/interrupts 显示使用的中断 /proc/ioports 当前使用的I/O端口 /proc/kcore 系统物理内存映像。与物理内存大小完全一样，但不实际占用这么多的内存。 /proc/kmsg 内核输出的消息，也被送到syslog https://www.nowcoder.com/profile/7404313/test/8148327/26137?onlyWrong=0 问：文件复制(1) cp命令：cp命令用于复制文件或目录。 将文件file1复制成文件file2命令如下：cp file1 file2 (2) cat命令 ：cat命令是linux下的一个文本输出命令，通常是用于观看某个文件的内容的。 一次显示整个文件命令如下： cat filename : linux中的数据流重导向：输出导向，覆盖导向的文件内容。 &lt; : linux中的数据流重导向：输入导向，理解为原本由键盘输入改为文本输入 (3) dd命令 : 作用是用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。 参数：if 输入文件(或设备名称) of 输出文件(或设备名称) 将文件file1拷贝到文件file2中命令如下： dd if=file1 of=file2 (4) | ：管道命令操作符，处理经由前面一个指令传出的正确输出信息，然后，传递给下一个命令，作为标准的输入 例1： 将文件file1复制为file2可以使用的命令： cp file1 file2 cat file1 &gt;file2 cat &lt; file1 &gt;file2 dd if=file1 of=file2 cat file1 | cat &gt;file2 问：Linux文件权限 Linux文件权限的长度为10位，分成四段：文件类型(1位) + 拥有者权限(3位) + 所属组权限(3位) + 其他用户权限(3位) 问：chmod 修改文件权限chmod [who] [+|-|=][mode] 文件名 (1) [who]的取值可以为u，g，o和a， u 表示”用户(user)”，即文件拥有者； g 表示”同组(group)用户”，即与文件拥有者有相同组ID的所有用户； o 表示”其他(others)用户”； a 表示”所有(all)用户”，它是系统默认值。 (2) [+|-|=] + 添加某个权限； 取消某个权限； = 赋予给定权限并取消其他所有权限（如果有的话）。 (3) [mode] 当使用+或-时，权限从0到7的一个八进制数，例如7为4+2+1的组合，代表可读可写可执行权限；5为4+1的组合，代表可读可执行，等； 当使用=时，权限为从0到7的3个八进制数，按(u)、(g)、(o)顺序组织，分别对应文件拥有着、同组用户和其他用户的权限。 例1： 文件file的访问权限为rw-r--r--，现要增加所有用户的执行权限和同组用户的写权限，其命令可以为：chmod a+x,g+w file 或 chmod 764 file 注意为多种用户设置权限时，中间以”,”隔开，不可以加空格。如chmod a+x, g+w file为错误形式，逗号后面存在空格。 例2： 现在file文件的权限改为只有拥有着拥有执行权限的命令可以为：chmod u+x,g-x,o-x file 或 chmod 100 file 例3： 在unix系统下执行chmod 753 file之后，该文件sample的访问权限为：拥有者可读写执行，同组用户可读可执行，其他用户可写可执行 问：umaskumask [-p] [-S] [mode] umask可用来指定在建立文件时预设的权限掩码。对于每一类用户(文件属主、同组用户、其他用户)在umask值mode中都存在一个相应的数字。 对于文件来说，这一数字的最大值是6。系统不允许你在创建一个文本文件时就赋予它执行权限，必须在创建后用chmod命令增加这一权限； 目录则允许设置执行权限，这样针对目录来说，umask中各个数字最大可以为7。 例1： 如果系统的umask设置为244，创建一个新文件后，它的权限为：-r---w--w- 创建时，文件权限默认为666，目录权限默认777，减去umask的位就是结果权限。因此该文件权限为666-244=422，即为-r---w--w- 例2： 设umask为002, 则新建立的文件的权限是：-rw-rw-r-- 问：tar 压缩和解压缩tar [必选项+可选项] 文件或者目录 必选项： -c 创建压缩包； -x 解开压缩包； -t 列出包中的内容； -r 增加文件到指定包中； -u 更新包中的文件 可选项： -j 创建或解开压缩包包时使用bzip2进行压缩或解压缩； -z 创建或解开压缩包包时使用gzip进行压缩或解压缩； -Z 创建或解开压缩包包时使用compress进行压缩或解压； -f 后面跟指定的压缩包文件名； -v 显示创建压缩包/解开压缩包的过程； -C 指定解开压缩包的路径 例1： 在linux中如何使用tar命令将文件aaa打包为bak.tar：tar -cf bak.tar aaa 例2： tar命令用于解压的参数是: -x 问：tar，gzip，compress，uncompresstar是操作.tar的命令 gzip是压缩.gz压缩包的命令 compress：压缩.Z文件 uncompress：解压缩.Z文件 例1： 一个文件名字为rr.Z，可以用来解压缩的命令是:uncompress 问：查看文件内容cat，less，more都可以查看文件内容 less命令除了可以按空格键向下显示文件外，还可以用上下键来卷动文件 cat是将文件中的内容全部输出，如果内容过多，鼠标光标自动移到最后一行 more只能用enter键往下翻 问：cut从行当中截取所需要的内容进行显示 https://www.nowcoder.com/profile/7404313/test/8343455/22098?onlyWrong=0 问：硬链接和软链接推荐阅读 https://www.nowcoder.com/profile/7404313/test/8114836/36414?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8343455/44623?onlyWrong=0 四、 网络管理问：ping 测试连通性ping命令用来测试主机之间网络的连通性，底层是ICMP协议。 主机发出ICMP报文后，若主机与目的主机之间的网络连通正常，则目的主机会返回响应报文。 我们经常会说”ping一下某机器，看是不是开着”、不能打开网页时会说”你先ping网关地址192.168.1.1试试”。它通过发送ICMP ECHO_REQUEST数据包到网络主机，并显示响应情况，这样我们就可以根据它输出的信息来确定目标主机是否可访问(但这不是绝对的)。有些服务器为了防止通过ping探测到，通过防火墙设置了禁止ping或者在内核参数中禁止ping，这样就不能通过ping确定该主机是否还处于开启状态。 问：traceroute 路径跟踪traceroute是常用的路由查看命令，用来追踪数据包到达网络上某个主机在时经过的路径 问：route 查看路由表route命令用来显示目前本机路由表的内容，并且还可以针对路由表中的记录进行相应的添加、删除或修改等操作。 (1) route print 本命令用于显示路由表中的当前项目，由于用IP地址配置了网卡，因此所有的这些项目都是自动添加的。 (2) route add 本命令可以将新路由项目添加到路由表。 (3) route change 使用本命令可以修改数据的传输路由，不过，你不能使用本命令来改变数据的目的地。 (4) route delete 使用本命令可以从路由表中删除路由。 例1： 局域网的网络地址192.168.1.0/24，局域网络连接其它网络的网关地址是192.168.1.1。 主机192.168.1.20访问172.16.1.0/24网络时，其路由设置正确的是：route add –net 172.16.1.0 gw 192.168.1.1 netmask 255.255.255.0 metric 1 路由信息是由{目的主机所在的网络地址，下一跳地址，子网掩码}组成，-net 后面跟的是目的网络，下一跳的地址就是局域网中连接外网的网关地址 问：ifconfigifconfig命令用来查看活动的网卡信息 问：telnettelnet命令通常用来进行远程登录。telnet程序是基于TELNET协议的远程登录客户端程序。Telnet协议是TCP/IP协议族中的一员，是Internet远程登录服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。 问：netstatnetstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。 netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。 如果你的计算机有时候接收到的数据报导致出错数据或故障，你不必感到奇怪，TCP/IP可以容许这些类型的错误，并能够自动重发数据报。但如果累计的出错情况数目占到所接收的IP数据报相当大的百分比，或者它的数目正迅速增加，那么你就应该使用 netstat查一查为什么会出现这些情况了。 问：tcpdumphttps://www.nowcoder.com/profile/7404313/test/8322129/14462?onlyWrong=0 五、 用户管理六、 系统管理问：uptimeuptime命令主要用于获取主机运行时间和查询linux系统负载等信息 问：top问：sar问：Linux关机命令 halt init 0 poweroff shutdown -h 时间 (例如，shutdown -h now) 问：Linux重启命令 reboot init 6 shutdown -r 时间 七、 内核管理八、 帮助文档问：man 查看Linux命令手册例1： 命令man 5 passwd的作用：显示password文件的格式描述 九、 其他问：查看相关信息 cat /proc/meminfo 查看物理内存的信息 问：常用命令介绍 grep netstat netstat命令用来查看本机的传输层连接状态，如TCP、UDP连接，端口等信息 tcpdump tcpdump是简单可靠网络监控的实用工具 top top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况 fg 将一个后台进程调至前台继续运行 bg 将一个在后台暂停的进程唤醒，继续执行 ctrl+z 可以将一个正在前台执行的进程放到后台，并且暂停，表示进程被挂起 dpkg “dpkg”是”Debian Packager”的简写，是为”Debian”专门开发的套件管理系统，方便软件的安装、更新及移除。所有源自”Debian”的”Linux “发行版都使用”dpkg”，例如”Ubuntu”、”Knoppix”等。示例：dpkg -i avg71flm_r28-1_i386.deb df df命令用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 https://www.nowcoder.com/profile/7404313/test/8078490/55441?onlyWrong=0 问：grep和findfind是根据文件名进行查找，grep是对文件的内容进行搜索 https://www.nowcoder.com/profile/7404313/test/8114836/14452?onlyWrong=0 问：sedhttps://www.nowcoder.com/profile/7404313/test/8114836/14510?onlyWrong=0 问：init命令是进程和作业管理命令，init命令是Linux下的进程初始化工具，init进程是所有Linux进程的父进程，它的进程号为1。init命令是 Linux操作系统中不可缺少的程序之一，init进程是Linux内核引导运行的，是系统中的第一个进程。 问：mount查看磁盘挂载状态 问：mkdirhttps://www.nowcoder.com/profile/7404313/test/8114836/23226?onlyWrong=0 问：usermodhttps://www.nowcoder.com/profile/7404313/test/8114836/22122?onlyWrong=0 问：crontab，定时任务通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本，该命令前五个域是指定命令被执行的时间，最后一个域是要被执行的命令，每个域之间使用空格或者制表符分隔。 格式如下： minute hour day-of-month month-of-year day-of-week command 这些项都不能为空，必须填入。如果用户不需要指定其中的几项，那么可以使用*代替。因为*是统配符，可以代替任何字符，所以就可以认为是任何时间，也就是该项被忽略了。 第1列表示分钟(1～59)，每分钟用*或者*/1表示 第2列表示小时(1～23，0表示0点) 第3列表示日期(1～31) 第4列表示月份(1～12) 第5列标识号星期(0～6，0表示星期天) 第6列要运行的命令 例如：*/5 * * * * exam，表示每5分钟运行一次任务exam。 问：Linux下的输入/输出重定向在Linux中，每个打开的文件被赋予一个文件描述符(file descriptor)，包括标准输入(stdin)，标准输出(stdout)和标准错误输出(stderr)，分别由0，1，2描述。 command &amp;&gt; file 表示将标准输出(stdout)和标准错误输出(stderr)重定向至指定的文件file中 command &gt; file 2&gt;&amp;1，是由两部分组成。首先command&gt;file表示将标准输出(stdout)重定向到文件file中。接下来的2&gt;&amp;1表示将标准错误输出(stderr)输出到文件描述符1指定的位置，即标准输出(stdout)的位置，由于标准输出已经冲定向到文件file中，所以标准错误输出也会重定向到文件file中。 https://www.nowcoder.com/profile/7404313/test/8343455/15827?onlyWrong=0 问：Shell命令https://www.nowcoder.com/profile/7404313/test/8114836/14919?onlyWrong=0 问：Linux内存划分https://www.nowcoder.com/profile/7404313/test/8114836/25177?onlyWrong=0 问：Nginxhttps://www.nowcoder.com/profile/7404313/test/8114836/26093?onlyWrong=0 问：forkhttps://www.nowcoder.com/profile/7404313/test/8114836/14836?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8343455/26090?onlyWrong=0 grep统计一个文件中&quot;牛客&quot;出现的行数: grep &quot;牛客&quot; 文件名 | wc -l https://www.nowcoder.com/profile/7404313/test/8148327/22524?onlyWrong=0 findhttps://www.nowcoder.com/profile/7404313/test/8148327/25705?onlyWrong=0 孤儿进程、僵尸进程https://www.nowcoder.com/profile/7404313/test/8148327/14857?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8148327/25761?onlyWrong=0 管道通信https://www.nowcoder.com/profile/7404313/test/8322129/36306?onlyWrong=0 ### makefile https://www.nowcoder.com/profile/7404313/test/8322129/15416?onlyWrong=0 Linux X Window System (X11)Linux X Window System中X是一个开放的协议规范，当前版本为11，俗称X11。X Window System由客户端和服务端组成，服务端X Server负责图形显示，而客户端库X Client根据系统设置的DISPLAY环境变量，将图形显示请求发送给相应的X Server。 https://www.nowcoder.com/profile/7404313/test/8343455/26052?onlyWrong=0","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://hepsilion.github.io/tags/操作系统/"},{"name":"Linux","slug":"Linux","permalink":"https://hepsilion.github.io/tags/Linux/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"Advanced Algorithms","slug":"Advanced-Algorithms","date":"2017-05-28T10:55:45.000Z","updated":"2017-05-28T10:56:16.240Z","comments":true,"path":"2017/05/28/Advanced-Algorithms/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/Advanced-Algorithms/","excerpt":"算法","text":"算法 一、分治法二、贪心算法三、动态规划四、回溯法五、分支限界法六、问题复杂性问：P、NP、NPChttps://www.nowcoder.com/profile/7404313/test/8073440/14496?onlyWrong=0","categories":[{"name":"算法","slug":"算法","permalink":"https://hepsilion.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://hepsilion.github.io/tags/算法/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://hepsilion.github.io/categories/算法/"}]},{"title":"计算机组成原理总结","slug":"计算机组成原理总结","date":"2017-05-28T10:54:33.000Z","updated":"2017-05-31T03:11:58.960Z","comments":true,"path":"2017/05/28/计算机组成原理总结/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/计算机组成原理总结/","excerpt":"计算机组成原理","text":"计算机组成原理 原码、反码和补码https://www.nowcoder.com/profile/7404313/test/7956107/927?onlyWrong=0 问：在定点二进制运算器中，减法运算一般通过补码运算的二进制加法器来实现https://www.nowcoder.com/profile/7404313/test/7994191/1735?onlyWrong=0 问：https://www.nowcoder.com/profile/7404313/test/8073949/15746?onlyWrong=0 问：IEEE754单精度浮点格式案例： float型数据通常用IEEE754单精度浮点数格式表示。若编译器将float型变量x分配在一个32位浮点寄存器FR1中，且x=-8.25，则FR1的内容是()。 1、十进制转二进制 小数点之前的部分除以2取余倒序，小数点之后的部分乘以2取整正序 例：8.25的二进制表示，整数部分：8=1000；小数部分：0.25=01，8.25=1000.01 规格化：8.25=1.00001*2^3 2、浮点数保存的字节格式如下： 地址 +0 +1 +2 +3 内容 SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM S表示符号位(正为0，负为1)；E表示阶码，M表示尾数 阶码=阶数+127；尾数还原=MMM MMMM MMMM MMMM MMMM MMMM(规格化时，最高位为1，默认隐藏，只取小数点后部分) 对于-8.25，S=1，阶码=3+127=130=1000 0010，尾数=00001 所以-8.25的字节格式如下 地址 +0 +1 +2 +3 内容 1100 0001 0000 0100 0000 0000 0000 0000 C1 04 00 00 来源：https://www.nowcoder.com/profile/7404313/test/7941145/52554?onlyWrong=0 问：大端和小端https://www.nowcoder.com/profile/7404313/test/8144521/36423?onlyWrong=0","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://hepsilion.github.io/tags/计算机组成原理/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"操作系统","slug":"操作系统","date":"2017-05-28T10:53:28.000Z","updated":"2017-06-01T12:22:50.177Z","comments":true,"path":"2017/05/28/操作系统/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/操作系统/","excerpt":"操作系统","text":"操作系统 一、 概述二、 进程管理问：进程的特征 并发性：指多个进程实体同存于内存中，且在一段时间内同时运行。并发性是进程的重要特征，同时也成为操作系统的重要特征。 动态性：进程的实质是进程实体的一次执行过程，因此，动态性是进程最基本的特征。 独立性：进程实体是一个独立运行、独立分配资源和独立接受调度的基本单位。 异步性：指进程按各自独立的、不可预知的速度向前推进，或者说实体按异步方式运行。 问：进程与线程的区别举例：若系统中只有用户级线程，则处理机调度单位是进程。 原因：如果系统只有用户态线程，则线程对操作系统是不可见的，操作系统只能调度进程；如果系统中有内核态线程，则操作系统可以按线程进行调度； https://www.nowcoder.com/profile/7404313/test/8078490/15365?onlyWrong=0 问：进程的重要性与进程的销毁顺序进程的重要性依次是：前台进程&gt;可见进程&gt;服务进程&gt;后台进程&gt;空进程。进程销毁的顺序为逆方向。 问：进程控制原语原语是由若干条机器指令所构成，用以完成特定功能的一段程序，为保证其操作的正确性，它应当是原子操作，即原语是一个不可分割的操作。所以，原语在执行的过程中，是不可以被中断的。 操作系统对进程的管理和控制主要是通过控制原语言实现的，包括：进程创建，进程阻塞，唤醒进程和进程终止四个原语。 问：高响应比优先调度算法响应比=(等待时间+服务时间)/服务时间 问：线程间同步的方式https://www.nowcoder.com/profile/7404313/test/8067759/14609?onlyWrong=0 在win32平台下，Event、Semaphore、Mutex能够实现进程同步，Critical Section无法实现进程同步。https://www.nowcoder.com/profile/7404313/test/8115789/5492?onlyWrong=0 问：锁的类型https://www.nowcoder.com/profile/7404313/test/8078490/16028?onlyWrong=0 三、 内存管理问：GB、MB和KB换算1GB=1024MB 1MB=1024KB 问：静态重定位和动态重定位对程序进行重定位的技术按重定位的时机可分为两种：静态重定位和动态重定位。 (1) 静态重定位：是在目标程序装入内存时，由装入程序对目标程序中的指令和数据的地址进行修改，即把程序的逻辑地址都改成实际的地址。对每个程序来说，这种地址变换只是在装入时一次完成，在程序运行期间不再进行重定位。 优点：是无需增加硬件地址转换机构，便于实现程序的静态连接。在早期计算机系统中大多采用这种方案。 缺点： 程序的存储空间只能是连续的一片区域，而且在重定位之后就不能再移动。这不利于内存空间的有效使用。 各个用户进程很难共享内存中的同一程序的副本。 (2) 动态重定位：是在程序执行期间每次访问内存之前进行重定位。这种变换是靠硬件地址变换机构实现的。通常采用一个重定位寄存器，其中放有当前正在执行的程序在内存空间中的起始地址，而地址空间中的代码在装入过程中不发生变化。 优点： 程序占用的内存空间动态可变，不必连续存放在一处。 比较容易实现几个进程对同一程序副本的共享使用。 缺点：是需要附加的硬件支持，增加了机器成本，而且实现存储管理的软件算法比较复杂。 现在一般计算机系统中都采用动态重定位方法。 https://www.nowcoder.com/profile/7404313/test/8067759/50614?onlyWrong=0 问：动态分区分配(1) 首次适应(First Fit)算法 空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。 该算法优先使用低址部分空闲区，在低址空间造成许多小的空闲区，在高地址空间保留大的空闲区。 (2) 最佳适应(Best Fit)算法 空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。 (3) 最坏适应(Worst Fit)算法，又称为最大适应(Largest Fit)算法 空闲分区按容量递减形成分区链，找到第一个能满足要求的空闲分区，也就是找出最大的分区。 (4) 邻近适应(Next Fit)算法，又称为循环首次适应算法 该算法是首次适应算法的变种，不同之处是分配时从上次查找结束的位置开始继续查找。 该算法能使内存中的空闲区分布得较均匀。 问：虚拟内存的容量https://www.nowcoder.com/questionTerminal/7caaa714b7dc480fa024be2f67e6b090 问：页面替换算法 FIFO(First in First out) LFU(Least Frequently Used)，和使用次数(频率)相关，和使用时间无关 LRU(Least Recently Used)，和使用时间相关，和使用次数（频率）无关 OPT(Optimal Replacement) 网络上的一个简要的总结：http://blog.csdn.net/spaceyqy/article/details/39399727 问：Belady’s AnomalyBelady’s Anomaly，即Belady异常或者Belady现象。 所谓Belady现象是指：在页面置换中，当发生缺页时的置换算法采用FIFO(先进先出)算法时，有时会出现分配的页面数增多但缺页率不减反增的异常现象。 只有FIFO算法可能出现Belady异常，而LRU和OPT算法永远不会出现Belady异常。 例如：访问页面序列为：1，2，3，4，1，2，5，1，2，3，4，5。当分配页面数位3时，缺页9次；当分配页面数位4时，缺页10次。 问：磁盘磁盘是可共享设备，一段时间内允许多个用户进行交叉访问，同一时刻只能有一个进程访问。 问：磁盘平均存取时间平均存取时间=寻道时间+延迟时间+传输时间 https://www.nowcoder.com/profile/7404313/test/7920678/52607?onlyWrong=0 问：RAID阵列RAID 0：无差错控制的带区组 要实现RAID0必须要有两个以上硬盘驱动器，RAID0实现了带区组，数据并不是保存在一个硬盘上，而是分成数据块保存在不同驱动器上。在所有的级别中，RAID 0的速度是最快的。但是RAID 0没有冗余功能的，如果一个磁盘(物理)损坏，则所有的数据都无法使用。 RAID 1：镜象结构 当主硬盘损坏时，镜像硬盘就可以代替主硬盘工作。镜像硬盘相当于一个备份盘，可想而知，这种硬盘模式的安全性是非常高的，RAID 1的数据安全性在所有的RAID级别上来说是最好的。但是其磁盘的利用率却只有50%，是所有RAID级别中最低的。 RAID5：分布式奇偶校验的独立磁盘结构 RAID5最大的好处是在一块盘掉线的情况下，RAID照常工作，相对于RAID0必须每一块盘都正常才可以正常工作的状况容错性能好多了。因此 RAID5是RAID级别中最常见的一个类型。RAID5校验位即P位是通过其它条带数据做异或(xor)求得的。计算公式为 P=D0xorD1xorD2…xorDn，其中p代表校验块，Dn代表相应的数据块，xor是数学运算符号异或。 RAID10：高可靠性与高效磁盘结构 RAID 10是先镜射再分区数据。是将所有硬盘分为两组，视为是RAID 0的最低组合，然后将这两组各自视为RAID 1运作。RAID 10有着不错的读取速度，而且拥有比RAID 0更高的数据保护性。 四、 文件管理硬链接和软链接https://www.nowcoder.com/profile/7404313/test/8129531/15818?onlyWrong=0 五、 输入输出(I/O)管理问：I/O控制方式 程序直接控制方式 中断驱动方式：允许I/O设备主动打断CPU的运行并请求服务，从而解放CPU，使得CPU向I/O控制器发送读命令后可以继续做其他有用的工作。 DMA方式：在中断驱动方式中，I/O设备与内存之间的数据交换必须要经过CPU中的寄存器，所以速度受限，而DMA(直接存储器存取)方式的基本思想是在I/O设备和内存之间开辟直接的数据交换通路，彻底解放CPU。 DMA方式的特点： (1) 基本单位是数据块 (2) 所传送的数据，是从设备直接送入内存的，或者相反。 (3) 仅在传送一个或多个数据块的开始和结束时，才需要CPU干预，整块数据的传送是在DMA控制器的控制下完成的。 通道方式 通道能够完成内存与外设之间数据的传输。 问：独享设备、共享设备和虚拟设备 独享设备：在一个用户作业未完成或退出之前，此设备不能分配给其他作业用。所有字符设备都是独享设备。如输入机、磁带机、打印机等。——很明显：需要装驱动。 共享设备：多个用户作业或多个进程可以”同时”从这些设备上存取信息。软硬盘、光盘等块设备都是共享设备。——无需驱动。 虚拟设备：通过软件技术将独享设备改造成共享设备。例如：通过SPOOLing技术将一台打印机虚拟成多台打印机。——实质还是独享设备，需要驱动。 问：单缓冲和双缓冲https://www.nowcoder.com/profile/7404313/test/8073949/24035?onlyWrong=0 问：I/O子系统的层次结构操作系统的I/O 子系统通常由 4 个层次组成，每一层明确定义了与邻近层次的接口，其合理的层次组织排列顺序是：用户级 I/O 软件、设备无关软件、设备驱动程序、中断处理程序 七、 其他进程间的通信方式 管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。 套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 RPC 内存分配方式有三种： （1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。 （2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 （3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多 相联存储器相联存储器（associative memory),也称为按内容访问存储器（content addressed memory)或简称为TLB(Translation Lookaside Buffer)，它是一种不根据地址而是根据存储内容来进行存取的存储器,可以实现快速地查找块表 大端存储和小端存储https://www.nowcoder.com/profile/7404313/test/7907952/14799?onlyWrong=0 案例1： union X{ int x; char y[4]; }; 在小端序的机器中,如果定义X a; a.x=0x11223344;//16 进制，则a.y[3]=0x11 在union 中所有的数据成员共用一个空间，同一时间只能储存其中一个数据成员，所有的数据成员具有相同的起始地址。 管道管道是指用于连接一个读进程和一个写进程以实现进程之间通信的一种共享文件。向管道提供输入的是发送进程，也称为 写进程，负责向管道输入数据，数据的格式是字符流。接受管道 数据的接受进程为读进程。 12. 零碎的东西孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上 ，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。 因此孤儿进程并不会有什么危害。 链接：https://www.nowcoder.com/questionTerminal/8c8bcba738eb4facbdfdb22f47961bee来源：牛客网 Redhat 9所支持的安装方式有光盘安装 (常规情况) 硬盘安装 (无光驱情况)网络安装-NFS方式 (适合于批量安装大量服务器，和kickstart自动安装一起使用)网络安装-FTP方式 (适合于批量安装大量服务器，和kickstart自动安装一起使网络安装-HTTP方式 (适合于批量安装大量服务器，和kickstart自动安装一起使 问：可重入函数https://www.nowcoder.com/profile/7404313/test/8114731/56534?onlyWrong=0 问：并发https://www.nowcoder.com/profile/7404313/test/8114731/44749?onlyWrong=0","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://hepsilion.github.io/tags/操作系统/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"04-JSP","slug":"04-JSP","date":"2017-05-28T10:52:12.000Z","updated":"2017-05-28T10:52:40.055Z","comments":true,"path":"2017/05/28/04-JSP/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/04-JSP/","excerpt":"JSP","text":"JSP https://www.nowcoder.com/profile/7404313/test/8073294/15276?onlyWrong=0","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://hepsilion.github.io/categories/Java-Web/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"},{"name":"Web","slug":"Web","permalink":"https://hepsilion.github.io/tags/Web/"}],"keywords":[{"name":"Java Web","slug":"Java-Web","permalink":"https://hepsilion.github.io/categories/Java-Web/"}]},{"title":"03-Servlet","slug":"03-Servlet","date":"2017-05-28T10:51:29.000Z","updated":"2017-05-28T10:51:59.804Z","comments":true,"path":"2017/05/28/03-Servlet/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/03-Servlet/","excerpt":"Servlet","text":"Servlet https://www.nowcoder.com/profile/7404313/test/8073294/15043?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8073294/7699?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8078128/15047?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8113740/15258?onlyWrong=0 https://my.oschina.net/dtkking/blog/89443 问：Servlet初始化https://www.nowcoder.com/profile/7404313/test/8103755/26091?onlyWrong=0","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://hepsilion.github.io/categories/Java-Web/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"},{"name":"Web","slug":"Web","permalink":"https://hepsilion.github.io/tags/Web/"}],"keywords":[{"name":"Java Web","slug":"Java-Web","permalink":"https://hepsilion.github.io/categories/Java-Web/"}]},{"title":"02-HTTP协议","slug":"02-HTTP协议","date":"2017-05-28T10:51:09.000Z","updated":"2017-05-28T10:51:09.667Z","comments":true,"path":"2017/05/28/02-HTTP协议/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/02-HTTP协议/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"01-XML","slug":"01-XML","date":"2017-05-28T10:50:01.000Z","updated":"2017-05-28T10:50:39.303Z","comments":true,"path":"2017/05/28/01-XML/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/01-XML/","excerpt":"XML解析","text":"XML解析 https://www.nowcoder.com/profile/7404313/test/8114731/25962?onlyWrong=0","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://hepsilion.github.io/categories/Java-Web/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"},{"name":"Web","slug":"Web","permalink":"https://hepsilion.github.io/tags/Web/"}],"keywords":[{"name":"Java Web","slug":"Java-Web","permalink":"https://hepsilion.github.io/categories/Java-Web/"}]},{"title":"Java","slug":"Java","date":"2017-05-28T10:47:23.000Z","updated":"2017-06-01T06:45:13.532Z","comments":true,"path":"2017/05/28/Java/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/Java/","excerpt":"Java整合","text":"Java整合 一、 Java概述问：什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？Java源文件被javac编译成能被Java虚拟机执行的.class字节码文件，Java虚拟机是一个可以执行Java字节码的虚拟机进程，它拥有自己完善的硬体架构，如堆栈、寄存器，还具有相应的指令系统。 Java虚拟机对开发者屏蔽了与具体操作系统平台相关的信息，使得Java源文件只需要被编译成可以在JVM上运行的字节码文件，就可以由相应平台的虚拟机在具体平台上解释运行，从而实现一次编译，处处执行。这样，Java被设计成允许应用程序可以运行在任意的平台上，而不需要程序员为每一个平台单独重写或者是重新编译。 问：动态语言和静态语言动态语言：运行时执行类型检查，如PHP、Ruby、Python等。 静态语言：编译时执行类型检查，如C、C++、Java和C#等。 问：编译型语言和解释型语言例1 问：JDK和JRE的区别是什么？Java运行时环境(JRE)包括Java虚拟机、Java核心类库和支持文件，JVM对Java字节码文件进行解释执行。只有JRE只能执行Java程序，不能进行java程序的开发。 Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。 例1： JRE判断程序是否执行结束的标准是：所有的前台线程执行完毕 问：一个”.java”源文件中是否可以包括多个类(不是内部类)？有什么限制？一个”.java”源文件中可以包括多个类。如果这个类的修饰符是public，其类名与文件名必须相同。 问：javac例1：下列说法正确的有哪些？ A. 环境变量可在编译source code时指定 B. 在编译程序时，所能指定的环境变量不包括class path C. javac一次可同时编译数个Java源文件 D. javac.exe能指定编译结果要置于哪个目录（directory） 答案：A C D 问：JAVA的事件委托机制和垃圾回收机制Java事件委托机制：一个源产生一个事件并将它送到一个或多个监听器那里。在这种方案中，监听器简单的等待，直到它收到一个事件。一旦事件被接受，监听器将处理这个事件，然后返回。 垃圾回收机制：垃圾收集是将分配给对象但不再使用的内存回收或释放的过程。如果一个对象没有指向它的引用或者其赋值为null，则此对象适合进行垃圾回收。 问：Java运行时数据区Java运行时数据区包括：虚拟机栈区，堆区，方法区，本地方法栈，程序计数器 虚拟机栈区：也就是我们常说的栈区，线程私有，在编译期间完成分配，为虚拟机执行Java方法(也就是字节码)服务，每个方法在执行时会创建一个栈帧用于存放局部变量表、操作数栈、动态链接和方法出口等信息，每个方法的调用直至执行完成对应于栈帧的入栈和出栈； 堆区：JAVA堆，也称GC堆，在JVM启动时创建，所有线程共享，存放对象的实例和数组，是垃圾收集器管理的主要区域。”GC堆”，可以细分为新生代和老年代，新生代又可以细分为Eden空间、From Survivor空间和To Survivor空间；物理上可以不连续，但逻辑上连续，可以选择固定大小或者扩展。 方法区：所有线程共享，用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池中的对象的回收和堆类型的卸载。方法区被称为“永久代”，是因为HotSpot虚拟机的设计团队把GC分代收集扩展到方法区，即使用永久代来实现方法区，像GC管理Java堆一样管理方法区，从而省去专门为方法区编写内存管理代码， 本地方法栈(Native Method Stacks)：线程私有，与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 程序计数器：线程私有，每个线程都有自己独立的程序计数器，用来指示下一条指令的地址，是当前线程所执行的字节码的行号指示器，如果线程正执行一个java方法，计数器记录下一条执行的虚拟机字节码指令的地址；如果线程正在执行的是Native方法，则计数器值为空； 运行时常量池：线程共享，是方法区的一部分，存放编译期Class文件中生成的各种字面量和符号引用。 例1 问：堆和栈的区别栈内存由操作系统来分配，只要栈剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出 堆内存由程序员自己来申请分配 例1： class A { private String a = &quot;aa&quot;; public boolean methodB() { String b = &quot;bb&quot;; final String c = &quot;cc&quot;; } } 上述Java代码中的变量a、b、c分别在内存的：堆区、栈区、栈区 问：Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)? 需要整理使答案更简洁JVM的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在JVM启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。 堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。 虚拟机中的堆内存共划分为三个代：年轻代（Young Generation）、年老代（Old Generation）和持久代（Permanent Generation）。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。 Java的垃圾收集机制主要针对新生代和老年代的内存进行回收，不同的垃圾收集算法针对不同的区域。所以java的垃圾收集算法使用的是分代回收。一般java的对象首先进入新生代的Eden区域，当进行GC的时候会回收新生代的区域，新生代一般采用复制收集算法，将活着的对象复制到survivor区域中，如果survivor区域装在不下，就查看老年代是否有足够的空间装下新生代中的对象，如果能装下就装下，否则老年代就执行FULL GC回收自己，老年代还是装不下，就会抛出OUtOfMemory的异常。 (1) 年轻代:所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。Minor GC是针对新生代的回收。 年轻代分三个区:一个Eden区，两个Survivor区(一般而言)。 大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区(两个中的一个)，当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。 (2) 年老代:在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。Major GC/Full GC是针对年老代的回收。 (3) 持久代:用于存放静态文件，如类、方法、final常量、static变量等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=进行设置。 例1：JVM中垃圾回收分为scanvenge gc和full GC，其中full GC触发的条件可能有哪些？ 答案：老年代满、持久代满、System.gc() 例2：以下哪些jvm的垃圾回收方式采用的是复制算法回收? A. 新生代串行收集器 B. 老年代串行收集器 C. 并行收集器 D. 新生代并行回收收集器 E. 老年代并行回收收集器 F. cms收集器 答案：A D 例3：下面哪种情况会导致持久区jvm堆内存溢出？ A. 循环上万次的字符串处理 B. 在一段代码内申请上百M甚至上G的内存 C. 使用CGLib技术直接操作字节码运行，生成大量的动态类 D. 不断创建对象 答案：C 问：JVM内存配置参数-Xmx：最大堆大小 -Xms：初始堆大小 -Xmn:年轻代大小 -XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值 例1： 当-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3时，其最小内存值和Survivor区总大小分别是() -Xms初始堆大小即最小内存值，即最小内存值为10240m JVM一般根据对象的生存周期将堆内存分为若干不同的区域，一般情况将新生代分为Eden，两块Survivor； 由-XXSurvivorRatio=3可知Eden:Survivor=3，年轻带总大小为5120m，那么Survivor区总大小为2048m 问：Java中垃圾回收(GC)有什么目的？什么时候进行垃圾回收？GC是垃圾收集的意思(Gabage Collection)，内存处理是编程人员容易出现问题的地方，忘记或者错误地内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的。 垃圾回收的目的是识别并回收堆内存中不再使用的对象所占的内存，释放资源。而栈区的内存是随着线程结束而释放的。 触发主GC(Garbage Collector，垃圾回收)的条件： (1) 当应用程序空闲时，即没有应用线程在运行时，GC会被调用。 (2) Java堆内存不足时，GC会被调用。 问：System.gc()和Runtime.gc()会做什么事情？Java提供了垃圾回收机制来帮助我们不定时的回收堆中不再使用的对象。当JVM启动时，除了启动我们的主线程外，还会启动垃圾回收线程，它运行优先非常低，会在JVM空闲时，自动回收我们不再使用的对象，释放内存空间。 程序员不能强制执行垃圾回收，可以用这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM，即垃圾回收的具体时间和顺序是无法预知的。 问：垃圾回收器的演化图 1 问：如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？不会立即释放对象占用的内存，如果对象的引用被置为null，只是断开了当前线程栈帧中对该对象的引用关系，在下一个垃圾回收周期中，这个对象将是可被回收的。 问：串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？吞吐量收集器使用并行版本的新生代垃圾收集器，它适合于吞吐量要求较高的场合，用于中等规模和大规模数据的应用程序。 串行收集器整个扫描和复制过程均采用单线程的方式，相对于吞吐量GC来说简单；适合于单CPU、客户端级别。串行对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。 问：在Java中，对象什么时候可以被垃圾回收？当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。 问：JVM的永久代中会发生垃圾回收么？(没看懂)垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。 请参考下Java8：从永久代到元数据区(注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区) 问：内存泄漏内存泄露(Memory Leak)是指一个不再被使用的对象或者变量还在内存中占有存储空间。在C/C++语言中，内存泄露出现在开发人员忘记释放已分配的内存就会造成内存泄露。在java语言中引入垃圾回收机制，有GC负责进行回收不再使用的对象，释放内存。但是还是会存在内存泄露的问题。 内存泄露主要有两种情况 (1) 在堆中申请的空间没有释放。 (2) 对象已不再被使用(注意：这里的不再被使用是指对程序来说没有用处，如数据库连接使用后没有关，但是还是存在着引用)，但是仍然在内存中保留着。 GC机制的引入只能解决第一种情况，对于第2种情况无法保证不再使用的对象会被释放。java语言中的内存泄露主要指第2种情况。 内存泄露的原因 (1) 静态集合类。如HashMap和Vector。这些容器是静态的，生命周期和程序的生命周期一致，那么在容器中对象的生命周期也和其一样，对象在程序结束之前将不能被释放，从而会造成内存泄露。 (2) 各种连接。如数据库连接，网络连接，IO连接，不再使用时如果连接不释放容易造成内存泄露。 (3) 监听器。释放对象时往往没有相应的删除监听器，可能会导致内存泄露。 内存溢出（OOM）是指程序在申请内存时没有足够的内存供使用，进而导致程序崩溃这是结果描述。内存泄露（Memory Leak）最终会导致内存溢出。 二、 基础语法问：关键字和保留字(1) Java关键字列表(依字母排序共50组) abstract, assert, boolean, break, byte, case, catch, char, class, const(保留关键字), continue, default, do, double, else, enum, extends, final, finally, float, for, goto(保留关键字), if, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while (2) 保留字列表(依字母排序共14组)，Java保留字是指现有Java版本尚未使用，但以后版本可能会作为关键字使用 byValue, cast, false, future, generic, inner, operator, outer, rest, true, var, goto(保留关键字), const(保留关键字), null 注意： (1) const和goto既是保留字又是关键字 (2) 除了const和goto，其余保留字和关键字是严格区分开的。 问：Java支持的数据类型有哪些？Java语言支持8种基本数据类型是：byte、short、int、long、float、double、boolean、char；支持3种引用数据类型：类、接口和数组。 (1) Java中整数值默认为int型，如果要指定整数为long型需要加L；浮点数值默认为double型，如果要指定浮点数为float型需要加F。 float f=3.4; //错误，3.4默认为double型。 float f=3.4F; //正确 float f=3; //正确 (2) Java中在定义类的成员变量时可以对其初始化，如果不对其初始化，Java使用默认值对其初始化；而局部变量在使用前则必须进行初始化，JVM不会进行默认值初始化。(3) Java中基本数据类型变量默认初始化值如表所示，对象引用默认初始化值为null。 图 2 问：Java中的中文字符Java语言中，中文字符所占的字节数取决于字符的编码方式，默认使用GBK编码方式。 当采用ISO8859-1编码方式时，一个中文字符占1个字节； 当采用GB2312或GBK编码方式时，一个中文字符占2个字节； 当采用UTF-8编码方式时，一个中文字符会占3个字节。 Java字符默认使用unicode编码，每个字符占用两个字节，所以char型变量可以存放一个中文字符。 Unicode字符编码标准是固定长度的字符编码方案。Unicode根据要编码的数据类型使用两种编码格式：8 位和16位。缺省编码格式是16位，即每个字符是16位(两个字节)宽。 注意：char与byte在Java和C++中的区别： 在C++中，char是基础数据类型，占1个字节；byte不是基础数据类型，一般定义为typedef unsigned char byte;也就是说，byte其实是unsigned char类型，那么也是占1个字节。不同的是，char可以表示的范围是-128-127，而byte可以表示的范围是0-255。 在java中，char和byte都是基础数据类型，其中的byte占1个字节，可以表示的范围是-128-127。而char占2个字节，可以表示的范围是’\\u0000’-‘\\uFFFF’。 例1： Java中实现国际化应用常用的手段是利用ResourceBundle类。 这个题目解答没看懂 问：类型转换(1) byte\\char\\short -&gt; int -&gt; long -&gt; float -&gt; double (2) Java中如果碰到char、byte和short参与运算时，会自动将这些值转换为int类型值然后再进行运算。 short s1 = 1; s1 = s1 + 1; //错误，s1+1运算结果是int型，需要强制转换类型 short s1 = 1; s1 += 1; //正确 short s = 16; byte a2 = s; //错误 (3) 低级向高级是隐式类型转换，高级向低级必须强制类型转换 (4) 两个数值进行二元操作时，会有如下的转换操作： 如果两个操作数其中有一个是double类型，另一个操作数将会转换为double类型； 否则，如果其中一个操作数是float类型，另一个操作数将会转换为float类型； 否则，如果其中一个操作数是long类型，另一个操作数会转换为long类型； 否则，两个操作数都转换为int类型。 例1： public static void main(String[] args){ int i=42; double d=42.0000; long l=42; float f=42.0f; float f2=42.00f; System.out.println(d==i); //true System.out.println(f==i); //true System.out.println(f==f2); //true System.out.println(l==i); //true System.out.println(l==f); //true System.out.println(d==f); //true } 例2： 对于java类型变量char c，short s，float f，double d，表达式c*s+f+d的结果类型为double 问：进制表示 八进制： 012 十六进制：0x12 问：源码、反码和补码例1： 变量a是一个64位有符号的整数，初始值用16进制表示为：0Xf000000000000000； 变量b是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF。 则a-b的结果用10进制表示为多少？ 计算机是用补码进行存储和计算的，因此a和b的初始值即为a和b在计算机中的补码形式，即：a的补码为0Xf000000000000000，b的补码为0x7FFFFFFFFFFFFFFF 0Xf000000000000000=1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x7FFFFFFFFFFFFFFF=0111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 a-b=a+(-b) 由于b是正数，原码与其补码相同，都为0x7FFFFFFFFFFFFFFF，则-b的原码为0xFFFFFFFFFFFFFFFF，是负数 现在求-b的补码，先对它的原码(除符号位外)各位取反得到-b的反码，然后反码尾部加1得到-b的补码，为 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001 所以a-b=a+(-b)= 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000+ 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001= 10111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001(最高位溢出，舍去，结果变成了正数) 则结果为0111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001=2^62+2^61+2^60+1 例2： 变量a是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF; 变量b是一个64位有符号的整数，初始值用16进制表示为：0x8000000000000000。 则a+b的结果用10进制表示为多少？ 计算机中是以补码形式存储数据，则a和b的初始值即为a和b在计算机中的补码形式。 0x7FFFFFFFFFFFFFFF+0x8000000000000000=0xFFFFFFFFFFFFFFFF 结果最高位符号位为1，说明结果为负数，现在求结果的原码值。 保持符号位不变，补码减1，得到结果的反码；保持符号位不变，反码取反，得到结果的原码：-1 例3： short a=128； byte b=(byte)a; 此时，变量a，b的值分别为128和-128 计算机是用补码进行存储和计算的，Java中short占2个字节，16位，因此a在内存中补码形式为0000 0000 1000 0000 Java中byte占1个字节，8位。将short变量强制类型转换时会截断前8位，得到1000 0000，即为b的补码形式。 现在已知a的补码为10000000，求原码。因为最高位表示符号位，所以首先这个数为负数。 保持符号位不变，补码减1，得到结果的反码1111 1111；保持符号位不变，反码取反，得到结果的原码1 0000 0000：-128 问：常见的运算符 +，%，~，三目运算符，++，&amp;&amp;和&amp;，&gt;&gt;和&gt;&gt;&gt; +： 例1： public class Test { public static void main(String args[]) { System.out.println(8+8+&quot;88&quot;+8+8); //168888 } } 例2： 若有定义语句：int a=10; double b=3.14;则表达式&apos;A&apos;+a+b 值的类型是double %：取模运算符，要求操作数为整型。 ~：按位取反运算符 例1： 若int j = 10; 则~j为多少？ 计算机是用补码进行存储和计算的，因此10在计算机中补码存储为：00000000 00000000 00000000 00001010 ~j操作是对j的补码取反，然后得到结果即为~j的补码： 11111111 11111111 11111111 11110101 现在通过~j的补码反推出~j的原码，~j最高位符号位为1，表明它是一个负数 保持符号位不变，补码减1，得到~j的反码： 11111111 11111111 11111111 11110100 保持符号位不变，反码取反，得到~j的原码： 10000000 00000000 00000000 00001011 换算为整数，~j大小为-11 三目运算符 例1： boolean b=true?false:true==true?false:true; System.out.println(b); //false ++ 例1： 假定x和y为double型，则表达式x=2，y=x+3/2的输出为3.000000 i=i++问题 Java使用了中间缓存变量机制，JVM运行这条语句时过程如下： 步骤1 JVM把i值拷贝到临时变量区； 步骤2 i值加1； 步骤3 返回临时变量区的值，注意这个值步骤1中没修改过的i值。 步骤4 返回值赋值给i，此时count值被重置成原来的值。 例2： package algorithms.com.guan.javajicu; public class Inc { public static void main(String[] args) { Inc inc = new Inc(); int i = 0; inc.fermin(i); i= i ++; System.out.println(i); } void fermin(int i){ i++; } } 程序输出结果为0 例3： public class Test2{ public void add(Byte b){ b = b++; } public void test(){ Byte a = 127; Byte b = 127; add(++a); System.out.print(a + &quot; &quot;); add(b); System.out.print(b + &quot;&quot;); } } 执行test()函数后，程序输出为：-128 127 &amp;&amp;和&amp; &amp;&amp;:短路与，若该运算符左边为false，运算符右边表达式不执行。 &amp;: 按位与，若该运算符左边为false，运算符右边表达式还会继续执行。 >&gt;和&gt;&gt;&gt; >&gt; 表示带符号右移 >&gt;&gt; 表示无符号右移，左边空出的位以0填充 int x=5&gt;&gt;2; // &gt;&gt;表示带符号右移，5&gt;&gt;2相当于5除于2的平方，等于1 int y=1&gt;&gt;&gt;2; // &gt;&gt;&gt;表示无符号右移，高位用0填充，0001右移两位为0000，等于0 问：switchswitch(expr)中，expr是一个整数表达式，因此传递给switch和case语句的参数应该是int、short、char、byte或者其对应的封装类以及Enum类型，long、String(在Java7中，也支持了String类型)都不能用于swtich表达式。 在switch语句中，表达式的值不能是null，否则会在运行时抛出NullPointerException。在case子句中也不能使用null，否则会出现编译错误。 问：switch与breakswitch结构中匹配的case子句中如果没有break跳出执行，那么程序执行完case子句后不会跳出，将会继续执行后续的case子句，直到遇到break跳出switch；如果一直没有遇到break，程序将一直执行到整个结构结束。 例1： public class SwitchTest{//1 public static void main(String[] args) { System.out.println(switchit(4)); } public static int switchit(int x) { int j=1; switch (x) { case 1:j++; case 2:j++; case 3:j++; case 4:j++; case 5:j++; default:j++; } return j+x; } } 程序将会输出8 例2： public static int getValue(int i) { int result = 0; switch (i) { case 1: result = result + i; case 2: result = result + i * 2; case 3: result = result + i * 3; } return result; } 调用getValue(2)将返回10 问：值传递和引用传递？java内的传递都是值传递。 (1) 对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。 (2) 对引用型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身，所以对引用对象进行操作会同时改变原对象。 例1： public class Tester{ public static void main(String[] args){ Integer var1=new Integer(1); Integer var2=var1; doSomething(var2); System.out.println(var1.intValue()); System.out.println(var1==var2); } public static void doSomething(Integer integer){ integer=new Integer(2); } } 程序运行输出如下： 1 true 例2：注意下一评论 三、 面向对象编程问：面向对象的基本特征(1) 封装：利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过对外已授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。 (2) 继承：继承是使用已存在的类作为基础定义新类，新类的定义可以增加新的数据或新的操作，也可以复用父类的操作，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。 (3) 多态：多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。 问：类例1 问：访问控制符Java类的成员默认为default访问权限。 图 1 访问权限大小：public&gt;protected&gt;default&gt;private 例1 问：Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？Java中每一个类都有构造方法，当使用关键字new实例化一个对象时，类的构造方法就会被自动调用，完成对象的初始化工作。 构造方法是一种特殊的方法，具有以下特点: (1) 构造方法的方法名必须与类名相同； (2) 构造方法没有返回值类型，也不能定义为void； (3) 构造方法不能被static、final、synchronized、abstract、native等关键字修饰，但可以被public、private、protected修饰 (4) 一个类可以定义多个构造方法，如果在定义类时没有定义构造方法，则编译系统会自动插入一个无参数的默认构造方法，这个构造器不执行任何代码； 例1： (5) 构造方法可以被重载，以参数的个数、类型、顺序进行区分； (6) 构造方法不能被继承，因此不能被重写，子类使用父类的构造方法需要使用super关键字 例1： Java中构造方法重载和方法重载很相似，可以为一个类创建多个构造方法，每一个构造方法必须有它自己唯一的参数列表。 Java不支持像C++中那样的复制构造方法，但是这并不代表Java中没有这种机制，Java中Object类的clone()方法就是这种机制的体现。 问：new关键字例1 问：this关键字问：static关键字“static”关键字可以用于修饰类的成员变量和成员方法，被其修饰的成员变量被称为类变量，被其修饰的成员方法成为类方法，它们随着类的加载而加载，使得该变量和方法可以在类没有实例化的情况下可以直接通过类名进行访问。 (1) 被static修饰的成员方法只能访问static成员，不可以访问非static成员 Java中被static修饰的变量和方法是属于类的，它们随着类的加载而加载，同时对static变量进行初始化并执行static代码块。如果static环境中的代码尝试访问非static的变量，编译器会报错，因为类的加载先于变量的创建，类加载的时候这些变量还没有被创建出来，例如，在static方法中访问某对象的非static方法，此时尚不能保证对象已经被实例化。因此在static环境中不能访问非static变量。 例1 package NowCoder; class Test { public static void hello() { System.out.println(&quot;hello&quot;); } } public class MyApplication { public static void main(String[] args) { Test test=null; test.hello(); } } 上述代码：能编译通过，并正确运行 (2) Java中静态变量只能在类主体中定义，不能在方法中定义。 静态变量属于类所有而不属于方法。静态变量是在方法之前被加载的，所以static变量只能是类成员变量，而不能是局部变量，因为在static加载时，方法还没有分配空间。 例1： public class Test { public int aMethod() { static int i = 0; i++; return i; } public static void main (String args[]) { Test test = new Test(); test.aMethod(); int j = test.aMethod(); System.out.println(j); } } 程序编译失败 问：继承继承时类的实例化问题：在实例化一个类时，一定是先创建其父类对象，即先执行父类的构造函数，然后再创建当前类对象。如果子类没有显示地调用父类的构造函数，编译器会自动加入父类的无参的构造函数super() 例1： package test; class FatherClass { public FatherClass() { System.out.println(&quot;FatherClass Create&quot;); } } class ChildClass extends FatherClass { public ChildClass() { System.out.println(&quot;ChildClass Create&quot;); } public static void main(String[] args) { FatherClass fc = new FatherClass(); ChildClass cc = new ChildClass(); } } 程序的输出结果如下： FatherClass Create FatherClass Create ChildClass Create 问：Java支持多继承么？Java中的类不支持多继承，只支持单继承(即一个类只有一个父类)。 但是Java中的接口支持多继承，即一个子接口可以有多个父接口。(接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能)。 问：super和thisthis代表当前类对象，super代表当前类对象的父类对象。 在子类构造方法中，使用super()调用的是其父类的构造方法，而使用this()调用的是同一个类中重载的构造方法 super关键字 (1) Java中子类不能继承父类的构造方法，只能调用父类构造方法； (2) 子类的构造方法可以使用super显示地调用父类构造方法； (3) 当子类构造方法中没有使用super来显示地调用父类构造方法时，系统会默认采用super()调用父类的无参构造方法，这时父类必须提供无参构造参数，否则编译出错。 案例： 例1，例2，例3，例4 this关键字 注意： (1) 使用super()或this()时，它们必须放在构造方法的第一行，否则编译通不过。 (2) 由于this()调用的构造函数默认调用super()方法，所以规定this()和super()不能同时出现在一个构造函数中。 (3) static环境，包括static方法和static语句块，在执行时还没有构造对象实例，因此不能在static环境中使用this()和super() 问：Java中的方法重写(Overriding)和方法重载(Overloading)是什么意思？方法重写和方法重载都是Java多态性的不同表现(动态绑定 dynamic binding) (1) 方法重载是一个类中多态性的一种表现，发生在同一个类里面两个或多个方法的方法名相同但是参数列表不同的情况。 函数名必须相同； 函数参数列表必须不相同，可以是参数个数、参数类型或者参数顺序不同； 函数的返回值类型、修饰符可以相同，也可以不相同； (2) 方法重写是父类与子类之间多态性的一种表现，是说子类重新定义了父类的方法；方法的重写满足两同两小一大原则 方法名相同，参数类型相同 子类返回类型小于等于父类方法返回类型； 子类抛出异常小于等于父类方法抛出异常； 子类访问权限大于等于父类方法访问权限 (public&gt;protected&gt;defualt(默认修饰符)&gt;private)。 注意：Java不支持运算符重载。 例1 问：Java中是否可以覆盖(override)一个private或者是static的方法？private修饰的方法不能被覆盖，因为被private修饰的父类方法在子类中是不可见的。 Java中静态方法在形式上可以被重写，即子类中可以重写父类中静态的方法。但是实际上从内存的角度上静态方法不可以被重写，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。 问：final关键字final关键字可以用于修饰类、变量和方法。 (1) final修饰的类不可被继承(因此一个类不能同时被final和abstract修饰)； (2) final修饰的方法不可被重写； (3) final修饰的变量的值不可被修改，一旦获得初始值，该变量就不能被重新赋值。 例1，例2，例3 (4) 形式参数只能用final修饰符，任何其它修饰符都会引起编译错误。但是用这个修饰符也有一定的限制，就是在方法中不能对参数做任何修改。不过在一般情况下，一个方法的形参不用final修饰。只有在特殊情况下：方法内部类，一个方法内的内部类如果使用了这个方法的参数或者局部变量，这个参数或局部变量应该是final。 (5) final修饰的成员变量既可以在定义时显示地初始化，也可以先声明而不初始化，这种成员变量称为blank final，此时可以在构造代码块或构造函数中对其赋初值，否则编译会报错。 例1： class Foo { final int i; int j; public void doSomething() { System.out.println(++j + i); // 编译出错，因为final成员变量在使用前没有赋初值 } } 例2：这一题解释尚不明确，不知道final方法在子类中继承了没有。 public class Car extends Vehicle{ public static void main(String[] args){ new Car().run(); //输出：Car } private final void run(){ System.out.println(&quot;Car&quot;); } } class Vehicle{ private final void run(){ System.out.println(&quot;Vehicle&quot;); } } (6) 被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化 例1： byte b1=1,b2=2,b3,b6,b8; final byte b4=4,b5=6,b7; b3=(b1+b2); /*语句1*/ b6=b4+b5; /*语句2*/ b8=(b1+b4); /*语句3*/ b7=(b2+b5); /*语句4*/ System.out.println(b3+b6); 代码片段中，存在编辑错误的语句是：语句1、语句3和语句4 语句1错误：b3=(b1+b2);自动转为int，所以正确写法为b3=(byte)(b1+b2);或者将b3定义为int； 语句2正确：b6=b4+b5;b4、b5为final类型，不会自动提升，计算结果任然是byte类型，然后结果的类型视左边变量类型而定，即b6可以是任意数值类型； 语句3错误：b8=(b1+b4);虽然b4不会自动提升，但b1仍会自动提升，所以结果需要强转，b8=(byte)(b1+b4); 语句4错误：b7=(b2+b5); 同上。同时注意b7是final修饰，即只可赋值一次，便不可再改变。 问：Object类Java中Object是所有类的祖先类，Object类中包含如下方法： 图 1 问：equals()方法和==的区别 ==运算符：对于基本数据类型变量比较的是两个变量的值是否相等；对于引用型变量表示的是两个变量指向的对象在堆中存储的地址是否相同，即栈中的内容是否相同 equals()方法：继承自Object类，默认调用==进行比较。判断两个对象是否相等需要覆盖equals()方法和hashcaode()方法 问：finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？finalize()是Object类的一个方法，垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法。 但是很不幸的是，在Java中，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说filalize()可能永远不被执行，显然指望它做收尾工作是靠不住的。 那么finalize()究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。 问：clone，没遇到过，暂时存放42、写clone()方法时，通常都有一行代码，是什么？Clone有缺省行为，super.clone();他负责产生正确大小的空间，并逐位复制。 问：多态的实现方式(1) 静态的多态：方法重载 (2) 动态的多态：子类覆盖父类的方法，将子类的实例赋值给父类的引用，此时调用的是子类的方法；实现接口的实例赋值给接口的引用，此时调用的实现类的方法。 例1：判断对错 在java的多态调用中，new的是哪一个类就是调用的哪个类的方法。 错误 问：抽象类和接口的区别Java提供和支持创建抽象类和接口。 含有abstract修饰符的class即为抽象类，abstract类不能创建类的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。 接口(interface)可以说成是抽象类的一种特例 它们的不同点在于： 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。 (1) 抽象类和接口都不可以被实例化 (2) 抽象类中可以包含普通成员变量、静态成员变量；而接口中没有普通成员变量、只有常量，接口中声明的成员变量默认为public static final类型，且只能是public static final类型； (3) 抽象类中可以同时包含抽象方法和非抽象方法，也可以没有抽象方法，但如果一个类中有一个抽象方法，那么当前类一定是抽象类；而接口中只有方法的声明、没有方法体，即接口中的所有方法必须都是抽象的，不能有非抽象的普通方法(Java8中接口可以有非抽象的default方法) (4) 抽象类中的抽象方法，需要由子类实现，如果子类不实现所有抽象方法，则子类也需要定义为抽象类；接口中定义的方法都需要由实现类来实现，如果实现类不能实现接口中的所有方法，则实现类需要定义为抽象类 (5) 抽象类中可以有构造方法，其作用是初始化抽象类的成员；接口中不能有构造方法 (6) 抽象类中的成员方法的访问类型可以为public、protected和private，抽象方法必须为public或protected；而接口中的成员方法的访问类型默认为public abstract类型，且只能是public abstract (7) 抽象类中可以包含静态方法；而接口中不能包含静态方法(Java8开始接口可以有静态方法) (8) 抽象类可以implements接口；接口可以继承接口，并且接口可以实现多继承(一个接口可以继承多个接口) (9) 抽象类只能被单一extends(一个类只能继承一个类)；接口却可以被多重implements(一个类可以实现多个接口) (10) 类可以不实现抽象类和接口中声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的 (11) 抽象方法既不能是static的，也不能是native的，还不能是synchronized的 例1，例2，例3，例4 问：instanceof关键字instanceof前一个参数通常是一个引用类型变量，后一个操作数通常是一个类（也可以是一个接口）。它用于判断前面的变量引用的对象是否是后面的类(也可以是一个接口)或者其子类的实例。 例1： public static void main(String args[]) { List Listlist1 = new ArrayList(); Listlist1.add(0); List Listlist2 = Listlist1; System.out.println(Listlist1.get(0) instanceof Integer); System.out.println(Listlist2.get(0) instanceof Integer); } 上面代码将输出：true true Collection类型的集合（ArrayList,LinkedList）只能装入对象类型的数据 该题中需要装入0，是一个基本类型，但是JDK5以后提供了自动装箱与自动拆箱，所以int类型自动装箱变为了Integer类型。 List没有使用泛型，因此使用get(0)取出的元素的编译类型是Object型的，但运行时类型是Integer，所以打印true，这里体现了多态的应用。 而Listlist1把引用赋给了Listlist2，说明两个指向同一个对象，因此第二个打印的也是true。 问：内部类内部类分类，来自例2中评论部分BlueFish的总结。 使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。 使用内部类最大的优点就在于它能够非常好的解决多重继承的问题,使用内部类还能够为我们带来如下特性: 内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立； 在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类； 创建内部类对象的时刻并不依赖于外围类对象的创建； 内部类并没有令人迷惑的”is-a”关系，他就是一个独立的实体； 内部类提供了更好的封装，除了该外围类，其他类都不能访问。 (1) 成员内部类 public class Outer{ private String name=&quot;Outer&quot;; private int age=99; public static void main(String[] args){ Outer outer=new Outer(); Inner inner=outer.new Inner(); inner.show(); } private class Inner{ private String name=&quot;Inner&quot;; private final int num=10; public void show(){ System.out.println(Outer.this.name); System.out.println(this.name); System.out.println(age); } } } Inner类定义在Outer类的内部(相当于Outer类的一个成员变量的位置处)，Inner类可以使用任意访问控制符，如public、protected、private等； Inner 类中定义的show()方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问Outer类中的私有属性age； 定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去new一个内部类对象，即：内部类 对象名=外部类对象.new 内部类(); 编译上面的程序后，会发现产生了两个.class文件: Outer.class和Outer$Inner.class 成员内部类中不能存在任何static的变量和方法，但可以定义常量: 因为非静态内部类的存在是依赖于外部类的实例的，而静态变量和方法是不依赖于对象的，仅与类相关。而在加载静态域时，根本没有外部类实例，所在在非静态内部类中不能定义静态变量或方法，编译不通过;非静态内部类的作用域是实例级别 常量是在编译器时确定的，放到所谓的常量池了，因此可以定义常量。 注意： 外部类是不能直接使用内部类的成员和方法的，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法； 如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用this关键字，如:Outer.this.name (2) 静态内部类，static修饰的内部类 public class Outer{ private static String name=&quot;Outer&quot;; private static String tag=&quot;tag&quot;; private int age=99; public static void main(String[] args){ Inner inner=new Inner(); inner.show(); } private static class Inner{ private String name=&quot;Inner&quot;; public void show(){ System.out.println(Outer.name); System.out.println(this.name); System.out.println(tag); System.out.println(new Outer().age); } } } 静态内部类不能直接访问外部类的非静态成员，但可以通过new 外部类().成员的方式访问 如果外部类的静态成员与内部类的成员名称相同，可通过类名.静态成员的方式访问外部类的静态成员； 如果外部类的静态成员与内部类的成员名称不相同，则可通过成员名直接调用外部类的静态成员； 创建静态内部类的对象时，不需要外部类的对象，可以直接创建内部类 对象名=new 内部类(); (3) 方法内部类，访问仅限于方法内或者该作用域内 public class Outer { public static void main(String[] args) { Outer outer = new Outer(); outer.print(); } public void print() { final int a = 25; class Inner { private int c = 2; public void show() { System.out.println(a); System.out.println(c); } } Inner inner = new Inner(); inner.show(); } } 方法内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的 方法内部类不能修改方法中定义的局部变量(解释看原评论，原评论这部分，我测试有点问题，大概原因是内部类访问方法局部变量时会拷贝局部变量，对局部变量修改会造成拷贝的局部变量值与方法中局部变量值不一致，为了保持局部变量值得一致性，可以将被内部类访问的局部变量声明为final) (4) 匿名内部类 public class Outer{ public static void main(String[] args){ Outer outer=new Outer(); InnerClass inner=outer.getInnerClass(2, &quot;inner&quot;); System.out.println(inner.getNumber()); } public InnerClass getInnerClass(int num, String str){ return new InnerClass(){ int count; int number=num+1; { count=100; } @Override public int getNumber() { return number; } }; } private interface InnerClass{ int getNumber(); } } 匿名内部类是直接使用 new 来生成一个对象的引用； 对于匿名内部类的使用，它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用； 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口； 匿名内部类中是不能定义构造函数的，匿名内部类中不能存在任何的静态成员变量和静态方法； 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法； 匿名内部类初始化:使用构造代码块! 利用构造代码块能够达到为匿名内部类创建一个构造器的效果 例1： 重要 非静态内部类是属于对象的，所以初始化时需要先初始化一个外部类实例对象，然后使用此对象调用内部类的构造方法。静态内部类属于类本身，初始化时直接使用外部类调用静态内部类的构造方法即可 public class Test{ public static void main(String[] args){ EnclosingOne.InsideOne obj1=new EnclosingOne().new InsideOne(); //非静态内部类 EnclosingOne.InsideTwo obj2=new EnclosingOne.InsideTwo(); //静态内部类 } } class EnclosingOne { //非静态内部类 public class InsideOne { } //静态内部类 public static class InsideTwo{ } } 例2：往OuterClass类的代码段中插入内部类声明，哪一个是错误的？ public class OuterClass{ private float f=1.0f; //插入代码到这里 } A. class InnerClass{ public static float func(){ return f; } } B. abstract class InnerClass{ public abstract float func(){} } C. static class InnerClass{ protected static float func(){ return f; } } D. public class InnerClass{ static float func(){return f;} } 答案：ABCD 例3 问Static Nested Class和Inner Class的不同？Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化，而通常的内部类需要在外部类实例化后才能实例化。 问：类加载器Java中类的加载是由类加载器完成的，类加载器包括：引导类加载器(BootStrap ClassLoader)、扩展类加载器(Extension ClassLoader)、应用类加载器(Application ClassLoader)和用户自定义类加载器(java.lang.ClassLoader的子类)。 Bootstrap ClassLoader：它负责加载放在\\jre\\lib/目录中的，或者-Xbootclasspath参数所指定路径中的Java核心库(如rt.jar)，是用原生代码来实现的； Extension ClassLoader：它负责加载\\jre\\lib\\ext目录中，或系统变量java.ext.dirs所指定路径中的所有类库； Application ClassLoader：它负责加载Java应用的CLASSPATH所指定的类库。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它是应用最广泛的类加载器。开发者可以直接使用这个类加载器，如果应用程序中没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器； Custom ClassLoader：应用程序根据自身需要自定义的ClassLoader，是java.lang.ClassLoader的子类，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader。 例1 问：JVM的类加载机制推荐阅读 Java类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中准备、验证、解析3个部分统称为连接（Linking）。 图 1 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定） 例1 问：Java类加载时的初始化顺序(1) 初始化父类中的静态成员变量和静态代码块(按照在程序中出现的顺序初始化) (2) 初始化子类中的静态成员变量和静态代码块(按照在程序中出现的顺序初始化) (3) 初始化父类中的普通成员变量和构造代码块(按照在程序中出现的顺序初始化)，然后再执行父类中的构造方法 (4) 初始化子类中的普通成员变量和构造代码块(按照在程序中出现的顺序初始化)，然后再执行子类中的构造方法 例1： class Member { Member(String str) { System.out.println(str); } } class A { static { System.out.println(&quot;父类静态代码块&quot;); } public A() { System.out.println(&quot;父类构造函数&quot;); } { System.out.println(&quot;父类构造代码块&quot;); } Member member=new Member(&quot;父类成员变量&quot;); } class B extends A { Member member=new Member(&quot;子类成员变量&quot;); static { System.out.println(&quot;子类静态代码块&quot;); } public B() { System.out.println(&quot;子类构造函数&quot;); } { System.out.println(&quot;子类构造代码块&quot;); } } public class Test{ public static void main(String[] args) { new B(); } } //输出： 父类静态代码块 子类静态代码块 父类构造代码块 父类成员变量 父类构造函数 子类成员变量 子类构造代码块 子类构造函数 例2： public class B { public static B t1 = new B(); public static B t2 = new B(); { System.out.println(&quot;构造块&quot;); } static { System.out.println(&quot;静态块&quot;); } public static void main(String[] args) { B t = new B(); } } // 输出 构造块 构造块 静态块 构造块 例3： 例4：下面代码的输出是什么？ public class Base { private String baseName = &quot;base&quot;; public Base() { callName(); } public void callName() { System.out.println(baseName); } static class Sub extends Base { private String baseName = &quot;sub&quot;; public void callName() { System.out.println(baseName); } } public static void main(String[] args) { Base b = new Sub(); } } // 输出：null 问：JNI(Java Native Interface)Java的不足除了体现在运行速度上要比传统的C++慢许多之外，Java无法直接访问到操作系统底层（如系统硬件等)，为此Java使用native方法来扩展Java程序的功能。 native是方法修饰符，native方法是由另外一种语言（如C/C++,汇编等）实现的本地方法，因为在外部实现了方法，所以在java代码中，就不需要声明了，有点类似于接口中的抽象方法。其实现步骤为： 在Java中声明native()方法，然后编译； 用javah产生一个.h文件； 写一个.cpp文件实现native导出方法，其中需要包含第二步产生的.h文件（注意其中又包含了JDK带的jni.h文件）； 将第三步的.cpp文件编译成动态链接库文件； 在Java中用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问了。 例1：以下声明合法的是： A. default String s B. public final static native int w() C. abstract double d D. abstract final double hyperbolicCosine() 答案：B native可以和任何修饰符连用，abstract除外。因为native暗示这个方法时有实现体的，而abstract却显式指明了这个方法没有实现体。 例2：Which of the following can be applied to constructors? A. final B. static C. synchronized D. native E. None of these. 答案：E native方法和abstract方法都是方法的声明，一个把方法实现移交给子类，另一个移交给本地操作系统。 如果同时出现，就相当于既把实现移交给子类，又把实现移交给本地操作系统，那就会产生混乱。 Java构造方法可以有任何访问的修饰：public，protected，private或者没有修饰。 但是不能有以下非访问性质的修饰：abstract，final，native，static，或者synchronized。 四、 异常处理问：Java中的两种异常类型是什么？他们有什么区别？Throwable包含了错误(Error)和异常(Excetion)两类。 图 1 (1) Error： 由Java虚拟机生成并抛出，属于JVM底层或者运行时环境的错误，程序无法预测和捕获处理，如OutOfMemoryError，如果出现Error，Java虚拟机会终止执行。 (2) Exception: 用户程序可以捕获的异常情况，Java中有两种异常，分别为运行时异常(RuntimeException, 又叫非检查异常)和非运行时异常(又叫检查异常)。 运行时异常：RuntimeException类及其子类，如ArithmeticException、NullPointerException、IndexOutOfBoundsException、ClassCastException、BufferOverflowException、ConcurrentModificationException、IllegalArgumentException、NoSuchElementException、UnsupportedOperationException等，这类异常是在程序运行的时候可能会发生的，Java编译器不去检查它，也就是说，当程序中可能出现这类异常时，即使没有用try…catch语句捕获它，也没有用throws字句声明抛出它，还是会编译通过。所以程序可以捕捉，也可以不捕捉。这些异常一般是由程序的逻辑错误引起的，其产生频繁，处理麻烦，若显示申明或者捕获将会对程序的可读性和运行效率影响很大，建议不要用try…catch…捕获处理，程序应该在开发调试的过程中从逻辑角度去尽量避免，例如：空值处理。 非运行时异常：运行时异常以外的异常，也是Exception及其子类，这些异常从程序的角度来说是必须经过捕捉检查处理的(要么用 try…catch捕获处理，要么用throws语句声明抛出)，否则不能通过编译。如IOException、SQLException、NoSuchMetodException、ClassNotFoundException、FileNotFoundException等。 问：异常处理语句的语法规则 try是用于检测被包住的语句块是否出现异常，如果有异常，则抛出异常，并执行catch语句 cacth用于捕获从try中抛出的异常并作出处理 finally语句块是不管有没有出现异常都要执行的内容 throw用于抛出异常 throws关键字可以在方法上声明该方法要抛出的异常，然后在方法内部通过throw抛出异常对象 (1) try代码块中包含可能产生异常的代码，其后跟一个或多个catch代码块，每个catch代码块用于捕获并处理一种特定类型的异常。 (2) 当try代码块中产生异常时，程序会终止当前的执行流程，Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个catch代码块，然后其他的catch代码块将不会再执行，即一个异常只能被一个catch代码块捕获执行。如果try代码块没有异常产生，所有的catch代码块将跳过不执行。 (3) catch代码块后可以跟finally代码块，无论try代码块中是否抛出异常，finally代码块都会被执行，因此finally代码块为异常处理提供一个统一的出口，使得在控制流程跳转到程序的其他部分之前，能够对程序的状态作统一的管理。通常在finally代码块中可以进行资源的清除工作。 (4) try代码块后基类异常的捕获语句不可以写在子类异常捕获语句的上面。 (5) 在try-catch-finally结构中，可重新抛出异常。 (6) try-catch-finally结构可嵌套。 (7) try不必一定有catch，只要catch和finally有一个存在就行，但是catch和finally不可以同时省略 (8) 自定义异常要继承Exception或Exception的子类。 问：异常处理完成以后，Exception对象会发生什么变化？Exception对象会在下一个垃圾回收过程中被回收掉。 问：throw和throws有什么区别？ throw关键字用来在方法内部明确地抛出异常，后面跟的是要抛出的异常对象且只能跟一个异常对象； throws关键字用在声明方法上，表示该方法可能要抛出的、该方法不能处理的异常，后面跟的是异常类名，可以有多个，用逗号隔开，这样方法的调用者才能够确保处理可能发生的异常。 问：finallyfinally作为异常处理的一部分，只能用在try/catch语句块后，无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。 例1：当程序执行到try{}语句中的return方法时，它将要返回的结果存储到一个临时栈中，然后程序不会立即返回，而是去执行finally{}中的代码，在执行a = 2时，程序仅仅是覆盖了a的值，但不会去更新临时栈中的那个要返回的值。finally{}执行完之后，程序就会将临时栈中的值取出来返回。 public abstract class Test { public static void main(String[] args) { System.out.println(beforeFinally()); // output: 1 } public static int beforeFinally(){ int a = 0; try{ a = 1; return a; }finally{ a = 2; } } } 例2：这里finally{}里也有一个return，那么在执行这个return时，就会更新临时栈中的值。同样，在执行完finally之后，程序将临时栈中的值取出来返回，即返回值是2. public abstract class Test { public static void main(String[] args) { System.out.println(beforeFinally()); //output: 2 } public static int beforeFinally(){ int a = 0; try{ a = 1; return a; }finally{ a = 2; return a; } } } 例3：try/catch可以捕获并处理异常，异常被捕获后程序可以继续向后执行 public class Test { public static void main(String[] args) { try { int i = 100 / 0; System.out.print(i); } catch (Exception e) { System.out.print(1); } finally { System.out.print(2); } System.out.print(3); } } // output: 123 例4：catch语句块里面，打印完1之后，又抛出了一个RuntimeException，程序并没有处理它，而是直接抛出，因此执行完finally语句块之后，程序便不往下执行直接终止了 public class Test { public static void main(String[] args) { try { int i = 100 / 0; System.out.print(i); } catch (Exception e) { System.out.print(1); throw new RuntimeException(); } finally { System.out.print(2); } System.out.print(3); } } // output: 12 例5：catch语句块里面，打印完1之后，程序先执行完finally语句块，然后return。 public class Test { public static void main(String[] args) { try { int i = 100 / 0; System.out.print(i); } catch (Exception e) { System.out.print(1); return; } finally { System.out.print(2); } System.out.print(3); } } // output: 12 问：final关键字、finally代码块和finalize()方法有什么区别？ final关键字用于声明变量、方法和类，分别表示变量的值不可被修改、方法不可被重写、类不可被继承。 finally作为异常处理的一部分，只能用在try/catch语句块后，无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。 finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由垃圾收集器来调用的。可以覆盖此方法在垃圾收集时的进行其他资源回收，例如关闭文件等。 五、 数组六、 常用类问：String、StringBuffer和StringBuilder(1) String：不可变的字符序列 String类不是基本数据类型，是引用数据类型 String是被final修饰的类，因此一旦一个String对象被创建并初始化后，包含在这个对象里的字符序列是不可改变的，直到这个对象被销毁，即本身的内容不可改变、长度不可改变； String类不可以被继承； String变量作为参数时相当于基本数据类型的值传递 对String对象的任何改变都不影响到原对象，每次操作都会生成新的String对象，然后将引用指向新的String对象，因此不推荐频繁改变String内容，会增加内存压力。为了提高效率节省空间，我们应该用StringBuffer类 当多个字符串联合时会先转为StringBuffer，再联合，最后生成String对象，速度较慢。 例1：Java中的字符串都是常量，字符串一旦被初始化，就不可以被改变，因为是常量，存放在方法区中的常量池中，可以实现共享。 // 双引号引起的数据都是字符串对象，存放在常量池中。s1指向的内存中只有一个对象，在常量池中。 String s1=&quot;abc&quot;; // 在内存中生成两个对象，&quot;abc&quot;存放在常量池中，new String()存放在堆内存中。s2指向的内存中有两个对象，分别在常量池中和堆内存中。 String s2=new String(&quot;abc&quot;); /*&quot;abc&quot;是字符串常量，被存在堆区的常量池中，当定义String s3=&quot;abc&quot;时，不会马上创建字符串&quot;abc&quot;对象，而是会先查找常量池中是否存在相同常量， 如果有，则s3指向同一内存空间，否则创建新的字符串对象。*/ String s3=&quot;abc&quot;; System.out.println(s1==s2); //false System.out.println(s1==s3); //true //String类重写了Object类的equals()方法，使其由比较引用变为了比较引用所指向的字符串内容是否一样。 System.out.println(s1.equals(s2)); //true 例2，例3，例4，例5：编译器优化 (2) StringBuffer：线程安全的可变字符序列 对StringBuffer对象进行操作都是对其本身的字符序列进行操作，而不是生成新的对象。因此StringBuffer对象内容可变、长度可变，可以将多个字符串值直接联合，效率高 例1 定义有StringBuffer s1=new StringBuffer(10);s1.append(&quot;1234&quot;)则s1.length()和s1.capacity()分别是：4和10 (3) StringBuilder：非线程安全的可变字符序列 问：数组有没有length()方法? String有没有length()方法？数组没有length()方法，但有length属性；String有length()方法。 问：String的replaceAll()方法例1：易错的题目 public static void main (String[] args) { String classFile = &quot;com.jd.&quot;. replaceAll(&quot;.&quot;, &quot;/&quot;) + &quot;MyClass.class&quot;; System.out.println(classFile); } 输出为：/////////MyClass.class replaceAll方法的第一个参数是一个正则表达式，而&quot;.&quot;在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成&quot;/&quot;。 如果想替换的只是&quot;.&quot;的话，正则表达式那里就要写成&quot;\\\\.&quot;或者是&quot;[.]&quot;。前者将&quot;.&quot;转义为&quot;.&quot;这个具体字符，后者则匹配&quot;[]&quot;中的任意字符。 问：String的编码转换编码转换，实现将GB2312编码的字符串转换为ISO-8859-1编码的字符串： String a=new String(&quot;中&quot;.getBytes(&quot;gb2312&quot;), &quot;iso-8859-1&quot;); 编码转换，实现将GBK编码字节流转换为UTF-8编码字节流： byte[] src, dst; dst=new String (src, &quot;GBK&quot;).getbytes(&quot;UTF-8&quot;); 问：Math类(1) Math.floor(a) 求小于或等于a的最大整数，返回double类型。 // 如果参数值总是等于某个整数，那么结果与该参数相同 Math.floor(1)=1.0 // 如果参数是NaN、无穷、正0、负0，那么结果与参数相同 Math.floor(Double.NaN)=Double.NaN Math.floor(Double.POSITIVE_INFINITY)=Double.POSITIVE_INFINITY Math.floor(Double.NEGATIVE_INFINITY)=Double.NEGATIVE_INFINITY Math.floor(0.0)=0.0 Math.floor(-0.0)=-0.0 (2) Math.ceil(a) 求大于或等于a的最小整数，返回double类型。 // 如果参数值总是等于某个整数，那么结果与该参数相同 Math.ceil(1)=1.0 // 如果参数是NaN、无穷、正0、负0，那么结果与参数相同 Math.ceil(Double.NaN)=Double.NaN Math.ceil(Double.POSITIVE_INFINITY)=Double.POSITIVE_INFINITY Math.ceil(Double.NEGATIVE_INFINITY)=Double.NEGATIVE_INFINITY Math.ceil(0.0)=0.0 Math.ceil(-0.0)=-0.0 //如果参数小于0但大于-1.0，那么结果为-0.0(重要) Math.ceil(-0.5)=-0.0 (3) Math.round(a)=(long)floor(a+0.5d)；将原来的数字加上0.5后再向下取整，返回long类型，注意向下取整是指小于或等于它的最大整数。 Math.round(6.4)=(long)floor(6.4+0.5d)=(long)floor(6.9)=6 Math.round(6.9)=(long)floor(6.9+0.5d)=(long)floor(7.4)=7 Math.round(6.5)=(long)floor(6.5+0.5d)=(long)floor(7.0)=7 Math.round(-6.4)=(long)floor(-6.4+0.5d)=(long)floor(-5.9)=-6 Math.round(-6.9)=(long)floor(-6.9+0.5d)=(long)floor(-6.4)=-7 Math.round(-6.5)=(long)floor(-6.5+0.5d)=(long)floor(-6.0)=-6 // 了解 Math.round(NaN)=0 Math.round(Math.round(Double.NEGATIVE_INFINITY或&lt;=Long.MIN_VALUE))=Long.MIN_VALUE Math.round(Math.round(Double.POSITIVE_INFINITY或&gt;=Long.MAX_VALUE))=Long.MAX_VALUE 问：枚举类型Java中创建枚举类型要使用enum关键字，所有的枚举值都默认为static，在初始化时会对所有的枚举值对象调用一次构造函数进行初始化。 例1： enum AccountType{ SAVING, FIXED, CURRENT; private AccountType(){ System.out.println(“It is a account type”); } } class EnumOne{ public static void main(String[]args){ System.out.println(AccountType.FIXED); } } 程序输出如下： It is a account type It is a account type It is a account type FIXED 问：基本数据类型的包装类Java语言是一个面向对象的语言，但Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，即包装类。 例1： class Two{ Byte x; } class PassO{ public static void main(String[] args){ PassO p=new PassO(); p.start(); } void start(){ Two t=new Two(); System.out.print(t.x+””); Two t2=fix(t); System.out.print(t.x+” ” +t2.x); } Two fix(Two tt){ tt.x=42; return tt; } } 上面代码的输出为：null 42 42 基本数据类型的包装类型，属于引用类型。如果包装类成员变量没有显示初始化，那么Java默认初始化为null。 问：如何将数值型字符串转换为对应类型的数字？例1： Integer.parseInt(&quot;1234&quot;); Double.parseDouble(&quot;123.2&quot;); 问：日期类例1： 使用Java编程，打印昨天的当前时刻 public class YesterdayCurrent{ public static void main(String[] args){ Calendar cal = Calendar.getInstance(); cal.add(Calendar.DAY_OF_MONTH, -1);//从当前日期减去一天 System.out.println(cal.getTime()); } } 例2： 如何获取当前时间对应的年月日时分秒? public class CurrentTime{ public static void main(String[] args){ Calendar c=Calendar.getInstance(); System.out.print(c.get(Calendar.YEAR)+&quot;年&quot;+(c.get(Calendar.MONTH)+1)+&quot;月&quot;+c.get(Calendar.DAY_OF_MONTH)+&quot;日, &quot;; System.out.println(c.get(Calendar.HOUR_OF_DAY)+&quot;:&quot;+c.get(Calendar.MINUTE)+&quot;:&quot;+c.get(Calendar.SECOND)); } } 或 public class CurrentTime{ public static void main(String[] args){ Date date=new Date(); System.out.println(date); } } 例3： 如何取得从1970年到现在的毫秒数 public static void main(String[] args){ System.out.println(System.currentTimeMillis()); } 例4： 如何格式化日期？SimpleDateFormat public static void main(String[] args){ SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); Date date=new Date(); String dateStr=sdf.format(date);//把日期按指定格式转化为字符串 System.out.println(dateStr); } 七、 容器问：Java的集合类框架Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和操作(增、删、改、查)。有的集合类允许重复的键，有些不允许。 Java集合类有两大接口：Collection和Map，一个是元素集合，另一个是键值对集合且键不能重复。 图 1 图 2 List和Set接口继承了Collection接口。List是有序元素集合(即每个元素都可以按index访问)，元素可以重复；Set是无序元素集合(即每个元素都不可以按index访问)，元素不可以重复。ArrayList和LinkedList实现了List接口，HashSet和TreeSet实现了Set接口，这几个都比较常用； HashMap和HashTable实现了Map接口。HashMap不是线程安全的，HashTable是线程安全的，但是HashMap性能更好； ArrayList和Vector都以数组的方式存储，增、删慢，查、改快；ArrayList:线程不安全，速度快；Vector:线程安全，速度慢；LikedList: 以单链表的方式存储，操作慢 注意： Arrays.asList()将一个数组转化为一个List对象，这个方法会返回一个ArrayList类型的对象，这个ArrayList类并非java.util.ArrayList类，而是Arrays类的静态内部类！对这个对象进行添加删除更新操作，会报UnsupportedOperationException异常。 ConcurrentHashMap使用segment来分段和管理锁，而不是用synchronized 问：java语言中的几种数组复制方法效率比较System.arraycopy &gt; clone &gt; Arrays.copyOf &gt; for循环 问：Java集合框架中线程安全的类Vector、Stack(它继承了Vector)、Hashtable、Properties、Enumeration、(非集合类的StringBuffer) 问：ArrayList和LinkedList有什么区别？ArrayList和LinkedList都实现了List接口，他们有以下的不同点： (1) ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以链表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。 (2) 相对于ArrayList，LinkedList的插入、添加、删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。 (3) LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。 问：数组(Array)和列表(ArrayList)的区别？什么时候应该使用Array而不是ArrayList？(1) Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。(但是需要注意的是：Array数组中存放的一定是同种类型的元素；ArrayList就不一定了，因为ArrayList可以存储Object。) (2) Array大小是固定的，ArrayList的大小是动态变化的。 (3) ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。 对于基本类型数据，ArrayList使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。 问：Vector和ArrayList的主要区别(1) Vector是同步的，而ArrayList不是同步的。即Vector是线程安全的，而ArrayList是线程不安全的。 (2) 在元素增加，容量需要增长时，Vector容量默认增长为原来一倍，而ArrayList增长原来的50%，这样,ArrayList就有利于节约内存空间。 (3) 如果涉及到堆栈、队列等操作，应该考虑用Vector；如果需要快速随机访问元素，应该使用ArrayList。 问：ArrayList容量ArrayList的构造函数总共有三个 ArrayList()构造一个初始容量为 10 的空列表，动态增长时，容量增长到当前容量的1.5倍 ArrayList(Collection&lt;? extends E&gt; c)构造一个包含指定collection的元素的列表，这些元素是按照该collection的迭代器返回它们的顺序排列的。 ArrayList(int initialCapacity)构造一个具有指定初始容量的空列表。 问：什么是Java优先级队列(Priority Queue)？PriorityQueue是一个基于堆排序的无界队列，此队列按照在构造时所指定的顺序对元素排序，既可以根据元素的自然顺序来指定排序，也可以给它提供一个负责给元素排序的比较器来指定，这取决于使用哪种构造方法。 PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。 最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。 问：什么是迭代器(Iterator)？Iterator接口提供了很多对集合中元素进行迭代的方法，每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的remove(Object Obj)删除，可以通过迭代器的remove()方法删除。 问：Enumeration接口和Iterator接口的区别有哪些？(1) Enumeration速度是Iterator的2倍，同时占用更少的内存。 (2) 但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。 (3) 同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。 例1：list是一个ArrayList的对象，为了能够在Iterator遍历的过程中正确并安全的删除一个list中保存的对象，//todo delete处可以可以填写什么代码？ Iterator it = list.iterator(); int index = 0; while (it.hasNext()){ Object obj = it.next(); if (needDelete(obj)){//needDelete返回boolean，决定是否要删除 //todo delete } index ++; } 正确答案：it.remove(); 问：Iterator和ListIterator的区别是什么？(1) Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 (2) Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 (3) ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。 问：快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个ConcurrentModification异常。 安全失败：你在迭代的时候会对底层集合做一个拷贝，所以有另一个线程在修改上层集合的时候，访问是不会受影响的，不会抛出ConcurrentModification异常。 Iterator的安全失败是基于对底层集合做拷贝，因此，它不受原集合上修改的影响。 java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。 快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。 问：HashMap和Hashtable有什么区别？HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点： (1) HashMap允许键和值是null（但是最多只能有一个键为null，可以有一个或多个键所对应的值都为null。当get()方法返回null值时，既可以表示HashMap中没有该键，又可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断 HashMap中是否存在某个键，而应该用containsKey()方法来判断）；而Hashtable不允许键或者值是null。 (2) Hashtable是同步的，而HashMap不是，即HashMap是非线程安全的，HashTable是线程安全的。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。因为线程安全的问题，HashMap效率比HashTable的要高。 (3) HashMap提供了可供应用于迭代键的Iterator，因此，HashMap是快速失败的。Hashtable也使用了Iterator，另一方面，由于历史原因，Hashtable还提供了对键的Enumeration，是安全失败的。 (4) 哈希值的使用不同，HashTable直接使用对象的hashCode，而HashMap重新计算hash值。 (5) Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式不同。HashTable中hash数组默认大小是11，增加的方式是old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数 例1，例2，看两道题的评论 一般现在不建议用HashTable (1) HashTable是遗留类，内部实现很多没优化和冗余。 (2) 即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。 问：Java中的HashMap的工作原理是什么？Java中的HashMap是以键值对(key-value)的形式存储元素的。 HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。 HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。 HashMap中解决哈希冲突的方法是链地址法。HashMap的底层结构是一个数组，数组中的每一项是一条链表。 例1 问：HashSetHashSet子类依靠hashCode()和equal()方法来区分重复元素 HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值前，会去判断当前Map中是否含有该key对象，内部是先通过key的hashCode，确定有相同的hashCode之后，再通过equals方法判断是否相同。 例1 问：HashSet和TreeSet有什么区别？HashSet的底层是由哈希表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。 TreeSet的底层是由红黑树来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。 问：Set中的元素不可重复Set中的元素是不允许重复的。因此Set再插入或删除元素时，需要对两个元素进行比较。比较时，Set会先调用hashCode方法，判断两个元素是否有相同的hashCode，如果不相同，证明不相等；如果hashcode相同，再调用equals方法，如果equals方法判断返回true，则两个元素是相同的，否则两个元素不相同。 判断Set中是否包含某一个元素是通过contains来判断的。 问：hashCode()和equals()方法的重要性体现在什么地方？Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。 问：Comparable和Comparator接口是干什么的？列出它们的区别。Java提供了只包含一个compareTo()方法的Comparable接口。 这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。 Java提供了包含compare()和equals()两个方法的Comparator接口。 compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。 equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。 (1) Comparable和Comparator都是用来实现集合中元素的比较、排序的，只是Comparable是在集合内部定义方法实现排序，Comparator是在集合外部定义方法实现排序，所以，如果想要实现对集合中元素的排序，就需要在集合外定义实现Comparator接口的方法或在集合内实现Comparable接口的方法compareTo()。Comparator位于包java.util下，而Comparable位于包java.lang下。 (2) Comparable是一个对象本身就已经支持自比较所需要实现的接口（如 String、Integer自己就可以完成比较大小操作，已经实现了Comparable接口），自定义的类要在加入list容器中后能够排序，可以实现Comparable接口，在用Collections类的sort方法排序时，如果不指定Comparator，那么就以自然顺序排序，这里的自然顺序就是实现Comparable接口设定的排序方式。 (3) Comparator是一个专用的比较器，当这个对象不支持自比较或者自比较函数不能满足你的要求时，你可以写一个比较器来完成两个对象之间大小的比较。 问：Collection和CollectionsCollection是java.util下的接口，它是各种集合结构的父接口，其下有set及list Collections是java.util下的类，它包含有各种有关集合操作的算法(静态方法) 问：Java集合类框架的最佳实践有哪些？根据应用的需要正确选择要使用的集合的类型对性能非常重要 (1) 假如元素的大小是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。 (2) 有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。 (3) 为了类型安全、可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。 (4) 使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。 (5) 编程的时候接口优先于实现。 (6) 底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。 问：装箱与拆箱自动装箱是Java编译器在基本数据类型和对应的包装类型之间做的一个转化，例如把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。 问：装箱与拆箱中的==和equals()下面的规则基本意思是对的，但语言尚不严格正确 (1) 基本数据类型变量和基本数据类型包装类对象进行”==”运算符的比较，基本数据类型封装类对象将会自动拆箱变为基本数据类型后再进行比较。例如Integer(0)和0比较时，Integer(0)会自动拆箱为int类型再进行比较。 (2) 两个Integer类型变量进行”==”比较，如果这两个对象的值在-128至127且值相等，那么返回true，否则返回false，这跟Integer.valueOf()方法的缓冲对象有关。 (3) (4) 两个基本数据类型封装类变量进行equals()比较，equals()会首先比较对象的类型，如果类型相同，继续比较值，如果值也相同，返回true，否则返回false。 (5) 基本数据类型封装类对象调用equals()，但是参数是基本数据类型变量，这时候，基本数据类型变量会先进行自动装箱转换为其封装类型对象，再进行4中的比较。 例1： int a=257; Integer b1=257; //Integer b1=257会先调用Integer.valueOf()方法将257转化为new Integer(257)对象 Integer b2=57; //Integer b2=57会先调用Integer.valueOf()方法返回缓存中的57 Integer b3=257; Integer b4=57; Integer c=new Integer(257); Integer d=new Integer(257); Integer e1=Integer.valueOf(257); //Integer.valueOf()方法将257转化为new Integer(257)对象 Integer e2=Integer.valueOf(57); //Integer.valueOf()方法返回缓存中的57 // int和Integer(无论new否)比，都为true System.out.println(a==b1); // true，规则(1) System.out.println(a==c); // true，规则(1) // 两个都是非new出来的Integer，如果数在-128到127之间，则是true，否则为false System.out.println(b1==b3); // false，规则(2) System.out.println(b2==b4); // true，规则(2) System.out.println(b1==e1); // false，规则(3) System.out.println(b2==e2); // true，规则(3) // Integer与new Integer比较，结果为false；两个都是new出来的,都为false System.out.println(b1==c); // false，规则(3) System.out.println(c==d); // false，规则(3) //System.out.println(a.equals(b1)); 编译出错，基本型不能调用equals() System.out.println(b1.equals(b3)); // true，规则(4) System.out.println(c.equals(d)); // true，规则(4) System.out.println(b1.equals(257.0)); // false，规则(5)，257.0先封装成Double对象再进行比较 public static void main(String[] args){ Boolean flag=false;//先调用Boolean.valueOf(boolean b)返回false对应的Boolean对象Boolean.FALSE，然后赋值给flag，flag值为Boolean.FALSE /* 先赋值，遇到if条件表达式自动拆箱 * 1. 先调用Boolean.valueOf(boolean b)返回true对应的Boolean对象Boolean.TRUE，然后赋值给flag，flag值为Boolean.TRUE * 2. 调用booleanValue()返回flag值对应的基础数据类型值true * 3. 结果输出true */ if (flag=true){ System.out.println(&quot;true&quot;); }else{ System.out.println(&quot;false&quot;); } } 例1，例2，例3 例4：重要的题目 问：为什么集合类没有实现Cloneable和Serializable接口？克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的，因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。 问：泛型例1：重要的题目 class A {} class B extends A {} class C extends A {} class D extends B {} Which four statements are true? (A) The type List&lt;A&gt;is assignable to List. (B) The type List&lt;B&gt;is assignable to List&lt;A&gt;. (C) The type List&lt;Object&gt;is assignable to List&lt;?&gt;. (D) The type List&lt;D&gt;is assignable to List&lt;?extends B&gt;. (E) The type List&lt;?extends A&gt;is assignable to List&lt;A&gt;. (F) The type List&lt;Object&gt;is assignable to any List reference. (G) The type List&lt;?extends B&gt;is assignable to List&lt;?extends A&gt;. 正确答案：ACDG 八、 流问：Java中有几种类型的流？Java中有字节流和字符流。字节流继承于InputStream/OutputStream，字符流继承于Reader/Writer。 在java.io包中还有许多其他的流，低层流与调层流，高层流主要是为了提高性能和使用方便。 图 1 问：输入输出流的理解在Java使用流的机制进行数据的传送，从文件到内存是输入流，从内存到文件是输出流。 流可以分为节点流和处理流，节点流可以从一个特定的数据源(如文件、内存等)读写数据；而处理流则是连接在已存在的节点流或处理流之上，通过对数据的处理为程序提供更强大的读写功能。 图 1 图 2 常用的节点流 图 1 常用的处理流 图 2 节点流向处理流转换的实例： FileInputStream(System.in) -&gt; InputSteamReader -&gt; BufferReader OutputSteam(System.out) -&gt; PrintStream FileReader -&gt; BufferedReader FileWriter -&gt; PrintWriter或bufferWriter 九、 多线程推荐阅读：嘟嘟独立博客 推荐阅读：Java多线程锁机制 问：进程和线程的区别是什么？进程是资源分配的基本单位，而线程是CPU调度的基本单位。 一个进程可以有多个线程，多个线程共享进程的资源，线程又叫做轻量级进程。 问：线程的几种状态 (1) 新建(new)：新创建了一个线程对象。 (2) 可运行(runnable)：线程对象创建后，其他线程(比如main线程)调用了该对象的start()方法，该状态的线程便位于可运行线程池中，等待被线程调度选中，获取cpu的使用权。 (3) 运行(running)：可运行状态(runnable)的线程获得了cpu时间片(timeslice)，执行程序代码。 (4) 阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种： 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。 其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。 当sleep()状态超时、 join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。 (5) 死亡(dead)：线程run()、 main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。 例1：此题有疑问，感觉下面这句话是不对的。 Java线程调度算法是平台独立的。 问：创建线程有几种不同的方式？你喜欢哪一种？为什么？(1) 继承Thread类，重写run()方法 public class ThreadTest1 { public static void main(String[] args){ MyThread thread=new MyThread(&quot;T1&quot;); thread.start(); System.out.println(&quot;The main thread is running.&quot;); } } class MyThread extends Thread{ private String name; public MyThread(String name) { this.name = name; } @Override public void run() { System.out.println(&quot;The thread &quot;+this.name+&quot; is running.&quot;); } } (2) 实现Runnable接口，重写run()方法 public class ThreadTest2 { public static void main(String[] args){ Thread thread=new Thread(new MyThread2(&quot;T2&quot;)); thread.start(); System.out.println(&quot;The main thread is running.&quot;); } } class MyThread2 implements Runnable{ private String name; public MyThread2(String name) { this.name = name; } @Override public void run() { System.out.println(&quot;The thread &quot;+this.name+&quot; is running.&quot;); } } (3) 使用ExecutorService、Callable、Future实现有返回结果的多线程 例1：例2：注意评论 实现Runnable接口这种方式更受欢迎。在应用设计中线程类已经继承了别的类的情况下，需要多继承，只能实现接口（而Java不支持多继承，却支持实现多个接口），这样就不再需要继承Thread类，避免单继承的局限。同时，线程池也是非常高效的，很容易实现和使用。 问：start()和run()无论是通过继承Thread类还是实现Runnable接口来创建线程，都必须调用start()方法启动线程。线程启动后，线程进入就绪状态，当CPU分配时间给它时，它才开始运行。并不是一调用start()方法线程就立即运行。 问：Java四种线程池的使用应用程序可以使用Executor/Callable/Future框架来创建线程池。 (1) ExecutorService java.util.concurrent.Executors.newSingleThreadExecutor() Creates an Executor that uses a single worker thread operating off an unbounded queue. (Note however that if this single thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks.) Tasks are guaranteed to execute sequentially, and no more than one task will be active at any given time. Unlike the otherwise equivalent newFixedThreadPool(1) the returned executor is guaranteed not to be reconfigurable to use additional threads. Returns:the newly created single-threaded Executor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 示例代码： import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class NewSingleThreadExecutor { public static void main(String[] args) { ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 10; i++) { final int index = i; singleThreadExecutor.execute(new Runnable() { public void run() { try { System.out.println(index); Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } } }); } } } // 顺序执行各个任务，依次输出结果 (2) ExecutorService java.util.concurrent.Executors.newFixedThreadPool(int nThreads) 创建一个含有固定数量线程的线程池，可控制最大并发任务数，超出的任务会在队列中等待。 `Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue. At any point, at most nThreads threads will be active processing tasks. If additional tasks are submitted when all threads are active, they will wait in the queue until a thread is available. If any thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks. The threads in the pool will exist until it is explicitly shutdown. Parameters:nThreads the number of threads in the pool Returns:the newly created thread pool import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class NewFixedThreadPool { public static void main(String[] args) { ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3); for (int i = 0; i &lt; 10; i++) { final int index = i; fixedThreadPool.execute(new Runnable() { public void run() { try { System.out.println(index); Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } } }); } } } // 因为线程池大小为3，每个线程输出index后sleep 2秒，所以每隔两秒打印3个数字 (3) ExecutorService java.util.concurrent.Executors.newCachedThreadPool() Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available. These pools will typically improve the performance of programs that execute many short-lived asynchronous tasks. Calls to execute will reuse previously constructed threads if available. If no existing thread is available, a new thread will be created and added to the pool. Threads that have not been used for sixty seconds are terminated and removed from the cache. Thus, a pool that remains idle for long enough will not consume any resources. Note that pools with similar properties but different details (for example, timeout parameters) may be created using ThreadPoolExecutor constructors. Returns:the newly created thread pool import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class ThreadPoolExecutorTest { public static void main(String[] args) { ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) { final int index = i; try { Thread.sleep(index * 1000); } catch (InterruptedException e) { e.printStackTrace(); } cachedThreadPool.execute(new Runnable() { public void run() { System.out.println(index); } }); } } } (4) ScheduledExecutorService java.util.concurrent.Executors.newScheduledThreadPool(int corePoolSize) 创建一个含有固定数量线程的线程池，支持延时任务或周期性任务的执行。 Creates a thread pool that can schedule commands to run after a given delay, or to execute periodically. Parameters:corePoolSize the number of threads to keep in the pool, even if they are idleReturns:a newly created scheduled thread poolThrows:IllegalArgumentException - if corePoolSize &lt; 0 执行延时任务的示例代码： import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class NewScheduledThreadPool1 { public static void main(String[] args) { ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); scheduledThreadPool.schedule(new Runnable() { public void run() { System.out.println(&quot;delay 3 seconds&quot;); } }, 3, TimeUnit.SECONDS); } } // 表示延迟3秒执行任务 执行定期性任务的示例代码： import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class NewScheduledThreadPool2 { public static void main(String[] args) { ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); scheduledThreadPool.scheduleAtFixedRate(new Runnable() { public void run() { System.out.println(&quot;delay 1 seconds, and excute every 3 seconds&quot;); } }, 1, 3, TimeUnit.SECONDS); } } // 表示延迟1秒后，每3秒执行一次任务 问：同步和异步同步：上一段代码没完成，下一段必须等到上一段代码完成后才可以执行。 异步：上一段代码没完成，下一段不必等到上一段代码完成就可以执行。 问：synchronized关键字推荐阅读：嘟嘟独立博客 在Java中，每一个对象都拥有一个锁标记，也称为监视器。一旦一个方法或一个代码块被synchronized修饰，那么这个部分就放入了监视器的监视区域，确保在同一时刻最多只有一个线程执行该部分代码，线程在获取锁之前不允许执行该部分的代码。 例1： java实现进程之间的同步执行采用的机制是：监视器 当两个并发线程访问同一个对象的synchronized方法或代码块时，两个线程间是互斥的，在同一时刻只能有一个线程得到执行，另一个线程被阻塞，因为在执行synchronized方法或代码块的线程会锁定当前对象，只有在当前线程执行完这些代码并释放该对象的锁时，下一个线程才能锁定并执行该对象的synchronized方法或代码块。 (1) 当一个线程访问对象的一个synchronized方法或代码块时，另一个线程仍然可以访问该对象的非synchronized方法或代码块。(两个线程使用的是同一个对象) (2) 当一个线程访问对象的一个synchronized方法或代码块时，其他线程对该对象的所有其它synchronized方法或代码块的访问将被阻塞(同上，两个线程使用的是同一个对象)。 例2： 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法? 答：其它线程可以进入该对象的非synchronized方法，不可以进入该对象的synchronized方法。 例3：看评论 public class HelloSogou{ public static synchronized void main(String[] a){ Thread t=new Thread(){ public void run(){ Sogou(); } }; t.run(); System.out.print(&quot;Hello&quot;); } static synchronized void Sogou(){ System.out.print(&quot;Sogou&quot;); } } 上面JAVA程序的输出是：SogouHello (3) 如果父类中的某个方法使用了synchronized关键字，而子类中覆盖了这个方法，默认情况下子类中的这个方法并不是同步的，必须显示的在子类的这个方法中加上synchronized关键字之后该方法才同步。当然，也可以在子类中调用父类中相应的方法，这样虽然子类中的方法并不是同步的，但子类调用了父类中的同步方法，也就相当子类方法也同步了。 例4：判断正误 构造方法不需要同步化。(正确) 一个子类不可以覆盖掉父类的同步方法。(错误) 问：同步方法和同步代码块的区别是什么？Java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时(增删改查)，将会导致数据的不准确，相互之间产生冲突。因此加入了同步锁，以避免在该线程没有结束前，其他线程操作该资源变量，从而保证了变量的唯一性，准确性。 Java中每个对象都有一把锁，线程可以通过synchronized关键字来获取对象上的锁。 (1) 同步方法(粗粒度锁)：由synchronized关键字修饰的方法 修饰一般方法:public synchronized void method(){…}，获取的是当前被调用对象的锁修饰静态方法:public static synchronized void method(){…}，获取当前类的字节码对象上的锁 举例：如果一个线程执行一个对象的非static的synchronized方法，另外一个线程执行这个对象所属类的static的synchronized方法，此时不会发生互斥现象，因为访问static的synchronized方法占用的是类的字节码对象锁，而访问非static的synchronized方法占用的是对象锁，所以不存在互斥现象。 public class SychronizedTest { public static void main(String[] args){ SynObj obj=new SynObj(); Thread01 thread01=new Thread01(&quot;Thread01&quot;, obj); Thread01 thread02=new Thread01(&quot;Thread02&quot;, obj); Thread02 thread03=new Thread02(&quot;Thread03&quot;); Thread02 thread04=new Thread02(&quot;Thread04&quot;); thread01.start(); thread02.start(); thread03.start(); thread04.start(); } } class Thread01 extends Thread{ private String threadName; private SynObj obj; public Thread01(String threadName, SynObj obj) { this.threadName=threadName; this.obj = obj; } @Override public void run() { this.obj.run1(this.threadName); } } class Thread02 extends Thread{ private String threadName; public Thread02(String threadName) { this.threadName=threadName; } @Override public void run() { SynObj.run2(this.threadName); } } class SynObj{ // 同步方法 public synchronized void run1(String threadName){ for(int i=0; i&lt;3; i++){ try { Thread.sleep(1000); System.out.println(threadName+&quot; run1 i=&quot;+i); } catch (InterruptedException e) { e.printStackTrace(); } } } // 同步static方法 public static synchronized void run2(String threadName){ for(int i=0; i&lt;3; i++){ try { Thread.sleep(1000); System.out.println(threadName+&quot; run2 i=&quot;+i); } catch (InterruptedException e) { e.printStackTrace(); } } } } Thread01和Thread02之间存在互斥关系，Thread03和Thread03之间存在互斥关系，但是Thread01/Thread02和Thread03/Thread04之间不存在互斥关系。 一种可能的输出： Thread01 run1 i=0 Thread03 run2 i=0 Thread03 run2 i=1 Thread01 run1 i=1 Thread03 run2 i=2 Thread01 run1 i=2 Thread02 run1 i=0 Thread04 run2 i=0 Thread04 run2 i=1 Thread02 run1 i=1 Thread02 run1 i=2 Thread04 run2 i=2 (2) 同步代码块(细粒度锁)：: 由synchronized关键字修饰的语句块，同步代码块可以选择以什么语句块来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法 synchronized(obj) {…}，同步代码块可以指定获取某个对象上的锁。 public class SychronizedTest { public static void main(String[] args){ SynObj synObj1=new SynObj(); SynObj synObj2=new SynObj(); Obj obj1=new Obj(); Obj obj2=new Obj(); Thread01 thread01=new Thread01(&quot;Thread01&quot;, synObj1); Thread01 thread02=new Thread01(&quot;Thread02&quot;, synObj1); Thread01 thread03=new Thread01(&quot;Thread03&quot;, synObj2); Thread02 thread04=new Thread02(&quot;Thread04&quot;, synObj1, obj1); Thread02 thread05=new Thread02(&quot;Thread05&quot;, synObj1, obj1); Thread02 thread06=new Thread02(&quot;Thread06&quot;, synObj2, obj2); thread01.start(); thread02.start(); thread03.start(); thread04.start(); thread05.start(); thread06.start(); } } class Thread01 extends Thread{ private String threadName; private SynObj obj; public Thread01(String threadName, SynObj obj) { this.threadName=threadName; this.obj = obj; } @Override public void run() { this.obj.run1(this.threadName); } } class Thread02 extends Thread{ private String threadName; private SynObj synObj; private Obj obj; public Thread02(String threadName, SynObj synObj, Obj obj) { this.threadName=threadName; this.synObj=synObj; this.obj=obj; } @Override public void run() { this.synObj.run2(this.threadName, this.obj); } } class SynObj{ public void run1(String threadName){ // 同步代码块，锁住的是对象本身 synchronized(this){ for(int i=0; i&lt;3; i++){ try { Thread.sleep(1000); System.out.println(threadName+&quot; run1 i=&quot;+i); } catch (InterruptedException e) { e.printStackTrace(); } } } } public void run2(String threadName, Obj obj){ // 同步代码块，锁住的是对象obj synchronized(obj){ for(int i=0; i&lt;3; i++){ try { Thread.sleep(1000); System.out.println(threadName+&quot; run1 i=&quot;+i); } catch (InterruptedException e) { e.printStackTrace(); } } } } } class Obj{} Thread01和Thread02之间存在互斥关系，但是Thread01/Thread02和Thread03之间不存在互斥关系。 注释掉thread04，thread05和thread06的启动代码 //thread04.start(); //thread05.start(); //thread06.start(); 一种可能的输出： Thread01 run1 i=0 Thread03 run1 i=0 Thread01 run1 i=1 Thread03 run1 i=1 Thread01 run1 i=2 Thread03 run1 i=2 Thread02 run1 i=0 Thread02 run1 i=1 Thread02 run1 i=2 Thread04和Thread05之间存在互斥关系，但是Thread04/Thread05和Thread06之间不存在互斥关系。 注释掉thread01，thread02和thread03的启动代码 //thread01.start(); //thread02.start(); //thread03.start(); 一种可能的输出： Thread04 run1 i=0 Thread06 run1 i=0 Thread06 run1 i=1 Thread04 run1 i=1 Thread04 run1 i=2 Thread06 run1 i=2 Thread05 run1 i=0 Thread05 run1 i=1 Thread05 run1 i=2 将SynObj的run2方法的被锁对象换成obj.getClass()之后，此时Thread04、Thread05和Thread06之间存在互斥关系。因此Synchronized后面括号括起来的部分为synchronized(className.class)，作用的对象是这个类的所有对象 public void run2(String threadName, Obj obj){ // 同步代码块，锁住的是对象obj synchronized(obj.getClass()){ for(int i=0; i&lt;3; i++){ try { Thread.sleep(1000); System.out.println(threadName+&quot; run1 i=&quot;+i); } catch (InterruptedException e) { e.printStackTrace(); } } } } 一种可能的输出为： Thread04 run1 i=0 Thread04 run1 i=1 Thread04 run1 i=2 Thread06 run1 i=0 Thread06 run1 i=1 Thread06 run1 i=2 Thread05 run1 i=0 Thread05 run1 i=1 Thread05 run1 i=2 Java支持并发编程的同步机制例1： JDK提供的用于并发编程的同步器有：Semaphore、CyclicBarrier、CountDownLatch 例2： CyclicBarrier让一组线程等待其他线程；CountDownLatch让一组线程等待某个事件发生 Callable类的call()方法可以返回值和抛出异常 线程调用start()方法后进行就绪状态，等待获取CPU的使用权 例3： CopyOnWriteArrayList适合于读操作远远大于写操作的场景里，比如缓存。 ReadWriteLock 当写操作时，其他线程无法读取或写入数据，而当读操作时，其它线程无法写入数据，但却可以读取数据。适用于读取远远大于写入的操作。 ConcurrentHashMap是一个线程安全的HashTable，它的主要功能是提供了一组和HashTable功能相同但是线程安全的方法。 ConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，不用对整个ConcurrentHashMap加锁。 问：wait、notify、notifyAll wait() (1) 该方法用来让当前线程进入休眠状态，直到被唤醒或被中断为止。 (2) 在调用wait()之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait()方法。如果调用wait()时，线程没有持有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch结构。 (3) 进入wait()方法后，当前线程释放锁。在从 wait()返回前，线程与其他线程竞争重新获得锁。 notify() (1) 该方法也要在同步方法或同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁，如果调用notify()时线程没有持有适当的锁，也会抛出IllegalMonitorStateException。 (2) 该方法用来唤醒那些可能等待该对象的对象锁的其他线程。如果有多个线程等待，则线程调度器任意挑选出其中一个wait()状态的线程来发出通知，并使它等待获取该对象的对象锁（notify后，发出通知的当前线程不会马上释放该对象锁，wait所在的线程并不能马上获取该对象锁，要等到程序退出synchronized代码块后，当前线程才会释放锁，wait所在的线程也才可以获取该对象锁），但不惊动其他同样在等待被该对象notify的线程们。 (3) 当第一个获得了该对象锁的wait线程运行完毕以后，它会释放掉该对象锁，此时如果该对象没有再次使用notify 语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，会继续阻塞在wait状态，直到这个对象发出一个notify或notifyAll。这里需要注意：它们等待的是被notify或notifyAll，而不是锁。这与下面的 notifyAll()方法执行后的情况不同。 notifyAll() 该方法与 notify ()方法的工作方式相同，重要的一点差异是：notifyAll 使所有原来在该对象上 wait 的线程统统退出 wait 的状态（即全部被唤醒，不再等待notify或notifyAll，但由于此时还没有获取到该对象锁，因此还不能继续往下执行），开始等待获取该对象上的锁，一旦该对象锁被释放（notifyAll线程退出调用了notifyAll的synchronized代码块的时候），他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出synchronized代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。 总结：如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。 案例：当前线程调用对象的notify后，当前线程不会马上释放该对象锁，wait所在的线程并不能马上获取该对象锁，要等到程序退出synchronized代码块后，当前线程才会释放锁，wait所在的线程也才可以获取该对象锁。 public static void main(String[]args)throws Exception { final Object obj = new Object(); Thread t1 = new Thread() { public void run() { synchronized (obj) { try { obj.wait(); System.out.println(&quot;Thread 1 wake up.&quot;); } catch (InterruptedException e) { } } } }; t1.start(); Thread.sleep(1000);//We assume thread 1 must start up within 1 sec. Thread t2 = new Thread() { public void run() { synchronized (obj) { obj.notifyAll(); System.out.println(&quot;Thread 2 sent notify.&quot;); } } }; t2.start(); } output: Thread 2 sent notify. Thread 1 wake up 例1：找出代码中错误的地方。 void waitForSignal(){ Object obj = new Object(); synchronized(Thread.currentThread()){ obj.wait(); obj.notify(); } } 第一个错误是wait()方法要以try/catch包覆，或是掷出InterruptedException才行 第二个错误是wait或者notify方法被调用的对象必须与synchronized中的对象一致，否则会有IllegalMonitorStateException 例2： 可用来实现线程间通知和唤醒的方式： Object.wait/notify/notifyAll Condition.await/signal/signalAll 问：sleep()方法和wait()方法的区别sleep()：该方法让线程休眠指定的时间，当这个时间达到之后，线程会再次醒来。 wait()：该方法用来让当前线程进入休眠状态，直到被唤醒或被中断为止。 (1) sleep()是Thread类的方法，wait()是Object类的方法 (2) wait()，notify()和notifyAll()只能在同步方法或同步代码块中使用，而sleep()可以在任何地方使用 (3) 调用sleep()方法后，线程进入睡眠状态，但不会释放对象锁，休眠时间结束后会自动进入就绪状态；调用wait()方法后，线程会释放对象锁，进入此对象的等待池(wait pool)中，直到其他线程调用对象的notify()方法(或notifyAll()方法)时才能唤醒等待池中的线程进入等锁池(lock pool)，如果线程重新获得对象的锁就可以进入就绪状态。 例1：sleep()和wait()的对比 问：sleep()方法和yield()方法的区别调用线程yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制交出CPU的具体时间，另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。 注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。 sleep()方法和yield()方法的区别: (1) sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会； (2) 线程执行sleep()方法后转入阻塞(blocked)状态，而执行yield()方法后转入就绪(ready)状态； (3) sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常； (4) sleep()方法比yield()方法(跟操作系统CPU调度相关)具有更好的可移植性。 问：join()方法方法join()的作用是让调用join()方法的线程等待被调用线程结束，再继续往下执行。 问：volatile关键字推荐阅读：嘟嘟独立博客 volatile是java中的一个关键字，可以用来修饰被不同线程访问和修改的变量。 出于运行速率的考虑，Java编译器会把经常经常访问的变量放到缓存（严格讲应该是工作内存）中，读取变量则从缓存中读。但是在多线程编程中,内存中的值和缓存中的值可能会出现不一致。volatile用于限定变量只能从内存中读取，保证对所有线程而言，值都是一致的。但是volatile不能保证原子性，也就不能保证线程安全。 一旦一个共享变量(类的成员变量、类的静态成员变量)被volatile修饰之后，那么就具备了两层语义：1）可见性：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。2）禁止进行指令重排序：volatile只提供了保证访问该变量时，每次都是从内存中读取最新值，并不会使用寄存器缓存该值，每次都会从内存中读取。 例1，例2 问：ThreadLocalThreadLocal类为每一个线程都维护了自己独有的变量拷贝。在Thread中有一个成员变量ThreadLocals，该变量的类型是ThreadLocalMap,也就是一个Map，它的键是threadLocal，值为就是变量的副本。因此ThreadLocal不是使用在多线程之间共享数据，而是让变量在每个线程中都有独立拷贝，使得不会出现一个线程读取变量时，该变量而被另一个线程修改的现象。 由于每个线程在访问该变量时，读取和修改的，都是自己独有的那一份变量拷贝，不会被其他线程访问，变量被彻底封闭在每个访问的线程中 例1，例2：这题A答案似乎是错的 问：什么是死锁(deadlock)？两个线程或两个以上线程因争夺资源而都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是若无外力作用，这些线程都陷入了无限的等待中。 问：如何确保N个线程可以访问N个资源同时又不导致死锁？使用多线程的时候，一种非常简单的避免死锁的方式就是：指定访问资源的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。 十、 网络编程问：Java Socket的几个方法getInetAddress() Returns the address to which the socket is connected. getLocalAddress() Gets the local address to which the socket is bound. getReuseAddress() Tests if SO_RESUSADDR is enabled. getLocalPort() Returns the remote port number to which this socket is connected. 问：序列化序列化:将一个对象保存到一个文件，可以通过流的方式在网络上传输；也可以将文件的内容读取，转化为一个对象。 处理对象流的机制：所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。 序列化是为了解决在对对象流进行读写操作时所引发的问题。 序列化的实现：将需要被序列化的类实现java.io.Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要写入的话则用输入流。","categories":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/categories/Java/"}]},{"title":"数据库系统概念","slug":"数据库系统概念","date":"2017-05-28T10:45:37.000Z","updated":"2017-06-01T06:39:02.465Z","comments":true,"path":"2017/05/28/数据库系统概念/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/数据库系统概念/","excerpt":"数据库系统概念","text":"数据库系统概念 问：数据库管理系统的特点数据库管理系统将具有一定结构的数据组成一个集合，它主要具有以下几个特点: (1) 数据的结构化：数据库中的数据并不是杂乱无章、毫不相干的，它们具有一定的组织结构，属于同一集合的数据具有相似的特征。 (2) 数据的共享性：在一个单位的各个部门之间，存在着大量的重复信息。使用数据库的目的就是要统一管理这些信息，减少冗余度，使各个部门共同享有相同的数据。 (3) 数据的独立性：数据的独立性是指数据记录和数据管理软件之间的独立。数据及其结构应具有独立性，而不应该去改变应用程序。 (4) 数据的完整性：数据的完整性是指保证数据库中数据的正确性。可能造成数据不正确的原因很多，数据库管理系统通过对数据性质进行检查而管理它们。 (5) 数据的灵活性：数据库管理系统不是把数据简单堆积，它在记录数据信息的基础上具有很多的管理功能，如输入、输出、查询、编辑修改等。 (6) 数据的安全性：根据用户的职责，不同级别的人对数据库具有不同的权限，数据库管理系统应该确保数据的安全性。 问：数据模型数据库是长期存储在计算机内有组织的大量的共享的数据集合。它可以供各种用户共享，具有最小冗余度和较高的数据独立性。数据库系统的核心和基础是数据模型。数据模型是对现实世界数据特征的抽象，是用来描述数据、组织数据和对数据进行操作的。根据模型应用目的的不同，数据模型可以分为两类，第一类是概念模型，第二类是逻辑模型和物理模型。 概念模型，也称信息模型，它是按用户的观点来对数据和信息建模，主要用于数据库设计。 第二类中的逻辑模型主要包括层次模型、网状模型、关系模型、面向对象模型和对象关系模型等。 第二类中的物理模型是对数据最底层的抽象，它描述数据在系统内部的表示方法和存取方法，在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的。 一般来说，数据模型是严格定义的一组概念的集合。这些概念精确地描述了系统的静态特征、动态特征和完整性约束条件。因此数据模型一般由数据结构、数据操作和完整性约束三部分组成。 数据结构:存储在数据库中对象类型的集合，作用是描述数据库组成对象以及对象之间的联系。 数据操作:指对数据库中各种对象实例允许执行的操作的集合，包括操作及其相关的操作规则。 数据完整性约束条件:指在给定的数据模型中，数据及其联系所遵守的一组通用的完整性规则，它能保证数据的正确性和一致性。 问：关系数据模型关系模型是目前最重要的一种数据模型。关系数据库系统采用关系模型作为数据的组织方式，在这些系统中，关系模型中数据的逻辑结构是一张二维表，或者说关系的数据结构就是一张表。 关系数据模型的数据操作主要包含查询、抽入、删除和更新数据。 关系模型的完整性约束包含:实体完整性、参照完整性和用户自定义的完整性。 问：关系数据库和非关系型数据库(1) 关系型数据库 MS SQL Server、IBM DB2、Oracle、MySQL、Microsoft Access和PostgreSQL。 (2) 非关系型数据库 (NoSQL) 键值(Key-Value)存储数据库 这一类数据库主要会使用到一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。Key/value模型对于IT系统来说的优势在于简单、易部署。但是如果DBA只对部分值进行查询或更新的时候，Key/value就显得效率低下了。 常见的键值存储数据库：Tokyo Cabinet/Tyrant，Redis，Voldemort，Oracle BDB.，Google BigTable，Amazon DynamoDB。 列存储数据库 这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。 常见的列存储数据库：Cassandra，HBase，Riak。 文档型数据库 文档型数据库的灵感是来自于LotusNotes办公软件的，而且它同第一种键值存储相类似。该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高。 常见的文档型数据库：CouchDB, MongoDb。国内也有文档型数据库SequoiaDB，已经开源。 图(Graph)数据库 图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。许多NoSQL数据库都有REST式的数据接口或者查询API。 常见的图数据库：Neo4J，InfoGrid，Infinite Graph。 NoSQL数据库在以下的这几种情况下比较适用： 数据模型比较简单； 需要灵活性更强的IT系统； 对数据库性能要求较高； 不需要高度的数据一致性； 对于给定key，比较容易映射复杂值的环境。 问：ER模型ER模型的基本元素是：实体、联系和属性 (1) 实体：是一个数据对象，指应用中可以区别的客观存在的事物。 (ER模型中的实体往往是指实体集)实体集：指同一类实体构成的实体集合，用矩形表示表示，矩形内注明实体名。 (2) 联系：表示一个或多个实体之间的关联关系。联系用菱形框表示，菱形框内注明联系名，并用无向边将与其相关的实体连接起来，同时在无向边旁标上联系的类型。 联系可分为以下3种类型：1对多联系，1对1联系和多对多联系 1对1联系(1:1)： 例如，一个部门有一个经理，而每个经理只在一个部门任职，则部门与经理的联系是一对一的。 一对多联系(1:N): 例如，某校教师与课程之间存在一对多的联系”教”，即每位教师可以教多门课程，但是每门课程只能由一位教师来教。 多对多联系(M:N): 例如，学生与课程间的联系(“学”)是多对多的，即一个学生可以学多门课程，而每门课程可以有多个学生来学。 (3) 属性：实体的某一特性称为属性，属性用椭圆形框表示，加下划线的属性为主属性。 例1：教学管理的一个可能设计的ER图 教学管理的一个可能设计的ER图 问：主键与外键若关系(二维表)中的某一属性组的值能唯一标识一个元组，则称该属性组为候选码。若个表中有多个候选码，则可选定其中一个为主键。 候选码的各个属性称为主属性。不包含在任何候选码中的属性称为非主属性或非码属性。 如果关系模式R1中的某属性集不是R1的主键，并且该属性集是另一个关系R2的主键，则该属性集是关系模式R1的外键。由此可见，外键表示了两个关系(表)之间的联系。以另一个关系的外键作主键的表被称为主表(R2)，具有此外键的表被称为主表的从表(R1)，外键又称为外关键字。 问：完整性约束主键的设置是为了强制表的实体完整性，外键的设置是为了强制表之间的参照完整性。 (1) 关系模型的实体完整性约束 若属性(指一个或一组属性)A是基本关系R的主属性，则A不能取空值。由此约束可得一直接结论:主键不能为空。 (2) 关系模型的参照完整性约束 若属性(或属性组)F是某基本关系R1的外键，且它与基本关系R2的主键相对应，则对于R1中，每个F上的值或为空值或者等于R1中的主键值。 (3) 关系模型的用户自定义完整性约束 例1：下列哪种完整性约束中，将每一条记录定义为表中的惟一实体，即不能重复 A. 域完整性 B. 引用完整性 C. 实体完整性 D. 其他 答案： C。 问：关系代数介绍关系代数的一篇文章 关系代数是关系数据库系统查询语言的理论基础，包括：并、交、差、乘、选择、投影、联接、除、自然联接等操作。 例1： 设有关系模式R(a,b,c,d,)，与关系代数表达式σ3&lt;&apos;4&apos;(R)等价的SQL语句为：select * from R where c&lt;&apos;4&apos;; 例2 问：常见的SQL语句SQL语句功能极强，包括数据定义(create、 drop和alter)、数据操纵(insert，update和delete)、数据查询(select)、数据控制(grant和revoke)。 例1：ANSI SQL语句的分类 (1) 数据定义 创建表：SQL语言使用create table语句定义表，其基本格式如下: create table &lt;表名&gt;( &lt;列名&gt; &lt;数据类型&gt; [列级完整性约束条件] [, &lt;列名&gt; &lt;数据类型&gt; [列级完整性约束条件]] ... [, &lt;表级完整性约束条件&gt;]); 例1：建立一个”学生信息”表Student: create table Student( Sno char(9) primary key, Sname char(20) unique, Ssex char(2), Sage smallint, Sdept char(20) ); 修改表：随着应用环境和应用需求的变化，有时需要修改已建立好的表，SQL语言用alter table语句修改表，其一般格式为: ALTER TABLE &lt;表名&gt; [ADD &lt;新列名&gt; &lt;数据类型&gt; [完整性约束]] [DROP &lt;完整性约束名&gt;] [MODIFY COLUMN &lt;列名&gt; &lt;数据类型&gt;] 其中，&lt;表名&gt;是要修改的表，ADD子句用于增加新列和新的完整性约束条件，DROP子句用于删除指定的完整性约束，MODIFY COLUMM子句用于修改原有的列定义，包括修改列名和数据类型。 例2：向Student表增加”入学时间”列，其数据类型为日期类型。 alter table Student add Sentrance date; 上述代码不论Student表中原来是否已有数据，新增加的列一律为空值。 例3：删除Student表中”年龄”列 alter table Student drop column Sage; 删除列可以省略column 例4：要求将年龄的数据类型由字符型(假设原来的数据类型是字符型)改为整数。 alter table Student modify column Sage int; 例5：增加Student表Sname必须取唯一值的约束条件。 alter table Student add unique(Sname); 删除表：当某个表不再需要时，可以使用drop table语句删除它。其一般格式为: DROP TABLE &lt;表名&gt; [RESTRICT | CASCADE]; 若选择RESTRICT，则该表的删除是有限制条件的:欲删除的表不能被其他表的约束所引用(如check，foreign key等约束)，不能有视图，不能有触发器，不能有存储过程或函数等。如果存在这些依赖该表的对象，则此表不能被删除。 若选择CASCADE，则该表的删除没有限制条件。在删除该表的同时，相关的依赖对象，例如视图，都将被一起删除。 例6：删除Student表 drop table Student cascade; (2) 数据操纵 数据操纵操作有3种：向表中添加若干行数据、修改表中的数据和删除表中的若干行数据。 插入元组：插入元组的INSERT语句的格式为: INSERT INTO table (fieldl, field2 ...) VALUES(valuel, value2..); 其功能是将新元组插入到指定表中，其中新元组的field1的值为value1, field2的值为value2…。 如果INTO语句中没有指定任何属性列名，则新插入的元组必须在每个属性列上均有值。 例1：将一个新学生元组(学号:201009014，姓名:Wang，性别:女， 所在系:MA，年龄:21)插入到Student表中 insert into Student(Sno, Sname, Ssex, Sdept, Sage) values (&apos;201009014&apos;, &apos;Wang&apos;, &apos;F&apos;, &apos;MA&apos;, 21); 修改数据：修改数据又称为更新操作，其语句的一般格式为: UPDATE table SET fieldl=valuel, field2=value2 WHERE 范围 其功能是修改指定表中满足WHERE子句条件的元组。其中SET子句给出的value值用于取代相应的属性列值。如果省略WHERE子句，则表示要修改表中的所有元组。 例2：将学生201009013的年龄改为22岁 update Student set Sage=22 where Sno=&apos;201009013&apos;; 删除数据：删除语句的一般格式为: DELETE FROM tabIe WHERE范围; DELETE语句的功能是从指定表中删除满足WHERE子句条件的所有元组。如果省略WHERE子句，表示删除表中全部元组，但表仍存在。 删除表中的所有行(truncate和delete的区别，这里尚未整理) truncate table TABLE_NAME; (不可恢复) 例3：删除学号为201009020的学生记录 delete from Student where Sno=&apos;201009020&apos;; (3) 数据查询 数据库查询是数据库的核心操作。SQL提供了select语句进行数据库的查询，其一般格式为: SELECT [ALL | DISTINCT] &lt;目标列表达式&gt; [，&lt;目标列表达式&gt;] ... FROM &lt;表名或视图名&gt; [,&lt;表名或视图名&gt;] ... [WHERE &lt;条件表达式&gt;] [GROUP BY &lt;列名1&gt; [HAVING &lt;条件表达式&gt;]] [ORDER BY &lt;列名2&gt; [ASC | DESC]]; 整个SELECT语句解析顺序：FROM-&gt;WHERE-&gt;GROUP BY-&gt;HAVING-&gt;SELECT-&gt;ORDER BY 整个SELECT语句的含义 根据WHERE子句的条件表达式，从FROM子句指定的表或视图中找出满足条件的元组，再按SELECT子句中的目标列表达式，选出元组中的属性值形成结果表。 如果有GROUP BY子句，则将结果按&lt;列名1&gt;的值进行分组，该属性值相等的元组为一个组。通常会在每组中使用聚集函数。如果GROUP BY子句带HAVING子句，则只有满足指定条件的组才会被输出。 如果有ORDER BY子句，则结果表还要按&lt;列名2&gt;的值的升序或降序排序。 选择表中的若干列 例1：在表Student中查询名为Wang的学生信息 select * from Student where Sname=&apos;Wang&apos;; 例2：在表Student中，查询名字中有ang的学生信息 select * from Student where Sname like &apos;%ang%&apos;; 上述%是通配符，代表任意长度(可为0)的字符串。例如a%b表示以a开头，以b结尾的任意长度的字符串。除此之外，_(下画线)代表任意单词字符。 例3：在表Student中查询年龄在20-22岁(包括20岁与22岁)之间的学生的信息 select * from Student where Sage between 20 and 22; 与BETWEEN...AND...相对的谓词是NOT BETWEEN...AND... 例4：在表Student中查询计算机系(CS)、信息系(MA)和和物理系(PH)学生的姓名和性别 select Sname, Ssex from Student where Sdept in (&apos;CS&apos;, &apos;MA&apos;, &apos;PH&apos;); 与IN相对的谓词是NOT IN，用于查找属性值不属于指定集合的元组。 例5：在表Student中查询没有年龄信息的学生 select * from Student where Sage is null; 注意这里的&quot;is&quot;不能被等号代替。 order by子句 用户可以用order by子句对查询的结果按照一个或多个属性列的升序(ASC)或降序(DESC)排列，默认值为升序。 例6：在表Student中，按学生的年龄值升序检索出全部学生的信息 select * from Student order by Sage; 在表Student中先按专业升序排序，然后同一专业的学生再按年龄降序排序，并输出全部学生信息 select * from Student order by Sdept, Sage desc; limit子句 limit主要是用于查询之后显示返回的前几条或者中间某几条数据。 SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset; LIMIT子句可以被用于强制SELECT语句返回指定的记录数。 LIMIT接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是0(而不是1)。 例7：从Student表中检索出第3到第7条记录，共5条记录 select * from Student limit 2, 5; 例8：从Student表中检索出前2条记录 select * from Student limit 2; 换句话说，LIMIT n等价于LIMIT 0, N 聚集函数 SQL语句中的常用聚集函数有以下几种：count，sum，avg，max，min。用法如下： 总数： select count(*) as totalcount from table; 求和： select sum(field) as sumvalue from table; 平均： select avg(field) as avgvalue from table; 最大： select max(field) as maxvalue from table; 最小： select min(field) as minvalue from table; GROUP BY子句 GROUP BY子句根据一个或多个属性的值来对元组进行分组，值相等的为一组。 对查询结果分组的目的是为了细化聚集函数的作用对象，分组后聚集函数将作用于每一个组，即每一组都有一个函数值。 例9：查询Student表中具有相同年龄的每个组的人数 select Sage, count(*) from Student group by Sage; 如果分组后还要求按一定的条件对这些组进行筛选，最终只输出满足指定条件的组，则使用HAVING短语指定筛选条件。通常，HAVING子句只用在GROUP BY子句的SQL语句中，用来选取符合指定条件的分组。 例10：查询Student表中每种年龄的人数大于1的年龄与人数信息 select Sage, count(*) from Student group by Sage having count(*) &gt; 1; 连接查询 前面的查询都是针对一个表进行的。若一个查询同时涉及两个以上的表，则称之为连接查询。 例11：若有表Student(学生信息表)、SC(选课表)，要求查询每个学生及其选修课程的情况: select Student.*, SC.* from Student, SC where Student.Sno=SC.Sno; 在以上的连接操作中，只有满足条件的元组才能作为结果输出。 若表Student中某些学生没有选课，则在SC表中没有相应的元组，造成最终结果中舍弃掉了这些学生的信息。 上述连接称为自然连接、内连接。有时想以Student表为主体列出每个学生的基本情况及其选课情况。若某个学生没有选课，依然将其保存到结果中(在SC表的属性上填空值)，这时就需要使用外连接。 select Student.*，SC.* from Student left join SC on (Student.Sno=SC.Sno); 以上是左外连接，左外连接列出左边表(本例为Student表)中的所有元组，右外连接列出右表关系中所有的元组。 例12 例13：一道综合题 设有学生信息表s(sno, sname)，其属性分别表示学号，姓名；课程信息表c(cno, cname)，其属性分别表示课程号、课程名称;选课信息表sc(sno, cno, grade)，其属性分别表示学号、课程号和成绩。 1) 问选修课程”db”的学生学号 select sc.sno from sc, c where sc.cno=c.cno and c.cname=&apos;db&apos;; 2) 平均成绩最高的学生学号 select sno, avg(grade) as g from sc group by sno order by g desc limit 1; 3) 每科大于90分的人数 select cno, count(sno) from sc where grade&gt;90 group by cno; 4) 列出既学过”math”，又学过”english”的所有学生学号、姓名 select s.sno, s.sname from s, (select sc.sno from sc, c where sc.cno=c.cno and c.cname in(&apos;math&apos;, &apos;english&apos;) group by sno having count (distince c.cno)=2) x where s.sno=x.sno; 5) 列出有两门以上(含两门)不及格课程(成绩小于60)的学生学号、姓名及其平均成绩 select s.sno, s.sname，avg(sc.grade) as avggrade from s, sc, (select sno from sc where grade&lt;60 group by sno having count (distince cno)&gt;=2) x where s.sno=x.sno and sc.sno=x.sno group by s.sno; 6) 列出”math”课程成绩比”english”课程成绩高的所有学生的姓名 select s.sname, from s, (select sno, grade from sc where cno in (select cno from c where cname=&apos;math&apos;)) A, (select sno, grade from se where cno in (select cno from c where cname=’english&apos;)) B where s.sno=A.sno and s.sno=B.sno and A.grade&gt;B.grade; (4) 数据控制 授予权限 grant [权限] on [table] to &apos;username&apos;@&apos;localhost&apos;; 例1：使用sql语句中为用户zhangsan分配数据库userdb表userinfo的查询和插入数据权限 grant select,insert on userdb.userinfo to&apos;zhangsan&apos;@&apos;localhost&apos; 问：视图视图是从一个或几个表(或视图)导出的表。它与表不同，是一个虚表。数据库中只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的表中。所以表中的数据发生变化时，从视图中查询出的数据也就随之发生改变了。从这个意义上讲，视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化。 例1：在学生表Student的基础上，创建一个计算机系学生的视图 create view cs_student as select sno, sname from Student where Sdept=&apos;CS&apos;; 视图一经定义，就可以和基本表一样被查询、被删除。 例2：若要求进行修改和插入操作时，仍需保证该视图中只有计算机系的学生: create view cs_student as select sno, sname from Student where Sdept=&apos;CS&apos; with check option; 例3：删除视图的语句为: drop view cs_student; 例4 问：SQL约束 NOT NULL：控制字段的内容不能为空(NULL)。 UNIQUE：控制字段的内容不能重复，一个表允许有多个Unique约束。 PRIMARY KEY：控制字段的内容不能重复，即它在一个表中只允许出现一个。 FOREIGN KEY：FOREIGN KEY约束用于预防破坏表之间连接的动作，FOREIGN KEY约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。 CHECK：用于控制字段的值范围。 DEFAULT：用于设置新记录的默认值。 问：SQL的匹配模式(1) %表示匹配0个或多个字符 select * from user where name LIKE &apos;%三%&apos;; 将会把name为&quot;张三&quot;、&quot;三脚猫&quot;、&quot;唐三藏&quot;等等有&quot;三&quot;的全找出来。 %三：表示左匹配； 三%：表示右匹配； %三%：表示模糊查询。 (2) _表示匹配单个任意字符 select * from user where name LIKE &apos;_三_&apos;； 只找出&quot;唐三藏&quot;这样name为三个字且中间一个字是&quot;三&quot;的； select * from user where name LIKE &apos;三__&apos;； 只找出&quot;三脚猫&quot;这样name为三个字且第一个字是&quot;三&quot;的 (3) [ ]表示匹配括号内所列字符中的任意一个 select * from user where name LIKE &apos;[张李王]三&apos;; 将找出&quot;张三&quot;、&quot;李三&quot;、&quot;王三&quot;(而不是&quot;张李王三&quot;)； 如[]内有一系列字符（01234、abcde之类的)，则可略写为&quot;0-4&quot;、&quot;a-e&quot;。 select * from user where name LIKE &apos;老[1-9]&apos;； 将找出&quot;老1&quot;、&quot;老2&quot;、……、&quot;老9&quot;； 如要找&quot;-&quot;字符，请将其放在首位：&apos;张三[-1-9]&apos;； (4) [^ ]表示匹配不在括号所列字符内的单个任意字符 select * from user where name LIKE &apos;[^张李王]三&apos;; 将找出不姓&quot;张&quot;、&quot;李&quot;、&quot;王&quot;的&quot;赵三&quot;、&quot;孙三&quot;等 select * from user where name LIKE &apos;老[^1-4]&apos;; 将排除&quot;老1&quot;到&quot;老4&quot;，寻找&quot;老5&quot;、&quot;老6&quot;、&quot;老9&quot;、…… 问：查看Mysql表结构的命令 desc 表名; show columns from 表名; describe 表名; show create table 表名; use information_schema select * from columns where table_name=’表名’; 问：union操作符SQL union语法： select COLUMN_NAME(S) from TABLE_NAME1 union select COLUMN_NAME(S) from TABLE_NAME2; union操作符用于合并两个或多个select语句的结果集。请注意，union内部的select语句必须拥有相同数量的列，列也必须拥有相似的数据类型。同时，每条select语句中的列的顺序必须相同。默认地，union操作符会剔除重复的结果。如果要允许重复的值，请使用union all。 问：从表TABLE_NAME中提取前10条记录Sql server: select TOP N * from table_name. MySQL: select * from table_name limit 0,10; Oracle: select * from table_name where rownum＜=10 问：MySQL中的”空值”和”NULL”例1 问：索引索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。 为表设置索引是要付出代价的:一是增加了数据库的存储空间；二是在插入和修改数据时要花费较多的时间维护索引。 例1：创建索引和删除索引 (1) 在表Student(学生信息表)上按Sno(学号)降序建唯一索引Stusno create unique index Stusno ON Student(Sno desc); (2) 删除Student表的索引Stusno alter table Student drop index Stusno; 注意:以上代码在MySQL数据库上调试通过，下文代码也都是在MySQL上运行的。 例2：数据库中索引的作川是什么？什么情况下适合建立索引以及什么情况下不适合建立索引？(2011·浙商银行) 解答:创建索引可以大大提高系统的性能。 (1) 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 (2) 可以大大加快数据的检索速度，这也是创建索引的最主要原因。 (3) 可以加速表和表之间的连接，特别是在实现数据的参照完整性方面特别有意义。 (4) 在使用分组(group by)和排序(order by)子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 (5) 通过使用索引，可以在查询的过程中，使用查询优化器，提高系统的性能。 那么索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？这是因为增加索引也有许多不利的方面。 (1) 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 (2) 索引需要占用物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 (3) 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。 一般来说，应该在这些列上创建索引: (1) 在经常需要搜索的列上创建索引，可以加快搜索的速度; (2) 在作为主键的列上创建索引，强制该列的唯一性和组织表中数据的排列结构; (3) 在经常用在连接的列上创建索引，这些列主要是一些外键，可以加快连接的速度; (4) 在经常需要根据范围进行搜索的列上创建索引，囚为索引已经排序，其指定的范围是连续的; (5) 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间: (6) 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 同样，对于有些列不应该创建索引。一般来说，不应该创建索引的这些列具有下列特点: (1) 对于那些在查询中很少使用的列不应该创建索引。这是因为，既然这些列很少使用到，因此有无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度，增大了空间需求。 (2) 对于那些只有很少数据值的列也不应该创建索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占据了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 (3) 对于那些定义为text和bit等数据类型的列不应该创建索引。这是因为，这些列的数据量要么相当大，要么取值很少，不利于使用索引。 (4) 当修改操作远远大于检索操作时，不应该创建索引。这是因为，修改性能和检索性能是互相相矛盾的。当增加索引时，会提高检索的性能，但是会降低修改的性能。当减少索引时，会提高修改的性能，降低检索的性能。因此，当修改操作远远多于检索操作时，不应该创建索引。 问：范式理论 待完善(1) 第一范式(1NF) 定义：如果关系模式R的每个关系r的属性都是不可分的数据项，那么就称R是第一范式的模式。 简单的说，每一个属性都是原子项，不可分割。 1NF是关系模式应具备的最起码的条件，如果数据库设计不能满足第一范式，就不称为关系型数据库。关系数据库设计研究的关系规范化是在1NF之上进行的。 例如(学生信息表)： 学生编号 姓名 性别 联系方式 20080901 张三 男 email:zs@126.com,phone:88886666 20080902 李四 女 email:ls@126.com,phone:66668888 以上的表就不符合第一范式：联系方式字段可以再分，所以变更为正确的模式是： 学生编号 姓名 性别 电子邮件 电话 20080901 张三 男 zs@126.com 88886666 20080902 李四 女 ls@126.com 66668888 (2) 第二范式(2NF) 定义：如果关系模式R是1NF，且每个非主键属性完全函数依赖于候选键，那么就称R是第二范式。 简单的说，第二范式要满足以下的条件：首先要满足第一范式，其次每个非主键属性要完全函数依赖于候选键，或者是主键。也就是说，每个非主属性是由整个主键函数决定的，而不能由主键的一部分来决定。 例如(学生选课表): 学生 课程 教师 教师职称 教材 教室 上课时间 李四 Spring 张老师 java讲师 《Spring深入浅出》 301 08:00 张三 Struts 杨老师 java讲师 《Struts in Action》 302 13:30 这里通过(学生，课程)可以确定教师、教师职称、教材、教室和上课时间，所以可以把(学生，课程)作为主键。但是，教材并不完全依赖于(学生，课程)，只拿出课程就可以确定教材，因为一个课程一定指定了某个教材。这就叫不完全依赖，或者部分依赖。出现这种情况，就不满足第二范式。 修改后，选课表： 学生 课程 教师 教师职称 教室 上课时间 李四 Spring 张老师 java讲师 301 08:00 张三 Struts 杨老师 java讲师 302 13:30 课程表： 课程 教材 Spring 《Spring深入浅出》 Struts 《Struts in Action》 所以，第二范式可以说是消除部分依赖。第二范式可以减少插入异常，删除异常和修改异常。 (3) 第三范式(3NF) 满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。 例1，例2，例3，例4 问：数据库事务的四大特性：数据库事务是指作为单个逻辑工作单元执行的一系列操作，这些操作要么全做要么全不做，是一个不可分割的工作单位。 数据库事务的四大特性是：原子性、一致性、独立性和持久性，简称ACID。 (1) 原子性(Atomicity) 事务的原子性指的是，事务中包含的程序作为数据库的逻辑工作单位，它所做的对数据修改操作要么全部执行，要么完全不执行。这种特性称为原子性。 例如银行取款事务分为2个步骤(1)存折减款(2)提取现金。不可能存折减款，却没有提取现金。2个步骤必须同时完成或者都不完成。 (2) 一致性(Consistency) 事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。这种特性称为事务的一致性。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。 例如完整性约束a+b=10，一个事务改变了a，那么b也应随之改变。 (3) 独立性(Isolation) 分离性指并发的事务是相互隔离的。即一个事务内部的操作及正在操作的数据必须封锁起来，不被其它企图进行修改的事务看到。假如并发交叉执行的事务没有任何控制，操纵相同的共享对象的多个并发事务的执行可能引起异常情况。 (4) 持久性(Durability) 持久性意味着当系统或介质发生故障时，确保已提交事务的更新不能丢失。即一旦一个事务提交，DBMS保证它对数据库中数据的改变应该是永久性的，即对已提交事务的更新能恢复。持久性通过数据库备份和恢复来保证。 例1： DBMS中实现事务持久性的子系统是：恢复管理子系统。 问：数据库事务隔离级别讲解”数据库事务隔离级别”的一篇文章 数据库事务的隔离级别有4个，由数据库系统实现，从低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。 问：数据库恢复的基础是利用转储的冗余数据。这些转储的冗余数据包括：日志文件，数据库后备副本","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://hepsilion.github.io/tags/数据库/"},{"name":"SQL","slug":"SQL","permalink":"https://hepsilion.github.io/tags/SQL/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"计算机网络总结","slug":"计算机网络","date":"2017-05-28T10:42:51.000Z","updated":"2017-06-01T12:18:07.533Z","comments":true,"path":"2017/05/28/计算机网络/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/计算机网络/","excerpt":"计算机网络","text":"计算机网络 一、 计算机网络体系结构问：OSI参考模型国际标准化组织(ISO)提出的网络体系结构模型，称为开放系统互联参考模型(OSI/RM)，通常简称为OSI参考模型。 OSI有七层，自下而上依次为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。每一层的作用如下： 物理层(比特Bit)：负责在连接各个计算机的传输媒介上传输数据比特流，确定与传输媒介的接口相关的一些特性。(通过媒介传输比特，确定机械及电气规范) 数据链路层(帧Frame)：将比特组装成帧和点到点的传递。 网络层(分组或数据包Packet)：负责网际互连及对数据包进行路由选择和存储转发。 传输层(报文或数据段Segment)：提供端到端的可靠报文传递和错误恢复。 会话层(会话协议数据单元SPDU)：建立、管理和终止会话 表示层(表示协议数据单元PPDU)：对数据进行翻译、加密和压缩 应用层(应用协议数据单元APDU)：允许访问OSI环境的手段 数据链路层在概念上常被划分为两个子层:逻辑链路控制子层(LLC)和媒体访问拧制子层(MAC)。数据链路层负责分配MAC地址。MAC地址(或称物理地址)，48比特长，由12个十六进制数字组成，0~23位(前6位十六进制数)是厂商向IETF等机构申请用来标识厂商的代码。24到47位由厂商自行分派，是各个厂商制造的所有网卡的一个唯一编号。因此每一个网卡会有一个全球唯一固定的MAC地址，但可对应多个IP地址。MAC地址的第48位是组播地址标志位。 网络层提供点到点的通信。直接相连的结点之间的通信称为点到点通信。它只提供一台机器到另一台机器之间的通信，不会涉及程序或进程的概念。 传输层是第一个提供端到端的通信，即进程到进程的层次。由于一个主机可同时运行多个进程，因此传输层有复用和分用的功能。 每一层的协议及设备如下： 物理层(中继器，集线器)：RJ45、CLOCK、IEEE802.3 数据链路(网桥，交换机)：PPP、FR、HDLC、VLAN、MAC 网络层(路由器)：IP、ICMP、ARP、RARP、OSPF、IPX、RIP(内部网关协议，基于UDP)、IGRP、IGMP 传输层：TCP、UDP、SPX、SCTP 会话层：NFS、SQL、NETBIOS、RPC 表示层：JPEG、MPEG、ASII 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS、SNMP 例1： RIP协议是基于UDP协议实现的。 例2：网卜完成哪一层的功能？ 答案：网卡工作在物理层和数据链路层的MAC子层 问：TCP/IP参考模型TCP/IP模型从低到高依次为：网络接口层、网际层、运输层、应用层。TCP/IP由于得到广泛应用而成为事实上的国际标准。 网络接口层的功能类似于OSI的物理层和数据链路层。 网际层是TCP/IP体系结构的关键部分。它和OSI网络层在功能上非常相似。网际层将分组发往任何网络，并为之独立地选择合适的路由，但它不保证各个分组有序到达，各个分组的有序交付由高层负责。网际层定义了标准的分组格式和协议，即IP协议。当前采用的IP协议是第4版，即IPv4，它的下一个版本是IPv6。 传输层的功能同样和OSI中的传输层类似，是使发送端和目的端主机上的对等实体可以进行会话。 应用层包含所有的高层协议。如虚拟终端协议(Telnet)、文件传输协议(FTP)、域名解析服务(DNS)、电子邮件协议(SMTP)和超文本传输协议(HTTP)。 传输层主要使用以下两种协议: (1) 传输控制协议(Transmission Control Protocol, TCP)。它是面向连接的，数据传输的单位是报文段，能够提供可靠的交付。 (2) 用户数据报协议(User Datagram Protocol, UDP)。它是无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供”尽最大努力交付”。 例1 TCP/IP模型中，ARP协议属于网络层，在OSI参考模型中，ARP属于数据链路层 问：各种协议的介绍(2) TFTP协议 TFTP协议是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。基于UDP协议实现，端口号为69。 (3) HTTP协议(超文本传输协议) 该协议定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。HTTP是面向事务的应用层协议，它规定了浏览器和服务器之间的请求和响应格式和规则，是万维网上能够可靠地交换文件(包括文本、声音、图像等各种多媒体文件)的重要基础。 (4) NAT协议 网络地址转换属接入广域网(WAN)技术，它通过将私有网络地址(如企业内部Internet)转换为共用地址(如Internet)，从而对外隐藏了内部管理的IP地址。它使得整个私有网络只需要一个全球IP地址就可以与因特网连同。由于私有网络本地IP地址是可以重用的，所以NA大大节省了IP地址的消耗；同时，它隐藏了内部网络结构，从而降低了内部网络收到攻击的风险。 (5) DHCP协议(动态主机配置协议，DHCP是应用层协议，它是基于UDP的) 常用于给主机动态地分配IP地址，提供了即插即用联网机制，这种机制允许一台计算机加入新的网络和获取IP地址而不用手动参与。 问：了解中继器、集线器、网桥、交换机、路由器、网关的概念，并知道各自的用途(1) 中继器 中继器工作在物理层，用来连接两个速率相同且数据链路层协议也相同的网段，连接起来的几个网段仍然是一个局域网。 中继器功能是消除数字信号在基带传输中由于经过一长段电缆而造成的失真和衰减，使信号的波形和强度达到所需的要求，其原理是信号再生。 中继器既不能隔离冲突域，也不能隔离广播域。 (2) 集线器 集线器也工作在物理层，相当于一个多接口的中继器，可以将多个节点连接成一个共享式局域网，但任何时刻只能有一个节点通过公共信道发送数据。 中继器既不能隔离冲突域，也不能隔离广播域。 举例：假设一集线器存在７个端口，共连接了５台计算机，那么该网络环境中存在冲突域的个数为1。 原因：集线器的所有端口是一个冲突域，而交换机的每个端口是一个冲突域 (3) 网桥 两个或多个以太网通过网桥连接起来后，就成为一个覆盖范围更大的以太网，而原来的每个以太网就可称为一个网段。 网桥工作在数据链路层的MAC子层，可以互联不同的物理层、不同的MAC子层以及不同速率的以太网，使以太网各网段成为隔离开的碰撞域。 网桥具有过滤帧以及存储转发帧的功能，可以隔离冲突域，但不能隔离广播域。 (4) 交换机 交换机工作在数据链路层，俗称”二层交换机”，相当于一个多端口的网桥，是交换式局域网的核心设备。除此之外，还有三层交换机、四层交换机，七层交换机，分别工作在OSI第三层、第四层、第七层。 交换机允许端口之间建立多个并发的连接，允许多对计算机同时通信，实现多个节点之间的并发传输。因此，交换机的每个端口节点所占用的带宽不会因为端口节点数目的增加而减少，且整个交换机的总带宽会随着端口节点的增加而增加。 交换机一般以全双工方式工作，有的局域网交换机采用存储转发方式进行转发，有的交换机采用直通交换方式(即在收到帧的同时立即按帧的目的MAC地址决定帧的转发端口，而不必进行先缓存再进行处理)。 利用交换机可以实现虚拟局域网(VLAN)，VLAN可以隔离冲突域，也可以隔离广播域。 (5) 路由器 路由器是一种具有多个输入输出端口的专用计算机，其任务是连接不同的网络(连接异构网络)并完成路由转发。 路由器是网络层设备，它实现了网络模型的下三层，即物理层、数据链路层和网络层。路由器隔离了广播域。 路由器主要完成两个功能：分组转发和路由计算。前者处理通过路由器的数据流，关键操作是转发表查询、转发以及相关的队列管理和任务调度等；后者通过和其他路由器进行基于路由协议的交互，完成路由表的计算。 (6) 网关 在传统TCP/IP术语中，网关(gateway)与路由器(router)没有区别。 在现代网络术语中，网关与路由器的定义不同。网关能在不同协议间移动数据，而路由器是在不同网络间移动数据，相当于传统所说的IP网关。网关是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过网关还原成模拟的电话信号，最后才能在电话机上听到。 二、 物理层三、 数据链路层问：太网卡的工作模式例1：太网卡的工作模式 答案：广播模式、多播传送、直接模式、混杂模式 问：海明码例1：用海明码对长度为8位的数据进行检/纠错时，若能纠正一位错，则校验位数至少为多少？ 答案为4。 假设为k个数据位设置r个校验位，则校验位能表示2^r个状态。 可用其中的一个状态指出&quot;没有发生错误&quot;，用其余的2^r-1个状态指出有错误发生在某一位，包括k个数据位和r个校验位。 因此校验位的位数应满足如下关系:2^r≥k+r+1。 问：交换机攻击交换机攻击主要有以下5种类型 (1) VLAN跳跃攻击(2) 生成树攻击(3) MAC表洪水攻击(4) ARP攻击(5) VTP攻击 问：CSMA/CD例1： CSMA/CD适用于有线网络，而CSMA/CA则广泛应用于无线局域网。 四、 网络层问：IPv4地址分类连接在Internet中的每台主机(或路由器)都分配一个32bit的全球唯一的标识符，即IP地址。IP地址的编码方法有三种:分类的IP地址、子网的划分和CIDR。 传统的IP地址是分类的地址，分为A、B、C、D、E五类。无论哪类IP地址，都由网络号和主机号两部分组成。其中，网络号代表主机所连接到的网络，主机号代表该主机或路由器在网络中的地址。 A类地址(1~126)：网络号占前8位，以0开头，主机号占后24位。 B类地址(128~191)：网络号占前16位，以10开头，主机号占后16位。 C类地址(192~223)：网络号占前24位，以110开头，主机号占后8位。 D类地址(224~239)：以1110开头，保留为多播地址。 E类地址(240~255)：以1111开头，保留为今后使用。 在各类IP地址中，有一些IP地址用于表示特殊用途，不用于作主机IP地址: 主机号全为0表示本网络本身，例如202.98.174.0；主机号全为1表示本网络的广播地址，例如202.98.174.255。 网络号剩余字段全为0的IP地址是保留地址，表示本网络，如00000000+24位主机号 127.X.X.X网络保留做为环路自检地址，该地址表示任意主机本身，目的地址为环路自检地址的IP数据报永远不会出现在网络上。 32位全为1，即255.255.255.255表示整个TCP/IP网络的广播地址;32位全为0，即0.0.0.0表示本网络上的本主机。 问：网络地址转换网络地址转换(NAT)是通过将专用网络地址(如企业内网)转换为公用地址(如互联网Internet，从而对外隐藏了内部管理的IP地址。这样，通过在内部使用非注册的IP地址，并将它们转换为一小部分外部注册的IP地址，从而减少了IP地址注册的费用以及节省了日前越来越缺乏的IPv4地址空间。 此外，划出了部分IP地址为私有IP地址。私有IP地址值用于LAN，不用于WLAN连接。因此私有IP地址不能直接用于Internet，必须通过网关利用NAT把私有IP地址转换为Internet中合法的全球IP地址后才能用于Internet。私有IP地址有效地解决了IP地址不足的问题。私有IP地址网段如下: A类：1个A类网段，即10.0.0.0~10.255.255.255 B类：16个B类网段，即172.16.0.0~172.31.255.255 C类：256个C类网段，即192.168.0.0~192.168.255.255 在因特网中的所有路由器，对目的地址是私有地址的数据报一律不进行转发。使用NAT时，需要在专用网连接到因特网的路由器上安装NAT软件，NAT路由器至少有一个有效的外部全球地址。普通路由器在转发数据报时不改变其源IP地址和目的IP地址，且路由器工作在网络层，而NAT路由器在转发IP数据报时，一定要更换其IP地址(按路由器中的地址转换表转换源IP地址或目的IP地址)。NAT路由器转发数据报时需要查看和转换传输层的端口，其操作没有严格的层次关系。 问：子网划分与子网掩码各类地址的默认子网掩码： A类：255.0.0.0 B类：255.255.0.0 C类：255.255.255.00 使用子网划分时的地址格式: A类网络：8位+子网X位+主机24-X位 B类网络：16位+子网X位+主机16-X位 C类网络：24位+子网X位+主机8-X位 例1：使用子网掩码255.255.255.224可以将C类地址203.67.12.0分成多少个子网。 答案：8个 把子网掩码255.255.255.224转换成二进制：11111111.11111111.11111111.11100000 网络ID=24bits(C类地址)，子网ID=3位，主机ID=5位 所以，子网数位2^3=8个，每个子网的地址数为2^5=32个，每个子网的主机地址数为32-2=30个。 自所以减去2是因为全0和全1的主机号不能使用。 问：无分类编址CIDRCIDR是在使用可变长度子网掩码的基础上提出的一种消除传统A，B，C类网络划分，并且可以在软件的支持下实现超网构造的一种IP地址的网络划分方法。这样可以大幅度提高IP地址空间的利用率，并减小路由表大小，提高路由器的路由转发能力。 CIDR的主要特点如下: (1) 消除了传统的A，B，C类地址以及子网的概念，因而可以更加有效地分配IPv4的地址空间。CIDR使用”网络前缀”概念代替子网络概念。这样IP地址分为两部分:网络前缀、主机号。CIDR使用斜线记法，即IP地址/网络前缀所占比特数。其中，网络前缀所占比特数对应于网络号的部分，等效子网掩码中连续1的部分。 (2) 将网络前缀都相同的连续的IP地址组成”CIDR地址块”。一个CIDR地址块可以包括多个A、B、C类地址，这种地址的聚合称为路由聚合，或称为构成超网。路由聚合使得路由表中的一个表项可以表示很多个原来传统分类地址的路由，有利于减少路由之间的路由选择信息的交换，从而提高网络性能。 例1：CIDR地址块192.168.10.0/20所能包含主机的最大地址范围是多少？ 答案：192.168.0.1~192.168.15.254 CIDR地址由网络前缀和主机号构成。CIDR将网络前缀都相同的连续的IP地址组成&quot;CIDR&quot;地址块。 本题中，网络前缀的长度为20，把IP的第17~24bit写成二进制位00001010，这8bit中的前4bit为前缀，后4bit为主机号。 由于主机号不能为全0或全1，因此地址块所能包含的主机最大范围为192.168.0.1~192.168.15.254。 问：ARP是地址解析协议，简单语言解释一下工作原理。在实际网络的数据链路上传送数据时，最终必须使用硬件地址。所以需要一种方法来完成IP地址到MAC地址的映射，这就需要用到地址解析协议(ARP)。 每个主机(或路由器)都有一个ARP高速缓存，存放本局域网上各主机或路由器的IP地址到MAC地址的映射表，称为ARP表，主机(或路由器)使用ARP协议来动态维护此ARP表。 ARP工作在网络层，其工作原理是(广播发送ARP请求，单播发送ARP响应)： (1) 当主机源欲向本局域网上的某个目的主机发送IP数据报时，就先在其ARP高速缓存中查看有无目的主机的IP地址，如果有，就可以查出其对应的MAC地址，并将此地址写入MAC帧，然后通过局域网将该MAC帧发往此地址；如果没有，就通过使用目的MAC地址为FF-FF-FF-FF-FF-FF的帧来封装并广播ARP请求数据包(该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP地址)，可以使同一个局域网中的所有主机收到ARP请求。 (2) 当本局域网中的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后向源主机发出ARP响应包，该响应包中包含自己的IP地址与MAC地址的映射关系。 (3) 源主机收到ARP响应包后,将目的主机的IP和MAC地址的映射写入ARP表，然后按查询到的MAC地址发送MAC帧。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。 问：描述RARP协议RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。 工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。 问：ICMP协议(因特网控制报文协议，TCP/IP协议族IP层子协议)为了提高IP数据报交付成功的机会，网络层使用ICMP协议来允许主机或路由器报告差错和异常情况。ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去。 问：在局域网内使用ping www.nowcoder.com时，使用了哪些协议？Ping命令工作在应用层，它直接使用网络层的ICMP协议，而没有使用传输层的TCP或UDP协议。 (1) 首先将域名转换为IP地址，用到了应用层的DNS协议，而DNS协议使用了传输层的UDP协议。 (2) ping功能是测试另一台主机是否可达，程序发送一份ICMP回显请求给目标主机，并等待返回ICMP回显应答 (3) 数据在局域网中，根据MAC地址通过数据链路层传输，所以要用到ARP解析服务，获取到目的主机的MAC地址 问：IPv6IPv6由128bit构成，通常使用冒号十六进制记法表示IPv6地址，每个16bit的值用四位十六进制值表示，各值之间用冒号分割，如68E6:8C64:FFFF:FFFF:0:1180:960A:FFFF。该表示方法允许使用零压缩，即一连串连续的零可以为一对冒号所取代，如DE08:0:0:0:0:0:0:B3可以写成DE08::B3。IP地址0:0:0:0:0:0:118.17.23.1可以写成::118.17.23.10。 IPv6所引入的主要变化: 更大的地址空间。IPv6将地址从IPv4的32bit增大到了128bit; 扩展的地址层次结构； 灵活的首部格式； 改进的选项。这一特征加快了分组处理速度； 允许协议继续扩充； 支持即插即用； 支持资源的预分配； 增加了安全性，身份验证和保密验证是IPv6的关键特征； 分片限制为由源点来完成，是端到端的，路由途中的路由器不允许进行分片。 问：TTL例1：当路由器接收的IP报文的TTL值等于1时，采取的策略是什么？ 答案：丢掉该分组 问：广播风暴一个数据帧或包被传输到本地网段上的每个节点就是广播；由于网络拓扑的设计和连接问题，或其他原因导致广播在网段内大量复制，传播数据帧，导致网络性能下降，甚至网络瘫痪，这就是广播风暴。所以需要有能够隔离广播域的设备才可以抑制广播风暴。 五、 传输层问：UDP用户数据报协议(User Datagram Protocol)。UDP是一种无连接协议，因为UDP客户与服务器不必存在长期的关系，例如一个UDP客户创建一个套接字并发送一个数据报给一个服务器，然后立即用同一个套接字发送另一个数据报给另外一个服务器。同样，一个UDP服务器可以使用同一个套接字从若干不同的客户一连串接受多个数据报。 UDP不是可靠的，不能保证最终到达它们的目的地，不保证各个数据报的先后顺序跨越网络保持不变，也不保证每个数据报只到达一次。 UDP既可以使用IPv4，也可以使用IPv6。 问：TCP传输控制协议(Transmission Control Protocol)。 (1) TCP是一种面向连接的协议，提供客户与服务器的连接。 (2) TCP提供可靠性。当使用TCP向另一端发送数据时，它要求对端返回一个确认。如果没有收到确认，TCP自动重传数据并等待更长时间。在数次重传失败后，TCP才放弃。 (3) TCP通过给所发送数据的每一个字节关联一个序列号进行排序。UDP提供不可靠的数据报传送，不提供确认、序列号、超时重传等机制。 (4) TCP提供流量控制，而UDP不提供流量控制。TCP总是告诉对端它能够接收多少字节的数据，这称为通信窗口。该窗口在任何时刻都指出接收缓冲区中的可用空间，从而确保发送端发送的数据不会溢出接收缓冲区。 (5) TCP的连接是全双工的。UDP也可以是全双工的。 TCP既可以使用IPv4，也可以使用IPv6 0 UDP与TCP的主要区别在于UDP不一定提供可靠的数据传输。事实上，该协议不能保证数据准确无误地到达目的地。UDP在许多方面非常有效，如UDP具有对系统资源要求较少、具有较好的实时性、网络开销小的优点。当某个程序的目标是尽快地传输尽可能多的信息时(其中任意给定数据的重要性相对较低)，可使用UDP。 问：TCP和UDP的区别？TCP和UDP的区别： (1) TCP提供面向连接的、可靠的数据流传输，而UDP提供的是面向无连接的、不可靠的数据流传输。 (2) TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。 (3) TCP由于提供面向连接的可靠的传输服务，因此不可避免地增加了许多开销，如确认、流量控制、计时器以及连接管理，这不仅使协议数据单元的头部增加很多，还占用许多处理机资源，因此TCP主要适用于可靠性更重要的场合，如文件传输协议FTP、超文本传输协议HTTP、远程登陆TELNET等；UDP由于在传送数据之前不需要先建立连接，远程主机的传输层收到UDP报文后，不需要给出任何确认，执行速度比较快、实时性较好，因此UDP主要适用于实时性要求高的场合，如小文件传输协议(TFTP)、DNS、SNMP和实时协议(RTP)。 例1 TCP对应的协议和UDP对应的协议 (1) TCP对应的协议： FTP：定义了文件传输协议，使用21端口。https://www.nowcoder.com/profile/7404313/test/8114836/23235?onlyWrong=0 Telnet：一个通过创建虚拟终端提供登陆到远程主机终端的协议，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。 SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。 POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。 HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。HTTP协议所用的是80端口。 (2) UDP对应的协议： DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。 SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。 TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。 问：TCP三次握手和四次挥手的全过程 (1) 三次握手 第一次握手(SYN=1，seq=x)：客户端首先向服务器发送一个连接请求报文段，并进入SYN_SEND状态，等待服务器确认。这个报文段不含应用层数据，其首部中的SYN标志位被置为1，另外，客户端会随机选择一个起始序号seq=x。(连接请求报文段不携带数据，但要消耗一个序号) 第二次握手(SYN=1, ACK=1, seq=y, ack=x+1)：服务器收到连接请求报文段，如同意建立连接，就向客户端发回确认，并为该TCP连接分配TCP缓存和变量，此时服务器进入SYN_RECV状态。在确认报文段中，SYN和ACK位都被置为1，确认号字段的值为x+1，并且服务器随机产生起始序号seq=y。确认报文段同样不包含应用层数据。 第三次握手(ACK=1, seq=x+1, ack=y+1)：当客户端收到确认报文段后，还要向服务器给出确认，并且也要给该连接分配缓存和变量，客户端和服务器进入ESTABLISHED状态，完成三次握手。这个报文段的ACK标志位被置1，序号字段为x+1，确认号字段ack=y+1。(该报文段可以携带数据，如果不携带数据则不消耗序号)。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。 例1 四次挥手 与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。 第一次挥手(FIN=1，seq=u)：主动关闭方打算关闭连接，就向被动关闭方发送一个连接释放报文段并停止再发送数据，进入FIN_WAIT1状态，主动关闭TCP连接。该报文段的FIN标志位被置为1，seq=u，它等于前面已传送过的数据的最后一个字节的序号加1(FIN报文段即使不携带数据，也要消耗一个序号)。当发送FIN报文时，发送FIN的一方就不能再发送数据了(当然，在FIN包之前发送出去的数据，如果没有收到对应的确认报文，主动关闭方依然会重发这些数据)，也就是关闭了其中一条数据通路，但此时对方还可以发送数据，主动关闭方还可以接受数据。 第二次挥手(ACK=1，seq=v，ack=u+1)：被动关闭方收到连接释放报文段后即发出确认，并进入CLOSE_WAIT状态，确认号是ack=u+1，而这个报文段自己的序号是v，等于它前面已经传送过的数据最后一个字节的序号加1。此时，从主动关闭方到被动关闭方这个方向的连接就释放了，TCP连接处于半关闭状态，但被动关闭方若发送数据，主动关闭方仍要接收。 第三次挥手(FIN=1，ACK=1，seq=w，ack=u+1)：若被动关闭方已经没有要向主动关闭方发送的数据，就通知TCP释放连接，此时其发出FIN=1的连接释放报文段。 第四次挥手(ACK=1，seq=u+1，ack=w+1)：主动关闭方收到连接释放报文段后，必须发出确认。在确认报文段中，ACK字段被置1，确认号ack=w+1，序号seq=u+1。至此，完成四次挥手。 此时，TCP连接还没有释放掉，必须经过时间等待计时器设置的时间2MSL后，主动关闭方才进入连接关闭状态。 例1:看评论中的图，例2，例3，例4 问：TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。 采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。 考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，若不采用三次握手，新的连接就建立了，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。 采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。 例1 问：TCP拥塞控制-慢启动和拥塞避免例1 六、 应用层问：FTP协议问：DNS域名系统，简单描述其工作原理。域名系统DNS(Domain Name System)是因特网使用的命名系统，用来把便于人们记忆的含有特定含义的主机名(如www.baidu.com)转换成便于机器处理的IP地址。DNS系统采用客户/服务器模型，其协议运行在UDP之上，使用53号端口。该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。 工作原理 当客户端需要域名解析时，通过本机的DNS客户端构造一个DNS请求报文，以UDP数据报方式发往本地域名服务器。域名解析有两种方式：递归查询(实际中几乎不使用)和迭代查询。 (1) 递归查询 如果本地主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向根域名服务器继续发出查询请求报文(即替该主机继续查询)，而不是让主机自己进行下一步的查询。在这种情况下，本地域名服务器只需向根域名服务器查询一次，后面的几次查询都是递归地在其他几个域名服务器之间进行的(如图a步骤3-6)。在步骤7中，本地域名服务器从根域名服务器得到了所需的IP地址，最后在步骤8中，本地域名服务器把查询结果告诉主机。 (2) 迭代查询 当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地域名服务器：“你下一次应当向哪个顶级域名服务器进行查询”，然后让本地域名服务器向这个顶级域名服务器进行后续的查询，如图b所示。同样，顶级域名服务器收到查询报文后，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步应当向哪一个域名服务器查询。最后，本地域名服务器知道了所要解析的域名的IP地址，然后把查询结果返回给发起查询的主机。 问：HTTP协议的特点例1，例2 问：在浏览器中输入www.baidu.com后执行的全部过程事件顺序 (1) 浏览器获取输入的域名www.baidu.com (2) 浏览器向DNS请求解析www.baidu.com对应的IP地址 (3) 域名系统DNS解析出百度服务器的IP地址 (4) 浏览器与该服务器建立TCP连接(默认端口号80)，并向服务器发送HTTP请求，请求百度首页 (6) 服务器通过HTTP响应把首页文件发送给浏览器 (7) TCP连接释放 (8) 浏览器将首页文件进行解析，并将Web页显示给用户。 涉及到的协议 (1) 应用层：HTTP(WWW访问协议)，DNS(域名解析服务) (2) 传输层：TCP(为HTTP提供可靠的数据传输)，UDP(DNS使用UDP传输) (3) 网络层：IP(IP数据数据包传输和路由选择)，ICMP(提供网络传输过程中的差错检测)，ARP(将本机的默认网关IP地址映射成物理MAC地址) 问：常见的http协议状态码网络上的一份总结 http1.1状态吗分为五类，所有状态码的第一个数字代表了响应的五种状态之一。 1xx:消息，这一类型的状态码，代表请求已被接受，需要继续处理。其中100表示客户端应当继续发送请求。 2xx:成功，这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。其中200表示请求已成功，请求所希望的响应头或数据体将随此响应返回。 3xx:重定向。 302 临时重定向，(此时浏览器会产生两次http请求) 4xx:客户端错误。其中400表示:语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求；或者请求参数有误。 400 请求报文存在语法错误 403 禁止访问，资源不可用 404 请求的资源不存在 5xx:服务器错误。 500 服务器内部错误 503 服务器繁忙 问：HTTP请求方法OPTIONS、HEAD、GET、POST、PUT、DELETE、TRACE、CONNECT 七、 常用网络测试工具问：pingping是用来检查网络是否通畅或者网络连接速度的命令。 它所利用的原理是这样的:利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通、时延是多少。ping命令是控制台命令，例如Ping百度的用法如下: ping www:baidu.com 问：tracerttracert是路由跟踪实用程序，用于确定IP数据包访问目标所采取的路径。 tracert命令用IP生存时间(TTL)字段和ICMP错误消息来确定从一个主机到网络上其他主机的路由。其命令格式如下: tracert[-d] [-h maximum_hops] [-j computer_list] [-w timeout] target_name 可以使用tracert命令确定数据包在网络上的停留位置。例如:tracert www:baidu.com则会打印出从当前主机到目的主机所经过的路由地址。 问：telnettelnet在网络测试中十分有用，例如可以用telnet测试80端口的Web服务器是否正常工作。输入: telnet www.hitsz .edu.cn 80 然后服务器响应: Trying 219.223.252.3... Connected to www.hitsz.edu.cn Eseape character is &apos;^]&apos;. 然后输入: GET / HTTP1.1 如果Web服务器正常工作的话，就会返回服务器的响应头，以便你确认服务器的情况。 问：netstatnetstat是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每个网络接口设备的状态信息。 netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。使用格式为: netstat [-a] [-e] [-n] [-o] [-p Protocol] [-r] [-s] [Interval] 一般用netstat -an来显示所有连接的端口并用数字表示。 例1：某校园网用户无法访问外部站点210.102.58.74，管理人员在Windows操作系统下可以使用()命令判断故障发生在校园网内还是校园网外。 A. ping 210.102.58.74 B. tracert 210.102.58.74 C. netstat 210.102.58.74 D. arp 210.102.58.74 答案：B 八、 其他东西问：往返时延和网络延迟往返时延(Round-Trip Time, RTT):表示从发送端发送数据开始，到发送端收到来自接收端的确认(接收端收到数据后便立即发送确认)，总共经历的时延。 网络延迟是数据进入网络到离开网络所花费的总时间。 使用最广泛是的B通路B通路：具有定时的64Kbit/s通路，用于传递广泛的各种用户信息流，不传递ISDN电路交换的信令信息。 D通路：主要用于传递ISDN电路交换的信令信息，也可以传递遥信信息和分组交换数 据。D通路可以有不同的比特率， H通路：H通路有以下几种传输速率： H0通路：384Kbit/s H11通路：1536 Kbit/s H12通路：1920 Kbit/s H通路用于传递各种用户信息流，例如高速传真、电视影像、高质量音频或声音节目、高速数据、分组交换信息等，不传递ISDN电路交换的信令信息。 https://www.nowcoder.com/profile/7404313/test/8046849/14529?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/7959409/3989?onlyWrong=0","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://hepsilion.github.io/tags/计算机网络/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"数据结构","slug":"数据结构","date":"2017-05-28T10:38:35.000Z","updated":"2017-06-01T12:21:14.885Z","comments":true,"path":"2017/05/28/数据结构/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/数据结构/","excerpt":"数据结构","text":"数据结构 一、绪论问：数据项、数据元素、数据对象、数据(了解)(1) 数据元素是数据的基本单位。一个数据元素可由若干个数据项组成，数据项是构成数据元素的不可分割的最小单位。 例如，学生记录就是一个数据元素，它由学号、姓名、性别等数据项组成。 (2) 数据对象是具有相同性质的数据元素的集合，是数据的一个子集。 问：抽象数据类型(了解)一个数学模型以及定义在此模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。通常用(数据对象、数据关系和基本操作)三元组来表示抽象数据类型。 问：数据结构的三要素：逻辑结构、存储结构和数据的运算。问：数据的逻辑结构与存储结构逻辑结构：指是数据元素之间的逻辑关系，通常分为线性结构和非线性结构。 存储结构：也称为物理结构，指数据结构在计算机中的表示，也称为存储结构，通常分为顺序结构，链式结构，索引结构，哈希结构。 问：线性结构与非线性结构线性结构与非线性结构，主要看元素之间的关系，如果是一对一的关系则是线性表，如果不是一对一的关系则是非线性表。 数据结构中线性结构指的是数据元素之间存在着“一对一”的线性关系的数据结构。常用的线性结构有：线性表，栈，队列，双队列，数组，串。 线性结构是一个数据元素的有序（次序）集合。它有四个基本特征： (1) 集合中必存在唯一的一个”第一个元素”； (2) 集合中必存在唯一的一个”最后的元素”； (3) 除最后元素之外，其它数据元素均有唯一的”后继”； (4) 除第一元素之外，其它数据元素均有唯一的”前驱”。 相对应于线性结构，非线性结构的逻辑特征是一个结点元素可能对应多个直接前驱和多个直接后继。如树，广义表，图，多维数组等 问：顺序存储结构和链式存储结构顺序存储结构的主要特点： (1) 结点中只有自身的信息域，没有关联信息域。因此，顺序存储结构的存储密度大、存储空间利用率高。 (2) 通过计算地址直接访问任何数据元素，即可以随机访问。 (3) 插入和删除操作会引起大量元素的移动。 链式存储结构的主要特点是： (1) 结点除自身的信息域外，还有表示关联信息的指针域。因此，链式存储结构的存储密度小、存储空间利用率低。 (2) 在逻辑上相邻的结点在物理上不必相邻，因此，不可以随机存取，只能顺序存取。 (3) 插入和删除操作方便灵活，不必移动结点只需修改结点中的指针域即可。 问：广义表如果广义表LS=(a1, a2, …, an)非空，则a1是LS的表头，其余元素组成的表(a2,a3,..an)是称为LS的表尾，所以非空广义表尾一定是个表。 例1： 已知广义表LS＝((a,b,c),(d,e,f)),运用head和tail函数取出LS中原子e的运算是：head(tail(head(tail(LS)))) tail(LS)＝((d,e,f)) head(tail(LS))=(d,e,f) tail(head(tail(LS)))=(e,f) head(tail(head(tail(LS))))=e 广义表可以是自身的子表。(没理解) 例2： 例3：判断正误。 若一个广义表的表头为空表,则此广义表亦为空表。 错误。 例4：判断正误。 对长度为无穷大的广义表,由于存储空间的限制,不能在计算机中实现. 正确。 问：算法的5个基本特征有穷性、确定性、可行性、输入、输出。 问：主定理图 1 二、线性表问：静态链表用数组描述线性表的链式存储结构，即称为静态链表，它的节点有数据域和指针域，指针是节点的相对地址(数组下标)。 例1： 用数组r存储静态链表，结点的next域指向后继，工作指针j指向链中结点，使j沿链移动的操作为：j=r[j].next 三、栈和队列栈有n个数依次入栈，则出栈序列有Cn种，Cn=C(2n,n)/(n+1)。 例1： 问：顺序存储结构的循环队列假设循环队列的队尾指针是rear，队头是front，其中QueueSize为循环队列的最大长度。 (1) 入队时队尾指针前进1：(rear+1)%QueueSize (2) 出队时队头指针前进1：(front+1)%QueueSize 例1，例2 (3) 队列长度：(rear-front+QueueSize)%QueueSize 例1： 现有一循环队列，其队头指针为front，队尾指针为rear；循环队列长度为N。其队内有效长度为？(假设队头不存放数据) 答案：(rear-front+N)%N (4) 队空和队满的条件 为了区分队空还是堆满的情况，有多种处理方式： 方式1： 牺牲一个单元来区分队空和队满，入队时少用一个队列单元，即约定以”队头指针在队尾指针的下一位置作为队满的标志”。 队满条件为：(rear+1)%QueueSize==front 队空条件为：front==rear 队列长度为：(rear-front++QueueSize)%QueueSize 方式2： 增设表示队列元素个数的数据成员size，此时，队空和队满时都有front==rear。 队满条件为：size==QueueSize 队空条件为：size==0 方式3： 增设tag数据成员以区分队满还是队空 tag表示0的情况下，若因删除导致front==rear，则队空； tag等于1的情况，若因插入导致front==rear则队满 例1： 循环队列的存储空间为Q(1:50)，初始状态为front=rear=50。 经过一系列正常的入队与退队操作后，front=rear=25。此后又插入一个元素，则循环队列中的元素个数为多少？ 答案：1，或50且产生上溢错误 例2： 循环队列的存储空间为Q(1:40)，初始状态为front=rear=40。 经过一系列正常的入队与退队操作后，front=rear=15，此后又退出一个元素，则循环队列中的元素个数为多少？ 答案：39，或0且产生下溢错误 例3： 设循环队列的存储空间为Q(1:35)，初始状态为front=rear=35。现经过一系列入队与退队运算后，front=15，rear=15，则循环队列中的元素个数为多少？ 答案：0或35 例4： 循环队列的存储空间为Q(1:200)，初始状态为front=rear=200。经过一系列正常的入队与退队操作后，front=rear=1 则循环队列中的元素个数为多少？ 答案：0或200 例：个人觉得这一题条件不全 最大容量为n的循环队列,队尾指针是rear,队头是front,则队空的条件是：rear=front 问：算术表达式的中缀表达式、前缀表达式和后缀表达式表达式一般由操作数、运算符组成，例如算术表达式中，通常把运算符放在两个操作数的中间，这称为中缀表达式，如A+B。波兰数学家Jan Lukasiewicz提出了另一种数学表示法，它有两种表示形式：把运算符写在操作数之前，称为波兰表达式或前缀表达式，如+AB；把运算符写在操作数之后，称为逆波兰表达式或后缀表达式，如AB+。 将中缀表达式转换成后缀表达式的算法： 例1：将中缀表达式a+b-a*((c+d)/e-f)+g转化为后缀表达式ab+acd+e/f-*-g+的过程。 图 1 例2：简易方法 中缀表达式：a+b*c-(d+e) (1) 中缀表达式转换为前缀表达式： 第一步：按照运算符的优先级对所有的运算单位加括号，算术表达式变成： ((a+(b*c))-(d+e)) 第二步：把每个运算符号移动到其对应的括号前面，则算术表达式变成了： -( +(a *(bc)) +(de)) 第三部：去掉括号得到前缀表达式： -+a*bc+de (2) 中缀表达式转换为后缀表达式： 第一步：按照运算符的优先级对所有的运算单位加括号，算术表达式变成： ((a+(b*c))-(d+e)) 第二步：把每个运算符号移动到其对应的括号后面，则算术表达式变成了： ((a(bc)* )+ (de)+ )- 第三部：去掉括号得到后缀表达式： abc*+de+- 例3，例4，例5，例6，例7，例8 逆波兰表达式求值算法： 1、循环扫描语法单元的项目。 2、如果扫描的项目是操作数，则将其压入操作数堆栈，并扫描下一个项目。 3、如果扫描的项目是一个二元运算符，则对栈的顶上两个操作数执行该运算。 4、如果扫描的项目是一个一元运算符，则对栈的最顶上操作数执行该运算。 5、将运算结果重新压入堆栈。 6、重复步骤2-5，堆栈中即为结果值。 问：稀疏矩阵的压缩存储方法有：三元组、十字链表四、树与二叉树问：平衡二叉树是平衡二叉排序树问：平衡二叉树的平衡操作图 1 例 问：完全二叉树的几个性质(1) 完全二叉树中，编号为i的结点，其父节点为[i/2]（向下取整）。 (2) 完全二叉树中，编号为i的结点，有如下四个性质（1&lt;=i&lt;=n，n为结点个数） 判断编号为i的结点是叶子结点，还是分支结点：若2*i&lt;=n，则结点i为分支结点，否则为叶子结点。 分支结点的左右孩子情况，以及最大分支结点编号 若n为奇数，则所有分支结点都有左右孩子。 若n为偶数，则编号为[n/2]（向下取整）的结点，只有左孩子，没有右孩子；其余分支结点左右孩子都有。 最大分支结点编号都是[n/2]（向下取整）。 编号为i的结点如果有左孩子，则左孩子编号为2i；如果有右孩子，则右孩子的编号为2i+1 编号为i的结点的父结点编号为[i/2]（向下取整）（根节点除外） 问：二叉树在线索化后,仍不能有效求解的问题例1：王道数据结构2015版118页27题 二叉树在线索化后，仍不能有效求解的问题是(D) A. 先序线索二叉树中求先序后继 B. 中序线索二叉树中求中序后继 C. 中序线索二叉树中求中序前驱 D. 后序线索二叉树中求后序后继 解释：如图所示，节点E的右指针指向右孩子，而在后序序列中E的后继节点为B，在查找E的后继时，后序线索不能起到任何作用，只能按常规方法来查找。 问：红黑树例1 问：森林与二叉树树转换成二叉树的步骤： 森林转换成二叉树的步骤： (1) 先把森林中的每棵树转换成二叉树 (2) 第一颗二叉树不动，从第二颗二叉树开始，依次把后一颗二叉树的根结点作为前一颗二叉树的根结点的右孩子结点，用线连起来。当所有的二叉树连接起来后得到的二叉树就是由森林转换得到的二叉树。 注意： (1) 将森林F转换为对应的二叉树T，F中叶结点的个数等于T中左孩子指针为空的结点个数。 在二叉树中，节点的左指针指向其孩子，节点的右指针指向其兄弟。在一颗二叉树中，如果某个节点的左指针为NULL，就说明这个节点在原来的森林中没有孩子，是叶子节点；如果某个节点的右指针为NULL，就说明这个节点在原来的森林中没有兄弟。 所以森林中的叶子节点=二叉树中左指针为NULL的个数。 问：将森林F转换为对应的二叉树T，F中叶结点的个数等于T中左孩子指针为空的结点个数例1 问：将森林F转换为对应的二叉树T，若F中有n个非终端结点，则T中右指针域为空的结点数为n+1。例1 问：树和森林的遍历与二叉树遍历的对应关系图 1 五、图问：顶点的度有向图中，所有顶点的入度之和等于所有顶点的出度之和 问：连通图与强连通图，连通分量与强连通分量在无向图中，如果从顶点v到顶点w有路径存在，则称v和w连通的。如果图中任意两个顶点之间都连通，则称该图为连通图，否则，称该图为非连通图。无向图的极大连通子图称为连通分量。 在有向图中，如果从顶点v到顶点w和从顶点w到顶点v之间都有路径存在，则称v和w是强连通的。如果图中任意两个顶点之间都是强连通的，则称该图为强连通图。有向图的极大连通子图称为强连通分量。 问：十字链表十字链表(Orthogonal List)是有向图的另一种链式存储结构。该结构可以看成是将有向图的邻接表和逆邻接表结合起来得到的。例子 问：几种算法的时间复杂度(1) Prim算法 例1 在图采用邻接表存储时,求最小生成树的Prim算法的时间复杂度为：O(n+e) (2) Kruskal算法 (3) Dijkstra算法 (4) Floyd算法 (5) 拓扑排序 例1 若初始序列为gbfcdae，那么至少需要()次两两交换，才能使该序列变为abcdefg。 任给一个自由a--g这7个字母组成的排列，最坏的情况下需要至少()次两两交换，才能使序列变为abcdefg。 答案：5 6 本质是图论里的拓扑排序问题，将每个字符现在的位置与其排序后的位置连一条单向边，最小两两交换次数为：字符总数-连接后形成的环数(包括自环) (1) gbfcdae-&gt;abcdefg g b f c d a e a b c d e f g 其中，b为自环，而a-&gt;f-&gt;c-&gt;d-&gt;e-&gt;g-&gt;a为另一个环，所以最小交换次数=7-2=5次 (2) 任意a--g这7个字母组成的排列-&gt;abcdefg 最坏情况下是所有字符形成一个环，如gabcdef需要至少6次交换才能变为abcdefg 问：AOV网和AOE网如果用有向无环图表示一个工程，其定点表示活动，用有向边表示活动Vi必须先于Vj进行的一种关系，则将这种有向图称为表示活动的网络，简称AOV网。 在带权有向图中，以定点表示事件，有向边表示活动，边上的权值表示完成该活动的开销(如完成活动所需要的时间)，则称这种有向图为用边表示活动的网络，简称为AOE网。 问：关键路径在AOE网中，从源点到汇点的所有路径中，具有最大路径长度的路径称为关键路径。 在AOE网中，可以有不止一条的关键路径。 关键路径的计算步骤 问：可以判断出一个有向图是否有环的算法(1) 深度优先遍历 (2) 拓扑排序 六、查找问：折半查找的条件数据有序、顺序存储 (如果数据存储在链式结构的链表中同样可以采用跳表完成二分法查找) 问：分块查找分块查找的平均查找长度为索引查找和块内查找的平均长度之和，设索引查找和块内查找的平均查找长度分别为Li和Ls，则分块查找的平均查找长度为ASL=Li+Ls。 问：B树与B+树的区别(1) B树是一棵多路搜索树。一棵m阶B树或为空树，或为满足如下特性的m叉树： 树中每个节点之多有m棵子树(即最多有m-1个关键字) 若根节点不是叶节点，则至少有两棵子树 除根节点以外的所有非叶节点至少有[m/2]棵子树(即至少含有[m/2]-1个关键字)。([]为(上取整)) 所有非叶节点的关键字为K[1]，K[2]，…，K[n-1]且K[i]&lt;K[i+1]；指向子树的指针为P[1]，P[2]，…，P[M]，其中P[0]指向关键字小于K[1] 的子树，P[n]指向关键字大于K[n]的子树，其它P[i]指向关键字属于(K[i], K[i+1])的子树 所有的叶节点都出现在同一层上，并且不带信息 (2) B+树 (3) B树与B+树的区别 B树只能进行索引查找，B+树既能顺序查找，也能索引查找 问：哈夫曼树最优二叉树是哈夫曼树，而哈夫曼树不一定是完全二叉树。 例1： 解析没看懂 已知三叉树T中6个叶结点的权分别是2，3，4，5，6，7，T的带权(外部)路径长度最小是：46 问：哈希表(1) 构造哈希表时经常使用的哈希函数 直接定址法：取关键字或关键字的某个线性函数值为散列地址，即H(key)=key或H(key)=a·key+b，其中a和b为常数(这种散列函数叫做自身函数) 数字分析法 平方取中法 折叠法 除留余数法 (2) 冲突处理的方法 开哈希表——-链式地址法/拉链法 闭哈希表——-开放地址法：线性探测法、平方探测法、再散列法、伪随机序列法 问：Hash的冲突处理例1，例2，例3，例4 问：KMP算法(1) 先了解使用KMP算法进行字符串匹配的过程 KMP算法的最大特点在于：当一趟匹配过程中出现字符不匹配时，不需回溯主串指针，而是利用已经得到的”部分匹配”结果将模式串向右”滑动”尽可能远的一段距离后，继续进行比较，从而提高匹配效率。 (2) KMP算法代码 #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; void computeNext(string pattern, vector&lt;int&gt;&amp; next){ int len=pattern.size(); next.push_back(0); int matchLength=0; for(int q=1; q&lt;len; q++){ while(matchLength&gt;0 &amp;&amp; pattern[q]!=pattern[matchLength]){ matchLength=next[matchLength-1]; } if(pattern[q]==pattern[matchLength]){ matchLength++; } next.push_back(matchLength); } } int kmp(string str, string pattern){ vector&lt;int&gt; next; computeNext(pattern, next); int m=str.size(); int n=pattern.size(); for(int i=0, matchLength=0; i&lt;m; i++){ while(matchLength&gt;0 &amp;&amp; str[i]!=pattern[matchLength]){ matchLength=next[matchLength-1]; } if(str[i]==pattern[matchLength]){ matchLength++; } if(matchLength==n) return i-n+1; } return -1; } int main(){ string str=&quot;BBC ABCDAB ABCDABCDABDE&quot;; string pattern=&quot;ABCDABD&quot;; cout&lt;&lt;kmp(str, pattern)&lt;&lt;endl; return 0; } (3) next数组求解，本质上在求模式串每一位的最大相同前后缀的长度 来源 void computeNext(string pattern, vector&lt;int&gt;&amp; next){ int len=pattern.size(); next.push_back(0); //模式串P的第一个字符的最大相同前后缀长度为0 int matchLength=0; //当前已经求得的子串的最大相同前后缀长度 for(int q=1; q&lt;len; q++){ //从第二个字符开始，依次计算每一个字符对应的next值 while(matchLength&gt;0 &amp;&amp; pattern[q]!=pattern[matchLength]){//while循环 matchLength=next[matchLength-1]; } if(pattern[q]==pattern[matchLength]){ //如果相等，那么最大相同前后缀长度加1 matchLength++; } next.push_back(matchLength); } } 设有模式串P(代码中表示为pattern)，第一个字符的最大相同前后缀长度为0，即next[0]=0，现在准备求模式串P其他字符位对应的next数组值。 next数组求解最大的难点在于while循环，这里重点解释while循环所做的工作： (1) 假设当前已求得P[0, …, q-1]的最大相同前后缀的长度为k(代码中表示为matchLength)，即next[q-1]=k。 (2) 现在求next[q]，即P[0, …, q]的最大相同前后缀的长度。此时比较模式串P中字符位P[q]和字符位P[k]，如图1所示。 如果P[q]等于P[k]，那么很简单，P[0, …, q]的最大相同前后缀的长度等于P[0, …, q-1]的最大相同前后缀的长度加1，即next[q]=next[q-1]+1，继续求下一个位置的next值。 但如果P[q]不等于P[k]又该怎么办呢？这时我们可以利用已经得到的next[0, …, k-1]，为什么呢？ 原因在于P[k]已经和P[q]失配了，而P[q-k, …, q-1]又与P[0, …, k-1]相同，那么在P[0]···P[k-1]这么长的子串用不了的情况下，我们能不能找到一个同样以P[0]开头、P[k-1]结尾且尽可能长的子串来和P[0, …, q-1]匹配？这样的子串存在吗？当然是存在的，想一想P[0, …, k-1]子串不是有最大相同前后缀吗？next[k-1]不就是P[0, …, k-1]子串的最大相同前后缀的长度嘛！那么我们取这个子串为P[0, …, k-1]的最大前缀不就可以了嘛，即P[0, …, j-1] (j=next[k-1])，然后看它的下一项P[j]能否和P[q]匹配，如图2所示。 注意：在一些笔试题中，经常会让选择正确的next数组值，不同的方法计算出来的next数组可能不一样 这里是其中一种计算方式： 例1：求模式串ababaaababaa的next数组。 i 0 1 2 3 4 5 6 7 8 9 10 11 s a b a b a a a b a b a a next[i]的值等于s[i]之前的子串中最长相同前后缀的长度。next[0]=-1为定值。 next[1]等于s[1]之前的子串&quot;a&quot;中最长相同前后缀的长度，为0，故next[1]=0； next[2]等于s[2]之前的子串&quot;ab&quot;中最长相同前后缀的长度，为0，故next[2]=0； next[3]等于s[3]之前的子串&quot;aba&quot;中最长相同前后缀的长度，s[0]与s[2]为最长相同前后缀，长度为1，故next[3]=1； next[4]等于s[4]之前的子串&quot;abab&quot;中最长相同前后缀的长度，s[01]与s[23]为最长相同前后缀，长度为2，故next[4]=2； next[5]等于s[5]之前的子串&quot;ababa&quot;中最长相同前后缀的长度，s[012]与s[234]为最长相同前后缀，长度为3，故next[5]=3； next[6]等于s[6]之前的子串&quot;ababaa&quot;中最长相同前后缀的长度，s[0]与s[5]为最长相同前后缀，长度为1，故next[6]=1； 类似的，可以求得next[7]、next[8]、next[9]、next[10]、next[11]分别为1和2、3、4、5。 next数组为-1 0 0 1 2 3 1 1 2 3 4 5 如果将这里的所有值加1可以得到另一种next数组，为0 1 1 2 3 4 2 2 3 4 5 6 例2：求模式串xyxyyxxyx的next数组。 采用例1相同的计算方式，得到next数组如下： x y x y y x x y x -1 0 0 1 2 0 1 1 2 0 1 1 2 3 1 2 2 3 例3：字符串S为”abaabaabacacaabaabcc”，模式串为”abaabc”。采用KMP算法进行匹配，第一次出现”失配”(s[i]≠t[j])时，i=j=5，则下次开始匹配时，i和j的值是多少？ 先求的模式串的next数组如下： a b a a b c -1 0 0 1 1 2 0 1 1 2 2 3 依据KMP算法&quot;当失配时，i不变，j回退到next[j-1]的位置并重新比较&quot;，当失配(s[i]≠t[j])时，i=j=5，由上表不难得出next[j]=next[5]=2(位序从0开始)。从而最后结果应为：i=5(i保持不变)，j=next[5-1]=2。 例4：求模式串ababaabab的nextval数组，这里使用了未加1的next数组 先计算前缀next[i]的值如下： s a b a b a a b a b -1 0 0 1 2 3 1 2 3 接下来计算nextval[i]的值，nextval[i]的求解需要比较s中next[i]所在位置的字符是否与s[i]的字符一致: 如果一致则用s[next[i]]的nextval的值作为nextval[i]，如果不一致，则用next[i]做为nextval[i]。 nextval[0]和next[0]的值一样，为-1，即nextval[0]=-1； nextval[1]，比较s[next[1]]和s[1]，next[1]=0，s[0]=a，而s[1]=b，二者不一致，则nextval[1]=next[1]=0； nextval[2]，比较s[next[2]]和s[2]，next[2]=0，s[0]=a，而s[2]=a，二者一致，则nextval[2]=nextval[s[next[2]]]=nextval[s[0]]=-1 (严谨来看这么表述是有问题的，因为nextval[2]表示nextval数组中 第3个数值，而nextval[s[0]]表示的是s[0]对应的字母&apos;a&apos;所对应的nextval值-1，这里nextval[]的用法并不严谨，只是为了表述方便)。 nextval[3]，比较s[next[3]]和s[3]，next[3]=1，s[1]=b，而s[3]=b，二者一致，则nextval[3]=nextval[s[next[3]]]=nextval[s[1]]=0； nextval[4]，比较s[next[4]]和s[4]，next[4]=2，s[2]=a，而s[4]=a，二者一致，则nextval[4]=nextval[s[next[4]]]=nextval[s[2]]=-1； nextval[5]，比较s[next[5]]和s[5]，next[5]=3，s[3]=b，而s[5]=a，二者不一致，则nextval[5]= next[5]=3； 同样的求nextval[6]、nextval[7]、nextval[8]分别为0，-1，0。 这里是nextval的下标从-1开始，如果从1开始，则其余各位均＋1，nextval为0，1，0，1，0，4，1，0，1 问：动态查找表动态查找表的表结构是在查找过程中动态生成的，对于给定key，若表中存在某关键字与key相等则查找成功返回，否则则插入关键字等于key的记录。常见的动态查找表有：二叉排序树、平衡二叉树、B树、B+树。 静态查找表有：有序表、分块有序表、线性链表。 七、排序问：各种内部排序算法性质图 1 备注：这里的冒泡排序是指优化的冒泡排序。 注意： (1) 若记录的初始状态已经按关键码基本有序，则选用直接插入排序或冒泡排序发为宜 (2) 在排序中关键字比较次数同记录初始排列次序无关的算法有：折半插入排序、选择排序、基数排序、 直接插入排序，在完全有序的情况下，每个元素只需要与它左边的元素比较一次就可以确定它的最终位置 快速排序，初始排序会影响划分次数。假设2n+1个数在一趟排序中被分为两部分，各为n个数，则下一趟排序中需要比较的次数为n-1+n-2=2n-2；假设分成的两部分分别有1个数和2n个数，则下一趟排序中需要比较的次数为2n-1。很明显初始排序会影响比较次数。 归并排序，假设在归并的时候，右路有n个元素，右路有n个元素，则一次归并最大比较次数为2n-1，最少比较次数为n，所以与初始排序有关。 (3) 在排序中关键字移动次数同记录初始排列次序无关的算法有： (4) 关键字初始排列顺序对算法的性能无影响的排序算法有：选择排序、(原始的)冒泡排序 例1，例2 (5) 快速排序在被排序的数据基本无序的时候最易发挥其长处，时间复杂度为O(nlogn)；在已经有序或逆序的情况下效率最差，为O(n^2)。 (6) 快速排序是目前基于比较的内部排序中平均时间复杂度最好的排序方法 (7) 希尔排序，也称为递减增量排序算法，是插入排序的一种高速而稳定的改进版本。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可达到线性排序的效率； 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位； (8) 堆排序建堆时间复杂度为O(n)，每次调整时间复杂度为O(h) (9) (假设根节点序号为1)小根堆中最大的数一定在叶子节点上，堆本身是个完全二叉树，完全二叉树的叶子节点的位置大于[n/2] 基于内部排序的最少比较次数 问：快速排序(1) 对n个记录的线性表进行快速排序为减少算法的递归深度，应该在每次分区后，先处理较短的部分解析 (2) 采用递归方式对顺序表进行快速排序，递归次数与每次划分后得到的分区处理顺序无关解析 问：外部排序外排中使用置换选择排序的目的,是为了增加初始归并段的长度解析 问：桶排序问：从n个数里面找最大的一个数理论最少需要比较：n-1次例1： 这道题其实就是一种二叉树结构，1001个员工为叶节点，而比赛次数则是求非叶节点 问：从n个数里面找最大的两个数理论最少需要比较：n+logn-2次解析 没看懂 问：希望用最快的速度从一个无序数组中挑选出其中前m个最大的元素，可以使用堆排序例1，例3，例4 问：在n个数中选出最大的m个数(3&lt;m&lt;n)，时间复杂度最小为O(n)网上的一个解析，例1，例2 例，这一题蛮好 问：在N个乱序数字中查找第k大的数字(未整理，因为还不是特别清楚)例1，例2 问：求n个数中的最大值和最小值，最少的比较次数例1 八、 其他","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://hepsilion.github.io/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"https://hepsilion.github.io/tags/数据结构/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"12-JDBC","slug":"12-JDBC","date":"2017-05-28T10:27:20.000Z","updated":"2017-05-29T08:31:02.648Z","comments":true,"path":"2017/05/28/12-JDBC/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/12-JDBC/","excerpt":"JDBC","text":"JDBC 问：什么是JDBC？JDBC是一套面向对象的应用程序接口(API)，制定了访问各类关系数据库的统一标准接口，为访问各个数据库厂商的关系数据库提供了标准的实现，它由一组用Java语言编写的类和接口组成。JDBC允许开发者用JAVA写数据库应用程序，而不需要关心底层特定数据库的细节。 问：JDBC访问数据库的步骤//1. 加载JDBC驱动 Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); //2. 连接Oracle数据库 String url=&quot;jdbc:oracle:thin:@localhost:1521:DataBaseName&quot;; String username=&quot;admin&quot;; String password=&quot;root&quot;; Connection con=DriverManager.openConnection(url, username, password); //3. 利用JDBC检索出表中的数据 PreparedStatment ps=Con.preparedStatment(&quot;select * from users;&quot;); ResultSet rs=ps.executeQuery(); While(rs.next){ Rs.getString(1); //或rs.getString(&quot;name&quot;) } //4. 关闭数据库连接 con.close(); 问：Class.forName()方法有什么作用？通过反射机制初始化参数指定的类，并且返回此类对应的Class对象。这个方法可以用来载入并注册跟数据库建立连接的驱动。 问：解释下驱动(Driver)在JDBC中的角色。JDBC驱动提供了特定厂商对JDBC API接口类的实现，驱动必须要提供java.sql包下面这些类的实现：Connection, Statement, PreparedStatement,CallableStatement, ResultSet和Driver。 加载驱动的几种方法： (1) 调用Class.forName()方法：Class.forName(“com.microsoft.sqlserver.jdbc.SQLServerDriver”); (2) 通过添加jdbc.drivers系统属性：DriverManager.registerDriver(new com.mysql.jdbc.Driver()); (3) 通过registerDriver方法注册：System.setProperty(“jdbc.drivers”, “com.mysql.jdbc.Driver”); 问：Statement、PreparedSatement和CallableStatement 问：PreparedStatement比Statement有什么优势？PreparedStatement接口继承自Statement (1) PreparedStatement实例包含预编译的SQL语句，执行速度要快于Statement对象，因此，性能会更好。 (2) PreparedStatements是预编译的，可以避免不良用户直接敲sql语句产生sql注入攻击，安全性更强。 (3) 对于不同的查询参数值，PreparedStatement可以重用。 https://www.nowcoder.com/profile/7404313/test/8004321/25808?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8088719/22471?onlyWrong=0 问：什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？CallableStatement接口继承自PreparedStatement CallableStatement用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。如果有输出参数要注册说明是输出参数。非常鼓励使用存储过程，因为它提供了安全性和模块化。 准备一个CallableStatement的方法是：Connection.prepareCall() 问：数据库连接池是什么意思？像打开关闭数据库连接这种和数据库的交互可能是很费时的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本是非常高的。 可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供服务。在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求。 问：ResultSethttps://www.nowcoder.com/profile/7404313/test/8078128/3223?onlyWrong=0 1、JDBC如何做事务处理？ Con.setAutoCommit(false) Con.commit(); Con.rollback(); Con.setAutoCommit(true) 6、执行存储过程用那一个类，如何操作输出参数?(操作) CallableStatement c=con. prepareCall (&quot;{call getCustomerName(?,?)}&quot;); c.setString(1,&quot;1&quot;); c.registerOutParameter(2,java.sql.Types.VARCHAR); c.execute(); c.getString(2); 10、Jdo是什么? JDO是Java对象持久化的新的规范，为java data object的简称,也是一个用于存取某种数据仓库中的对象的标准化API。JDO提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如JDBC API的使用）。这些繁琐的例行工作已经转移到JDO产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上。另外，JDO很灵活，因为它可以在任何数据底层上运行。JDBC只是面向关系数据库（RDBMS)JDO更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML以及对象数据库（ODBMS）等等，使得应用可移植性更强。(o/rMapping工具 集合处理) 11、在ORACLE大数据量下的分页解决方法。一般用截取ID方法，还有是三层嵌套方法 create or replace package myPack is type c_type is ref cursor; procedure getPage(v_sql varchar2,pageSize number,pageIndex number,c out c_type); end; create or replace package body myPack is procedure getPage(v_sql varchar2,pageSize number,pageIndex number,c out c_type) is pageTotal int:=0; pageFirstRow int:=0; pageLastRow int:=0; rowTotal int:=0; begin execute immediate &apos;select count(*) from (&apos;||v_sql||&apos;)&apos; into rowTotal; pageTotal:=ceil(rowTotal/pageSize); if(pageIndex&lt;1) then raise_application_error(-20001,&apos;页数不能小于1&apos;); end if; if(pageIndex&gt;pageTotal) then raise_application_error(-20001,&apos;页数太大，不能读取&apos;); end if; pageFirstRow:=(pageIndex-1)*pageIndex+1; pageLastRow:=pageFirstRow+pageSize; open c for &apos; select * from &apos;||v_sql||&apos; where rownum&lt;&apos;|| pageLastRow||&apos;minus select * from &apos;||v_sql ||&apos; where rownum&lt;&apos;||pageFirstRow; end; end;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"11-反射","slug":"11-反射","date":"2017-05-28T10:26:12.000Z","updated":"2017-05-29T08:31:01.079Z","comments":true,"path":"2017/05/28/11-反射/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/11-反射/","excerpt":"反射","text":"反射 19、什么是类的返射机制? 通过类(Class对象)，可以得出当前类的fields、method、construtor、interface、superClass、modified等，同是可以通过类实例化一个实例、设置属性、唤醒方法。Spring中一切都是返射、struts、hibernate都是通过类的返射进行开发的。 https://www.nowcoder.com/profile/7404313/test/8049404/15427?onlyWrong=0 20、类的返射机制中的包及核心类?  java.lang.Class java.lang.refrection.Method java.lang.refrection.Field java.lang.refrection.Constructor java.lang.refrection.Modifier java.lang.refrection.Interface 21、得到Class的三个过程是什么? 对象.getClass() 类.class或Integer.type(int) Integer.class(java.lang.Integer) Class.forName(); 22、如何唤起类中的一个方法？ 产生一个Class数组，说明方法的参数通过Class对象及方法参数得到Method通过method.invoke(实例,参数值数组)唤醒方法 85、描述一下JVM加载class文件的原理机制?JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader 是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。 ClassLoaderhttps://www.nowcoder.com/profile/7404313/test/7993658/14508?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8100292/26130?onlyWrong=0","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"10-网络编程","slug":"10-网络编程","date":"2017-05-28T10:25:25.000Z","updated":"2017-05-29T08:30:59.341Z","comments":true,"path":"2017/05/28/10-网络编程/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/10-网络编程/","excerpt":"网络编程","text":"网络编程 问：Java Socket的几个方法getInetAddress() Returns the address to which the socket is connected. getLocalAddress() Gets the local address to which the socket is bound. getReuseAddress() Tests if SO_RESUSADDR is enabled. getLocalPort() Returns the remote port number to which this socket is connected. 问：序列化序列化:将一个对象保存到一个文件，可以通过流的方式在网络上传输；也可以将文件的内容读取，转化为一个对象。 处理对象流的机制：所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。 序列化是为了解决在对对象流进行读写操作时所引发的问题。 序列化的实现：将需要被序列化的类实现java.io.Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要写入的话则用输入流。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"09-多线程","slug":"09-多线程","date":"2017-05-28T10:23:52.000Z","updated":"2017-05-29T08:30:57.789Z","comments":true,"path":"2017/05/28/09-多线程/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/09-多线程/","excerpt":"多线程","text":"多线程 推荐阅读：嘟嘟独立博客 推荐阅读：Java多线程锁机制 问：进程和线程的区别是什么？进程是资源分配的基本单位，而线程是CPU调度的基本单位。 一个进程可以有多个线程，多个线程共享进程的资源，线程又叫做轻量级进程。 问：线程的几种状态 (1) 新建(new)：新创建了一个线程对象。 (2) 可运行(runnable)：线程对象创建后，其他线程(比如main线程)调用了该对象的start()方法，该状态的线程便位于可运行线程池中，等待被线程调度选中，获取cpu的使用权。 (3) 运行(running)：可运行状态(runnable)的线程获得了cpu时间片(timeslice)，执行程序代码。 (4) 阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种： 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。 其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。 当sleep()状态超时、 join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。 (5) 死亡(dead)：线程run()、 main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。 例1：此题有疑问，感觉下面这句话是不对的。 Java线程调度算法是平台独立的。 问：创建线程有几种不同的方式？你喜欢哪一种？为什么？(1) 继承Thread类，重写run()方法 public class ThreadTest1 { public static void main(String[] args){ MyThread thread=new MyThread(&quot;T1&quot;); thread.start(); System.out.println(&quot;The main thread is running.&quot;); } } class MyThread extends Thread{ private String name; public MyThread(String name) { this.name = name; } @Override public void run() { System.out.println(&quot;The thread &quot;+this.name+&quot; is running.&quot;); } } (2) 实现Runnable接口，重写run()方法 public class ThreadTest2 { public static void main(String[] args){ Thread thread=new Thread(new MyThread2(&quot;T2&quot;)); thread.start(); System.out.println(&quot;The main thread is running.&quot;); } } class MyThread2 implements Runnable{ private String name; public MyThread2(String name) { this.name = name; } @Override public void run() { System.out.println(&quot;The thread &quot;+this.name+&quot; is running.&quot;); } } (3) 使用ExecutorService、Callable、Future实现有返回结果的多线程 例1：例2：注意评论 实现Runnable接口这种方式更受欢迎。在应用设计中线程类已经继承了别的类的情况下，需要多继承，只能实现接口（而Java不支持多继承，却支持实现多个接口），这样就不再需要继承Thread类，避免单继承的局限。同时，线程池也是非常高效的，很容易实现和使用。 问：start()和run()无论是通过继承Thread类还是实现Runnable接口来创建线程，都必须调用start()方法启动线程。线程启动后，线程进入就绪状态，当CPU分配时间给它时，它才开始运行。并不是一调用start()方法线程就立即运行。 问：Java四种线程池的使用应用程序可以使用Executor/Callable/Future框架来创建线程池。 (1) ExecutorService java.util.concurrent.Executors.newSingleThreadExecutor() Creates an Executor that uses a single worker thread operating off an unbounded queue. (Note however that if this single thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks.) Tasks are guaranteed to execute sequentially, and no more than one task will be active at any given time. Unlike the otherwise equivalent newFixedThreadPool(1) the returned executor is guaranteed not to be reconfigurable to use additional threads. Returns:the newly created single-threaded Executor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 示例代码： import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class NewSingleThreadExecutor { public static void main(String[] args) { ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 10; i++) { final int index = i; singleThreadExecutor.execute(new Runnable() { public void run() { try { System.out.println(index); Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } } }); } } } // 顺序执行各个任务，依次输出结果 (2) ExecutorService java.util.concurrent.Executors.newFixedThreadPool(int nThreads) 创建一个含有固定数量线程的线程池，可控制最大并发任务数，超出的任务会在队列中等待。 `Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue. At any point, at most nThreads threads will be active processing tasks. If additional tasks are submitted when all threads are active, they will wait in the queue until a thread is available. If any thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks. The threads in the pool will exist until it is explicitly shutdown. Parameters:nThreads the number of threads in the pool Returns:the newly created thread pool import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class NewFixedThreadPool { public static void main(String[] args) { ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3); for (int i = 0; i &lt; 10; i++) { final int index = i; fixedThreadPool.execute(new Runnable() { public void run() { try { System.out.println(index); Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } } }); } } } // 因为线程池大小为3，每个线程输出index后sleep 2秒，所以每隔两秒打印3个数字 (3) ExecutorService java.util.concurrent.Executors.newCachedThreadPool() Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available. These pools will typically improve the performance of programs that execute many short-lived asynchronous tasks. Calls to execute will reuse previously constructed threads if available. If no existing thread is available, a new thread will be created and added to the pool. Threads that have not been used for sixty seconds are terminated and removed from the cache. Thus, a pool that remains idle for long enough will not consume any resources. Note that pools with similar properties but different details (for example, timeout parameters) may be created using ThreadPoolExecutor constructors. Returns:the newly created thread pool import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class ThreadPoolExecutorTest { public static void main(String[] args) { ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) { final int index = i; try { Thread.sleep(index * 1000); } catch (InterruptedException e) { e.printStackTrace(); } cachedThreadPool.execute(new Runnable() { public void run() { System.out.println(index); } }); } } } (4) ScheduledExecutorService java.util.concurrent.Executors.newScheduledThreadPool(int corePoolSize) 创建一个含有固定数量线程的线程池，支持延时任务或周期性任务的执行。 Creates a thread pool that can schedule commands to run after a given delay, or to execute periodically. Parameters:corePoolSize the number of threads to keep in the pool, even if they are idleReturns:a newly created scheduled thread poolThrows:IllegalArgumentException - if corePoolSize &lt; 0 执行延时任务的示例代码： import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class NewScheduledThreadPool1 { public static void main(String[] args) { ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); scheduledThreadPool.schedule(new Runnable() { public void run() { System.out.println(&quot;delay 3 seconds&quot;); } }, 3, TimeUnit.SECONDS); } } // 表示延迟3秒执行任务 执行定期性任务的示例代码： import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class NewScheduledThreadPool2 { public static void main(String[] args) { ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); scheduledThreadPool.scheduleAtFixedRate(new Runnable() { public void run() { System.out.println(&quot;delay 1 seconds, and excute every 3 seconds&quot;); } }, 1, 3, TimeUnit.SECONDS); } } // 表示延迟1秒后，每3秒执行一次任务 问：同步和异步同步：上一段代码没完成，下一段必须等到上一段代码完成后才可以执行。 异步：上一段代码没完成，下一段不必等到上一段代码完成就可以执行。 问：synchronized关键字推荐阅读：嘟嘟独立博客 在Java中，每一个对象都拥有一个锁标记，也称为监视器。一旦一个方法或一个代码块被synchronized修饰，那么这个部分就放入了监视器的监视区域，确保在同一时刻最多只有一个线程执行该部分代码，线程在获取锁之前不允许执行该部分的代码。 例1： java实现进程之间的同步执行采用的机制是：监视器 当两个并发线程访问同一个对象的synchronized方法或代码块时，两个线程间是互斥的，在同一时刻只能有一个线程得到执行，另一个线程被阻塞，因为在执行synchronized方法或代码块的线程会锁定当前对象，只有在当前线程执行完这些代码并释放该对象的锁时，下一个线程才能锁定并执行该对象的synchronized方法或代码块。 (1) 当一个线程访问对象的一个synchronized方法或代码块时，另一个线程仍然可以访问该对象的非synchronized方法或代码块。(两个线程使用的是同一个对象) (2) 当一个线程访问对象的一个synchronized方法或代码块时，其他线程对该对象的所有其它synchronized方法或代码块的访问将被阻塞(同上，两个线程使用的是同一个对象)。 例2： 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法? 答：其它线程可以进入该对象的非synchronized方法，不可以进入该对象的synchronized方法。 例3：看评论 public class HelloSogou{ public static synchronized void main(String[] a){ Thread t=new Thread(){ public void run(){ Sogou(); } }; t.run(); System.out.print(&quot;Hello&quot;); } static synchronized void Sogou(){ System.out.print(&quot;Sogou&quot;); } } 上面JAVA程序的输出是：SogouHello (3) 如果父类中的某个方法使用了synchronized关键字，而子类中覆盖了这个方法，默认情况下子类中的这个方法并不是同步的，必须显示的在子类的这个方法中加上synchronized关键字之后该方法才同步。当然，也可以在子类中调用父类中相应的方法，这样虽然子类中的方法并不是同步的，但子类调用了父类中的同步方法，也就相当子类方法也同步了。 例4：判断正误 构造方法不需要同步化。(正确) 一个子类不可以覆盖掉父类的同步方法。(错误) 问：同步方法和同步代码块的区别是什么？Java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时(增删改查)，将会导致数据的不准确，相互之间产生冲突。因此加入了同步锁，以避免在该线程没有结束前，其他线程操作该资源变量，从而保证了变量的唯一性，准确性。 Java中每个对象都有一把锁，线程可以通过synchronized关键字来获取对象上的锁。 (1) 同步方法(粗粒度锁)：由synchronized关键字修饰的方法 修饰一般方法:public synchronized void method(){…}，获取的是当前被调用对象的锁修饰静态方法:public static synchronized void method(){…}，获取当前类的字节码对象上的锁 举例：如果一个线程执行一个对象的非static的synchronized方法，另外一个线程执行这个对象所属类的static的synchronized方法，此时不会发生互斥现象，因为访问static的synchronized方法占用的是类的字节码对象锁，而访问非static的synchronized方法占用的是对象锁，所以不存在互斥现象。 public class SychronizedTest { public static void main(String[] args){ SynObj obj=new SynObj(); Thread01 thread01=new Thread01(&quot;Thread01&quot;, obj); Thread01 thread02=new Thread01(&quot;Thread02&quot;, obj); Thread02 thread03=new Thread02(&quot;Thread03&quot;); Thread02 thread04=new Thread02(&quot;Thread04&quot;); thread01.start(); thread02.start(); thread03.start(); thread04.start(); } } class Thread01 extends Thread{ private String threadName; private SynObj obj; public Thread01(String threadName, SynObj obj) { this.threadName=threadName; this.obj = obj; } @Override public void run() { this.obj.run1(this.threadName); } } class Thread02 extends Thread{ private String threadName; public Thread02(String threadName) { this.threadName=threadName; } @Override public void run() { SynObj.run2(this.threadName); } } class SynObj{ // 同步方法 public synchronized void run1(String threadName){ for(int i=0; i&lt;3; i++){ try { Thread.sleep(1000); System.out.println(threadName+&quot; run1 i=&quot;+i); } catch (InterruptedException e) { e.printStackTrace(); } } } // 同步static方法 public static synchronized void run2(String threadName){ for(int i=0; i&lt;3; i++){ try { Thread.sleep(1000); System.out.println(threadName+&quot; run2 i=&quot;+i); } catch (InterruptedException e) { e.printStackTrace(); } } } } Thread01和Thread02之间存在互斥关系，Thread03和Thread03之间存在互斥关系，但是Thread01/Thread02和Thread03/Thread04之间不存在互斥关系。 一种可能的输出： Thread01 run1 i=0 Thread03 run2 i=0 Thread03 run2 i=1 Thread01 run1 i=1 Thread03 run2 i=2 Thread01 run1 i=2 Thread02 run1 i=0 Thread04 run2 i=0 Thread04 run2 i=1 Thread02 run1 i=1 Thread02 run1 i=2 Thread04 run2 i=2 (2) 同步代码块(细粒度锁)：: 由synchronized关键字修饰的语句块，同步代码块可以选择以什么语句块来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法 synchronized(obj) {…}，同步代码块可以指定获取某个对象上的锁。 public class SychronizedTest { public static void main(String[] args){ SynObj synObj1=new SynObj(); SynObj synObj2=new SynObj(); Obj obj1=new Obj(); Obj obj2=new Obj(); Thread01 thread01=new Thread01(&quot;Thread01&quot;, synObj1); Thread01 thread02=new Thread01(&quot;Thread02&quot;, synObj1); Thread01 thread03=new Thread01(&quot;Thread03&quot;, synObj2); Thread02 thread04=new Thread02(&quot;Thread04&quot;, synObj1, obj1); Thread02 thread05=new Thread02(&quot;Thread05&quot;, synObj1, obj1); Thread02 thread06=new Thread02(&quot;Thread06&quot;, synObj2, obj2); thread01.start(); thread02.start(); thread03.start(); thread04.start(); thread05.start(); thread06.start(); } } class Thread01 extends Thread{ private String threadName; private SynObj obj; public Thread01(String threadName, SynObj obj) { this.threadName=threadName; this.obj = obj; } @Override public void run() { this.obj.run1(this.threadName); } } class Thread02 extends Thread{ private String threadName; private SynObj synObj; private Obj obj; public Thread02(String threadName, SynObj synObj, Obj obj) { this.threadName=threadName; this.synObj=synObj; this.obj=obj; } @Override public void run() { this.synObj.run2(this.threadName, this.obj); } } class SynObj{ public void run1(String threadName){ // 同步代码块，锁住的是对象本身 synchronized(this){ for(int i=0; i&lt;3; i++){ try { Thread.sleep(1000); System.out.println(threadName+&quot; run1 i=&quot;+i); } catch (InterruptedException e) { e.printStackTrace(); } } } } public void run2(String threadName, Obj obj){ // 同步代码块，锁住的是对象obj synchronized(obj){ for(int i=0; i&lt;3; i++){ try { Thread.sleep(1000); System.out.println(threadName+&quot; run1 i=&quot;+i); } catch (InterruptedException e) { e.printStackTrace(); } } } } } class Obj{} Thread01和Thread02之间存在互斥关系，但是Thread01/Thread02和Thread03之间不存在互斥关系。 注释掉thread04，thread05和thread06的启动代码 //thread04.start(); //thread05.start(); //thread06.start(); 一种可能的输出： Thread01 run1 i=0 Thread03 run1 i=0 Thread01 run1 i=1 Thread03 run1 i=1 Thread01 run1 i=2 Thread03 run1 i=2 Thread02 run1 i=0 Thread02 run1 i=1 Thread02 run1 i=2 Thread04和Thread05之间存在互斥关系，但是Thread04/Thread05和Thread06之间不存在互斥关系。 注释掉thread01，thread02和thread03的启动代码 //thread01.start(); //thread02.start(); //thread03.start(); 一种可能的输出： Thread04 run1 i=0 Thread06 run1 i=0 Thread06 run1 i=1 Thread04 run1 i=1 Thread04 run1 i=2 Thread06 run1 i=2 Thread05 run1 i=0 Thread05 run1 i=1 Thread05 run1 i=2 将SynObj的run2方法的被锁对象换成obj.getClass()之后，此时Thread04、Thread05和Thread06之间存在互斥关系。因此Synchronized后面括号括起来的部分为synchronized(className.class)，作用的对象是这个类的所有对象 public void run2(String threadName, Obj obj){ // 同步代码块，锁住的是对象obj synchronized(obj.getClass()){ for(int i=0; i&lt;3; i++){ try { Thread.sleep(1000); System.out.println(threadName+&quot; run1 i=&quot;+i); } catch (InterruptedException e) { e.printStackTrace(); } } } } 一种可能的输出为： Thread04 run1 i=0 Thread04 run1 i=1 Thread04 run1 i=2 Thread06 run1 i=0 Thread06 run1 i=1 Thread06 run1 i=2 Thread05 run1 i=0 Thread05 run1 i=1 Thread05 run1 i=2 Java支持并发编程的同步机制例1： JDK提供的用于并发编程的同步器有：Semaphore、CyclicBarrier、CountDownLatch 例2： CyclicBarrier让一组线程等待其他线程；CountDownLatch让一组线程等待某个事件发生 Callable类的call()方法可以返回值和抛出异常 线程调用start()方法后进行就绪状态，等待获取CPU的使用权 例3： CopyOnWriteArrayList适合于读操作远远大于写操作的场景里，比如缓存。 ReadWriteLock 当写操作时，其他线程无法读取或写入数据，而当读操作时，其它线程无法写入数据，但却可以读取数据。适用于读取远远大于写入的操作。 ConcurrentHashMap是一个线程安全的HashTable，它的主要功能是提供了一组和HashTable功能相同但是线程安全的方法。 ConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，不用对整个ConcurrentHashMap加锁。 问：wait、notify、notifyAll wait() (1) 该方法用来让当前线程进入休眠状态，直到被唤醒或被中断为止。 (2) 在调用wait()之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait()方法。如果调用wait()时，线程没有持有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch结构。 (3) 进入wait()方法后，当前线程释放锁。在从 wait()返回前，线程与其他线程竞争重新获得锁。 notify() (1) 该方法也要在同步方法或同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁，如果调用notify()时线程没有持有适当的锁，也会抛出IllegalMonitorStateException。 (2) 该方法用来唤醒那些可能等待该对象的对象锁的其他线程。如果有多个线程等待，则线程调度器任意挑选出其中一个wait()状态的线程来发出通知，并使它等待获取该对象的对象锁（notify后，发出通知的当前线程不会马上释放该对象锁，wait所在的线程并不能马上获取该对象锁，要等到程序退出synchronized代码块后，当前线程才会释放锁，wait所在的线程也才可以获取该对象锁），但不惊动其他同样在等待被该对象notify的线程们。 (3) 当第一个获得了该对象锁的wait线程运行完毕以后，它会释放掉该对象锁，此时如果该对象没有再次使用notify 语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，会继续阻塞在wait状态，直到这个对象发出一个notify或notifyAll。这里需要注意：它们等待的是被notify或notifyAll，而不是锁。这与下面的 notifyAll()方法执行后的情况不同。 notifyAll() 该方法与 notify ()方法的工作方式相同，重要的一点差异是：notifyAll 使所有原来在该对象上 wait 的线程统统退出 wait 的状态（即全部被唤醒，不再等待notify或notifyAll，但由于此时还没有获取到该对象锁，因此还不能继续往下执行），开始等待获取该对象上的锁，一旦该对象锁被释放（notifyAll线程退出调用了notifyAll的synchronized代码块的时候），他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出synchronized代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。 总结：如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。 案例：当前线程调用对象的notify后，当前线程不会马上释放该对象锁，wait所在的线程并不能马上获取该对象锁，要等到程序退出synchronized代码块后，当前线程才会释放锁，wait所在的线程也才可以获取该对象锁。 public static void main(String[]args)throws Exception { final Object obj = new Object(); Thread t1 = new Thread() { public void run() { synchronized (obj) { try { obj.wait(); System.out.println(&quot;Thread 1 wake up.&quot;); } catch (InterruptedException e) { } } } }; t1.start(); Thread.sleep(1000);//We assume thread 1 must start up within 1 sec. Thread t2 = new Thread() { public void run() { synchronized (obj) { obj.notifyAll(); System.out.println(&quot;Thread 2 sent notify.&quot;); } } }; t2.start(); } output: Thread 2 sent notify. Thread 1 wake up 例1：找出代码中错误的地方。 void waitForSignal(){ Object obj = new Object(); synchronized(Thread.currentThread()){ obj.wait(); obj.notify(); } } 第一个错误是wait()方法要以try/catch包覆，或是掷出InterruptedException才行 第二个错误是wait或者notify方法被调用的对象必须与synchronized中的对象一致，否则会有IllegalMonitorStateException 例2： 可用来实现线程间通知和唤醒的方式： Object.wait/notify/notifyAll Condition.await/signal/signalAll 问：sleep()方法和wait()方法的区别sleep()：该方法让线程休眠指定的时间，当这个时间达到之后，线程会再次醒来。 wait()：该方法用来让当前线程进入休眠状态，直到被唤醒或被中断为止。 (1) sleep()是Thread类的方法，wait()是Object类的方法 (2) wait()，notify()和notifyAll()只能在同步方法或同步代码块中使用，而sleep()可以在任何地方使用 (3) 调用sleep()方法后，线程进入睡眠状态，但不会释放对象锁，休眠时间结束后会自动进入就绪状态；调用wait()方法后，线程会释放对象锁，进入此对象的等待池(wait pool)中，直到其他线程调用对象的notify()方法(或notifyAll()方法)时才能唤醒等待池中的线程进入等锁池(lock pool)，如果线程重新获得对象的锁就可以进入就绪状态。 例1：sleep()和wait()的对比 问：sleep()方法和yield()方法的区别调用线程yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制交出CPU的具体时间，另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。 注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。 sleep()方法和yield()方法的区别: (1) sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会； (2) 线程执行sleep()方法后转入阻塞(blocked)状态，而执行yield()方法后转入就绪(ready)状态； (3) sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常； (4) sleep()方法比yield()方法(跟操作系统CPU调度相关)具有更好的可移植性。 问：join()方法方法join()的作用是让调用join()方法的线程等待被调用线程结束，再继续往下执行。 问：volatile关键字推荐阅读：嘟嘟独立博客 volatile是java中的一个关键字，可以用来修饰被不同线程访问和修改的变量。 出于运行速率的考虑，Java编译器会把经常经常访问的变量放到缓存（严格讲应该是工作内存）中，读取变量则从缓存中读。但是在多线程编程中,内存中的值和缓存中的值可能会出现不一致。volatile用于限定变量只能从内存中读取，保证对所有线程而言，值都是一致的。但是volatile不能保证原子性，也就不能保证线程安全。 一旦一个共享变量(类的成员变量、类的静态成员变量)被volatile修饰之后，那么就具备了两层语义：1）可见性：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。2）禁止进行指令重排序：volatile只提供了保证访问该变量时，每次都是从内存中读取最新值，并不会使用寄存器缓存该值，每次都会从内存中读取。 例1，例2 问：ThreadLocalThreadLocal类为每一个线程都维护了自己独有的变量拷贝。在Thread中有一个成员变量ThreadLocals，该变量的类型是ThreadLocalMap,也就是一个Map，它的键是threadLocal，值为就是变量的副本。因此ThreadLocal不是使用在多线程之间共享数据，而是让变量在每个线程中都有独立拷贝，使得不会出现一个线程读取变量时，该变量而被另一个线程修改的现象。 由于每个线程在访问该变量时，读取和修改的，都是自己独有的那一份变量拷贝，不会被其他线程访问，变量被彻底封闭在每个访问的线程中 例1，例2：这题A答案似乎是错的 问：什么是死锁(deadlock)？两个线程或两个以上线程因争夺资源而都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是若无外力作用，这些线程都陷入了无限的等待中。 问：如何确保N个线程可以访问N个资源同时又不导致死锁？使用多线程的时候，一种非常简单的避免死锁的方式就是：指定访问资源的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"08-流","slug":"08-流","date":"2017-05-28T10:22:25.000Z","updated":"2017-05-29T08:30:51.992Z","comments":true,"path":"2017/05/28/08-流/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/08-流/","excerpt":"流","text":"流 问：Java中有几种类型的流？Java中有字节流和字符流。字节流继承于InputStream/OutputStream，字符流继承于Reader/Writer。 在java.io包中还有许多其他的流，低层流与调层流，高层流主要是为了提高性能和使用方便。 图 1 问：输入输出流的理解在Java使用流的机制进行数据的传送，从文件到内存是输入流，从内存到文件是输出流。 流可以分为节点流和处理流，节点流可以从一个特定的数据源(如文件、内存等)读写数据；而处理流则是连接在已存在的节点流或处理流之上，通过对数据的处理为程序提供更强大的读写功能。 图 1 图 2 常用的节点流 图 1 常用的处理流 图 2 节点流向处理流转换的实例： FileInputStream(System.in) -&gt; InputSteamReader -&gt; BufferReader OutputSteam(System.out) -&gt; PrintStream FileReader -&gt; BufferedReader FileWriter -&gt; PrintWriter或bufferWriter","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"07-容器","slug":"07-容器","date":"2017-05-28T10:20:30.000Z","updated":"2017-05-29T08:31:16.462Z","comments":true,"path":"2017/05/28/07-容器/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/07-容器/","excerpt":"容器","text":"容器 问：Java的集合类框架Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和操作(增、删、改、查)。有的集合类允许重复的键，有些不允许。 Java集合类有两大接口：Collection和Map，一个是元素集合，另一个是键值对集合且键不能重复。 图 1 图 2 List和Set接口继承了Collection接口。List是有序元素集合(即每个元素都可以按index访问)，元素可以重复；Set是无序元素集合(即每个元素都不可以按index访问)，元素不可以重复。ArrayList和LinkedList实现了List接口，HashSet和TreeSet实现了Set接口，这几个都比较常用； HashMap和HashTable实现了Map接口。HashMap不是线程安全的，HashTable是线程安全的，但是HashMap性能更好； ArrayList和Vector都以数组的方式存储，增、删慢，查、改快；ArrayList:线程不安全，速度快；Vector:线程安全，速度慢；LikedList: 以单链表的方式存储，操作慢 注意： Arrays.asList()将一个数组转化为一个List对象，这个方法会返回一个ArrayList类型的对象，这个ArrayList类并非java.util.ArrayList类，而是Arrays类的静态内部类！对这个对象进行添加删除更新操作，会报UnsupportedOperationException异常。 ConcurrentHashMap使用segment来分段和管理锁，而不是用synchronized 问：java语言中的几种数组复制方法效率比较System.arraycopy &gt; clone &gt; Arrays.copyOf &gt; for循环 问：Java集合框架中线程安全的类Vector、Stack(它继承了Vector)、Hashtable、Properties、Enumeration、(非集合类的StringBuffer) 问：ArrayList和LinkedList有什么区别？ArrayList和LinkedList都实现了List接口，他们有以下的不同点： (1) ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以链表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。 (2) 相对于ArrayList，LinkedList的插入、添加、删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。 (3) LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。 问：数组(Array)和列表(ArrayList)的区别？什么时候应该使用Array而不是ArrayList？(1) Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。(但是需要注意的是：Array数组中存放的一定是同种类型的元素；ArrayList就不一定了，因为ArrayList可以存储Object。) (2) Array大小是固定的，ArrayList的大小是动态变化的。 (3) ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。 对于基本类型数据，ArrayList使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。 问：Vector和ArrayList的主要区别(1) Vector是同步的，而ArrayList不是同步的。即Vector是线程安全的，而ArrayList是线程不安全的。 (2) 在元素增加，容量需要增长时，Vector容量默认增长为原来一倍，而ArrayList增长原来的50%，这样,ArrayList就有利于节约内存空间。 (3) 如果涉及到堆栈、队列等操作，应该考虑用Vector；如果需要快速随机访问元素，应该使用ArrayList。 问：ArrayList容量ArrayList的构造函数总共有三个 ArrayList()构造一个初始容量为 10 的空列表，动态增长时，容量增长到当前容量的1.5倍 ArrayList(Collection&lt;? extends E&gt; c)构造一个包含指定collection的元素的列表，这些元素是按照该collection的迭代器返回它们的顺序排列的。 ArrayList(int initialCapacity)构造一个具有指定初始容量的空列表。 问：什么是Java优先级队列(Priority Queue)？PriorityQueue是一个基于堆排序的无界队列，此队列按照在构造时所指定的顺序对元素排序，既可以根据元素的自然顺序来指定排序，也可以给它提供一个负责给元素排序的比较器来指定，这取决于使用哪种构造方法。 PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。 最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。 问：什么是迭代器(Iterator)？Iterator接口提供了很多对集合中元素进行迭代的方法，每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的remove(Object Obj)删除，可以通过迭代器的remove()方法删除。 问：Enumeration接口和Iterator接口的区别有哪些？(1) Enumeration速度是Iterator的2倍，同时占用更少的内存。 (2) 但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。 (3) 同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。 例1：list是一个ArrayList的对象，为了能够在Iterator遍历的过程中正确并安全的删除一个list中保存的对象，//todo delete处可以可以填写什么代码？ Iterator it = list.iterator(); int index = 0; while (it.hasNext()){ Object obj = it.next(); if (needDelete(obj)){//needDelete返回boolean，决定是否要删除 //todo delete } index ++; } 正确答案：it.remove(); 问：Iterator和ListIterator的区别是什么？(1) Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 (2) Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 (3) ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。 问：快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个ConcurrentModification异常。 安全失败：你在迭代的时候会对底层集合做一个拷贝，所以有另一个线程在修改上层集合的时候，访问是不会受影响的，不会抛出ConcurrentModification异常。 Iterator的安全失败是基于对底层集合做拷贝，因此，它不受原集合上修改的影响。 java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。 快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。 问：HashMap和Hashtable有什么区别？HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点： (1) HashMap允许键和值是null（但是最多只能有一个键为null，可以有一个或多个键所对应的值都为null。当get()方法返回null值时，既可以表示HashMap中没有该键，又可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断 HashMap中是否存在某个键，而应该用containsKey()方法来判断）；而Hashtable不允许键或者值是null。 (2) Hashtable是同步的，而HashMap不是，即HashMap是非线程安全的，HashTable是线程安全的。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。因为线程安全的问题，HashMap效率比HashTable的要高。 (3) HashMap提供了可供应用于迭代键的Iterator，因此，HashMap是快速失败的。Hashtable也使用了Iterator，另一方面，由于历史原因，Hashtable还提供了对键的Enumeration，是安全失败的。 (4) 哈希值的使用不同，HashTable直接使用对象的hashCode，而HashMap重新计算hash值。 (5) Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式不同。HashTable中hash数组默认大小是11，增加的方式是old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数 例1，例2，看两道题的评论 一般现在不建议用HashTable (1) HashTable是遗留类，内部实现很多没优化和冗余。 (2) 即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。 问：Java中的HashMap的工作原理是什么？Java中的HashMap是以键值对(key-value)的形式存储元素的。 HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。 HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。 HashMap中解决哈希冲突的方法是链地址法。HashMap的底层结构是一个数组，数组中的每一项是一条链表。 例1 问：HashSetHashSet子类依靠hashCode()和equal()方法来区分重复元素 HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值前，会去判断当前Map中是否含有该key对象，内部是先通过key的hashCode，确定有相同的hashCode之后，再通过equals方法判断是否相同。 例1 问：HashSet和TreeSet有什么区别？HashSet的底层是由哈希表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。 TreeSet的底层是由红黑树来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。 问：Set中的元素不可重复Set中的元素是不允许重复的。因此Set再插入或删除元素时，需要对两个元素进行比较。比较时，Set会先调用hashCode方法，判断两个元素是否有相同的hashCode，如果不相同，证明不相等；如果hashcode相同，再调用equals方法，如果equals方法判断返回true，则两个元素是相同的，否则两个元素不相同。 判断Set中是否包含某一个元素是通过contains来判断的。 问：hashCode()和equals()方法的重要性体现在什么地方？Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。 问：Comparable和Comparator接口是干什么的？列出它们的区别。Java提供了只包含一个compareTo()方法的Comparable接口。 这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。 Java提供了包含compare()和equals()两个方法的Comparator接口。 compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。 equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。 (1) Comparable和Comparator都是用来实现集合中元素的比较、排序的，只是Comparable是在集合内部定义方法实现排序，Comparator是在集合外部定义方法实现排序，所以，如果想要实现对集合中元素的排序，就需要在集合外定义实现Comparator接口的方法或在集合内实现Comparable接口的方法compareTo()。Comparator位于包java.util下，而Comparable位于包java.lang下。 (2) Comparable是一个对象本身就已经支持自比较所需要实现的接口（如 String、Integer自己就可以完成比较大小操作，已经实现了Comparable接口），自定义的类要在加入list容器中后能够排序，可以实现Comparable接口，在用Collections类的sort方法排序时，如果不指定Comparator，那么就以自然顺序排序，这里的自然顺序就是实现Comparable接口设定的排序方式。 (3) Comparator是一个专用的比较器，当这个对象不支持自比较或者自比较函数不能满足你的要求时，你可以写一个比较器来完成两个对象之间大小的比较。 问：Collection和CollectionsCollection是java.util下的接口，它是各种集合结构的父接口，其下有set及list Collections是java.util下的类，它包含有各种有关集合操作的算法(静态方法) 问：Java集合类框架的最佳实践有哪些？根据应用的需要正确选择要使用的集合的类型对性能非常重要 (1) 假如元素的大小是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。 (2) 有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。 (3) 为了类型安全、可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。 (4) 使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。 (5) 编程的时候接口优先于实现。 (6) 底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。 问：装箱与拆箱自动装箱是Java编译器在基本数据类型和对应的包装类型之间做的一个转化，例如把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。 问：装箱与拆箱中的==和equals()下面的规则基本意思是对的，但语言尚不严格正确 (1) 基本数据类型变量和基本数据类型包装类对象进行”==”运算符的比较，基本数据类型封装类对象将会自动拆箱变为基本数据类型后再进行比较。例如Integer(0)和0比较时，Integer(0)会自动拆箱为int类型再进行比较。 (2) 两个Integer类型变量进行”==”比较，如果这两个对象的值在-128至127且值相等，那么返回true，否则返回false，这跟Integer.valueOf()方法的缓冲对象有关。 (3) (4) 两个基本数据类型封装类变量进行equals()比较，equals()会首先比较对象的类型，如果类型相同，继续比较值，如果值也相同，返回true，否则返回false。 (5) 基本数据类型封装类对象调用equals()，但是参数是基本数据类型变量，这时候，基本数据类型变量会先进行自动装箱转换为其封装类型对象，再进行4中的比较。 例1： int a=257; Integer b1=257; //Integer b1=257会先调用Integer.valueOf()方法将257转化为new Integer(257)对象 Integer b2=57; //Integer b2=57会先调用Integer.valueOf()方法返回缓存中的57 Integer b3=257; Integer b4=57; Integer c=new Integer(257); Integer d=new Integer(257); Integer e1=Integer.valueOf(257); //Integer.valueOf()方法将257转化为new Integer(257)对象 Integer e2=Integer.valueOf(57); //Integer.valueOf()方法返回缓存中的57 // int和Integer(无论new否)比，都为true System.out.println(a==b1); // true，规则(1) System.out.println(a==c); // true，规则(1) // 两个都是非new出来的Integer，如果数在-128到127之间，则是true，否则为false System.out.println(b1==b3); // false，规则(2) System.out.println(b2==b4); // true，规则(2) System.out.println(b1==e1); // false，规则(3) System.out.println(b2==e2); // true，规则(3) // Integer与new Integer比较，结果为false；两个都是new出来的,都为false System.out.println(b1==c); // false，规则(3) System.out.println(c==d); // false，规则(3) //System.out.println(a.equals(b1)); 编译出错，基本型不能调用equals() System.out.println(b1.equals(b3)); // true，规则(4) System.out.println(c.equals(d)); // true，规则(4) System.out.println(b1.equals(257.0)); // false，规则(5)，257.0先封装成Double对象再进行比较 public static void main(String[] args){ Boolean flag=false;//先调用Boolean.valueOf(boolean b)返回false对应的Boolean对象Boolean.FALSE，然后赋值给flag，flag值为Boolean.FALSE /* 先赋值，遇到if条件表达式自动拆箱 * 1. 先调用Boolean.valueOf(boolean b)返回true对应的Boolean对象Boolean.TRUE，然后赋值给flag，flag值为Boolean.TRUE * 2. 调用booleanValue()返回flag值对应的基础数据类型值true * 3. 结果输出true */ if (flag=true){ System.out.println(&quot;true&quot;); }else{ System.out.println(&quot;false&quot;); } } 例1，例2，例3 例4：重要的题目 问：为什么集合类没有实现Cloneable和Serializable接口？克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的，因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。 问：泛型例1：重要的题目 class A {} class B extends A {} class C extends A {} class D extends B {} Which four statements are true? (A) The type List&lt;A&gt;is assignable to List. (B) The type List&lt;B&gt;is assignable to List&lt;A&gt;. (C) The type List&lt;Object&gt;is assignable to List&lt;?&gt;. (D) The type List&lt;D&gt;is assignable to List&lt;?extends B&gt;. (E) The type List&lt;?extends A&gt;is assignable to List&lt;A&gt;. (F) The type List&lt;Object&gt;is assignable to any List reference. (G) The type List&lt;?extends B&gt;is assignable to List&lt;?extends A&gt;. 正确答案：ACDG","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"06-常用类","slug":"06-常用类","date":"2017-05-28T10:19:20.000Z","updated":"2017-05-29T08:31:14.528Z","comments":true,"path":"2017/05/28/06-常用类/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/06-常用类/","excerpt":"常用类","text":"常用类 问：String、StringBuffer和StringBuilder(1) String：不可变的字符序列 String类不是基本数据类型，是引用数据类型 String是被final修饰的类，因此一旦一个String对象被创建并初始化后，包含在这个对象里的字符序列是不可改变的，直到这个对象被销毁，即本身的内容不可改变、长度不可改变； String类不可以被继承； String变量作为参数时相当于基本数据类型的值传递 对String对象的任何改变都不影响到原对象，每次操作都会生成新的String对象，然后将引用指向新的String对象，因此不推荐频繁改变String内容，会增加内存压力。为了提高效率节省空间，我们应该用StringBuffer类 当多个字符串联合时会先转为StringBuffer，再联合，最后生成String对象，速度较慢。 例1：Java中的字符串都是常量，字符串一旦被初始化，就不可以被改变，因为是常量，存放在方法区中的常量池中，可以实现共享。 // 双引号引起的数据都是字符串对象，存放在常量池中。s1指向的内存中只有一个对象，在常量池中。 String s1=&quot;abc&quot;; // 在内存中生成两个对象，&quot;abc&quot;存放在常量池中，new String()存放在堆内存中。s2指向的内存中有两个对象，分别在常量池中和堆内存中。 String s2=new String(&quot;abc&quot;); /*&quot;abc&quot;是字符串常量，被存在堆区的常量池中，当定义String s3=&quot;abc&quot;时，不会马上创建字符串&quot;abc&quot;对象，而是会先查找常量池中是否存在相同常量， 如果有，则s3指向同一内存空间，否则创建新的字符串对象。*/ String s3=&quot;abc&quot;; System.out.println(s1==s2); //false System.out.println(s1==s3); //true //String类重写了Object类的equals()方法，使其由比较引用变为了比较引用所指向的字符串内容是否一样。 System.out.println(s1.equals(s2)); //true 例2，例3，例4，例5：编译器优化 (2) StringBuffer：线程安全的可变字符序列 对StringBuffer对象进行操作都是对其本身的字符序列进行操作，而不是生成新的对象。因此StringBuffer对象内容可变、长度可变，可以将多个字符串值直接联合，效率高 例1 定义有StringBuffer s1=new StringBuffer(10);s1.append(&quot;1234&quot;)则s1.length()和s1.capacity()分别是：4和10 (3) StringBuilder：非线程安全的可变字符序列 问：数组有没有length()方法? String有没有length()方法？数组没有length()方法，但有length属性；String有length()方法。 问：String的replaceAll()方法例1：易错的题目 public static void main (String[] args) { String classFile = &quot;com.jd.&quot;. replaceAll(&quot;.&quot;, &quot;/&quot;) + &quot;MyClass.class&quot;; System.out.println(classFile); } 输出为：/////////MyClass.class replaceAll方法的第一个参数是一个正则表达式，而&quot;.&quot;在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成&quot;/&quot;。 如果想替换的只是&quot;.&quot;的话，正则表达式那里就要写成&quot;\\\\.&quot;或者是&quot;[.]&quot;。前者将&quot;.&quot;转义为&quot;.&quot;这个具体字符，后者则匹配&quot;[]&quot;中的任意字符。 问：String的编码转换编码转换，实现将GB2312编码的字符串转换为ISO-8859-1编码的字符串： String a=new String(&quot;中&quot;.getBytes(&quot;gb2312&quot;), &quot;iso-8859-1&quot;); 编码转换，实现将GBK编码字节流转换为UTF-8编码字节流： byte[] src, dst; dst=new String (src, &quot;GBK&quot;).getbytes(&quot;UTF-8&quot;); 问：Math类(1) Math.floor(a) 求小于或等于a的最大整数，返回double类型。 // 如果参数值总是等于某个整数，那么结果与该参数相同 Math.floor(1)=1.0 // 如果参数是NaN、无穷、正0、负0，那么结果与参数相同 Math.floor(Double.NaN)=Double.NaN Math.floor(Double.POSITIVE_INFINITY)=Double.POSITIVE_INFINITY Math.floor(Double.NEGATIVE_INFINITY)=Double.NEGATIVE_INFINITY Math.floor(0.0)=0.0 Math.floor(-0.0)=-0.0 (2) Math.ceil(a) 求大于或等于a的最小整数，返回double类型。 // 如果参数值总是等于某个整数，那么结果与该参数相同 Math.ceil(1)=1.0 // 如果参数是NaN、无穷、正0、负0，那么结果与参数相同 Math.ceil(Double.NaN)=Double.NaN Math.ceil(Double.POSITIVE_INFINITY)=Double.POSITIVE_INFINITY Math.ceil(Double.NEGATIVE_INFINITY)=Double.NEGATIVE_INFINITY Math.ceil(0.0)=0.0 Math.ceil(-0.0)=-0.0 //如果参数小于0但大于-1.0，那么结果为-0.0(重要) Math.ceil(-0.5)=-0.0 (3) Math.round(a)=(long)floor(a+0.5d)；将原来的数字加上0.5后再向下取整，返回long类型，注意向下取整是指小于或等于它的最大整数。 Math.round(6.4)=(long)floor(6.4+0.5d)=(long)floor(6.9)=6 Math.round(6.9)=(long)floor(6.9+0.5d)=(long)floor(7.4)=7 Math.round(6.5)=(long)floor(6.5+0.5d)=(long)floor(7.0)=7 Math.round(-6.4)=(long)floor(-6.4+0.5d)=(long)floor(-5.9)=-6 Math.round(-6.9)=(long)floor(-6.9+0.5d)=(long)floor(-6.4)=-7 Math.round(-6.5)=(long)floor(-6.5+0.5d)=(long)floor(-6.0)=-6 // 了解 Math.round(NaN)=0 Math.round(Math.round(Double.NEGATIVE_INFINITY或&lt;=Long.MIN_VALUE))=Long.MIN_VALUE Math.round(Math.round(Double.POSITIVE_INFINITY或&gt;=Long.MAX_VALUE))=Long.MAX_VALUE 问：枚举类型Java中创建枚举类型要使用enum关键字，所有的枚举值都默认为static，在初始化时会对所有的枚举值对象调用一次构造函数进行初始化。 例1： enum AccountType{ SAVING, FIXED, CURRENT; private AccountType(){ System.out.println(“It is a account type”); } } class EnumOne{ public static void main(String[]args){ System.out.println(AccountType.FIXED); } } 程序输出如下： It is a account type It is a account type It is a account type FIXED 问：基本数据类型的包装类Java语言是一个面向对象的语言，但Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，即包装类。 例1： class Two{ Byte x; } class PassO{ public static void main(String[] args){ PassO p=new PassO(); p.start(); } void start(){ Two t=new Two(); System.out.print(t.x+””); Two t2=fix(t); System.out.print(t.x+” ” +t2.x); } Two fix(Two tt){ tt.x=42; return tt; } } 上面代码的输出为：null 42 42 基本数据类型的包装类型，属于引用类型。如果包装类成员变量没有显示初始化，那么Java默认初始化为null。 问：如何将数值型字符串转换为对应类型的数字？例1： Integer.parseInt(&quot;1234&quot;); Double.parseDouble(&quot;123.2&quot;); 问：日期类例1： 使用Java编程，打印昨天的当前时刻 public class YesterdayCurrent{ public static void main(String[] args){ Calendar cal = Calendar.getInstance(); cal.add(Calendar.DAY_OF_MONTH, -1);//从当前日期减去一天 System.out.println(cal.getTime()); } } 例2： 如何获取当前时间对应的年月日时分秒? public class CurrentTime{ public static void main(String[] args){ Calendar c=Calendar.getInstance(); System.out.print(c.get(Calendar.YEAR)+&quot;年&quot;+(c.get(Calendar.MONTH)+1)+&quot;月&quot;+c.get(Calendar.DAY_OF_MONTH)+&quot;日, &quot;; System.out.println(c.get(Calendar.HOUR_OF_DAY)+&quot;:&quot;+c.get(Calendar.MINUTE)+&quot;:&quot;+c.get(Calendar.SECOND)); } } 或 public class CurrentTime{ public static void main(String[] args){ Date date=new Date(); System.out.println(date); } } 例3： 如何取得从1970年到现在的毫秒数 public static void main(String[] args){ System.out.println(System.currentTimeMillis()); } 例4： 如何格式化日期？SimpleDateFormat public static void main(String[] args){ SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); Date date=new Date(); String dateStr=sdf.format(date);//把日期按指定格式转化为字符串 System.out.println(dateStr); }","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"05-数组","slug":"05-数组","date":"2017-05-28T10:18:25.000Z","updated":"2017-05-29T08:31:12.548Z","comments":true,"path":"2017/05/28/05-数组/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/05-数组/","excerpt":"数组","text":"数组","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"04-异常处理","slug":"04-异常处理","date":"2017-05-28T10:15:57.000Z","updated":"2017-05-29T08:31:10.094Z","comments":true,"path":"2017/05/28/04-异常处理/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/04-异常处理/","excerpt":"异常处理","text":"异常处理 问：Java中的两种异常类型是什么？他们有什么区别？Throwable包含了错误(Error)和异常(Excetion)两类。 图 1 (1) Error： 由Java虚拟机生成并抛出，属于JVM底层或者运行时环境的错误，程序无法预测和捕获处理，如OutOfMemoryError，如果出现Error，Java虚拟机会终止执行。 (2) Exception: 用户程序可以捕获的异常情况，Java中有两种异常，分别为运行时异常(RuntimeException, 又叫非检查异常)和非运行时异常(又叫检查异常)。 运行时异常：RuntimeException类及其子类，如ArithmeticException、NullPointerException、IndexOutOfBoundsException、ClassCastException、BufferOverflowException、ConcurrentModificationException、IllegalArgumentException、NoSuchElementException、UnsupportedOperationException等，这类异常是在程序运行的时候可能会发生的，Java编译器不去检查它，也就是说，当程序中可能出现这类异常时，即使没有用try…catch语句捕获它，也没有用throws字句声明抛出它，还是会编译通过。所以程序可以捕捉，也可以不捕捉。这些异常一般是由程序的逻辑错误引起的，其产生频繁，处理麻烦，若显示申明或者捕获将会对程序的可读性和运行效率影响很大，建议不要用try…catch…捕获处理，程序应该在开发调试的过程中从逻辑角度去尽量避免，例如：空值处理。 非运行时异常：运行时异常以外的异常，也是Exception及其子类，这些异常从程序的角度来说是必须经过捕捉检查处理的(要么用 try…catch捕获处理，要么用throws语句声明抛出)，否则不能通过编译。如IOException、SQLException、NoSuchMetodException、ClassNotFoundException、FileNotFoundException等。 问：异常处理语句的语法规则 try是用于检测被包住的语句块是否出现异常，如果有异常，则抛出异常，并执行catch语句 cacth用于捕获从try中抛出的异常并作出处理 finally语句块是不管有没有出现异常都要执行的内容 throw用于抛出异常 throws关键字可以在方法上声明该方法要抛出的异常，然后在方法内部通过throw抛出异常对象 (1) try代码块中包含可能产生异常的代码，其后跟一个或多个catch代码块，每个catch代码块用于捕获并处理一种特定类型的异常。 (2) 当try代码块中产生异常时，程序会终止当前的执行流程，Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个catch代码块，然后其他的catch代码块将不会再执行，即一个异常只能被一个catch代码块捕获执行。如果try代码块没有异常产生，所有的catch代码块将跳过不执行。 (3) catch代码块后可以跟finally代码块，无论try代码块中是否抛出异常，finally代码块都会被执行，因此finally代码块为异常处理提供一个统一的出口，使得在控制流程跳转到程序的其他部分之前，能够对程序的状态作统一的管理。通常在finally代码块中可以进行资源的清除工作。 (4) try代码块后基类异常的捕获语句不可以写在子类异常捕获语句的上面。 (5) 在try-catch-finally结构中，可重新抛出异常。 (6) try-catch-finally结构可嵌套。 (7) try不必一定有catch，只要catch和finally有一个存在就行，但是catch和finally不可以同时省略 (8) 自定义异常要继承Exception或Exception的子类。 问：异常处理完成以后，Exception对象会发生什么变化？Exception对象会在下一个垃圾回收过程中被回收掉。 问：throw和throws有什么区别？ throw关键字用来在方法内部明确地抛出异常，后面跟的是要抛出的异常对象且只能跟一个异常对象； throws关键字用在声明方法上，表示该方法可能要抛出的、该方法不能处理的异常，后面跟的是异常类名，可以有多个，用逗号隔开，这样方法的调用者才能够确保处理可能发生的异常。 问：finallyfinally作为异常处理的一部分，只能用在try/catch语句块后，无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。 例1：当程序执行到try{}语句中的return方法时，它将要返回的结果存储到一个临时栈中，然后程序不会立即返回，而是去执行finally{}中的代码，在执行a = 2时，程序仅仅是覆盖了a的值，但不会去更新临时栈中的那个要返回的值。finally{}执行完之后，程序就会将临时栈中的值取出来返回。 public abstract class Test { public static void main(String[] args) { System.out.println(beforeFinally()); // output: 1 } public static int beforeFinally(){ int a = 0; try{ a = 1; return a; }finally{ a = 2; } } } 例2：这里finally{}里也有一个return，那么在执行这个return时，就会更新临时栈中的值。同样，在执行完finally之后，程序将临时栈中的值取出来返回，即返回值是2. public abstract class Test { public static void main(String[] args) { System.out.println(beforeFinally()); //output: 2 } public static int beforeFinally(){ int a = 0; try{ a = 1; return a; }finally{ a = 2; return a; } } } 例3：try/catch可以捕获并处理异常，异常被捕获后程序可以继续向后执行 public class Test { public static void main(String[] args) { try { int i = 100 / 0; System.out.print(i); } catch (Exception e) { System.out.print(1); } finally { System.out.print(2); } System.out.print(3); } } // output: 123 例4：catch语句块里面，打印完1之后，又抛出了一个RuntimeException，程序并没有处理它，而是直接抛出，因此执行完finally语句块之后，程序便不往下执行直接终止了 public class Test { public static void main(String[] args) { try { int i = 100 / 0; System.out.print(i); } catch (Exception e) { System.out.print(1); throw new RuntimeException(); } finally { System.out.print(2); } System.out.print(3); } } // output: 12 例5：catch语句块里面，打印完1之后，程序先执行完finally语句块，然后return。 public class Test { public static void main(String[] args) { try { int i = 100 / 0; System.out.print(i); } catch (Exception e) { System.out.print(1); return; } finally { System.out.print(2); } System.out.print(3); } } // output: 12 问：final关键字、finally代码块和finalize()方法有什么区别？ final关键字用于声明变量、方法和类，分别表示变量的值不可被修改、方法不可被重写、类不可被继承。 finally作为异常处理的一部分，只能用在try/catch语句块后，无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。 finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由垃圾收集器来调用的。可以覆盖此方法在垃圾收集时的进行其他资源回收，例如关闭文件等。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"03-面向对象编程","slug":"03-面向对象编程","date":"2017-05-28T10:14:04.000Z","updated":"2017-05-29T08:31:08.102Z","comments":true,"path":"2017/05/28/03-面向对象编程/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/03-面向对象编程/","excerpt":"面向对象编程","text":"面向对象编程 问：面向对象的基本特征(1) 封装：利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过对外已授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。 (2) 继承：继承是使用已存在的类作为基础定义新类，新类的定义可以增加新的数据或新的操作，也可以复用父类的操作，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。 (3) 多态：多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。 问：类例1 问：访问控制符Java类的成员默认为default访问权限。 图 1 访问权限大小：public&gt;protected&gt;default&gt;private 例1 问：Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？Java中每一个类都有构造方法，当使用关键字new实例化一个对象时，类的构造方法就会被自动调用，完成对象的初始化工作。 构造方法是一种特殊的方法，具有以下特点: (1) 构造方法的方法名必须与类名相同； (2) 构造方法没有返回值类型，也不能定义为void； (3) 构造方法不能被static、final、synchronized、abstract、native等关键字修饰，但可以被public、private、protected修饰 (4) 一个类可以定义多个构造方法，如果在定义类时没有定义构造方法，则编译系统会自动插入一个无参数的默认构造方法，这个构造器不执行任何代码； 例1： (5) 构造方法可以被重载，以参数的个数、类型、顺序进行区分； (6) 构造方法不能被继承，因此不能被重写，子类使用父类的构造方法需要使用super关键字 例1： Java中构造方法重载和方法重载很相似，可以为一个类创建多个构造方法，每一个构造方法必须有它自己唯一的参数列表。 Java不支持像C++中那样的复制构造方法，但是这并不代表Java中没有这种机制，Java中Object类的clone()方法就是这种机制的体现。 问：new关键字例1 问：this关键字问：static关键字“static”关键字可以用于修饰类的成员变量和成员方法，被其修饰的成员变量被称为类变量，被其修饰的成员方法成为类方法，它们随着类的加载而加载，使得该变量和方法可以在类没有实例化的情况下可以直接通过类名进行访问。 (1) 被static修饰的成员方法只能访问static成员，不可以访问非static成员 Java中被static修饰的变量和方法是属于类的，它们随着类的加载而加载，同时对static变量进行初始化并执行static代码块。如果static环境中的代码尝试访问非static的变量，编译器会报错，因为类的加载先于变量的创建，类加载的时候这些变量还没有被创建出来，例如，在static方法中访问某对象的非static方法，此时尚不能保证对象已经被实例化。因此在static环境中不能访问非static变量。 例1 package NowCoder; class Test { public static void hello() { System.out.println(&quot;hello&quot;); } } public class MyApplication { public static void main(String[] args) { Test test=null; test.hello(); } } 上述代码：能编译通过，并正确运行 (2) Java中静态变量只能在类主体中定义，不能在方法中定义。 静态变量属于类所有而不属于方法。静态变量是在方法之前被加载的，所以static变量只能是类成员变量，而不能是局部变量，因为在static加载时，方法还没有分配空间。 例1： public class Test { public int aMethod() { static int i = 0; i++; return i; } public static void main (String args[]) { Test test = new Test(); test.aMethod(); int j = test.aMethod(); System.out.println(j); } } 程序编译失败 问：继承继承时类的实例化问题：在实例化一个类时，一定是先创建其父类对象，即先执行父类的构造函数，然后再创建当前类对象。如果子类没有显示地调用父类的构造函数，编译器会自动加入父类的无参的构造函数super() 例1： package test; class FatherClass { public FatherClass() { System.out.println(&quot;FatherClass Create&quot;); } } class ChildClass extends FatherClass { public ChildClass() { System.out.println(&quot;ChildClass Create&quot;); } public static void main(String[] args) { FatherClass fc = new FatherClass(); ChildClass cc = new ChildClass(); } } 程序的输出结果如下： FatherClass Create FatherClass Create ChildClass Create 问：Java支持多继承么？Java中的类不支持多继承，只支持单继承(即一个类只有一个父类)。 但是Java中的接口支持多继承，即一个子接口可以有多个父接口。(接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能)。 问：super和thisthis代表当前类对象，super代表当前类对象的父类对象。 在子类构造方法中，使用super()调用的是其父类的构造方法，而使用this()调用的是同一个类中重载的构造方法 super关键字 (1) Java中子类不能继承父类的构造方法，只能调用父类构造方法； (2) 子类的构造方法可以使用super显示地调用父类构造方法； (3) 当子类构造方法中没有使用super来显示地调用父类构造方法时，系统会默认采用super()调用父类的无参构造方法，这时父类必须提供无参构造参数，否则编译出错。 案例： 例1，例2，例3，例4 this关键字 注意： (1) 使用super()或this()时，它们必须放在构造方法的第一行，否则编译通不过。 (2) 由于this()调用的构造函数默认调用super()方法，所以规定this()和super()不能同时出现在一个构造函数中。 (3) static环境，包括static方法和static语句块，在执行时还没有构造对象实例，因此不能在static环境中使用this()和super() 问：Java中的方法重写(Overriding)和方法重载(Overloading)是什么意思？方法重写和方法重载都是Java多态性的不同表现(动态绑定 dynamic binding) (1) 方法重载是一个类中多态性的一种表现，发生在同一个类里面两个或多个方法的方法名相同但是参数列表不同的情况。 函数名必须相同； 函数参数列表必须不相同，可以是参数个数、参数类型或者参数顺序不同； 函数的返回值类型、修饰符可以相同，也可以不相同； (2) 方法重写是父类与子类之间多态性的一种表现，是说子类重新定义了父类的方法；方法的重写满足两同两小一大原则 方法名相同，参数类型相同 子类返回类型小于等于父类方法返回类型； 子类抛出异常小于等于父类方法抛出异常； 子类访问权限大于等于父类方法访问权限 (public&gt;protected&gt;defualt(默认修饰符)&gt;private)。 注意：Java不支持运算符重载。 例1 问：Java中是否可以覆盖(override)一个private或者是static的方法？private修饰的方法不能被覆盖，因为被private修饰的父类方法在子类中是不可见的。 Java中静态方法在形式上可以被重写，即子类中可以重写父类中静态的方法。但是实际上从内存的角度上静态方法不可以被重写，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。 问：final关键字final关键字可以用于修饰类、变量和方法。 (1) final修饰的类不可被继承(因此一个类不能同时被final和abstract修饰)； (2) final修饰的方法不可被重写； (3) final修饰的变量的值不可被修改，一旦获得初始值，该变量就不能被重新赋值。 例1，例2，例3 (4) 形式参数只能用final修饰符，任何其它修饰符都会引起编译错误。但是用这个修饰符也有一定的限制，就是在方法中不能对参数做任何修改。不过在一般情况下，一个方法的形参不用final修饰。只有在特殊情况下：方法内部类，一个方法内的内部类如果使用了这个方法的参数或者局部变量，这个参数或局部变量应该是final。 (5) final修饰的成员变量既可以在定义时显示地初始化，也可以先声明而不初始化，这种成员变量称为blank final，此时可以在构造代码块或构造函数中对其赋初值，否则编译会报错。 例1： class Foo { final int i; int j; public void doSomething() { System.out.println(++j + i); // 编译出错，因为final成员变量在使用前没有赋初值 } } 例2：这一题解释尚不明确，不知道final方法在子类中继承了没有。 public class Car extends Vehicle{ public static void main(String[] args){ new Car().run(); //输出：Car } private final void run(){ System.out.println(&quot;Car&quot;); } } class Vehicle{ private final void run(){ System.out.println(&quot;Vehicle&quot;); } } (6) 被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化 例1： byte b1=1,b2=2,b3,b6,b8; final byte b4=4,b5=6,b7; b3=(b1+b2); /*语句1*/ b6=b4+b5; /*语句2*/ b8=(b1+b4); /*语句3*/ b7=(b2+b5); /*语句4*/ System.out.println(b3+b6); 代码片段中，存在编辑错误的语句是：语句1、语句3和语句4 语句1错误：b3=(b1+b2);自动转为int，所以正确写法为b3=(byte)(b1+b2);或者将b3定义为int； 语句2正确：b6=b4+b5;b4、b5为final类型，不会自动提升，计算结果任然是byte类型，然后结果的类型视左边变量类型而定，即b6可以是任意数值类型； 语句3错误：b8=(b1+b4);虽然b4不会自动提升，但b1仍会自动提升，所以结果需要强转，b8=(byte)(b1+b4); 语句4错误：b7=(b2+b5); 同上。同时注意b7是final修饰，即只可赋值一次，便不可再改变。 问：Object类Java中Object是所有类的祖先类，Object类中包含如下方法： 图 1 问：equals()方法和==的区别 ==运算符：对于基本数据类型变量比较的是两个变量的值是否相等；对于引用型变量表示的是两个变量指向的对象在堆中存储的地址是否相同，即栈中的内容是否相同 equals()方法：继承自Object类，默认调用==进行比较。判断两个对象是否相等需要覆盖equals()方法和hashcaode()方法 问：finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？finalize()是Object类的一个方法，垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法。 但是很不幸的是，在Java中，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说filalize()可能永远不被执行，显然指望它做收尾工作是靠不住的。 那么finalize()究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。 问：clone，没遇到过，暂时存放42、写clone()方法时，通常都有一行代码，是什么？Clone有缺省行为，super.clone();他负责产生正确大小的空间，并逐位复制。 问：多态的实现方式(1) 静态的多态：方法重载 (2) 动态的多态：子类覆盖父类的方法，将子类的实例赋值给父类的引用，此时调用的是子类的方法；实现接口的实例赋值给接口的引用，此时调用的实现类的方法。 例1：判断对错 在java的多态调用中，new的是哪一个类就是调用的哪个类的方法。 错误 问：抽象类和接口的区别Java提供和支持创建抽象类和接口。 含有abstract修饰符的class即为抽象类，abstract类不能创建类的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。 接口(interface)可以说成是抽象类的一种特例 它们的不同点在于： 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。 (1) 抽象类和接口都不可以被实例化 (2) 抽象类中可以包含普通成员变量、静态成员变量；而接口中没有普通成员变量、只有常量，接口中声明的成员变量默认为public static final类型，且只能是public static final类型； (3) 抽象类中可以同时包含抽象方法和非抽象方法，也可以没有抽象方法，但如果一个类中有一个抽象方法，那么当前类一定是抽象类；而接口中只有方法的声明、没有方法体，即接口中的所有方法必须都是抽象的，不能有非抽象的普通方法(Java8中接口可以有非抽象的default方法) (4) 抽象类中的抽象方法，需要由子类实现，如果子类不实现所有抽象方法，则子类也需要定义为抽象类；接口中定义的方法都需要由实现类来实现，如果实现类不能实现接口中的所有方法，则实现类需要定义为抽象类 (5) 抽象类中可以有构造方法，其作用是初始化抽象类的成员；接口中不能有构造方法 (6) 抽象类中的成员方法的访问类型可以为public、protected和private，抽象方法必须为public或protected；而接口中的成员方法的访问类型默认为public abstract类型，且只能是public abstract (7) 抽象类中可以包含静态方法；而接口中不能包含静态方法(Java8开始接口可以有静态方法) (8) 抽象类可以implements接口；接口可以继承接口，并且接口可以实现多继承(一个接口可以继承多个接口) (9) 抽象类只能被单一extends(一个类只能继承一个类)；接口却可以被多重implements(一个类可以实现多个接口) (10) 类可以不实现抽象类和接口中声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的 (11) 抽象方法既不能是static的，也不能是native的，还不能是synchronized的 例1，例2，例3，例4 问：instanceof关键字instanceof前一个参数通常是一个引用类型变量，后一个操作数通常是一个类（也可以是一个接口）。它用于判断前面的变量引用的对象是否是后面的类(也可以是一个接口)或者其子类的实例。 例1： public static void main(String args[]) { List Listlist1 = new ArrayList(); Listlist1.add(0); List Listlist2 = Listlist1; System.out.println(Listlist1.get(0) instanceof Integer); System.out.println(Listlist2.get(0) instanceof Integer); } 上面代码将输出：true true Collection类型的集合（ArrayList,LinkedList）只能装入对象类型的数据 该题中需要装入0，是一个基本类型，但是JDK5以后提供了自动装箱与自动拆箱，所以int类型自动装箱变为了Integer类型。 List没有使用泛型，因此使用get(0)取出的元素的编译类型是Object型的，但运行时类型是Integer，所以打印true，这里体现了多态的应用。 而Listlist1把引用赋给了Listlist2，说明两个指向同一个对象，因此第二个打印的也是true。 问：内部类内部类分类，来自例2中评论部分BlueFish的总结。 使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。 使用内部类最大的优点就在于它能够非常好的解决多重继承的问题,使用内部类还能够为我们带来如下特性: 内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立； 在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类； 创建内部类对象的时刻并不依赖于外围类对象的创建； 内部类并没有令人迷惑的”is-a”关系，他就是一个独立的实体； 内部类提供了更好的封装，除了该外围类，其他类都不能访问。 (1) 成员内部类 public class Outer{ private String name=&quot;Outer&quot;; private int age=99; public static void main(String[] args){ Outer outer=new Outer(); Inner inner=outer.new Inner(); inner.show(); } private class Inner{ private String name=&quot;Inner&quot;; private final int num=10; public void show(){ System.out.println(Outer.this.name); System.out.println(this.name); System.out.println(age); } } } Inner类定义在Outer类的内部(相当于Outer类的一个成员变量的位置处)，Inner类可以使用任意访问控制符，如public、protected、private等； Inner 类中定义的show()方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问Outer类中的私有属性age； 定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去new一个内部类对象，即：内部类 对象名=外部类对象.new 内部类(); 编译上面的程序后，会发现产生了两个.class文件: Outer.class和Outer$Inner.class 成员内部类中不能存在任何static的变量和方法，但可以定义常量: 因为非静态内部类的存在是依赖于外部类的实例的，而静态变量和方法是不依赖于对象的，仅与类相关。而在加载静态域时，根本没有外部类实例，所在在非静态内部类中不能定义静态变量或方法，编译不通过;非静态内部类的作用域是实例级别 常量是在编译器时确定的，放到所谓的常量池了，因此可以定义常量。 注意： 外部类是不能直接使用内部类的成员和方法的，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法； 如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用this关键字，如:Outer.this.name (2) 静态内部类，static修饰的内部类 public class Outer{ private static String name=&quot;Outer&quot;; private static String tag=&quot;tag&quot;; private int age=99; public static void main(String[] args){ Inner inner=new Inner(); inner.show(); } private static class Inner{ private String name=&quot;Inner&quot;; public void show(){ System.out.println(Outer.name); System.out.println(this.name); System.out.println(tag); System.out.println(new Outer().age); } } } 静态内部类不能直接访问外部类的非静态成员，但可以通过new 外部类().成员的方式访问 如果外部类的静态成员与内部类的成员名称相同，可通过类名.静态成员的方式访问外部类的静态成员； 如果外部类的静态成员与内部类的成员名称不相同，则可通过成员名直接调用外部类的静态成员； 创建静态内部类的对象时，不需要外部类的对象，可以直接创建内部类 对象名=new 内部类(); (3) 方法内部类，访问仅限于方法内或者该作用域内 public class Outer { public static void main(String[] args) { Outer outer = new Outer(); outer.print(); } public void print() { final int a = 25; class Inner { private int c = 2; public void show() { System.out.println(a); System.out.println(c); } } Inner inner = new Inner(); inner.show(); } } 方法内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的 方法内部类不能修改方法中定义的局部变量(解释看原评论，原评论这部分，我测试有点问题，大概原因是内部类访问方法局部变量时会拷贝局部变量，对局部变量修改会造成拷贝的局部变量值与方法中局部变量值不一致，为了保持局部变量值得一致性，可以将被内部类访问的局部变量声明为final) (4) 匿名内部类 public class Outer{ public static void main(String[] args){ Outer outer=new Outer(); InnerClass inner=outer.getInnerClass(2, &quot;inner&quot;); System.out.println(inner.getNumber()); } public InnerClass getInnerClass(int num, String str){ return new InnerClass(){ int count; int number=num+1; { count=100; } @Override public int getNumber() { return number; } }; } private interface InnerClass{ int getNumber(); } } 匿名内部类是直接使用 new 来生成一个对象的引用； 对于匿名内部类的使用，它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用； 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口； 匿名内部类中是不能定义构造函数的，匿名内部类中不能存在任何的静态成员变量和静态方法； 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法； 匿名内部类初始化:使用构造代码块! 利用构造代码块能够达到为匿名内部类创建一个构造器的效果 例1： 重要 非静态内部类是属于对象的，所以初始化时需要先初始化一个外部类实例对象，然后使用此对象调用内部类的构造方法。静态内部类属于类本身，初始化时直接使用外部类调用静态内部类的构造方法即可 public class Test{ public static void main(String[] args){ EnclosingOne.InsideOne obj1=new EnclosingOne().new InsideOne(); //非静态内部类 EnclosingOne.InsideTwo obj2=new EnclosingOne.InsideTwo(); //静态内部类 } } class EnclosingOne { //非静态内部类 public class InsideOne { } //静态内部类 public static class InsideTwo{ } } 例2：往OuterClass类的代码段中插入内部类声明，哪一个是错误的？ public class OuterClass{ private float f=1.0f; //插入代码到这里 } A. class InnerClass{ public static float func(){ return f; } } B. abstract class InnerClass{ public abstract float func(){} } C. static class InnerClass{ protected static float func(){ return f; } } D. public class InnerClass{ static float func(){return f;} } 答案：ABCD 例3 问Static Nested Class和Inner Class的不同？Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化，而通常的内部类需要在外部类实例化后才能实例化。 问：类加载器Java中类的加载是由类加载器完成的，类加载器包括：引导类加载器(BootStrap ClassLoader)、扩展类加载器(Extension ClassLoader)、应用类加载器(Application ClassLoader)和用户自定义类加载器(java.lang.ClassLoader的子类)。 Bootstrap ClassLoader：它负责加载放在\\jre\\lib/目录中的，或者-Xbootclasspath参数所指定路径中的Java核心库(如rt.jar)，是用原生代码来实现的； Extension ClassLoader：它负责加载\\jre\\lib\\ext目录中，或系统变量java.ext.dirs所指定路径中的所有类库； Application ClassLoader：它负责加载Java应用的CLASSPATH所指定的类库。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它是应用最广泛的类加载器。开发者可以直接使用这个类加载器，如果应用程序中没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器； Custom ClassLoader：应用程序根据自身需要自定义的ClassLoader，是java.lang.ClassLoader的子类，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader。 例1 问：JVM的类加载机制推荐阅读 Java类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中准备、验证、解析3个部分统称为连接（Linking）。 图 1 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定） 例1 问：Java类加载时的初始化顺序(1) 初始化父类中的静态成员变量和静态代码块(按照在程序中出现的顺序初始化) (2) 初始化子类中的静态成员变量和静态代码块(按照在程序中出现的顺序初始化) (3) 初始化父类中的普通成员变量和构造代码块(按照在程序中出现的顺序初始化)，然后再执行父类中的构造方法 (4) 初始化子类中的普通成员变量和构造代码块(按照在程序中出现的顺序初始化)，然后再执行子类中的构造方法 例1： class Member { Member(String str) { System.out.println(str); } } class A { static { System.out.println(&quot;父类静态代码块&quot;); } public A() { System.out.println(&quot;父类构造函数&quot;); } { System.out.println(&quot;父类构造代码块&quot;); } Member member=new Member(&quot;父类成员变量&quot;); } class B extends A { Member member=new Member(&quot;子类成员变量&quot;); static { System.out.println(&quot;子类静态代码块&quot;); } public B() { System.out.println(&quot;子类构造函数&quot;); } { System.out.println(&quot;子类构造代码块&quot;); } } public class Test{ public static void main(String[] args) { new B(); } } //输出： 父类静态代码块 子类静态代码块 父类构造代码块 父类成员变量 父类构造函数 子类成员变量 子类构造代码块 子类构造函数 例2： public class B { public static B t1 = new B(); public static B t2 = new B(); { System.out.println(&quot;构造块&quot;); } static { System.out.println(&quot;静态块&quot;); } public static void main(String[] args) { B t = new B(); } } // 输出 构造块 构造块 静态块 构造块 例3： 例4：下面代码的输出是什么？ public class Base { private String baseName = &quot;base&quot;; public Base() { callName(); } public void callName() { System.out.println(baseName); } static class Sub extends Base { private String baseName = &quot;sub&quot;; public void callName() { System.out.println(baseName); } } public static void main(String[] args) { Base b = new Sub(); } } // 输出：null 问：JNI(Java Native Interface)Java的不足除了体现在运行速度上要比传统的C++慢许多之外，Java无法直接访问到操作系统底层（如系统硬件等)，为此Java使用native方法来扩展Java程序的功能。 native是方法修饰符，native方法是由另外一种语言（如C/C++,汇编等）实现的本地方法，因为在外部实现了方法，所以在java代码中，就不需要声明了，有点类似于接口中的抽象方法。其实现步骤为： 在Java中声明native()方法，然后编译； 用javah产生一个.h文件； 写一个.cpp文件实现native导出方法，其中需要包含第二步产生的.h文件（注意其中又包含了JDK带的jni.h文件）； 将第三步的.cpp文件编译成动态链接库文件； 在Java中用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问了。 例1：以下声明合法的是： A. default String s B. public final static native int w() C. abstract double d D. abstract final double hyperbolicCosine() 答案：B native可以和任何修饰符连用，abstract除外。因为native暗示这个方法时有实现体的，而abstract却显式指明了这个方法没有实现体。 例2：Which of the following can be applied to constructors? A. final B. static C. synchronized D. native E. None of these. 答案：E native方法和abstract方法都是方法的声明，一个把方法实现移交给子类，另一个移交给本地操作系统。 如果同时出现，就相当于既把实现移交给子类，又把实现移交给本地操作系统，那就会产生混乱。 Java构造方法可以有任何访问的修饰：public，protected，private或者没有修饰。 但是不能有以下非访问性质的修饰：abstract，final，native，static，或者synchronized。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"02-基础语法","slug":"02-基础语法","date":"2017-05-28T09:26:00.000Z","updated":"2017-05-29T08:31:06.157Z","comments":true,"path":"2017/05/28/02-基础语法/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/02-基础语法/","excerpt":"基础语法","text":"基础语法 问：关键字和保留字(1) Java关键字列表(依字母排序共50组) abstract, assert, boolean, break, byte, case, catch, char, class, const(保留关键字), continue, default, do, double, else, enum, extends, final, finally, float, for, goto(保留关键字), if, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while (2) 保留字列表(依字母排序共14组)，Java保留字是指现有Java版本尚未使用，但以后版本可能会作为关键字使用 byValue, cast, false, future, generic, inner, operator, outer, rest, true, var, goto(保留关键字), const(保留关键字), null 注意： (1) const和goto既是保留字又是关键字 (2) 除了const和goto，其余保留字和关键字是严格区分开的。 问：Java支持的数据类型有哪些？Java语言支持8种基本数据类型是：byte、short、int、long、float、double、boolean、char；支持3种引用数据类型：类、接口和数组。 (1) Java中整数值默认为int型，如果要指定整数为long型需要加L；浮点数值默认为double型，如果要指定浮点数为float型需要加F。 float f=3.4; //错误，3.4默认为double型。 float f=3.4F; //正确 float f=3; //正确 (2) Java中在定义类的成员变量时可以对其初始化，如果不对其初始化，Java使用默认值对其初始化；而局部变量在使用前则必须进行初始化，JVM不会进行默认值初始化。(3) Java中基本数据类型变量默认初始化值如表所示，对象引用默认初始化值为null。 图 2 问：Java中的中文字符Java语言中，中文字符所占的字节数取决于字符的编码方式，默认使用GBK编码方式。 当采用ISO8859-1编码方式时，一个中文字符占1个字节； 当采用GB2312或GBK编码方式时，一个中文字符占2个字节； 当采用UTF-8编码方式时，一个中文字符会占3个字节。 Java字符默认使用unicode编码，每个字符占用两个字节，所以char型变量可以存放一个中文字符。 Unicode字符编码标准是固定长度的字符编码方案。Unicode根据要编码的数据类型使用两种编码格式：8 位和16位。缺省编码格式是16位，即每个字符是16位(两个字节)宽。 注意：char与byte在Java和C++中的区别： 在C++中，char是基础数据类型，占1个字节；byte不是基础数据类型，一般定义为typedef unsigned char byte;也就是说，byte其实是unsigned char类型，那么也是占1个字节。不同的是，char可以表示的范围是-128-127，而byte可以表示的范围是0-255。 在java中，char和byte都是基础数据类型，其中的byte占1个字节，可以表示的范围是-128-127。而char占2个字节，可以表示的范围是’\\u0000’-‘\\uFFFF’。 例1： Java中实现国际化应用常用的手段是利用ResourceBundle类。 这个题目解答没看懂 问：类型转换(1) byte\\char\\short -&gt; int -&gt; long -&gt; float -&gt; double (2) Java中如果碰到char、byte和short参与运算时，会自动将这些值转换为int类型值然后再进行运算。 short s1 = 1; s1 = s1 + 1; //错误，s1+1运算结果是int型，需要强制转换类型 short s1 = 1; s1 += 1; //正确 short s = 16; byte a2 = s; //错误 (3) 低级向高级是隐式类型转换，高级向低级必须强制类型转换 (4) 两个数值进行二元操作时，会有如下的转换操作： 如果两个操作数其中有一个是double类型，另一个操作数将会转换为double类型； 否则，如果其中一个操作数是float类型，另一个操作数将会转换为float类型； 否则，如果其中一个操作数是long类型，另一个操作数会转换为long类型； 否则，两个操作数都转换为int类型。 例1： public static void main(String[] args){ int i=42; double d=42.0000; long l=42; float f=42.0f; float f2=42.00f; System.out.println(d==i); //true System.out.println(f==i); //true System.out.println(f==f2); //true System.out.println(l==i); //true System.out.println(l==f); //true System.out.println(d==f); //true } 例2： 对于java类型变量char c，short s，float f，double d，表达式c*s+f+d的结果类型为double 问：进制表示 八进制： 012 十六进制：0x12 问：源码、反码和补码例1： 变量a是一个64位有符号的整数，初始值用16进制表示为：0Xf000000000000000； 变量b是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF。 则a-b的结果用10进制表示为多少？ 计算机是用补码进行存储和计算的，因此a和b的初始值即为a和b在计算机中的补码形式，即：a的补码为0Xf000000000000000，b的补码为0x7FFFFFFFFFFFFFFF 0Xf000000000000000=1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x7FFFFFFFFFFFFFFF=0111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 a-b=a+(-b) 由于b是正数，原码与其补码相同，都为0x7FFFFFFFFFFFFFFF，则-b的原码为0xFFFFFFFFFFFFFFFF，是负数 现在求-b的补码，先对它的原码(除符号位外)各位取反得到-b的反码，然后反码尾部加1得到-b的补码，为 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001 所以a-b=a+(-b)= 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000+ 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001= 10111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001(最高位溢出，舍去，结果变成了正数) 则结果为0111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001=2^62+2^61+2^60+1 例2： 变量a是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF; 变量b是一个64位有符号的整数，初始值用16进制表示为：0x8000000000000000。 则a+b的结果用10进制表示为多少？ 计算机中是以补码形式存储数据，则a和b的初始值即为a和b在计算机中的补码形式。 0x7FFFFFFFFFFFFFFF+0x8000000000000000=0xFFFFFFFFFFFFFFFF 结果最高位符号位为1，说明结果为负数，现在求结果的原码值。 保持符号位不变，补码减1，得到结果的反码；保持符号位不变，反码取反，得到结果的原码：-1 例3： short a=128； byte b=(byte)a; 此时，变量a，b的值分别为128和-128 计算机是用补码进行存储和计算的，Java中short占2个字节，16位，因此a在内存中补码形式为0000 0000 1000 0000 Java中byte占1个字节，8位。将short变量强制类型转换时会截断前8位，得到1000 0000，即为b的补码形式。 现在已知a的补码为10000000，求原码。因为最高位表示符号位，所以首先这个数为负数。 保持符号位不变，补码减1，得到结果的反码1111 1111；保持符号位不变，反码取反，得到结果的原码1 0000 0000：-128 问：常见的运算符 +，%，~，三目运算符，++，&amp;&amp;和&amp;，&gt;&gt;和&gt;&gt;&gt; +： 例1： public class Test { public static void main(String args[]) { System.out.println(8+8+&quot;88&quot;+8+8); //168888 } } 例2： 若有定义语句：int a=10; double b=3.14;则表达式&apos;A&apos;+a+b 值的类型是double %：取模运算符，要求操作数为整型。 ~：按位取反运算符 例1： 若int j = 10; 则~j为多少？ 计算机是用补码进行存储和计算的，因此10在计算机中补码存储为：00000000 00000000 00000000 00001010 ~j操作是对j的补码取反，然后得到结果即为~j的补码： 11111111 11111111 11111111 11110101 现在通过~j的补码反推出~j的原码，~j最高位符号位为1，表明它是一个负数 保持符号位不变，补码减1，得到~j的反码： 11111111 11111111 11111111 11110100 保持符号位不变，反码取反，得到~j的原码： 10000000 00000000 00000000 00001011 换算为整数，~j大小为-11 三目运算符 例1： boolean b=true?false:true==true?false:true; System.out.println(b); //false ++ 例1： 假定x和y为double型，则表达式x=2，y=x+3/2的输出为3.000000 i=i++问题 Java使用了中间缓存变量机制，JVM运行这条语句时过程如下： 步骤1 JVM把i值拷贝到临时变量区； 步骤2 i值加1； 步骤3 返回临时变量区的值，注意这个值步骤1中没修改过的i值。 步骤4 返回值赋值给i，此时count值被重置成原来的值。 例2： package algorithms.com.guan.javajicu; public class Inc { public static void main(String[] args) { Inc inc = new Inc(); int i = 0; inc.fermin(i); i= i ++; System.out.println(i); } void fermin(int i){ i++; } } 程序输出结果为0 例3： public class Test2{ public void add(Byte b){ b = b++; } public void test(){ Byte a = 127; Byte b = 127; add(++a); System.out.print(a + &quot; &quot;); add(b); System.out.print(b + &quot;&quot;); } } 执行test()函数后，程序输出为：-128 127 &amp;&amp;和&amp; &amp;&amp;:短路与，若该运算符左边为false，运算符右边表达式不执行。 &amp;: 按位与，若该运算符左边为false，运算符右边表达式还会继续执行。 和&gt;&gt;&gt; >&gt; 表示带符号右移 >&gt;&gt; 表示无符号右移，左边空出的位以0填充 int x=5&gt;&gt;2; // &gt;&gt;表示带符号右移，5&gt;&gt;2相当于5除于2的平方，等于1 int y=1&gt;&gt;&gt;2; // &gt;&gt;&gt;表示无符号右移，高位用0填充，0001右移两位为0000，等于0 问：switchswitch(expr)中，expr是一个整数表达式，因此传递给switch和case语句的参数应该是int、short、char、byte或者其对应的封装类以及Enum类型，long、String(在Java7中，也支持了String类型)都不能用于swtich表达式。 在switch语句中，表达式的值不能是null，否则会在运行时抛出NullPointerException。在case子句中也不能使用null，否则会出现编译错误。 问：switch与breakswitch结构中匹配的case子句中如果没有break跳出执行，那么程序执行完case子句后不会跳出，将会继续执行后续的case子句，直到遇到break跳出switch；如果一直没有遇到break，程序将一直执行到整个结构结束。 例1： public class SwitchTest{//1 public static void main(String[] args) { System.out.println(switchit(4)); } public static int switchit(int x) { int j=1; switch (x) { case 1:j++; case 2:j++; case 3:j++; case 4:j++; case 5:j++; default:j++; } return j+x; } } 程序将会输出8 例2： public static int getValue(int i) { int result = 0; switch (i) { case 1: result = result + i; case 2: result = result + i * 2; case 3: result = result + i * 3; } return result; } 调用getValue(2)将返回10 问：值传递和引用传递？java内的传递都是值传递。 (1) 对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。 (2) 对引用型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身，所以对引用对象进行操作会同时改变原对象。 例1： public class Tester{ public static void main(String[] args){ Integer var1=new Integer(1); Integer var2=var1; doSomething(var2); System.out.println(var1.intValue()); System.out.println(var1==var2); } public static void doSomething(Integer integer){ integer=new Integer(2); } } 程序运行输出如下： 1 true 例2：注意下一评论","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"01-Java概述","slug":"01-Java概述","date":"2017-05-28T09:22:19.000Z","updated":"2017-05-29T08:31:04.392Z","comments":true,"path":"2017/05/28/01-Java概述/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/01-Java概述/","excerpt":"Java概述","text":"Java概述 问：什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？Java源文件被javac编译成能被Java虚拟机执行的.class字节码文件，Java虚拟机是一个可以执行Java字节码的虚拟机进程，它拥有自己完善的硬体架构，如堆栈、寄存器，还具有相应的指令系统。 Java虚拟机对开发者屏蔽了与具体操作系统平台相关的信息，使得Java源文件只需要被编译成可以在JVM上运行的字节码文件，就可以由相应平台的虚拟机在具体平台上解释运行，从而实现一次编译，处处执行。这样，Java被设计成允许应用程序可以运行在任意的平台上，而不需要程序员为每一个平台单独重写或者是重新编译。 问：动态语言和静态语言动态语言：运行时执行类型检查，如PHP、Ruby、Python等。 静态语言：编译时执行类型检查，如C、C++、Java和C#等。 问：编译型语言和解释型语言例1 问：JDK和JRE的区别是什么？Java运行时环境(JRE)包括Java虚拟机、Java核心类库和支持文件，JVM对Java字节码文件进行解释执行。只有JRE只能执行Java程序，不能进行java程序的开发。 Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。 例1： JRE判断程序是否执行结束的标准是：所有的前台线程执行完毕 问：一个”.java”源文件中是否可以包括多个类(不是内部类)？有什么限制？一个”.java”源文件中可以包括多个类。如果这个类的修饰符是public，其类名与文件名必须相同。 问：javac例1：下列说法正确的有哪些？ A. 环境变量可在编译source code时指定 B. 在编译程序时，所能指定的环境变量不包括class path C. javac一次可同时编译数个Java源文件 D. javac.exe能指定编译结果要置于哪个目录（directory） 答案：A C D 问：JAVA的事件委托机制和垃圾回收机制Java事件委托机制：一个源产生一个事件并将它送到一个或多个监听器那里。在这种方案中，监听器简单的等待，直到它收到一个事件。一旦事件被接受，监听器将处理这个事件，然后返回。 垃圾回收机制：垃圾收集是将分配给对象但不再使用的内存回收或释放的过程。如果一个对象没有指向它的引用或者其赋值为null，则此对象适合进行垃圾回收。 问：Java运行时数据区Java运行时数据区包括：虚拟机栈区，堆区，方法区，本地方法栈，程序计数器 虚拟机栈区：也就是我们常说的栈区，线程私有，在编译期间完成分配，为虚拟机执行Java方法(也就是字节码)服务，每个方法在执行时会创建一个栈帧用于存放局部变量表、操作数栈、动态链接和方法出口等信息，每个方法的调用直至执行完成对应于栈帧的入栈和出栈； 堆区：JAVA堆，也称GC堆，在JVM启动时创建，所有线程共享，存放对象的实例和数组，是垃圾收集器管理的主要区域。”GC堆”，可以细分为新生代和老年代，新生代又可以细分为Eden空间、From Survivor空间和To Survivor空间；物理上可以不连续，但逻辑上连续，可以选择固定大小或者扩展。 方法区：所有线程共享，用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池中的对象的回收和堆类型的卸载。方法区被称为“永久代”，是因为HotSpot虚拟机的设计团队把GC分代收集扩展到方法区，即使用永久代来实现方法区，像GC管理Java堆一样管理方法区，从而省去专门为方法区编写内存管理代码， 本地方法栈(Native Method Stacks)：线程私有，与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 程序计数器：线程私有，每个线程都有自己独立的程序计数器，用来指示下一条指令的地址，是当前线程所执行的字节码的行号指示器，如果线程正执行一个java方法，计数器记录下一条执行的虚拟机字节码指令的地址；如果线程正在执行的是Native方法，则计数器值为空； 运行时常量池：线程共享，是方法区的一部分，存放编译期Class文件中生成的各种字面量和符号引用。 例1 问：堆和栈的区别栈内存由操作系统来分配，只要栈剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出 堆内存由程序员自己来申请分配 例1： class A { private String a = &quot;aa&quot;; public boolean methodB() { String b = &quot;bb&quot;; final String c = &quot;cc&quot;; } } 上述Java代码中的变量a、b、c分别在内存的：堆区、栈区、栈区 问：Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)? 需要整理使答案更简洁JVM的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在JVM启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。 堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。 虚拟机中的堆内存共划分为三个代：年轻代（Young Generation）、年老代（Old Generation）和持久代（Permanent Generation）。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。 Java的垃圾收集机制主要针对新生代和老年代的内存进行回收，不同的垃圾收集算法针对不同的区域。所以java的垃圾收集算法使用的是分代回收。一般java的对象首先进入新生代的Eden区域，当进行GC的时候会回收新生代的区域，新生代一般采用复制收集算法，将活着的对象复制到survivor区域中，如果survivor区域装在不下，就查看老年代是否有足够的空间装下新生代中的对象，如果能装下就装下，否则老年代就执行FULL GC回收自己，老年代还是装不下，就会抛出OUtOfMemory的异常。 (1) 年轻代:所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。Minor GC是针对新生代的回收。 年轻代分三个区:一个Eden区，两个Survivor区(一般而言)。 大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区(两个中的一个)，当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。 (2) 年老代:在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。Major GC/Full GC是针对年老代的回收。 (3) 持久代:用于存放静态文件，如类、方法、final常量、static变量等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=进行设置。 例1：JVM中垃圾回收分为scanvenge gc和full GC，其中full GC触发的条件可能有哪些？ 答案：老年代满、持久代满、System.gc() 例2：以下哪些jvm的垃圾回收方式采用的是复制算法回收? A. 新生代串行收集器 B. 老年代串行收集器 C. 并行收集器 D. 新生代并行回收收集器 E. 老年代并行回收收集器 F. cms收集器 答案：A D 例3：下面哪种情况会导致持久区jvm堆内存溢出？ A. 循环上万次的字符串处理 B. 在一段代码内申请上百M甚至上G的内存 C. 使用CGLib技术直接操作字节码运行，生成大量的动态类 D. 不断创建对象 答案：C 问：JVM内存配置参数-Xmx：最大堆大小 -Xms：初始堆大小 -Xmn:年轻代大小 -XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值 例1： 当-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3时，其最小内存值和Survivor区总大小分别是() -Xms初始堆大小即最小内存值，即最小内存值为10240m JVM一般根据对象的生存周期将堆内存分为若干不同的区域，一般情况将新生代分为Eden，两块Survivor； 由-XXSurvivorRatio=3可知Eden:Survivor=3，年轻带总大小为5120m，那么Survivor区总大小为2048m 问：Java中垃圾回收(GC)有什么目的？什么时候进行垃圾回收？GC是垃圾收集的意思(Gabage Collection)，内存处理是编程人员容易出现问题的地方，忘记或者错误地内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的。 垃圾回收的目的是识别并回收堆内存中不再使用的对象所占的内存，释放资源。而栈区的内存是随着线程结束而释放的。 触发主GC(Garbage Collector，垃圾回收)的条件： (1) 当应用程序空闲时，即没有应用线程在运行时，GC会被调用。 (2) Java堆内存不足时，GC会被调用。 问：System.gc()和Runtime.gc()会做什么事情？Java提供了垃圾回收机制来帮助我们不定时的回收堆中不再使用的对象。当JVM启动时，除了启动我们的主线程外，还会启动垃圾回收线程，它运行优先非常低，会在JVM空闲时，自动回收我们不再使用的对象，释放内存空间。 程序员不能强制执行垃圾回收，可以用这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM，即垃圾回收的具体时间和顺序是无法预知的。 问：垃圾回收器的演化 问：如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？不会立即释放对象占用的内存，如果对象的引用被置为null，只是断开了当前线程栈帧中对该对象的引用关系，在下一个垃圾回收周期中，这个对象将是可被回收的。 问：串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？吞吐量收集器使用并行版本的新生代垃圾收集器，它适合于吞吐量要求较高的场合，用于中等规模和大规模数据的应用程序。 串行收集器整个扫描和复制过程均采用单线程的方式，相对于吞吐量GC来说简单；适合于单CPU、客户端级别。串行对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。 问：在Java中，对象什么时候可以被垃圾回收？当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。 问：JVM的永久代中会发生垃圾回收么？(没看懂)垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。 请参考下Java8：从永久代到元数据区(注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区) 问：内存泄漏内存泄露(Memory Leak)是指一个不再被使用的对象或者变量还在内存中占有存储空间。在C/C++语言中，内存泄露出现在开发人员忘记释放已分配的内存就会造成内存泄露。在java语言中引入垃圾回收机制，有GC负责进行回收不再使用的对象，释放内存。但是还是会存在内存泄露的问题。 内存泄露主要有两种情况 (1) 在堆中申请的空间没有释放。 (2) 对象已不再被使用(注意：这里的不再被使用是指对程序来说没有用处，如数据库连接使用后没有关，但是还是存在着引用)，但是仍然在内存中保留着。 GC机制的引入只能解决第一种情况，对于第2种情况无法保证不再使用的对象会被释放。java语言中的内存泄露主要指第2种情况。 内存泄露的原因 (1) 静态集合类。如HashMap和Vector。这些容器是静态的，生命周期和程序的生命周期一致，那么在容器中对象的生命周期也和其一样，对象在程序结束之前将不能被释放，从而会造成内存泄露。 (2) 各种连接。如数据库连接，网络连接，IO连接，不再使用时如果连接不释放容易造成内存泄露。 (3) 监听器。释放对象时往往没有相应的删除监听器，可能会导致内存泄露。 内存溢出（OOM）是指程序在申请内存时没有足够的内存供使用，进而导致程序崩溃这是结果描述。内存泄露（Memory Leak）最终会导致内存溢出。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]}]}