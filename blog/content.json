{"meta":{"title":"Hepsilion","subtitle":"Hepsilion的博客","description":"Hepsilion的博客","author":"Hepsilion","url":"https://hepsilion.github.io"},"pages":[{"title":"About","date":"2017-05-29T07:13:28.924Z","updated":"2017-04-12T15:14:25.000Z","comments":true,"path":"about/index.html","permalink":"https://hepsilion.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-05-28T07:45:09.167Z","updated":"2017-04-12T15:14:25.000Z","comments":true,"path":"categories/index.html","permalink":"https://hepsilion.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-05-28T07:45:09.170Z","updated":"2017-04-12T15:14:25.000Z","comments":true,"path":"tags/index.html","permalink":"https://hepsilion.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2017-07-22T13:35:02.340Z","updated":"2017-07-22T13:35:02.340Z","comments":true,"path":"home/index.html","permalink":"https://hepsilion.github.io/home/index.html","excerpt":"","text":"博客说明目前本博客主要记录了我前一段时间在牛客网刷题过程中遇到的一些知识点，包含：我经常出错的、我认为易错的、我经常做到的、我容易忘记的题目，以及为保持内容相对完整性而加入的内容等。部分内容均来自牛客网中题目下方别人的评论，部分内容来自于网络上别人的博客，还有一部分内容来自书籍。 由于本人水平有限，目前该博客中的内容相对简单，未来我希望能够加入一些具有更多价值含量的东西，例如机器学习、深度学习或者比较酷炫的项目说明等。如果朋友你觉得下面的内容都太简单的话，还请多多包涵。 由于时间原因，我只是加之前记录的东西添加在该博客当中，而没有检查所有内容的正确性与完整性。如果有人在看下面这些知识点的过程中，发现存在错误的地方，还请帮忙指正，谢谢。 内容分类1. 计算机基础 数据结构 操作系统 计算机网络 计算机组成原理 未整理 数据库系统概念 Linux 未整理 软件工程 未整理 软件测试 未整理 信息安全 未整理 并发 未整理 2. 算法 未整理算法 3. Java基础 01-Java概述 02-基础语法 03-面向对象编程 04-异常处理 05-数组 06-常用类 07-集合类 08-流 09-多线程 10-网络编程 11-反射 12-JDBC 4. Java Web 未整理 01-XML基础 02-Tomcat 03-Servlet 04-JSP 5. Android基础 03-Activity 04-数据存储 05-SQLite数据库 06-ContentProvider 07-BroadcastReceiver 08-Service 09-网络编程 6. C/C++ 未整理C/C++ 7. 设计模式 未整理设计模式 8. 环境配置01-使用Docker在本地搭建Hadoop分布式集群"}],"posts":[{"title":"MapReduce","slug":"MapReduce","date":"2017-06-06T14:06:35.000Z","updated":"2017-06-06T14:06:35.040Z","comments":true,"path":"2017/06/06/MapReduce/","link":"","permalink":"https://hepsilion.github.io/2017/06/06/MapReduce/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Docker-Hadoop-Helloworld","slug":"Docker-Hadoop-Helloworld","date":"2017-05-28T14:48:12.000Z","updated":"2017-05-28T14:49:46.120Z","comments":true,"path":"2017/05/28/Docker-Hadoop-Helloworld/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/Docker-Hadoop-Helloworld/","excerpt":"使用Docker在本地搭建Hadoop分布式集群本文档参考http://tashan10.com/yong-dockerda-jian-hadoopwei-fen-bu-shi-ji-qun/。","text":"使用Docker在本地搭建Hadoop分布式集群本文档参考http://tashan10.com/yong-dockerda-jian-hadoopwei-fen-bu-shi-ji-qun/。 一、 Docker安装二、构建含有Java运行环境的ubuntu镜像1. 下载ubuntu镜像使用如下命令从Docker仓库中获取ubuntu的最新镜像。 SimontekiMacBook-Pro:~ liu$ docker pull ubuntu 镜像下载完成后，使用命令docker images可以查看本地所有镜像。 SimontekiMacBook-Pro:~ liu$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest f49eec89601e 4 weeks ago 129 MB SimontekiMacBook-Pro:~ liu$ 2. 启动容器下面，我们以ubuntu镜像作为基准镜像，构建包含Java运行环境的ubuntu镜像。 先使用如下命令启动一个容器： SimontekiMacBook-Pro:~ liu$ docker run -ti ubuntu root@52573ef1de5d:/# 可以看到容器几乎瞬间就启动起来了，比虚拟机不知快了多少倍！ 3. Java安装依次执行下面命令安装Java root@52573ef1de5d:/# apt-get update root@52573ef1de5d:/# apt-get install software-properties-common python-software-properties root@52573ef1de5d:/# add-apt-repository ppa:webupd8team/java root@52573ef1de5d:/# apt-get update root@52573ef1de5d:/# apt-get install oracle-java7-installer root@52573ef1de5d:/# java -version 注意：这里安装的Java7(JDK1.7)，如需其他版本请自行修改apt-get install oracle-java7-installer命令，例如命令apt-get install oracle-java6-installer将安装JDK1.6 4. 保存镜像复本现在可以将装好Java的容器保存为一个镜像副本，将来需要的时候可以在此复本基础上构建其他镜像。 先退出上面启动的容器，将上面的容器保存为镜像ubuntu:java，然后使用docker images命令，发现ubuntu:java已保存为本地镜像。 root@52573ef1de5d:/# exit exit SimontekiMacBook-Pro:~ liu$ docker commit -m &quot;java install&quot; 52573ef1de5d ubuntu:java sha256:21716d1532e71a207cd80bcea8579e646a73d6e688ec0984562c92cdbc6296f4 SimontekiMacBook-Pro:~ liu$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu java 21716d1532e7 About a minute ago 791 MB ubuntu latest f49eec89601e 4 weeks ago 129 MB SimontekiMacBook-Pro:~ liu$ 上面命令中52573ef1de5d为之前启动的容器的ID, ubuntu:java是为复本镜像的标识，ubuntu为仓库名，java是Tag。 如何获取容器ID： 在使用到容器的ID却不知道时，可以使用下面两个方法找到容器的ID： 启动容器后，命令行中用户名@后面的那一串字符时当前启动的容器的ID，因此上面启动的容器的ID为52573ef1de5d。这个方法只在容器启动并且没有指定hostname时才能用。 使用docker ps列出所有正在运行的容器，在命令结果中查看对应容器的ID。 三、 构建含有Hadoop运行环境的ubuntu镜像下面，我们以包含Java运行环境的ubuntu镜像作为基准镜像，构建包含Hadoop运行环境的ubuntu镜像。 1. 启动容器使用刚刚已经安装了Java的容器镜像启动一个容器： SimontekiMacBook-Pro:~ liu$ docker run -ti ubuntu:java root@aac699216bce:/# 装有Java的ubuntu容器启动成功了，现在我们开始安装Hadoop。 这里，我们直接使用wget下载安装文件。 2. 安装wget使用如下命令安装wget。 root@aac699216bce:/# apt-get install -y wget 3. 下载并解压安装Hadoop文件使用如下命令下载并解压安装Hadoop。 root@aac699216bce:/# cd ~ root@aac699216bce:~# mkdir software root@aac699216bce:~# cd software root@aac699216bce:~/software# mkdir apache root@aac699216bce:~/software# cd apache/ root@aac699216bce:~/software/apache# mkdir hadoop root@aac699216bce:~/software/apache# cd hadoop/ root@aac699216bce:~/software/apache/hadoop# wget http://mirrors.sonic.net/apache/hadoop/common/hadoop-2.6.0/hadoop-2.6.0.tar.gz root@aac699216bce:~/software/apache/hadoop# tar zxvf hadoop-2.6.0.tar.gz 注意：这里我们安装的Hadoop版本是2.6.0 4. 配置环境变量由于我们使用apt-get安装java，不知道java装在什么地方，使用如下命令查看Java安装目录 root@aac699216bce:~/software/apache/hadoop# update-alternatives --config java There is only one alternative in link group java (providing /usr/bin/java): /usr/lib/jvm/java-7-oracle/jre/bin/java Nothing to configure. root@aac699216bce:~/software/apache/hadoop# 修改~/.bashrc文件，在文件末尾加入下面配置信息： export JAVA_HOME=/usr/lib/jvm/java-7-oracle export HADOOP_HOME=/root/software/apache/hadoop/hadoop-2.6.0 export HADOOP_CONFIG_HOME=$HADOOP_HOME/etc/hadoop export PATH=$PATH:$HADOOP_HOME/bin export PATH=$PATH:$HADOOP_HOME/sbin 5. 配置Hadoop下面，我们开始修改Hadoop的配置文件：core-site.xml、hdfs-site.xml、mapred-site.xml和hadoop-env.sh。 (1) 创建目录开始配置之前，执行下面命令，创建三个目录 root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0# mkdir tmp root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0# cd tmp/ root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0/tmp# pwd /root/software/apache/hadoop/hadoop-2.6.0/tmp root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0/tmp# cd .. root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0# mkdir namenode root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0# cd namenode/ root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0/namenode# pwd /root/software/apache/hadoop/hadoop-2.6.0/namenode root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0/namenode# cd .. root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0# mkdir datanode root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0# cd datanode/ root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0/datanode# pwd /root/software/apache/hadoop/hadoop-2.6.0/datanode tmp：作为Hadoop的临时目录 namenode：作为NameNode的存放目录 datanode：作为DataNode的存放目录 (2) core-site.xml配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt; &lt;!--Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file. --&gt; &lt;!-- Put site-specific property overrides in this file. --&gt; &lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/root/soft/apache/hadoop/hadoop-2.6.0/tmp&lt;/value&gt; &lt;description&gt;A base for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://master:9000&lt;/value&gt; &lt;final&gt;true&lt;/final&gt; &lt;description&gt; The name of the default file system. A URI whose scheme and authority determine the FileSystem implementation. The uri&apos;s scheme determines the config property (fs.SCHEME.impl) naming the FileSystem implementation class. The uri&apos;s authority is used to determine the host, port, etc. for a filesystem. &lt;/description&gt; &lt;/property&gt; &lt;/configuration&gt; 注意： hadoop.tmp.dir配置项值即为此前命令中创建的tmp目录路径。 fs.default.name配置为hdfs://master:9000，指向的是Master节点的主机（后续做集群配置时，需要配置这个节点，先写在这里） (3) hdfs-site.xml配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt; &lt;!-- Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file. --&gt; &lt;!-- Put site-specific property overrides in this file. --&gt; &lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;2&lt;/value&gt; &lt;final&gt;true&lt;/final&gt; &lt;description&gt;Default block replication. The actual number of replications can be specified when the file is created. The default is used if replication is not specified in create time. &lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;/root/software/apache/hadoop/hadoop-2.6.0/namenode&lt;/value&gt; &lt;final&gt;true&lt;/final&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;/root/software/apache/hadoop/hadoop-2.6.0/datanode&lt;/value&gt; &lt;final&gt;true&lt;/final&gt; &lt;/property&gt; &lt;/configuration&gt; 注意： 我们后续搭建集群环境时，将配置一个master节点和两个slave节点，所以dfs.replication配置为2。 dfs.namenode.name.dir和dfs.datanode.data.dir分别配置为之前创建的NameNode和DataNode的目录路径。 (4) mapred-site.xml配置 创建mapred-site.xml文件 cp mapred-site.xml.template mapred-site.xml 配置mapref-site.xml文件 &lt;?xml version=&quot;1.0&quot;?&gt; &lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt; &lt;!-- Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file. --&gt; &lt;!-- Put site-specific property overrides in this file. --&gt; &lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapred.job.tracker&lt;/name&gt; &lt;value&gt;master:9001&lt;/value&gt; &lt;description&gt;The host and port that the MapReduce job tracker runs at. If &quot;local&quot;, then jobs are run in-process as a single map and reduce task. &lt;/description&gt; &lt;/property&gt; &lt;/configuration&gt; 这里只有一个配置项mapred.job.tracker，我们指向master节点机器。 (5) 修改hadoop-env.sh配置修改如下配置： # The java implementation to use. export JAVA_HOME=/usr/lib/jvm/java-7-oracle 6. 安装SSH搭建集群环境，自然少不了使用SSH，这可以实现无密码访问，访问集群机器的时候很方便。 root@aac699216bce:~# apt-get install ssh 7. 生成访问密钥root@aac699216bce:~# cd ~/ root@aac699216bce:~# ssh-keygen -t rsa -P &apos;&apos; -f ~/.ssh/id_dsa Generating public/private rsa key pair. Created directory &apos;/root/.ssh&apos;. Your identification has been saved in /root/.ssh/id_dsa. Your public key has been saved in /root/.ssh/id_dsa.pub. The key fingerprint is: SHA256:SO6qH6zwvNUKDqVWDYcexe7OQBJ3Jy5vd/mZlF6FiWM root@aac699216bce The key&apos;s randomart image is: +---[RSA 2048]----+ | .. | | . .o+ . | | o++.+ . o | | ..o== . E o . | | +o+.o S o o . | | o.o * . o o . | |+.. O + . + + | |.* + * = | | B++ | +----[SHA256]-----+ root@aac699216bce:~# cd .ssh root@aac699216bce:~/.ssh# cat id_dsa.pub &gt;&gt; authorized_keys 注意： 这里思路是直接将密钥生成后写入镜像，免得在每个容器里面再单独生成一次，还要相互拷贝公钥，比较麻烦。当然这只是学习使用，实际操作时，应该不会这么搞，因为这样所有容器的密钥都是一样的！！ 8. 保存镜像我们将安装好Hadoop的镜像保存为一个镜像副本ubuntu:hadoop，然后使用docker images命令，发现ubuntu:hadoop已保存为本地镜像。 root@aac699216bce:~# exit exit SimontekiMacBook-Pro:~ liu$ docker commit -m &quot;hadoop install&quot; aac699216bce ubuntu:hadoop sha256:b6c13157056ff28c5b8703991bd1c4ba993bc7a3fae17547bff82eedae571529 SimontekiMacBook-Pro:~ liu$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu hadoop b6c13157056f 18 seconds ago 1.35 GB ubuntu java 21716d1532e7 About an hour ago 791 MB ubuntu latest f49eec89601e 4 weeks ago 129 MB 四、 搭建Hadoop分布式集群按照hadoop集群的基本要求，集群中至少需要有3个结点，其中一个为master结点，主要是用于运行hadoop集群中的namenode、secondorynamenode和jobtracker(新版本名字变了)任务；另外两个结点均为slave结点，其中一个节点作为冗余节点。 1. 启动容器打开三个命令行，每个命令行各启动一个容器，其中一个容器作为master节点，另外两个容器作为slave节点。 ####(1)启动master容器 SimontekiMacBook-Pro:~ liu$ docker run -ti -d -p 50070:50070 -h master ubuntu:hadoop d13443e6f6e3575beee69e9cc51f0569067dc0b96fb24a756578aa610ce3310c 这里使用镜像创建容器时，将容器的50070端口映射为本地的50070端口，便于后面可以直接在本地浏览器访问集群的状态。 使用docker ps查看启动的master容器对应的ID，然后使用下面命令进入master容器。 SimontekiMacBook-Pro:~ liu$ docker attach d13443e6f6e3 root@master:/# (2)启动slave1容器SimontekiMacBook-Pro:~ liu$ docker run -ti -h slave1 ubuntu:hadoop Missing privilege separation directory: /var/run/sshd root@slave1:/# (3)启动slave2容器SimontekiMacBook-Pro:~ liu$ docker run -ti -h slave2 ubuntu:hadoop Missing privilege separation directory: /var/run/sshd root@slave2:/# 2. 配置hosts(1)查看各节点ip由于在不同的网络环境下，容器获取的ip可能不一样，例如本机三个容器获取的ip分别如下： master: 172.17.0.2 slave1: 172.17.0.3 slave2: 172.17.0.4 (2)修改各节点的hosts文件根据(1)中查看得到的各节点ip配置hosts文件 172.17.0.2 master 172.17.0.3 slave1 172.17.0.4 slave2 (3)配置slaves下面配置哪些节点是slave。 较老版本的Hadoop中有一个masters文件和一个slaves文件，但新版本中只有slaves文件了。 在master节点容器中执行如下命令打开slaves配置文件： root@master:~/software/apache/hadoop/hadoop-2.6.0/etc/hadoop# vim slaves 将所有slave节点的hostname写入该文件： slave1 slave2 3. 启动Hadoop(1)启动SSH服务在每个节点上之下下面命令，启动SSH服务，实现无密码访问。 master节点 root@master:~/software/apache/hadoop/hadoop-2.6.0/etc/hadoop# /etc/init.d/ssh start * Starting OpenBSD Secure Shell server sshd [ OK ] root@master:~/software/apache/hadoop/hadoop-2.6.0/etc/hadoop# slave1节点 root@slave1:~# /etc/init.d/ssh start * Starting OpenBSD Secure Shell server sshd [ OK ] root@slave1:~# slave2节点 root@slave2:~# /etc/init.d/ssh start * Starting OpenBSD Secure Shell server sshd [ OK ] root@slave2:~# (2)格式化 namenoderoot@master:~/software/apache/hadoop/hadoop-2.6.0/bin# ./hadoop namenode -format (3)启动hadoop在master节点上执行start-all.sh命令，启动Hadoop root@master:~/software/apache/hadoop/hadoop-2.6.0/sbin# ./start-all.sh This script is Deprecated. Instead use start-dfs.sh and start-yarn.sh Starting namenodes on [master] master: starting namenode, logging to /root/software/apache/hadoop/hadoop-2.6.0/logs/hadoop-root-namenode-master.out slave2: starting datanode, logging to /root/software/apache/hadoop/hadoop-2.6.0/logs/hadoop-root-datanode-slave2.out slave1: starting datanode, logging to /root/software/apache/hadoop/hadoop-2.6.0/logs/hadoop-root-datanode-slave1.out Starting secondary namenodes [0.0.0.0] 0.0.0.0: starting secondarynamenode, logging to /root/software/apache/hadoop/hadoop-2.6.0/logs/hadoop-root-secondarynamenode-master.out starting yarn daemons starting resourcemanager, logging to /root/software/apache/hadoop/hadoop-2.6.0/logs/yarn--resourcemanager-master.out slave1: starting nodemanager, logging to /root/software/apache/hadoop/hadoop-2.6.0/logs/yarn-root-nodemanager-slave1.out slave2: starting nodemanager, logging to /root/software/apache/hadoop/hadoop-2.6.0/logs/yarn-root-nodemanager-slave2.out root@master:~/software/apache/hadoop/hadoop-2.6.0/sbin# 如果看到如下信息，则说明启动成功了。 在个节点上执行jps命令，结果如下： master节点 root@master:~/software/apache/hadoop/hadoop-2.6.0/sbin# jps 2149 Jps 1887 ResourceManager 1560 NameNode 1736 SecondaryNameNode root@master:~/software/apache/hadoop/hadoop-2.6.0/sbin# slave1节点 root@slave1:~# jps 352 DataNode 454 NodeManager 569 Jps slave2节点 root@slave2:~# jps 252 DataNode 354 NodeManager 469 Jps 下面，我们在master节点上通过命令hdfs dfsadmin -report查看DataNode是否正常启动 root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# ./hdfs dfsadmin -report Configured Capacity: 134743154688 (125.49 GB) Present Capacity: 117625421824 (109.55 GB) DFS Remaining: 117625372672 (109.55 GB) DFS Used: 49152 (48 KB) DFS Used%: 0.00% Under replicated blocks: 0 Blocks with corrupt replicas: 0 Missing blocks: 0 ------------------------------------------------- Live datanodes (2): Name: 172.17.0.4:50010 (slave2) Hostname: slave2 Decommission Status : Normal Configured Capacity: 67371577344 (62.74 GB) DFS Used: 24576 (24 KB) Non DFS Used: 8558866432 (7.97 GB) DFS Remaining: 58812686336 (54.77 GB) DFS Used%: 0.00% DFS Remaining%: 87.30% Configured Cache Capacity: 0 (0 B) Cache Used: 0 (0 B) Cache Remaining: 0 (0 B) Cache Used%: 100.00% Cache Remaining%: 0.00% Xceivers: 1 Last contact: Wed Feb 22 12:58:22 UTC 2017 Name: 172.17.0.3:50010 (slave1) Hostname: slave1 Decommission Status : Normal Configured Capacity: 67371577344 (62.74 GB) DFS Used: 24576 (24 KB) Non DFS Used: 8558866432 (7.97 GB) DFS Remaining: 58812686336 (54.77 GB) DFS Used%: 0.00% DFS Remaining%: 87.30% Configured Cache Capacity: 0 (0 B) Cache Used: 0 (0 B) Cache Remaining: 0 (0 B) Cache Used%: 100.00% Cache Remaining%: 0.00% Xceivers: 1 Last contact: Wed Feb 22 12:58:22 UTC 2017 root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# 还可以通过Web页面http://127.0.0.1:50070/看到查看DataNode和NameNode的状态。 4. WordCount实例(1) 创建本地单词文件words.txtroot@master:~/software/apache/hadoop/hadoop-2.6.0/bin# touch words.txt root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# 在words.txt文件中写入单词。 （2）将单词文件words.txt上传到到hdfs上root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# ./hdfs dfs -ls / root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# ./hdfs dfs -put words.txt / root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# ./hdfs dfs -ls / Found 1 items -rw-r--r-- 2 root supergroup 1763 2017-02-22 14:42 /words.txt root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# (3) 执行wordcount程序root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# ./hadoop jar ../share/ hadoop/mapreduce/hadoop-mapreduce-examples-2.6.0.jar wordcount /words.txt /out (4) 查看结果root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# ./hdfs dfs -text /out/part-r-00000","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://hepsilion.github.io/categories/环境配置/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hepsilion.github.io/tags/docker/"},{"name":"hadoop","slug":"hadoop","permalink":"https://hepsilion.github.io/tags/hadoop/"}],"keywords":[{"name":"环境配置","slug":"环境配置","permalink":"https://hepsilion.github.io/categories/环境配置/"}]},{"title":"C plus plus","slug":"C-plus-plus","date":"2017-05-28T11:03:50.000Z","updated":"2017-05-28T11:04:33.544Z","comments":true,"path":"2017/05/28/C-plus-plus/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/C-plus-plus/","excerpt":"C++","text":"C++ 一、概述二、基础语法整型一般我们把short称为短整型，把int称为整型，把long称为长整型，把long long称为超长整型。以unsigned开头的那些整数类型统称为无符号整型。例如：我们称unsigned short为无符号短整型，以此类推。 问：https://www.nowcoder.com/profile/7404313/test/8046125/55536?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8046125/23331?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8078490/15721?onlyWrong=0 问：求一个整数二进制表示中1的个数int fun(int x){ int countx = 0; while(x){ countx++; x = x &amp; (x – 1); } return countx; ｝ 问：forkhttps://www.nowcoder.com/profile/7404313/test/7993780/1023?onlyWrong=0 问：各种数据类型的大小(单位Bytes) 32位系统 64位系统 char 1 1 short 2 2 int 4 4 指针 4 8 long 4 8 float 4 4 double 8 8 long long 8 问：一道题目的分析(y^(x^y)&amp;-(x","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://hepsilion.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://hepsilion.github.io/tags/C/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://hepsilion.github.io/categories/C-C/"}]},{"title":"Probability Theory","slug":"Probability-Theory","date":"2017-05-28T11:02:06.000Z","updated":"2017-05-28T11:02:42.408Z","comments":true,"path":"2017/05/28/Probability-Theory/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/Probability-Theory/","excerpt":"概率论与数理统计","text":"概率论与数理统计 问：全概率和后验概率案例： https://www.nowcoder.com/profile/7404313/test/7971904/14885?onlyWrong=0","categories":[{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://hepsilion.github.io/categories/概率论与数理统计/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"https://hepsilion.github.io/tags/概率论/"},{"name":"数理统计","slug":"数理统计","permalink":"https://hepsilion.github.io/tags/数理统计/"}],"keywords":[{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://hepsilion.github.io/categories/概率论与数理统计/"}]},{"title":"信息安全总结","slug":"信息安全","date":"2017-05-28T11:01:20.000Z","updated":"2017-05-31T03:18:01.069Z","comments":true,"path":"2017/05/28/信息安全/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/信息安全/","excerpt":"信息安全","text":"信息安全 问：计算机病毒计算机病毒实质上是一种特殊的计算机程序，一般具有寄生性、破坏性、传染性、潜伏性和隐蔽性 问：加密算法是双向的，摘要算法是单向的摘要算法是单向的，即明文可以通过摘要算法生成摘要结果，但反之则不能通过摘要结果还原成明文，所以不可逆；加密算法是双向的，即可以从明文通过加密算法生成密文，反之也可以通过解密算法将密文还原成明文，所以可逆。 对称加密算法 DES 3DES AES：高级加密标准，是下一代的加密算法标准，速度快，安全级别高。 AES的区块长度固定为128比特，密钥长度则可以是128、192或256比特。 Blowfish：BlowFish算法用来加密64Bit长度的字符串，它使用两个盒，一个是unsigned long pbox[18]，一个是unsigned long sbox[4*256]。 Twofish IDEA RC6 CAST5 Serpent 攻击DES最有效方法是密钥穷举攻击，因为它使用56位密钥过短，已经被高级加密标准如AES所替代 非对称加密算法 DHA(差异哈希算法) RSA：TLS/SSL协议中RSA的公钥长度一般为1024或2048位，它的安全性依赖于大数分解。 EIGamal DSA：数字签名算法，是一种标准的DSS(数字签名标准)。 ECC 信息摘要算法 MD5 SHA1 SHA512 CRC-32 问：RSAhttps://www.nowcoder.com/profile/7404313/test/8122789/46253?onlyWrong=0 问：MD5摘要算法，不是加密算法MD5即Message-Digest Algorithm 5(信息-摘要算法5)，用于确保信息传输完整一致，是计算机广泛使用的杂凑算法之一(又译摘要算法、哈希算法)，主流编程语言普遍已有MD5实现。将数据(如汉字)运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。 MD5算法具有以下特点： 压缩性：任意长度的数据，算出的MD5值长度都是固定的。 容易计算：从原数据计算出MD5值很容易。 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。 弱抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据(即伪造数据)是非常困难的。 强抗碰撞：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。 MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式(就是把一个任意长度的字节串变换成一定长的十六进制数字串)。除了MD5以外，其中比较有名的还有SHA-1、RIPEMD以及Haval等。 注意：由于MD5是单向不可逆的，所以不可以解密，不能用来对文本进行加密，只能用来签名，校验数据的完整性 问：HttpsHTTP协议通常承载于TCP协议之上，有时也承载于TLS(安全传输层协议)或SSL(安全套接层协议Secure Sockets Layer)协议层之上，这个时候，就成了我们常说的HTTPS。 问：常见的攻击方法 Vulnerability scan，缺陷/弱点扫描 SQL Injection，SQL注入攻击 Drive-by downloading Brute force，暴力破解 问：实现防火墙的主流技术(1) 包过滤技术 包过滤是最早使用的一种防火墙技术，包过滤技术工作的地方就是各种基于TCP/IP协议的数据报文进出的通道，它把这两层作为数据监控的对象，对每个数据包的头部、协议、地址、端口、类型等信息进行分析，并与预先设定好的防火墙过滤规则(Filtering Rule)进行核对，一旦发现某个包的某个或多个部分与过滤规则匹配并且条件为”阻止”的时候，这个包就会被丢弃。 (2) 应用代理技术 由于包过滤技术无法提供完善的数据保护措施，而且一些特殊的报文攻击仅仅使用过滤的方法并不能消除危害(如SYN攻击、ICMP洪水等)，因此人们需要一种更全面的防火墙保护技术，在这样的需求背景下，采用”应用代理”(Application Proxy)技术的防火墙诞生了。一个完整的代理设备包含一个服务端和客户端，服务端接收来自用户的请求，调用自身的客户端模拟一个基于用户请求的连接到目标服务器，再把目标服务器返回的数据转发给用户，完成一次代理工作过程。应用级网关和代理服务器技术都是是应用代理技术实现防火墙。 (3) 状态检测技术 这种防火墙技术通过一种被称为”状态监视”的模块，在不影响网络安全正常工作的前提下采用抽取相关数据的方法对网络通信的各个层次实行监测，并根据各种过滤规则作出安全决策。 问：能加强家用路由器的网络安全的措施 将wifi加密方式从wep改为wpa2 关闭wan管理端口 关闭upnp 配置MAC地址绑定 升级路由器固件 问：交换机攻击交换机攻击主要有以下5种类型： vlan跳跃攻击 生成树攻击 mac表洪水攻击 arp攻击 vtp攻击 问：DNS欺骗的方式hosts文件篡改， 本机DNS服务器IP地址篡改，DNS通讯包篡改 https://www.nowcoder.com/profile/7404313/test/8122845/15110?onlyWrong=0","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"信息安全","slug":"信息安全","permalink":"https://hepsilion.github.io/tags/信息安全/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"软件测试总结","slug":"软件测试","date":"2017-05-28T11:00:19.000Z","updated":"2017-05-31T03:17:47.329Z","comments":true,"path":"2017/05/28/软件测试/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/软件测试/","excerpt":"软件测试","text":"软件测试 软件测试软件测试的对象包括源程序、目标程序、数据及相关文档 单元测试(Unit Testing)单元测试(unit testing)，是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如C语言中单元指一个函数，Java里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。 单元测试能发现约80%的软件缺陷。 测试用例测试用例(Test Case)是为测试设计的数据，由测试输入数据和与之对应的预期输出结果两部分组成 https://www.nowcoder.com/profile/7404313/test/8133610/55464?onlyWrong=0 瀑布模型中的软件测试按照瀑布模型的阶段划分，软件测试可以分为单元测试，集成测试，系统测试。 系统测试：压力测试，功能测试，安全测试，性能测试 集成测试：接口测试 内测和公测内侧是开发人员与用户、测试人员一起进行的，而公测是仅有用户参与的 黑盒测试黑盒测试是对软件已经实现的功能是否满足需求进行测试和验证，黑盒测试完全不考虑程序内部的逻辑结构和内部特性，只根据程序的需求和功能规格说明，检查程序的功能是否符合它的功能说明 白盒测试https://www.nowcoder.com/profile/7404313/test/8133610/55176?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133610/26144?onlyWrong=0 软件测试的步骤单元测试、集成测试、确认测试和系统测试 https://www.nowcoder.com/profile/7404313/test/8133610/3137?onlyWrong=0 alpha测试与beta测试的区别https://www.nowcoder.com/profile/7404313/test/8133610/14374?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133610/4480?onlyWrong=0 软件验收测试的合格通过准则https://www.nowcoder.com/profile/7404313/test/8133610/56351?onlyWrong=0 负载测试，容量测试和强度测试https://www.nowcoder.com/profile/7404313/test/8133610/14375?onlyWrong=0 ###集成测试的过程 https://www.nowcoder.com/profile/7404313/test/8133610/14368?onlyWrong=0 测试设计员的职责测试设计人员主要负责设计测试用例以及设计测试过程。 测试工具https://www.nowcoder.com/profile/7404313/test/8133610/14488?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133610/14491?onlyWrong=0","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://hepsilion.github.io/tags/软件工程/"},{"name":"软件测试","slug":"软件测试","permalink":"https://hepsilion.github.io/tags/软件测试/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"Concurrency","slug":"Concurrency","date":"2017-05-28T10:59:30.000Z","updated":"2017-05-28T10:59:57.497Z","comments":true,"path":"2017/05/28/Concurrency/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/Concurrency/","excerpt":"并发","text":"并发 问：并发与并行两个线程并发执行以下代码，假设a是全局变量，初始为1，那么执行完下列语句后的输出可能为：3 2，2 3，3 3和2 2 void foo(){ ++a; printf(&quot;%d &quot;,a); } 解释还不是特别清楚 https://www.nowcoder.com/profile/7404313/test/8115789/3939?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8120272/3356 https://www.nowcoder.com/profile/7404313/test/8120272/4607?onlyWrong=0 问：进程同步为禁止两个进程同时进入临界区，同步机制应该遵循一下基本准则： 空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。 忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待。 有限等待：对要求访问临界资源的进程，应保证能在有限的时间内进入临界区。 让权等待：当进程不能进入自己的临界区时，应立即释放处理机，防止进程忙等待。 问：死锁死锁产生的原因 系统资源的竞争，资源出现循环等待 https://www.nowcoder.com/profile/7404313/test/8067759/14356?onlyWrong=0 死锁产生的必要条件 互斥条件：一个资源在一段时间内仅为一个进程所占有，此时若有其他进程请求该资源，则请求进程只能等待。 不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放。 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不妨。 循环等待条件：存在一种资源的进程循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。即存在一个处于等待状态的进程集合{P1, P2, …, Pn}，其中Pi等待的资源被P(i+1)占有，Pn等待的资源被P0占有。 死锁的处理策略 (1) 死锁预防：破坏产生死锁的四个必要条件中的一个或几个，防止发生死锁。 (2) 死锁避免：死锁避免同样属于事先预防的策略，但并不是事先采取某种限制措施破坏死锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。 银行家算法是最著名的死锁避免算法。 (3) 死锁检测 问：共享内存共享内存是进程间通信的一种方式。尽管每个进程都有自己的内存地址，但是不同的进程可以同时将同一个内存页面映射到自己的地址空间中，所有进程都可以访问共享内存中的地址，从而达到共享内存的目的。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。共享内存并未提供同步机制，也就是说，在第一个进程结束对共享内存的写操作之前，并无自动机制可以阻止第二个进程开始对它进行读取。所以我们通常需要使用像信号量这样的同步机制来限制对共享内存的访问。 其他问：无锁化编程https://www.nowcoder.com/profile/7404313/test/8120272/4043?onlyWrong=0","categories":[{"name":"并发","slug":"并发","permalink":"https://hepsilion.github.io/categories/并发/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://hepsilion.github.io/tags/并发/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"https://hepsilion.github.io/categories/并发/"}]},{"title":"Design Pattern","slug":"Design-Pattern","date":"2017-05-28T10:58:37.000Z","updated":"2017-07-22T13:29:54.553Z","comments":true,"path":"2017/05/28/Design-Pattern/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/Design-Pattern/","excerpt":"设计模式","text":"设计模式 问：设计模式分类设计模式主要分三个类型：创建型、结构型和行为型。 创建型模式：社会化的分工越来越细，自然在软件设计方面也是如此，因此对象的创建和对象的使用分开也就成为了必然趋势。因为对象的创建会消耗掉系统的很多资源，所以单独对对象的创建进行研究，从而能够高效地创建对象就是创建型模式要探讨的问题。这里有6个具体的创建型模式可供研究，它们分别是：抽象工厂模式、工厂方法模式、建造者模式、原型模式、单例模式。 (0) 简单工厂模式 https://www.nowcoder.com/profile/7404313/test/8133214/25215?onlyWrong=0 (1) 抽象工厂模式(Abstract Factory)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。 (2) 工厂方法模式(Factory Method)：定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类。 (3) 建造模式(Builder)：将一个复杂对象的构建与他的表示相分离，使得同样的构建过程可以创建不同的表示。 (4) 原型模式(Prototype)：用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象。 (5) 单例模式(Singleton)：保证一个类只有一个实例，并提供一个访问它的全局访问点 结构型模式：在解决了对象的创建问题之后，对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点，因为如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等。对象结构的设计很容易体现出设计人员水平的高低，这里有7个具体的结构型模式可供研究，它们分别是：外观模式、适配器模式、代理模式、装饰器模式、桥接模式、组合模式、享元模式。 (6) 外观模式(Facade)：为子系统中的一组接口提供一致的界面，fa?ade提供了一高层接口，这个接口使得子系统更容易使用。 (7) 适配器模式(Adapter)：将一类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作那些类可以一起工作。 (8) 代理模式(Proxy)：为其他对象提供一种代理以控制对这个对象的访问 (9) 装饰器模式(Decorator)：动态地给一个对象增加一些额外的职责，就增加的功能来说，Decorator模式相比生成子类更加灵活。 (10) 桥接模式(Bridge)：将抽象部分与它的实现部分相分离，使他们可以独立的变化。 (11) 组合模式(Composite)：将对象组合成树形结构以表示部分整体的关系，Composite使得用户对单个对象和组合对象的使用具有一致性。 (12) 享元模式(Flyweight) 行为型模式：在对象的结构和对象的创建问题都解决了之后，就剩下对象的行为问题了，如果对象的行为设计的好，那么对象的行为就会更清晰，它们之间的协作效率就会提高，这里有11个具体的行为型模式可供研究，它们分别是：模板方法模式、观察者模式、状态模式、策略模式、责任链模式、命令模式、访问者模式、中介者模式、备忘录模式、迭代器模式、解释器模式。 (13) 模板方法模式(Template Method)：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可以重定义该算法得某些特定步骤。 (14) 观察者模式(Observer)：定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新。 (15) 状态模式(State)：允许对象在其内部状态改变时改变他的行为。对象看起来似乎改变了他的类。 (16) 策略模式(Strategy)：定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们的客户。 (17) 责任链模式(Chain of Responsibility)：使多个对象都有机会处理请求，从而避免请求的送发者和接收者之间的耦合关系 (18) 命令模式(Command)：将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。 (19) 访问者模式(Visitor)：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作。 (20) 中介者模式(Mediator)：用一个中介对象封装一些列的对象交互。 (21) 备忘录模式(Memento)：在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 (22) 迭代器模式(Iterator)：提供一个方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示。 (23) 解释器模式(Interpreter)：给定一个语言，定义他的文法的一个表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 工厂方法模式https://www.nowcoder.com/profile/7404313/test/8133214/1466?onlyWrong=0 装饰器模式https://www.nowcoder.com/profile/7404313/test/8130955/50973?onlyWrong=0 策略模式https://www.nowcoder.com/profile/7404313/test/8133296/3006?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8114731/1063?onlyWrong=0 观察者模式https://www.nowcoder.com/profile/7404313/test/8114731/4716?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8129910/15064?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8129910/25593?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8129910/25465?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8130955/3006?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/55299?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/1063?onlyWrong=0","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://hepsilion.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://hepsilion.github.io/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"https://hepsilion.github.io/categories/设计模式/"}]},{"title":"软件工程总结","slug":"软件工程","date":"2017-05-28T10:57:43.000Z","updated":"2017-07-22T13:29:03.565Z","comments":true,"path":"2017/05/28/软件工程/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/软件工程/","excerpt":"软件工程","text":"软件工程 本文档总结软件工程的一些知识，侧重于了解。 问：计算机软件计算机软件指的是计算机系统中与硬件相互依赖的另一部分，包括程序、数据和有关的文档。 问：软件危机的主要原因缺乏好的开发方法和手段；软件本身特点；开发效率低。 软件生命周期软件生命周期分为3个阶段：软件定义阶段、软件开发阶段 (1) 软件定义阶段，任务是确定软件开发工作必须完成的目标，确定工程的可行性； (2) 软件开发阶段，任务是具体完成设计和实现定义阶段所定义的软件，通常包括总体设计、详细设计、编码和测试； (3) 软件维护阶段，任务是使软件在运行中持久地满足用户的需要。 https://www.nowcoder.com/profile/7404313/test/8130955/3131?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8130955/55220?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8130955/57997?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/58141?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/57880?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/57923?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/58000?onlyWrong=0 结构化方法软件需求分析工具结构化分析的常用工具有数据流图、数据字典、判定树和判定表 https://www.nowcoder.com/profile/7404313/test/8133296/3129?onlyWrong=0 问：软件设计的主要任务https://www.nowcoder.com/profile/7404313/test/8133296/3133 软件设计，包括软件的结构设计、数据设计、接口设计和过程设计。 结构设计 ：定义软件系统各主要部件之间的关系； 数据设计 ：将模型转换成数据结构的定义； 接口设计 ：软件内部，软件和操作系统间及软件和人之间如何通信； 过程设计 ：系统结构部件转换成软件的过程描述。 面向过程的系统采用的集成策略对面向过程的系统采用的集成策略有自顶向下(也就是先整体再局部)和自底向上(也就是先局部再整体)两种 问：软件工程的三要素方法(开发方法)、工具(支持方法的工具)、过程(管理过程)。 问：软件需求分析阶段的主要工作需求分析是软件生命周期的一个重要阶段，它的基本任务是准确地回答”系统必须做什么”这个问题，它的主要工作分为4个方面，分别为需求获取、需求分析、编写需求规格说明书及需求评审。 需求获取是通过和用户的接触初步确定系统的功能； 需求分析的任务是确定系统必须完成哪些工作，也就是对目标系统提出完整、准确、清晰、具体的要求； 在需求分析阶段结束以前，系统分析员应该写出需求规格说明书； 需求评审是根据需求规格说明书来严格审查和验证需求分析的结果。 问：软件需求规格说明软件需求规格说明应重点描述软件的目标，包括软件的功能需求、性能需求、外部接口、属性及约束条件等。 功能需求是软件需求规格说明，给出软件要执行什么功能的详尽描述。 性能需求是指定量的描述软件系统应满足的具体性能需求，即各种软件功能的速度、响应时间、恢复时间。 外部接口指软件如何与人、系统的硬件及其他硬件和其他软件进行交互。 属性是指与软件有关的质量属性，如正确性、可用性、可靠性、安全性、可维护性等。 约束条件包括影响软件实现的各种设计约束，如使用的标准、编程语言、数据库完整性方针、资源限制、运行环境等方面的要求。 https://www.nowcoder.com/profile/7404313/test/8129910/58186?onlyWrong=0 问：软件需求规格说明书的作用软件需求规格说明书的编制是为了使用户和软件开发者双方对该软件的初始规定有一个共同的理解，使之成为整个开发工作的基础。软件需求规格说明书包含硬件、功能、性能、输入输出、接口界面、警示信息、保密安全、数据与数据库、文档和法规的要求。 软件规格说明书是开发软件的方向，程序员要根椐需求规格说明书去开发软件，作用在于便于用户、开发人员进行理解和交流，反映出用户问题的结构，可以作为软件开发工作的基础和依据，并作为确认测试和验收的依据。但不包括软件设计的依据。 https://www.nowcoder.com/profile/7404313/test/8114731/3132 https://www.nowcoder.com/profile/7404313/test/8133214/3132?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133296/58071?onlyWrong=0 软件设计软件设计是软件工程的重要阶段，是一个把软件需求转换为软件表示的过程。软件设计的基本目标是用比较抽象概括的方式确定目标系统如何完成预定的任务，即解决软件“怎么做”的问题。 面向数据流的设计方法在面向数据流的设计方法中，一般把数据流图中的数据划分变换流和事务流。 (1) 交换流：信息沿输入通路进入系统，同时由外部形式变换为内部形式，进入系统的信息通过变换中心，经加工处理以后再沿输出通路变换成外部形式离开软件系统。 (2) 事务流：沿传入路径进入系统，由外部形式变换为内部形式后到达事务中心，事务中心根据数据项计值结果从若干动作路径中选定一条执行。有这样形状的成为事务流。 关联、聚合和组合https://www.nowcoder.com/profile/7404313/test/8130955/15073?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8130955/15866?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/55300?onlyWrong=0 问：软件开发模型https://www.nowcoder.com/profile/7404313/test/8114731/56412?onlyWrong=0 快速原型法https://www.nowcoder.com/profile/7404313/test/8129910/4441#summary https://www.nowcoder.com/profile/7404313/test/8133214/4441?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/2232?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133296/4436?onlyWrong=0 问：瀑布模型瀑布模型，提供一种结构化的、自顶向下的软件开发方法，是所有软件生命周期模型的基础。 https://www.nowcoder.com/profile/7404313/test/8129910/4443?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8130955/4442?onlyWrong=0 问：演化模型演化模型，针对实现不能完整定义需求的软件项目，利用迭代的思想，使软件逐步开发、逐步完善的机制，产品需求分解成多组，分批循环开发。 问：螺旋模型螺旋模型，遵从瀑布模型，迭代和风险驱动的开发过程，将瀑布模型的多个阶段转化到多个迭代过程中，适合大型系统的开发。过程：需求、架构、设计、开发、测试。 https://www.nowcoder.com/profile/7404313/test/8130955/4444?onlyWrong=0 螺旋模型是一种演化软件开发过程模型，它兼顾了快速原型的迭代特征以及瀑布模型的系统化与严格监控。螺旋模型最大的特点在于引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。同时，在每个迭代阶段构建原型是螺旋模型用以减小风险的途径。螺旋模型更适合大型的昂贵的系统级的软件应用。 问：喷泉模型喷泉模型，主要用于面向对象软件技术开发项目，特点是各项活动之间没有明显界限。过程为：分析、设计、实现、确认、维护和演化。 问：软件设计中模块划分应遵循的准则 高内聚低偶合：指功能集中模块化，低耦合只模块之间相互影响尽量小，改动一个模块不影响另一个模块或者尽可能减少影响 模块大小规模适当 模块的依赖关系适当等 https://www.nowcoder.com/profile/7404313/test/8129910/57922?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8130955/22264?onlyWrong=0 E-R模型向关系模型的转换的规则https://www.nowcoder.com/profile/7404313/test/8133214/4462?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/57907?onlyWrong=0 代码评审代码评审也称代码复查，是指通过阅读代码来检查源代码与编码标准的符合性以及代码质量的活动。 问：结构化程序设计的原则自顶向下、逐步求精、模块化、限制使用goto语句 维护性的特性https://www.nowcoder.com/profile/7404313/test/8129910/2231?onlyWrong=0 软件实施活动的进入准则需求工件已经被基线化，详细设计工件已经被基线化，构架工件已经被基线化 问：在数据流图中，用标有名字的箭头表示数据流。在程序流程图中，用标有名字的箭头表示控制流。 问：模型驱动开发技术过程建模 数据建模 对象建模。 工厂模式是比较常用的设计模式，它遵循了设计原则中的开放-封闭原则。https://www.nowcoder.com/profile/7404313/test/8129910/55299 其他系统软件中主要包括操作系统，语言处理程序和实用程序。 层次模型、网状模型和关系模型不知道考什么 https://www.nowcoder.com/profile/7404313/test/8129910/2277?onlyWrong=0 B/S架构软件与C/S架构软件的区别C/S又称Client/Server或客户/服务器模式。服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix或 SQL Server。客户端需要安装专用的客户端软件。 B/S是Brower/Server的缩写，客户机上只要安装一个浏览器（Browser），如Netscape Navigator或Internet Explorer，服务器安装Oracle、Sybase、Informix或 SQL Server等数据库。浏览器通过Web Server 同数据库进行数据交互。 https://www.nowcoder.com/profile/7404313/test/8129910/15285?onlyWrong=0 面向对象的五大原则https://www.nowcoder.com/profile/7404313/test/8066549/14362?onlyWrong=0 MVChttps://www.nowcoder.com/profile/7404313/test/8130955/45212?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8130955/1331?onlyWrong=0 名词辨析：CAD、CAI、CAM、CASE CAD(Computer Aided Design)：计算机辅助设计，指利用计算机及其图形设备帮助设计人员进行设计工作。 CAI(Computer Aided Instruction)：计算机辅助教学，是在计算机辅助下进行的各种教学活动，以对话方式与学生讨论教学内容、安排教学进程、进行教学训练的方法与技术。 CAM(Computer Aided Manufacturing)：计算机辅助制造 ，是将计算机应用于制造生产过程的过程或系统。 CASE(Computer Aided Software Engineering):计算机辅助软件工程，用来辅助软件开发、运行、维护、管理、支持等过程中的活动的软件称为软件开发工具。 在面向对象方法中，对象有如下一些基本特点：标识唯一性、分类性、多态性、封装性、模块独立性好。DAO模式DAO的本质是提供数据访问接口 https://www.nowcoder.com/profile/7404313/test/8129910/15008?onlyWrong=0 值对象模式https://www.nowcoder.com/profile/7404313/test/8133214/15007?onlyWrong=0 可维护性https://www.nowcoder.com/profile/7404313/test/8130955/2231?onlyWrong=0 游戏软件和通用软件https://www.nowcoder.com/profile/7404313/test/8130955/14553?onlyWrong=0 模型驱动开发技术过程建模、数据建模、对象建模。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://hepsilion.github.io/tags/软件工程/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"Linux总结","slug":"Linux","date":"2017-05-28T10:56:37.000Z","updated":"2017-06-02T00:53:52.218Z","comments":true,"path":"2017/05/28/Linux/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/Linux/","excerpt":"Linux","text":"Linux 一、 进程管理问：Linux进程间的通信方式Linux进程间通信方式有：消息队列，命名管道，信号量，共享内存，套接字等，临界区不能用于Linux中的进程间通信。 https://www.nowcoder.com/profile/7404313/test/8067759/1034?onlyWrong=0 问：终止一个前台进程可能用到的命令和操作终止一个前台进程用Ctrl+C； 暂停一个前台进程用Ctrl+Z； 终止一个后台进程： 使用kill命令； 或使用fg命令将后台进程变为前台进程，然后Ctrl+C。 问：ps问：jobs显示系统进程 二、 存储管理问：freefree是系统自带的、常用的监控工具，用于显示已使用物理内存和交换空间，相对于top命令，free可以更简洁的查看内存的使用情况。 三、 文件管理 Linux中，在所有目录下都会有存在两个目录：”.”和”..”，分别代表此层和上层目录的意思。 目录与文件相关操作 1. cdcd是Change Directory的缩写，这是用来变换工作目录的指令。 语法是：cd [目标目录]，如：cd /home cd指令可让用户在不同的目录间切换，但该用户必须拥有足够权限进入目标目录。 2. pwdpwd是Print Working Directory的缩写，是显示当前所在目录的指令。 3. mkdir(建立新目录)在默认情况下，你所需要的目录要一层一层建立才行。例如:假如你要建立一个目录为:/home/bird/testing/test，那么首先必须要有/home，然后要有/home/bird，再有/home/bird/testing，最后才可以建立/home/bird/testing/test这个目录。 不过，加上-p这个选项就可以直接完成功能:mkdir -p /home/bird/testing/test。使用上述命令，系统会自动帮你将各个目录依次建立起来。 4. rmdir如果要将刚刚建立的test删掉，使用:rmdir test。但是目录需要一层一层删除，而且被删除的目录里面必定不能存在其他的目录或文件，也就是说只能删除空目录。 如果需要删除非空目录，可以使用:rm -r test 5. ls(文件与目录的查看)ls最常用的选项是”-l”。 6. cp要复制文件或目录，可以使用cp。如将当前目录下的aaa文件复制到/tmp下，并更名为bbb:cp ./aaa /tmp/bbb 复制目录时需要使用”-r”选项，如复制/etc/这个目录下的所有内容到/tmp下：cp -r /etc/ /tmp 7. rm执行rm指令可删除文件或目录，如欲删除目录必须加上参数”-r”，否则默认仅会删除文件。 8. mvmv命令移动或更名现有的文件或目录。 如何更改一个目录的名称，例如由/home/test变为/tome/test2？ 命令如下:mv /home/test /home/test2 例1: Linux的非root用户，在自己的目录中，解决不可以删除非空目录dirs的方法是() A. rm dir dirs B. rm -r dins C. my dirs /dev/null D. destroy dirs 解答:B。C需要root权限，且只能对文件进行操作，而不能对目录进行操作。 文本文件内容查看 如果我们要查阅一个文件内容时，该如何是好呢？这里有相当多命令可以使用，最常使用的显示文件内容的命令可以说是cat, more及less了。 1. cat由第一行开始查看文件。cat是Concatenate(连续)的简写，主要的功能是将一个文件的内容连续输出在屏幕上。如显示当前目录下的aaa的内容:cat ./aaa 2. tac从最后一行开始显示，可以看出。cat与tac是倒置的。cat是由第一行到最后一行连续显示在屏幕上，而tac则是由最后一行到第一行反向在屏幕上显示出来。 3. nl显示文件内容的时候，一起显示文件行号。 4. more一页一页显示文件内容。前面提到的n1, cat, tac等，都是一次性将数据显示到屏幕上面，若是文件行数很多，前面的内容就会看不到，这时就需要使用more与less来一页一页查看文件内容。命令如下:more ./aaa 5. lessless与more类似，但是比more更好的是，它可以向前翻页。命令如下:less ./aaa 6. headhead命令查看文本文件时，只显示头几行。用法如下:head -n number 文件名 上述用法表示只显示文件的前number行。另外一n选项后而的参数如果接的是负数，代表列出前而的所有行数，但不包括后面number行。举例来说，/etc/man.config共有141行，则下述的指令:head -n -100 /etc/man.config就会列出前面41行，后面100行不会打印出来了。 7. tailtail命令查看文本文件时，只显示尾几行。tail的用法跟head很相似：tail -n number 文件名 当number前面有”+”号时，与head -n -xx有异曲同工之妙。如:tail -n +100 /etc/man.config代表该文件从100行以后都会被列出来，同样，在man.config共有141行，因此第100-141行就会被列出来，前面的99行都不会被显示出来。 8. touchtouch这个指令最常被使用的情况是建立一个空的文件。 若aaa不存在，则:touch aaa，将会新建一个名为”aaa”的文件。 9. grepgrep是分析一行信息，若当中有我们所需要的信息，就将该行显示出来。 grep常用在管道中。例如将文件aaa中包含”root”的行的内容显示出来的命令如cat aaa grep &quot;root&quot;或grep &quot;root&quot; aaa 当使用”grep -E”表示后面跟着的内容是延伸型正则表达式，等价于”egrep”。 例1: 在Linux系统中，为找到文件try_grep中含有以a字母为行开头的内容，可以使用()命令。 A. grep -E #$ try_grep B. grep -E #a try_grep C. grep -E ^$ try_grep D. grep -E ^a try_grep 答案：D。 ^M表示以M开头的行，^表示开始的意思；M$表示以M结尾的行，$表示结束的意思。 查看系统信息 1. df列出文件系统的整体磁盘使用量。 2. ps将某个时间点的程序运行情况显示出来。 3. top(动态观察程序的变化)top可以持续侦测程序运作的状态。 问：Linux文件目录/bin 二进制执行文件，也就是命令文件 /etc 下存放的是配置文件 /dev 存放是时外部设备文件，硬盘，usb等 /lib 存放的是库文件 问：常用文件介绍 /etc/resolv.conf DNS解析的设置文件 /etc/dhcpd.conf DHCP的设置文件 /etc/gateways 网络路由的设置文件(建立动态路由需要用到) /etc/mail.rc 邮件服务的设置文件 /etc/hosts hosts文件是Linux系统上一个负责ip地址与域名快速解析的文件，以ascii格式保存在/etc/目录下。hosts文件包含了ip地址与主机名之间的映射，还包括主机的别名。在没有域名解析服务器的情况下，系统上的所有网络程序都通过查询该文件来解析对应于某个主机名的ip地址，否则就需要使用dns服务程序来解决。通过可以将常用的域名和ip地址映射加入到hosts文件中，实现快速方便的访问。 /etc/hostname 主机名设置文件 /etc/fstab 系统分区的配置文件，开机后系统会自动挂载文件中指定的设备 https://www.nowcoder.com/profile/7404313/test/8343455/22114?onlyWrong=0 /proc/interrupts 显示使用的中断 /proc/ioports 当前使用的I/O端口 /proc/kcore 系统物理内存映像。与物理内存大小完全一样，但不实际占用这么多的内存。 /proc/kmsg 内核输出的消息，也被送到syslog https://www.nowcoder.com/profile/7404313/test/8148327/26137?onlyWrong=0 问：文件复制(1) cp命令：cp命令用于复制文件或目录。 将文件file1复制成文件file2命令如下：cp file1 file2 (2) cat命令 ：cat命令是linux下的一个文本输出命令，通常是用于观看某个文件的内容的。 一次显示整个文件命令如下： cat filename : linux中的数据流重导向：输出导向，覆盖导向的文件内容。 &lt; : linux中的数据流重导向：输入导向，理解为原本由键盘输入改为文本输入 (3) dd命令 : 作用是用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。 参数：if 输入文件(或设备名称) of 输出文件(或设备名称) 将文件file1拷贝到文件file2中命令如下： dd if=file1 of=file2 (4) | ：管道命令操作符，处理经由前面一个指令传出的正确输出信息，然后，传递给下一个命令，作为标准的输入 例1： 将文件file1复制为file2可以使用的命令： cp file1 file2 cat file1 &gt;file2 cat &lt; file1 &gt;file2 dd if=file1 of=file2 cat file1 | cat &gt;file2 问：Linux文件权限 Linux文件权限的长度为10位，分成四段：文件类型(1位) + 拥有者权限(3位) + 所属组权限(3位) + 其他用户权限(3位) 问：chmod 修改文件权限chmod [who] [+|-|=][mode] 文件名 (1) [who]的取值可以为u，g，o和a， u 表示”用户(user)”，即文件拥有者； g 表示”同组(group)用户”，即与文件拥有者有相同组ID的所有用户； o 表示”其他(others)用户”； a 表示”所有(all)用户”，它是系统默认值。 (2) [+|-|=] + 添加某个权限； 取消某个权限； = 赋予给定权限并取消其他所有权限（如果有的话）。 (3) [mode] 当使用+或-时，权限从0到7的一个八进制数，例如7为4+2+1的组合，代表可读可写可执行权限；5为4+1的组合，代表可读可执行，等； 当使用=时，权限为从0到7的3个八进制数，按(u)、(g)、(o)顺序组织，分别对应文件拥有着、同组用户和其他用户的权限。 例1： 文件file的访问权限为rw-r--r--，现要增加所有用户的执行权限和同组用户的写权限，其命令可以为：chmod a+x,g+w file 或 chmod 764 file 注意为多种用户设置权限时，中间以”,”隔开，不可以加空格。如chmod a+x, g+w file为错误形式，逗号后面存在空格。 例2： 现在file文件的权限改为只有拥有着拥有执行权限的命令可以为：chmod u+x,g-x,o-x file 或 chmod 100 file 例3： 在unix系统下执行chmod 753 file之后，该文件sample的访问权限为：拥有者可读写执行，同组用户可读可执行，其他用户可写可执行 问：umaskumask [-p] [-S] [mode] umask可用来指定在建立文件时预设的权限掩码。对于每一类用户(文件属主、同组用户、其他用户)在umask值mode中都存在一个相应的数字。 对于文件来说，这一数字的最大值是6。系统不允许你在创建一个文本文件时就赋予它执行权限，必须在创建后用chmod命令增加这一权限； 目录则允许设置执行权限，这样针对目录来说，umask中各个数字最大可以为7。 例1： 如果系统的umask设置为244，创建一个新文件后，它的权限为：-r---w--w- 创建时，文件权限默认为666，目录权限默认777，减去umask的位就是结果权限。因此该文件权限为666-244=422，即为-r---w--w- 例2： 设umask为002, 则新建立的文件的权限是：-rw-rw-r-- 问：tar 压缩和解压缩tar [必选项+可选项] 文件或者目录 必选项： -c 创建压缩包； -x 解开压缩包； -t 列出包中的内容； -r 增加文件到指定包中； -u 更新包中的文件 可选项： -j 创建或解开压缩包包时使用bzip2进行压缩或解压缩； -z 创建或解开压缩包包时使用gzip进行压缩或解压缩； -Z 创建或解开压缩包包时使用compress进行压缩或解压； -f 后面跟指定的压缩包文件名； -v 显示创建压缩包/解开压缩包的过程； -C 指定解开压缩包的路径 例1： 在linux中如何使用tar命令将文件aaa打包为bak.tar：tar -cf bak.tar aaa 例2： tar命令用于解压的参数是: -x 问：tar，gzip，compress，uncompresstar是操作.tar的命令 gzip是压缩.gz压缩包的命令 compress：压缩.Z文件 uncompress：解压缩.Z文件 例1： 一个文件名字为rr.Z，可以用来解压缩的命令是:uncompress 问：查看文件内容cat，less，more都可以查看文件内容 less命令除了可以按空格键向下显示文件外，还可以用上下键来卷动文件 cat是将文件中的内容全部输出，如果内容过多，鼠标光标自动移到最后一行 more只能用enter键往下翻 问：cut从行当中截取所需要的内容进行显示 https://www.nowcoder.com/profile/7404313/test/8343455/22098?onlyWrong=0 问：硬链接和软链接推荐阅读 https://www.nowcoder.com/profile/7404313/test/8114836/36414?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8343455/44623?onlyWrong=0 四、 网络管理问：ping 测试连通性ping命令用来测试主机之间网络的连通性，底层是ICMP协议。 主机发出ICMP报文后，若主机与目的主机之间的网络连通正常，则目的主机会返回响应报文。 我们经常会说”ping一下某机器，看是不是开着”、不能打开网页时会说”你先ping网关地址192.168.1.1试试”。它通过发送ICMP ECHO_REQUEST数据包到网络主机，并显示响应情况，这样我们就可以根据它输出的信息来确定目标主机是否可访问(但这不是绝对的)。有些服务器为了防止通过ping探测到，通过防火墙设置了禁止ping或者在内核参数中禁止ping，这样就不能通过ping确定该主机是否还处于开启状态。 问：traceroute 路径跟踪traceroute是常用的路由查看命令，用来追踪数据包到达网络上某个主机在时经过的路径 问：route 查看路由表route命令用来显示目前本机路由表的内容，并且还可以针对路由表中的记录进行相应的添加、删除或修改等操作。 (1) route print 本命令用于显示路由表中的当前项目，由于用IP地址配置了网卡，因此所有的这些项目都是自动添加的。 (2) route add 本命令可以将新路由项目添加到路由表。 (3) route change 使用本命令可以修改数据的传输路由，不过，你不能使用本命令来改变数据的目的地。 (4) route delete 使用本命令可以从路由表中删除路由。 例1： 局域网的网络地址192.168.1.0/24，局域网络连接其它网络的网关地址是192.168.1.1。 主机192.168.1.20访问172.16.1.0/24网络时，其路由设置正确的是：route add –net 172.16.1.0 gw 192.168.1.1 netmask 255.255.255.0 metric 1 路由信息是由{目的主机所在的网络地址，下一跳地址，子网掩码}组成，-net 后面跟的是目的网络，下一跳的地址就是局域网中连接外网的网关地址 问：ifconfigifconfig命令用来查看活动的网卡信息 问：telnettelnet命令通常用来进行远程登录。telnet程序是基于TELNET协议的远程登录客户端程序。Telnet协议是TCP/IP协议族中的一员，是Internet远程登录服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。 问：netstatnetstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。 netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。 如果你的计算机有时候接收到的数据报导致出错数据或故障，你不必感到奇怪，TCP/IP可以容许这些类型的错误，并能够自动重发数据报。但如果累计的出错情况数目占到所接收的IP数据报相当大的百分比，或者它的数目正迅速增加，那么你就应该使用 netstat查一查为什么会出现这些情况了。 问：tcpdumphttps://www.nowcoder.com/profile/7404313/test/8322129/14462?onlyWrong=0 五、 用户管理六、 系统管理问：uptimeuptime命令主要用于获取主机运行时间和查询linux系统负载等信息 问：top问：sar问：Linux关机命令 halt init 0 poweroff shutdown -h 时间 (例如，shutdown -h now) 问：Linux重启命令 reboot init 6 shutdown -r 时间 七、 内核管理八、 帮助文档问：man 查看Linux命令手册例1： 命令man 5 passwd的作用：显示password文件的格式描述 九、 其他问：查看相关信息 cat /proc/meminfo 查看物理内存的信息 问：常用命令介绍 grep netstat netstat命令用来查看本机的传输层连接状态，如TCP、UDP连接，端口等信息 tcpdump tcpdump是简单可靠网络监控的实用工具 top top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况 fg 将一个后台进程调至前台继续运行 bg 将一个在后台暂停的进程唤醒，继续执行 ctrl+z 可以将一个正在前台执行的进程放到后台，并且暂停，表示进程被挂起 dpkg “dpkg”是”Debian Packager”的简写，是为”Debian”专门开发的套件管理系统，方便软件的安装、更新及移除。所有源自”Debian”的”Linux “发行版都使用”dpkg”，例如”Ubuntu”、”Knoppix”等。示例：dpkg -i avg71flm_r28-1_i386.deb df df命令用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 https://www.nowcoder.com/profile/7404313/test/8078490/55441?onlyWrong=0 问：grep和findfind是根据文件名进行查找，grep是对文件的内容进行搜索 https://www.nowcoder.com/profile/7404313/test/8114836/14452?onlyWrong=0 问：sedhttps://www.nowcoder.com/profile/7404313/test/8114836/14510?onlyWrong=0 问：init命令是进程和作业管理命令，init命令是Linux下的进程初始化工具，init进程是所有Linux进程的父进程，它的进程号为1。init命令是 Linux操作系统中不可缺少的程序之一，init进程是Linux内核引导运行的，是系统中的第一个进程。 问：mount查看磁盘挂载状态 问：mkdirhttps://www.nowcoder.com/profile/7404313/test/8114836/23226?onlyWrong=0 问：usermodhttps://www.nowcoder.com/profile/7404313/test/8114836/22122?onlyWrong=0 问：crontab，定时任务通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本，该命令前五个域是指定命令被执行的时间，最后一个域是要被执行的命令，每个域之间使用空格或者制表符分隔。 格式如下： minute hour day-of-month month-of-year day-of-week command 这些项都不能为空，必须填入。如果用户不需要指定其中的几项，那么可以使用*代替。因为*是统配符，可以代替任何字符，所以就可以认为是任何时间，也就是该项被忽略了。 第1列表示分钟(1～59)，每分钟用*或者*/1表示 第2列表示小时(1～23，0表示0点) 第3列表示日期(1～31) 第4列表示月份(1～12) 第5列标识号星期(0～6，0表示星期天) 第6列要运行的命令 例如：*/5 * * * * exam，表示每5分钟运行一次任务exam。 问：Linux下的输入/输出重定向在Linux中，每个打开的文件被赋予一个文件描述符(file descriptor)，包括标准输入(stdin)，标准输出(stdout)和标准错误输出(stderr)，分别由0，1，2描述。 command &amp;&gt; file 表示将标准输出(stdout)和标准错误输出(stderr)重定向至指定的文件file中 command &gt; file 2&gt;&amp;1，是由两部分组成。首先command&gt;file表示将标准输出(stdout)重定向到文件file中。接下来的2&gt;&amp;1表示将标准错误输出(stderr)输出到文件描述符1指定的位置，即标准输出(stdout)的位置，由于标准输出已经冲定向到文件file中，所以标准错误输出也会重定向到文件file中。 https://www.nowcoder.com/profile/7404313/test/8343455/15827?onlyWrong=0 问：Shell命令https://www.nowcoder.com/profile/7404313/test/8114836/14919?onlyWrong=0 问：Linux内存划分https://www.nowcoder.com/profile/7404313/test/8114836/25177?onlyWrong=0 问：Nginxhttps://www.nowcoder.com/profile/7404313/test/8114836/26093?onlyWrong=0 问：forkhttps://www.nowcoder.com/profile/7404313/test/8114836/14836?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8343455/26090?onlyWrong=0 grep统计一个文件中&quot;牛客&quot;出现的行数: grep &quot;牛客&quot; 文件名 | wc -l https://www.nowcoder.com/profile/7404313/test/8148327/22524?onlyWrong=0 findhttps://www.nowcoder.com/profile/7404313/test/8148327/25705?onlyWrong=0 孤儿进程、僵尸进程https://www.nowcoder.com/profile/7404313/test/8148327/14857?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8148327/25761?onlyWrong=0 管道通信https://www.nowcoder.com/profile/7404313/test/8322129/36306?onlyWrong=0 ### makefile https://www.nowcoder.com/profile/7404313/test/8322129/15416?onlyWrong=0 Linux X Window System (X11)Linux X Window System中X是一个开放的协议规范，当前版本为11，俗称X11。X Window System由客户端和服务端组成，服务端X Server负责图形显示，而客户端库X Client根据系统设置的DISPLAY环境变量，将图形显示请求发送给相应的X Server。 https://www.nowcoder.com/profile/7404313/test/8343455/26052?onlyWrong=0","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://hepsilion.github.io/tags/操作系统/"},{"name":"Linux","slug":"Linux","permalink":"https://hepsilion.github.io/tags/Linux/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"Advanced Algorithms","slug":"Advanced-Algorithms","date":"2017-05-28T10:55:45.000Z","updated":"2017-05-28T10:56:16.240Z","comments":true,"path":"2017/05/28/Advanced-Algorithms/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/Advanced-Algorithms/","excerpt":"算法","text":"算法 一、分治法二、贪心算法三、动态规划四、回溯法五、分支限界法六、问题复杂性问：P、NP、NPChttps://www.nowcoder.com/profile/7404313/test/8073440/14496?onlyWrong=0","categories":[{"name":"算法","slug":"算法","permalink":"https://hepsilion.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://hepsilion.github.io/tags/算法/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://hepsilion.github.io/categories/算法/"}]},{"title":"计算机组成原理总结","slug":"计算机组成原理","date":"2017-05-28T10:54:33.000Z","updated":"2017-05-31T03:11:58.960Z","comments":true,"path":"2017/05/28/计算机组成原理/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/计算机组成原理/","excerpt":"计算机组成原理","text":"计算机组成原理 原码、反码和补码https://www.nowcoder.com/profile/7404313/test/7956107/927?onlyWrong=0 问：在定点二进制运算器中，减法运算一般通过补码运算的二进制加法器来实现https://www.nowcoder.com/profile/7404313/test/7994191/1735?onlyWrong=0 问：https://www.nowcoder.com/profile/7404313/test/8073949/15746?onlyWrong=0 问：IEEE754单精度浮点格式案例： float型数据通常用IEEE754单精度浮点数格式表示。若编译器将float型变量x分配在一个32位浮点寄存器FR1中，且x=-8.25，则FR1的内容是()。 1、十进制转二进制 小数点之前的部分除以2取余倒序，小数点之后的部分乘以2取整正序 例：8.25的二进制表示，整数部分：8=1000；小数部分：0.25=01，8.25=1000.01 规格化：8.25=1.00001*2^3 2、浮点数保存的字节格式如下： 地址 +0 +1 +2 +3 内容 SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM S表示符号位(正为0，负为1)；E表示阶码，M表示尾数 阶码=阶数+127；尾数还原=MMM MMMM MMMM MMMM MMMM MMMM(规格化时，最高位为1，默认隐藏，只取小数点后部分) 对于-8.25，S=1，阶码=3+127=130=1000 0010，尾数=00001 所以-8.25的字节格式如下 地址 +0 +1 +2 +3 内容 1100 0001 0000 0100 0000 0000 0000 0000 C1 04 00 00 来源：https://www.nowcoder.com/profile/7404313/test/7941145/52554?onlyWrong=0 问：大端和小端https://www.nowcoder.com/profile/7404313/test/8144521/36423?onlyWrong=0","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://hepsilion.github.io/tags/计算机组成原理/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"04-JSP","slug":"04-JSP","date":"2017-05-28T10:52:12.000Z","updated":"2017-05-28T10:52:40.055Z","comments":true,"path":"2017/05/28/04-JSP/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/04-JSP/","excerpt":"JSP","text":"JSP https://www.nowcoder.com/profile/7404313/test/8073294/15276?onlyWrong=0","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://hepsilion.github.io/categories/Java-Web/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"},{"name":"Web","slug":"Web","permalink":"https://hepsilion.github.io/tags/Web/"}],"keywords":[{"name":"Java Web","slug":"Java-Web","permalink":"https://hepsilion.github.io/categories/Java-Web/"}]},{"title":"03-Servlet","slug":"03-Servlet","date":"2017-05-28T10:51:29.000Z","updated":"2017-05-28T10:51:59.804Z","comments":true,"path":"2017/05/28/03-Servlet/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/03-Servlet/","excerpt":"Servlet","text":"Servlet https://www.nowcoder.com/profile/7404313/test/8073294/15043?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8073294/7699?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8078128/15047?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8113740/15258?onlyWrong=0 https://my.oschina.net/dtkking/blog/89443 问：Servlet初始化https://www.nowcoder.com/profile/7404313/test/8103755/26091?onlyWrong=0","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://hepsilion.github.io/categories/Java-Web/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"},{"name":"Web","slug":"Web","permalink":"https://hepsilion.github.io/tags/Web/"}],"keywords":[{"name":"Java Web","slug":"Java-Web","permalink":"https://hepsilion.github.io/categories/Java-Web/"}]},{"title":"02-HTTP协议","slug":"02-HTTP协议","date":"2017-05-28T10:51:09.000Z","updated":"2017-05-28T10:51:09.667Z","comments":true,"path":"2017/05/28/02-HTTP协议/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/02-HTTP协议/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"01-XML","slug":"01-XML","date":"2017-05-28T10:50:01.000Z","updated":"2017-05-28T10:50:39.303Z","comments":true,"path":"2017/05/28/01-XML/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/01-XML/","excerpt":"XML解析","text":"XML解析 https://www.nowcoder.com/profile/7404313/test/8114731/25962?onlyWrong=0","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://hepsilion.github.io/categories/Java-Web/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"},{"name":"Web","slug":"Web","permalink":"https://hepsilion.github.io/tags/Web/"}],"keywords":[{"name":"Java Web","slug":"Java-Web","permalink":"https://hepsilion.github.io/categories/Java-Web/"}]},{"title":"如何使用Markdown","slug":"如何使用Markdown","date":"2017-05-27T14:07:46.000Z","updated":"2017-06-06T14:08:20.899Z","comments":true,"path":"2017/05/27/如何使用Markdown/","link":"","permalink":"https://hepsilion.github.io/2017/05/27/如何使用Markdown/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"数据库系统概念","slug":"数据库系统概念","date":"2017-03-18T10:45:37.000Z","updated":"2017-07-22T13:13:21.158Z","comments":true,"path":"2017/03/18/数据库系统概念/","link":"","permalink":"https://hepsilion.github.io/2017/03/18/数据库系统概念/","excerpt":"数据库系统概念","text":"数据库系统概念 问：数据库管理系统的特点数据库管理系统将具有一定结构的数据组成一个集合，它主要具有以下几个特点: (1) 数据的结构化：数据库中的数据并不是杂乱无章、毫不相干的，它们具有一定的组织结构，属于同一集合的数据具有相似的特征。 (2) 数据的共享性：在一个单位的各个部门之间，存在着大量的重复信息。使用数据库的目的就是要统一管理这些信息，减少冗余度，使各个部门共同享有相同的数据。 (3) 数据的独立性：数据的独立性是指数据记录和数据管理软件之间的独立。数据及其结构应具有独立性，而不应该去改变应用程序。 (4) 数据的完整性：数据的完整性是指保证数据库中数据的正确性。可能造成数据不正确的原因很多，数据库管理系统通过对数据性质进行检查而管理它们。 (5) 数据的灵活性：数据库管理系统不是把数据简单堆积，它在记录数据信息的基础上具有很多的管理功能，如输入、输出、查询、编辑修改等。 (6) 数据的安全性：根据用户的职责，不同级别的人对数据库具有不同的权限，数据库管理系统应该确保数据的安全性。 问：数据模型数据库是长期存储在计算机内有组织的大量的共享的数据集合。它可以供各种用户共享，具有最小冗余度和较高的数据独立性。数据库系统的核心和基础是数据模型。数据模型是对现实世界数据特征的抽象，是用来描述数据、组织数据和对数据进行操作的。根据模型应用目的的不同，数据模型可以分为两类，第一类是概念模型，第二类是逻辑模型和物理模型。 概念模型，也称信息模型，它是按用户的观点来对数据和信息建模，主要用于数据库设计。 第二类中的逻辑模型主要包括层次模型、网状模型、关系模型、面向对象模型和对象关系模型等。 第二类中的物理模型是对数据最底层的抽象，它描述数据在系统内部的表示方法和存取方法，在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的。 一般来说，数据模型是严格定义的一组概念的集合。这些概念精确地描述了系统的静态特征、动态特征和完整性约束条件。因此数据模型一般由数据结构、数据操作和完整性约束三部分组成。 数据结构:存储在数据库中对象类型的集合，作用是描述数据库组成对象以及对象之间的联系。 数据操作:指对数据库中各种对象实例允许执行的操作的集合，包括操作及其相关的操作规则。 数据完整性约束条件:指在给定的数据模型中，数据及其联系所遵守的一组通用的完整性规则，它能保证数据的正确性和一致性。 问：关系数据模型关系模型是目前最重要的一种数据模型。关系数据库系统采用关系模型作为数据的组织方式，在这些系统中，关系模型中数据的逻辑结构是一张二维表，或者说关系的数据结构就是一张表。 关系数据模型的数据操作主要包含查询、抽入、删除和更新数据。 关系模型的完整性约束包含:实体完整性、参照完整性和用户自定义的完整性。 问：关系数据库和非关系型数据库(1) 关系型数据库 MS SQL Server、IBM DB2、Oracle、MySQL、Microsoft Access和PostgreSQL。 (2) 非关系型数据库 (NoSQL) 键值(Key-Value)存储数据库 这一类数据库主要会使用到一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。Key/value模型对于IT系统来说的优势在于简单、易部署。但是如果DBA只对部分值进行查询或更新的时候，Key/value就显得效率低下了。 常见的键值存储数据库：Tokyo Cabinet/Tyrant，Redis，Voldemort，Oracle BDB.，Google BigTable，Amazon DynamoDB。 列存储数据库 这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。 常见的列存储数据库：Cassandra，HBase，Riak。 文档型数据库 文档型数据库的灵感是来自于LotusNotes办公软件的，而且它同第一种键值存储相类似。该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高。 常见的文档型数据库：CouchDB, MongoDb。国内也有文档型数据库SequoiaDB，已经开源。 图(Graph)数据库 图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。许多NoSQL数据库都有REST式的数据接口或者查询API。 常见的图数据库：Neo4J，InfoGrid，Infinite Graph。 NoSQL数据库在以下的这几种情况下比较适用： 数据模型比较简单； 需要灵活性更强的IT系统； 对数据库性能要求较高； 不需要高度的数据一致性； 对于给定key，比较容易映射复杂值的环境。 问：ER模型ER模型的基本元素是：实体、联系和属性 (1) 实体：是一个数据对象，指应用中可以区别的客观存在的事物。 (ER模型中的实体往往是指实体集)实体集：指同一类实体构成的实体集合，用矩形表示表示，矩形内注明实体名。 (2) 联系：表示一个或多个实体之间的关联关系。联系用菱形框表示，菱形框内注明联系名，并用无向边将与其相关的实体连接起来，同时在无向边旁标上联系的类型。 联系可分为以下3种类型：1对多联系，1对1联系和多对多联系 1对1联系(1:1)： 例如，一个部门有一个经理，而每个经理只在一个部门任职，则部门与经理的联系是一对一的。 一对多联系(1:N): 例如，某校教师与课程之间存在一对多的联系”教”，即每位教师可以教多门课程，但是每门课程只能由一位教师来教。 多对多联系(M:N): 例如，学生与课程间的联系(“学”)是多对多的，即一个学生可以学多门课程，而每门课程可以有多个学生来学。 (3) 属性：实体的某一特性称为属性，属性用椭圆形框表示，加下划线的属性为主属性。 例1：教学管理的一个可能设计的ER图 教学管理的一个可能设计的ER图 问：主键与外键若关系(二维表)中的某一属性组的值能唯一标识一个元组，则称该属性组为候选码。若个表中有多个候选码，则可选定其中一个为主键。 候选码的各个属性称为主属性。不包含在任何候选码中的属性称为非主属性或非码属性。 如果关系模式R1中的某属性集不是R1的主键，并且该属性集是另一个关系R2的主键，则该属性集是关系模式R1的外键。由此可见，外键表示了两个关系(表)之间的联系。以另一个关系的外键作主键的表被称为主表(R2)，具有此外键的表被称为主表的从表(R1)，外键又称为外关键字。 问：完整性约束主键的设置是为了强制表的实体完整性，外键的设置是为了强制表之间的参照完整性。 (1) 关系模型的实体完整性约束 若属性(指一个或一组属性)A是基本关系R的主属性，则A不能取空值。由此约束可得一直接结论:主键不能为空。 (2) 关系模型的参照完整性约束 若属性(或属性组)F是某基本关系R1的外键，且它与基本关系R2的主键相对应，则对于R1中，每个F上的值或为空值或者等于R1中的主键值。 (3) 关系模型的用户自定义完整性约束 例1：下列哪种完整性约束中，将每一条记录定义为表中的惟一实体，即不能重复 A. 域完整性 B. 引用完整性 C. 实体完整性 D. 其他 答案： C。 问：关系代数介绍关系代数的一篇文章 关系代数是关系数据库系统查询语言的理论基础，包括：并、交、差、乘、选择、投影、联接、除、自然联接等操作。 例1： 设有关系模式R(a,b,c,d,)，与关系代数表达式σ3&lt;&apos;4&apos;(R)等价的SQL语句为：select * from R where c&lt;&apos;4&apos;; 例2 问：常见的SQL语句SQL语句功能极强，包括数据定义(create、 drop和alter)、数据操纵(insert，update和delete)、数据查询(select)、数据控制(grant和revoke)。 例1：ANSI SQL语句的分类 (1) 数据定义 创建表：SQL语言使用create table语句定义表，其基本格式如下: create table &lt;表名&gt;( &lt;列名&gt; &lt;数据类型&gt; [列级完整性约束条件] [, &lt;列名&gt; &lt;数据类型&gt; [列级完整性约束条件]] ... [, &lt;表级完整性约束条件&gt;]); 例1：建立一个”学生信息”表Student: create table Student( Sno char(9) primary key, Sname char(20) unique, Ssex char(2), Sage smallint, Sdept char(20) ); 修改表：随着应用环境和应用需求的变化，有时需要修改已建立好的表，SQL语言用alter table语句修改表，其一般格式为: ALTER TABLE &lt;表名&gt; [ADD &lt;新列名&gt; &lt;数据类型&gt; [完整性约束]] [DROP &lt;完整性约束名&gt;] [MODIFY COLUMN &lt;列名&gt; &lt;数据类型&gt;] 其中，&lt;表名&gt;是要修改的表，ADD子句用于增加新列和新的完整性约束条件，DROP子句用于删除指定的完整性约束，MODIFY COLUMM子句用于修改原有的列定义，包括修改列名和数据类型。 例2：向Student表增加”入学时间”列，其数据类型为日期类型。 alter table Student add Sentrance date; 上述代码不论Student表中原来是否已有数据，新增加的列一律为空值。 例3：删除Student表中”年龄”列 alter table Student drop column Sage; 删除列可以省略column 例4：要求将年龄的数据类型由字符型(假设原来的数据类型是字符型)改为整数。 alter table Student modify column Sage int; 例5：增加Student表Sname必须取唯一值的约束条件。 alter table Student add unique(Sname); 删除表：当某个表不再需要时，可以使用drop table语句删除它。其一般格式为: DROP TABLE &lt;表名&gt; [RESTRICT | CASCADE]; 若选择RESTRICT，则该表的删除是有限制条件的:欲删除的表不能被其他表的约束所引用(如check，foreign key等约束)，不能有视图，不能有触发器，不能有存储过程或函数等。如果存在这些依赖该表的对象，则此表不能被删除。 若选择CASCADE，则该表的删除没有限制条件。在删除该表的同时，相关的依赖对象，例如视图，都将被一起删除。 例6：删除Student表 drop table Student cascade; (2) 数据操纵 数据操纵操作有3种：向表中添加若干行数据、修改表中的数据和删除表中的若干行数据。 插入元组：插入元组的INSERT语句的格式为: INSERT INTO table (fieldl, field2 ...) VALUES(valuel, value2..); 其功能是将新元组插入到指定表中，其中新元组的field1的值为value1, field2的值为value2…。 如果INTO语句中没有指定任何属性列名，则新插入的元组必须在每个属性列上均有值。 例1：将一个新学生元组(学号:201009014，姓名:Wang，性别:女， 所在系:MA，年龄:21)插入到Student表中 insert into Student(Sno, Sname, Ssex, Sdept, Sage) values (&apos;201009014&apos;, &apos;Wang&apos;, &apos;F&apos;, &apos;MA&apos;, 21); 修改数据：修改数据又称为更新操作，其语句的一般格式为: UPDATE table SET fieldl=valuel, field2=value2 WHERE 范围 其功能是修改指定表中满足WHERE子句条件的元组。其中SET子句给出的value值用于取代相应的属性列值。如果省略WHERE子句，则表示要修改表中的所有元组。 例2：将学生201009013的年龄改为22岁 update Student set Sage=22 where Sno=&apos;201009013&apos;; 删除数据：删除语句的一般格式为: DELETE FROM tabIe WHERE范围; DELETE语句的功能是从指定表中删除满足WHERE子句条件的所有元组。如果省略WHERE子句，表示删除表中全部元组，但表仍存在。 删除表中的所有行(truncate和delete的区别，这里尚未整理) truncate table TABLE_NAME; (不可恢复) 例3：删除学号为201009020的学生记录 delete from Student where Sno=&apos;201009020&apos;; (3) 数据查询 数据库查询是数据库的核心操作。SQL提供了select语句进行数据库的查询，其一般格式为: SELECT [ALL | DISTINCT] &lt;目标列表达式&gt; [，&lt;目标列表达式&gt;] ... FROM &lt;表名或视图名&gt; [,&lt;表名或视图名&gt;] ... [WHERE &lt;条件表达式&gt;] [GROUP BY &lt;列名1&gt; [HAVING &lt;条件表达式&gt;]] [ORDER BY &lt;列名2&gt; [ASC | DESC]]; 整个SELECT语句解析顺序：FROM-&gt;WHERE-&gt;GROUP BY-&gt;HAVING-&gt;SELECT-&gt;ORDER BY 整个SELECT语句的含义 根据WHERE子句的条件表达式，从FROM子句指定的表或视图中找出满足条件的元组，再按SELECT子句中的目标列表达式，选出元组中的属性值形成结果表。 如果有GROUP BY子句，则将结果按&lt;列名1&gt;的值进行分组，该属性值相等的元组为一个组。通常会在每组中使用聚集函数。如果GROUP BY子句带HAVING子句，则只有满足指定条件的组才会被输出。 如果有ORDER BY子句，则结果表还要按&lt;列名2&gt;的值的升序或降序排序。 选择表中的若干列 例1：在表Student中查询名为Wang的学生信息 select * from Student where Sname=&apos;Wang&apos;; 例2：在表Student中，查询名字中有ang的学生信息 select * from Student where Sname like &apos;%ang%&apos;; 上述%是通配符，代表任意长度(可为0)的字符串。例如a%b表示以a开头，以b结尾的任意长度的字符串。除此之外，_(下画线)代表任意单词字符。 例3：在表Student中查询年龄在20-22岁(包括20岁与22岁)之间的学生的信息 select * from Student where Sage between 20 and 22; 与BETWEEN...AND...相对的谓词是NOT BETWEEN...AND... 例4：在表Student中查询计算机系(CS)、信息系(MA)和和物理系(PH)学生的姓名和性别 select Sname, Ssex from Student where Sdept in (&apos;CS&apos;, &apos;MA&apos;, &apos;PH&apos;); 与IN相对的谓词是NOT IN，用于查找属性值不属于指定集合的元组。 例5：在表Student中查询没有年龄信息的学生 select * from Student where Sage is null; 注意这里的&quot;is&quot;不能被等号代替。 order by子句 用户可以用order by子句对查询的结果按照一个或多个属性列的升序(ASC)或降序(DESC)排列，默认值为升序。 例6：在表Student中，按学生的年龄值升序检索出全部学生的信息 select * from Student order by Sage; 在表Student中先按专业升序排序，然后同一专业的学生再按年龄降序排序，并输出全部学生信息 select * from Student order by Sdept, Sage desc; limit子句 limit主要是用于查询之后显示返回的前几条或者中间某几条数据。 SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset; LIMIT子句可以被用于强制SELECT语句返回指定的记录数。 LIMIT接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是0(而不是1)。 例7：从Student表中检索出第3到第7条记录，共5条记录 select * from Student limit 2, 5; 例8：从Student表中检索出前2条记录 select * from Student limit 2; 换句话说，LIMIT n等价于LIMIT 0, N 聚集函数 SQL语句中的常用聚集函数有以下几种：count，sum，avg，max，min。用法如下： 总数： select count(*) as totalcount from table; 求和： select sum(field) as sumvalue from table; 平均： select avg(field) as avgvalue from table; 最大： select max(field) as maxvalue from table; 最小： select min(field) as minvalue from table; GROUP BY子句 GROUP BY子句根据一个或多个属性的值来对元组进行分组，值相等的为一组。 对查询结果分组的目的是为了细化聚集函数的作用对象，分组后聚集函数将作用于每一个组，即每一组都有一个函数值。 例9：查询Student表中具有相同年龄的每个组的人数 select Sage, count(*) from Student group by Sage; 如果分组后还要求按一定的条件对这些组进行筛选，最终只输出满足指定条件的组，则使用HAVING短语指定筛选条件。通常，HAVING子句只用在GROUP BY子句的SQL语句中，用来选取符合指定条件的分组。 例10：查询Student表中每种年龄的人数大于1的年龄与人数信息 select Sage, count(*) from Student group by Sage having count(*) &gt; 1; 连接查询 前面的查询都是针对一个表进行的。若一个查询同时涉及两个以上的表，则称之为连接查询。 例11：若有表Student(学生信息表)、SC(选课表)，要求查询每个学生及其选修课程的情况: select Student.*, SC.* from Student, SC where Student.Sno=SC.Sno; 在以上的连接操作中，只有满足条件的元组才能作为结果输出。 若表Student中某些学生没有选课，则在SC表中没有相应的元组，造成最终结果中舍弃掉了这些学生的信息。 上述连接称为自然连接、内连接。有时想以Student表为主体列出每个学生的基本情况及其选课情况。若某个学生没有选课，依然将其保存到结果中(在SC表的属性上填空值)，这时就需要使用外连接。 select Student.*，SC.* from Student left join SC on (Student.Sno=SC.Sno); 以上是左外连接，左外连接列出左边表(本例为Student表)中的所有元组，右外连接列出右表关系中所有的元组。 例12 例13：一道综合题 设有学生信息表s(sno, sname)，其属性分别表示学号，姓名；课程信息表c(cno, cname)，其属性分别表示课程号、课程名称;选课信息表sc(sno, cno, grade)，其属性分别表示学号、课程号和成绩。 1) 问选修课程”db”的学生学号 select sc.sno from sc, c where sc.cno=c.cno and c.cname=&apos;db&apos;; 2) 平均成绩最高的学生学号 select sno, avg(grade) as g from sc group by sno order by g desc limit 1; 3) 每科大于90分的人数 select cno, count(sno) from sc where grade&gt;90 group by cno; 4) 列出既学过”math”，又学过”english”的所有学生学号、姓名 select s.sno, s.sname from s, (select sc.sno from sc, c where sc.cno=c.cno and c.cname in(&apos;math&apos;, &apos;english&apos;) group by sno having count (distince c.cno)=2) x where s.sno=x.sno; 5) 列出有两门以上(含两门)不及格课程(成绩小于60)的学生学号、姓名及其平均成绩 select s.sno, s.sname，avg(sc.grade) as avggrade from s, sc, (select sno from sc where grade&lt;60 group by sno having count (distince cno)&gt;=2) x where s.sno=x.sno and sc.sno=x.sno group by s.sno; 6) 列出”math”课程成绩比”english”课程成绩高的所有学生的姓名 select s.sname, from s, (select sno, grade from sc where cno in (select cno from c where cname=&apos;math&apos;)) A, (select sno, grade from se where cno in (select cno from c where cname=’english&apos;)) B where s.sno=A.sno and s.sno=B.sno and A.grade&gt;B.grade; (4) 数据控制 授予权限 grant [权限] on [table] to &apos;username&apos;@&apos;localhost&apos;; 例1：使用sql语句中为用户zhangsan分配数据库userdb表userinfo的查询和插入数据权限 grant select,insert on userdb.userinfo to&apos;zhangsan&apos;@&apos;localhost&apos; 问：视图视图是从一个或几个表(或视图)导出的表。它与表不同，是一个虚表。数据库中只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的表中。所以表中的数据发生变化时，从视图中查询出的数据也就随之发生改变了。从这个意义上讲，视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化。 例1：在学生表Student的基础上，创建一个计算机系学生的视图 create view cs_student as select sno, sname from Student where Sdept=&apos;CS&apos;; 视图一经定义，就可以和基本表一样被查询、被删除。 例2：若要求进行修改和插入操作时，仍需保证该视图中只有计算机系的学生: create view cs_student as select sno, sname from Student where Sdept=&apos;CS&apos; with check option; 例3：删除视图的语句为: drop view cs_student; 例4 问：SQL约束 NOT NULL：控制字段的内容不能为空(NULL)。 UNIQUE：控制字段的内容不能重复，一个表允许有多个Unique约束。 PRIMARY KEY：控制字段的内容不能重复，即它在一个表中只允许出现一个。 FOREIGN KEY：FOREIGN KEY约束用于预防破坏表之间连接的动作，FOREIGN KEY约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。 CHECK：用于控制字段的值范围。 DEFAULT：用于设置新记录的默认值。 问：SQL的匹配模式(1) %表示匹配0个或多个字符 select * from user where name LIKE &apos;%三%&apos;; 将会把name为&quot;张三&quot;、&quot;三脚猫&quot;、&quot;唐三藏&quot;等等有&quot;三&quot;的全找出来。 %三：表示左匹配； 三%：表示右匹配； %三%：表示模糊查询。 (2) _表示匹配单个任意字符 select * from user where name LIKE &apos;_三_&apos;； 只找出&quot;唐三藏&quot;这样name为三个字且中间一个字是&quot;三&quot;的； select * from user where name LIKE &apos;三__&apos;； 只找出&quot;三脚猫&quot;这样name为三个字且第一个字是&quot;三&quot;的 (3) [ ]表示匹配括号内所列字符中的任意一个 select * from user where name LIKE &apos;[张李王]三&apos;; 将找出&quot;张三&quot;、&quot;李三&quot;、&quot;王三&quot;(而不是&quot;张李王三&quot;)； 如[]内有一系列字符（01234、abcde之类的)，则可略写为&quot;0-4&quot;、&quot;a-e&quot;。 select * from user where name LIKE &apos;老[1-9]&apos;； 将找出&quot;老1&quot;、&quot;老2&quot;、……、&quot;老9&quot;； 如要找&quot;-&quot;字符，请将其放在首位：&apos;张三[-1-9]&apos;； (4) [^ ]表示匹配不在括号所列字符内的单个任意字符 select * from user where name LIKE &apos;[^张李王]三&apos;; 将找出不姓&quot;张&quot;、&quot;李&quot;、&quot;王&quot;的&quot;赵三&quot;、&quot;孙三&quot;等 select * from user where name LIKE &apos;老[^1-4]&apos;; 将排除&quot;老1&quot;到&quot;老4&quot;，寻找&quot;老5&quot;、&quot;老6&quot;、&quot;老9&quot;、…… 问：查看Mysql表结构的命令 desc 表名; show columns from 表名; describe 表名; show create table 表名; use information_schema select * from columns where table_name=’表名’; 问：union操作符SQL union语法： select COLUMN_NAME(S) from TABLE_NAME1 union select COLUMN_NAME(S) from TABLE_NAME2; union操作符用于合并两个或多个select语句的结果集。请注意，union内部的select语句必须拥有相同数量的列，列也必须拥有相似的数据类型。同时，每条select语句中的列的顺序必须相同。默认地，union操作符会剔除重复的结果。如果要允许重复的值，请使用union all。 问：从表TABLE_NAME中提取前10条记录Sql server: select TOP N * from table_name. MySQL: select * from table_name limit 0,10; Oracle: select * from table_name where rownum＜=10 问：MySQL中的”空值”和”NULL”例1 问：索引索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。 为表设置索引是要付出代价的:一是增加了数据库的存储空间；二是在插入和修改数据时要花费较多的时间维护索引。 例1：创建索引和删除索引 (1) 在表Student(学生信息表)上按Sno(学号)降序建唯一索引Stusno create unique index Stusno ON Student(Sno desc); (2) 删除Student表的索引Stusno alter table Student drop index Stusno; 注意:以上代码在MySQL数据库上调试通过，下文代码也都是在MySQL上运行的。 例2：数据库中索引的作川是什么？什么情况下适合建立索引以及什么情况下不适合建立索引？(2011·浙商银行) 解答:创建索引可以大大提高系统的性能。 (1) 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 (2) 可以大大加快数据的检索速度，这也是创建索引的最主要原因。 (3) 可以加速表和表之间的连接，特别是在实现数据的参照完整性方面特别有意义。 (4) 在使用分组(group by)和排序(order by)子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 (5) 通过使用索引，可以在查询的过程中，使用查询优化器，提高系统的性能。 那么索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？这是因为增加索引也有许多不利的方面。 (1) 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 (2) 索引需要占用物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 (3) 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。 一般来说，应该在这些列上创建索引: (1) 在经常需要搜索的列上创建索引，可以加快搜索的速度; (2) 在作为主键的列上创建索引，强制该列的唯一性和组织表中数据的排列结构; (3) 在经常用在连接的列上创建索引，这些列主要是一些外键，可以加快连接的速度; (4) 在经常需要根据范围进行搜索的列上创建索引，囚为索引已经排序，其指定的范围是连续的; (5) 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间: (6) 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 同样，对于有些列不应该创建索引。一般来说，不应该创建索引的这些列具有下列特点: (1) 对于那些在查询中很少使用的列不应该创建索引。这是因为，既然这些列很少使用到，因此有无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度，增大了空间需求。 (2) 对于那些只有很少数据值的列也不应该创建索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占据了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 (3) 对于那些定义为text和bit等数据类型的列不应该创建索引。这是因为，这些列的数据量要么相当大，要么取值很少，不利于使用索引。 (4) 当修改操作远远大于检索操作时，不应该创建索引。这是因为，修改性能和检索性能是互相相矛盾的。当增加索引时，会提高检索的性能，但是会降低修改的性能。当减少索引时，会提高修改的性能，降低检索的性能。因此，当修改操作远远多于检索操作时，不应该创建索引。 问：范式理论 待完善(1) 第一范式(1NF) 定义：如果关系模式R的每个关系r的属性都是不可分的数据项，那么就称R是第一范式的模式。 简单的说，每一个属性都是原子项，不可分割。 1NF是关系模式应具备的最起码的条件，如果数据库设计不能满足第一范式，就不称为关系型数据库。关系数据库设计研究的关系规范化是在1NF之上进行的。 例如(学生信息表)： 学生编号 姓名 性别 联系方式 20080901 张三 男 email:zs@126.com,phone:88886666 20080902 李四 女 email:ls@126.com,phone:66668888 以上的表就不符合第一范式：联系方式字段可以再分，所以变更为正确的模式是： 学生编号 姓名 性别 电子邮件 电话 20080901 张三 男 zs@126.com 88886666 20080902 李四 女 ls@126.com 66668888 (2) 第二范式(2NF) 定义：如果关系模式R是1NF，且每个非主键属性完全函数依赖于候选键，那么就称R是第二范式。 简单的说，第二范式要满足以下的条件：首先要满足第一范式，其次每个非主键属性要完全函数依赖于候选键，或者是主键。也就是说，每个非主属性是由整个主键函数决定的，而不能由主键的一部分来决定。 例如(学生选课表): 学生 课程 教师 教师职称 教材 教室 上课时间 李四 Spring 张老师 java讲师 《Spring深入浅出》 301 08:00 张三 Struts 杨老师 java讲师 《Struts in Action》 302 13:30 这里通过(学生，课程)可以确定教师、教师职称、教材、教室和上课时间，所以可以把(学生，课程)作为主键。但是，教材并不完全依赖于(学生，课程)，只拿出课程就可以确定教材，因为一个课程一定指定了某个教材。这就叫不完全依赖，或者部分依赖。出现这种情况，就不满足第二范式。 修改后，选课表： 学生 课程 教师 教师职称 教室 上课时间 李四 Spring 张老师 java讲师 301 08:00 张三 Struts 杨老师 java讲师 302 13:30 课程表： 课程 教材 Spring 《Spring深入浅出》 Struts 《Struts in Action》 所以，第二范式可以说是消除部分依赖。第二范式可以减少插入异常，删除异常和修改异常。 (3) 第三范式(3NF) 满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。 例1，例2，例3，例4 问：数据库事务的四大特性：数据库事务是指作为单个逻辑工作单元执行的一系列操作，这些操作要么全做要么全不做，是一个不可分割的工作单位。 数据库事务的四大特性是：原子性、一致性、独立性和持久性，简称ACID。 (1) 原子性(Atomicity) 事务的原子性指的是，事务中包含的程序作为数据库的逻辑工作单位，它所做的对数据修改操作要么全部执行，要么完全不执行。这种特性称为原子性。 例如银行取款事务分为2个步骤(1)存折减款(2)提取现金。不可能存折减款，却没有提取现金。2个步骤必须同时完成或者都不完成。 (2) 一致性(Consistency) 事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。这种特性称为事务的一致性。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。 例如完整性约束a+b=10，一个事务改变了a，那么b也应随之改变。 (3) 独立性(Isolation) 分离性指并发的事务是相互隔离的。即一个事务内部的操作及正在操作的数据必须封锁起来，不被其它企图进行修改的事务看到。假如并发交叉执行的事务没有任何控制，操纵相同的共享对象的多个并发事务的执行可能引起异常情况。 (4) 持久性(Durability) 持久性意味着当系统或介质发生故障时，确保已提交事务的更新不能丢失。即一旦一个事务提交，DBMS保证它对数据库中数据的改变应该是永久性的，即对已提交事务的更新能恢复。持久性通过数据库备份和恢复来保证。 例1： DBMS中实现事务持久性的子系统是：恢复管理子系统。 问：数据库事务隔离级别讲解”数据库事务隔离级别”的一篇文章 数据库事务的隔离级别有4个，由数据库系统实现，从低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。 问：数据库恢复的基础是利用转储的冗余数据。这些转储的冗余数据包括：日志文件，数据库后备副本","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://hepsilion.github.io/tags/数据库/"},{"name":"SQL","slug":"SQL","permalink":"https://hepsilion.github.io/tags/SQL/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"计算机网络","slug":"计算机网络","date":"2017-03-17T10:42:51.000Z","updated":"2017-07-22T13:13:16.718Z","comments":true,"path":"2017/03/17/计算机网络/","link":"","permalink":"https://hepsilion.github.io/2017/03/17/计算机网络/","excerpt":"计算机网络","text":"计算机网络 一、 计算机网络体系结构问：OSI参考模型国际标准化组织(ISO)提出的网络体系结构模型，称为开放系统互联参考模型(OSI/RM)，通常简称为OSI参考模型。 OSI有七层，自下而上依次为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。每一层的作用如下： 物理层(比特Bit)：负责在连接各个计算机的传输媒介上传输数据比特流，确定与传输媒介的接口相关的一些特性。(通过媒介传输比特，确定机械及电气规范) 数据链路层(帧Frame)：将比特组装成帧和点到点的传递。 网络层(分组或数据包Packet)：负责网际互连及对数据包进行路由选择和存储转发。 传输层(报文或数据段Segment)：提供端到端的可靠报文传递和错误恢复。 会话层(会话协议数据单元SPDU)：建立、管理和终止会话 表示层(表示协议数据单元PPDU)：对数据进行翻译、加密和压缩 应用层(应用协议数据单元APDU)：允许访问OSI环境的手段 数据链路层在概念上常被划分为两个子层:逻辑链路控制子层(LLC)和媒体访问拧制子层(MAC)。数据链路层负责分配MAC地址。MAC地址(或称物理地址)，48比特长，由12个十六进制数字组成，0~23位(前6位十六进制数)是厂商向IETF等机构申请用来标识厂商的代码。24到47位由厂商自行分派，是各个厂商制造的所有网卡的一个唯一编号。因此每一个网卡会有一个全球唯一固定的MAC地址，但可对应多个IP地址。MAC地址的第48位是组播地址标志位。 网络层提供点到点的通信。直接相连的结点之间的通信称为点到点通信。它只提供一台机器到另一台机器之间的通信，不会涉及程序或进程的概念。 传输层是第一个提供端到端的通信，即进程到进程的层次。由于一个主机可同时运行多个进程，因此传输层有复用和分用的功能。 每一层的协议及设备如下： 物理层(中继器，集线器)：RJ45、CLOCK、IEEE802.3 数据链路(网桥，交换机)：PPP、FR、HDLC、VLAN、MAC 网络层(路由器)：IP、ICMP、ARP、RARP、OSPF、IPX、RIP(内部网关协议，基于UDP)、IGRP、IGMP 传输层：TCP、UDP、SPX、SCTP 会话层：NFS、SQL、NETBIOS、RPC 表示层：JPEG、MPEG、ASII 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS、SNMP 例1： RIP协议是基于UDP协议实现的。 例2：网卜完成哪一层的功能？ 答案：网卡工作在物理层和数据链路层的MAC子层 问：TCP/IP参考模型TCP/IP模型从低到高依次为：网络接口层、网际层、运输层、应用层。TCP/IP由于得到广泛应用而成为事实上的国际标准。 网络接口层的功能类似于OSI的物理层和数据链路层。 网际层是TCP/IP体系结构的关键部分。它和OSI网络层在功能上非常相似。网际层将分组发往任何网络，并为之独立地选择合适的路由，但它不保证各个分组有序到达，各个分组的有序交付由高层负责。网际层定义了标准的分组格式和协议，即IP协议。当前采用的IP协议是第4版，即IPv4，它的下一个版本是IPv6。 传输层的功能同样和OSI中的传输层类似，是使发送端和目的端主机上的对等实体可以进行会话。 应用层包含所有的高层协议。如虚拟终端协议(Telnet)、文件传输协议(FTP)、域名解析服务(DNS)、电子邮件协议(SMTP)和超文本传输协议(HTTP)。 传输层主要使用以下两种协议: (1) 传输控制协议(Transmission Control Protocol, TCP)。它是面向连接的，数据传输的单位是报文段，能够提供可靠的交付。 (2) 用户数据报协议(User Datagram Protocol, UDP)。它是无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供”尽最大努力交付”。 例1 TCP/IP模型中，ARP协议属于网络层，在OSI参考模型中，ARP属于数据链路层 问：各种协议的介绍(2) TFTP协议 TFTP协议是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。基于UDP协议实现，端口号为69。 (3) HTTP协议(超文本传输协议) 该协议定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。HTTP是面向事务的应用层协议，它规定了浏览器和服务器之间的请求和响应格式和规则，是万维网上能够可靠地交换文件(包括文本、声音、图像等各种多媒体文件)的重要基础。 (4) NAT协议 网络地址转换属接入广域网(WAN)技术，它通过将私有网络地址(如企业内部Internet)转换为共用地址(如Internet)，从而对外隐藏了内部管理的IP地址。它使得整个私有网络只需要一个全球IP地址就可以与因特网连同。由于私有网络本地IP地址是可以重用的，所以NA大大节省了IP地址的消耗；同时，它隐藏了内部网络结构，从而降低了内部网络收到攻击的风险。 (5) DHCP协议(动态主机配置协议，DHCP是应用层协议，它是基于UDP的) 常用于给主机动态地分配IP地址，提供了即插即用联网机制，这种机制允许一台计算机加入新的网络和获取IP地址而不用手动参与。 问：了解中继器、集线器、网桥、交换机、路由器、网关的概念，并知道各自的用途(1) 中继器 中继器工作在物理层，用来连接两个速率相同且数据链路层协议也相同的网段，连接起来的几个网段仍然是一个局域网。 中继器功能是消除数字信号在基带传输中由于经过一长段电缆而造成的失真和衰减，使信号的波形和强度达到所需的要求，其原理是信号再生。 中继器既不能隔离冲突域，也不能隔离广播域。 (2) 集线器 集线器也工作在物理层，相当于一个多接口的中继器，可以将多个节点连接成一个共享式局域网，但任何时刻只能有一个节点通过公共信道发送数据。 中继器既不能隔离冲突域，也不能隔离广播域。 举例：假设一集线器存在７个端口，共连接了５台计算机，那么该网络环境中存在冲突域的个数为1。 原因：集线器的所有端口是一个冲突域，而交换机的每个端口是一个冲突域 (3) 网桥 两个或多个以太网通过网桥连接起来后，就成为一个覆盖范围更大的以太网，而原来的每个以太网就可称为一个网段。 网桥工作在数据链路层的MAC子层，可以互联不同的物理层、不同的MAC子层以及不同速率的以太网，使以太网各网段成为隔离开的碰撞域。 网桥具有过滤帧以及存储转发帧的功能，可以隔离冲突域，但不能隔离广播域。 (4) 交换机 交换机工作在数据链路层，俗称”二层交换机”，相当于一个多端口的网桥，是交换式局域网的核心设备。除此之外，还有三层交换机、四层交换机，七层交换机，分别工作在OSI第三层、第四层、第七层。 交换机允许端口之间建立多个并发的连接，允许多对计算机同时通信，实现多个节点之间的并发传输。因此，交换机的每个端口节点所占用的带宽不会因为端口节点数目的增加而减少，且整个交换机的总带宽会随着端口节点的增加而增加。 交换机一般以全双工方式工作，有的局域网交换机采用存储转发方式进行转发，有的交换机采用直通交换方式(即在收到帧的同时立即按帧的目的MAC地址决定帧的转发端口，而不必进行先缓存再进行处理)。 利用交换机可以实现虚拟局域网(VLAN)，VLAN可以隔离冲突域，也可以隔离广播域。 (5) 路由器 路由器是一种具有多个输入输出端口的专用计算机，其任务是连接不同的网络(连接异构网络)并完成路由转发。 路由器是网络层设备，它实现了网络模型的下三层，即物理层、数据链路层和网络层。路由器隔离了广播域。 路由器主要完成两个功能：分组转发和路由计算。前者处理通过路由器的数据流，关键操作是转发表查询、转发以及相关的队列管理和任务调度等；后者通过和其他路由器进行基于路由协议的交互，完成路由表的计算。 (6) 网关 在传统TCP/IP术语中，网关(gateway)与路由器(router)没有区别。 在现代网络术语中，网关与路由器的定义不同。网关能在不同协议间移动数据，而路由器是在不同网络间移动数据，相当于传统所说的IP网关。网关是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过网关还原成模拟的电话信号，最后才能在电话机上听到。 二、 物理层三、 数据链路层问：太网卡的工作模式例1：太网卡的工作模式 答案：广播模式、多播传送、直接模式、混杂模式 问：海明码例1：用海明码对长度为8位的数据进行检/纠错时，若能纠正一位错，则校验位数至少为多少？ 答案为4。 假设为k个数据位设置r个校验位，则校验位能表示2^r个状态。 可用其中的一个状态指出&quot;没有发生错误&quot;，用其余的2^r-1个状态指出有错误发生在某一位，包括k个数据位和r个校验位。 因此校验位的位数应满足如下关系:2^r≥k+r+1。 问：交换机攻击交换机攻击主要有以下5种类型 (1) VLAN跳跃攻击(2) 生成树攻击(3) MAC表洪水攻击(4) ARP攻击(5) VTP攻击 问：CSMA/CD例1： CSMA/CD适用于有线网络，而CSMA/CA则广泛应用于无线局域网。 四、 网络层问：IPv4地址分类连接在Internet中的每台主机(或路由器)都分配一个32bit的全球唯一的标识符，即IP地址。IP地址的编码方法有三种:分类的IP地址、子网的划分和CIDR。 传统的IP地址是分类的地址，分为A、B、C、D、E五类。无论哪类IP地址，都由网络号和主机号两部分组成。其中，网络号代表主机所连接到的网络，主机号代表该主机或路由器在网络中的地址。 A类地址(1~126)：网络号占前8位，以0开头，主机号占后24位。 B类地址(128~191)：网络号占前16位，以10开头，主机号占后16位。 C类地址(192~223)：网络号占前24位，以110开头，主机号占后8位。 D类地址(224~239)：以1110开头，保留为多播地址。 E类地址(240~255)：以1111开头，保留为今后使用。 在各类IP地址中，有一些IP地址用于表示特殊用途，不用于作主机IP地址: 主机号全为0表示本网络本身，例如202.98.174.0；主机号全为1表示本网络的广播地址，例如202.98.174.255。 网络号剩余字段全为0的IP地址是保留地址，表示本网络，如00000000+24位主机号 127.X.X.X网络保留做为环路自检地址，该地址表示任意主机本身，目的地址为环路自检地址的IP数据报永远不会出现在网络上。 32位全为1，即255.255.255.255表示整个TCP/IP网络的广播地址;32位全为0，即0.0.0.0表示本网络上的本主机。 问：网络地址转换网络地址转换(NAT)是通过将专用网络地址(如企业内网)转换为公用地址(如互联网Internet，从而对外隐藏了内部管理的IP地址。这样，通过在内部使用非注册的IP地址，并将它们转换为一小部分外部注册的IP地址，从而减少了IP地址注册的费用以及节省了日前越来越缺乏的IPv4地址空间。 此外，划出了部分IP地址为私有IP地址。私有IP地址值用于LAN，不用于WLAN连接。因此私有IP地址不能直接用于Internet，必须通过网关利用NAT把私有IP地址转换为Internet中合法的全球IP地址后才能用于Internet。私有IP地址有效地解决了IP地址不足的问题。私有IP地址网段如下: A类：1个A类网段，即10.0.0.0~10.255.255.255 B类：16个B类网段，即172.16.0.0~172.31.255.255 C类：256个C类网段，即192.168.0.0~192.168.255.255 在因特网中的所有路由器，对目的地址是私有地址的数据报一律不进行转发。使用NAT时，需要在专用网连接到因特网的路由器上安装NAT软件，NAT路由器至少有一个有效的外部全球地址。普通路由器在转发数据报时不改变其源IP地址和目的IP地址，且路由器工作在网络层，而NAT路由器在转发IP数据报时，一定要更换其IP地址(按路由器中的地址转换表转换源IP地址或目的IP地址)。NAT路由器转发数据报时需要查看和转换传输层的端口，其操作没有严格的层次关系。 问：子网划分与子网掩码各类地址的默认子网掩码： A类：255.0.0.0 B类：255.255.0.0 C类：255.255.255.00 使用子网划分时的地址格式: A类网络：8位+子网X位+主机24-X位 B类网络：16位+子网X位+主机16-X位 C类网络：24位+子网X位+主机8-X位 例1：使用子网掩码255.255.255.224可以将C类地址203.67.12.0分成多少个子网。 答案：8个 把子网掩码255.255.255.224转换成二进制：11111111.11111111.11111111.11100000 网络ID=24bits(C类地址)，子网ID=3位，主机ID=5位 所以，子网数位2^3=8个，每个子网的地址数为2^5=32个，每个子网的主机地址数为32-2=30个。 自所以减去2是因为全0和全1的主机号不能使用。 问：无分类编址CIDRCIDR是在使用可变长度子网掩码的基础上提出的一种消除传统A，B，C类网络划分，并且可以在软件的支持下实现超网构造的一种IP地址的网络划分方法。这样可以大幅度提高IP地址空间的利用率，并减小路由表大小，提高路由器的路由转发能力。 CIDR的主要特点如下: (1) 消除了传统的A，B，C类地址以及子网的概念，因而可以更加有效地分配IPv4的地址空间。CIDR使用”网络前缀”概念代替子网络概念。这样IP地址分为两部分:网络前缀、主机号。CIDR使用斜线记法，即IP地址/网络前缀所占比特数。其中，网络前缀所占比特数对应于网络号的部分，等效子网掩码中连续1的部分。 (2) 将网络前缀都相同的连续的IP地址组成”CIDR地址块”。一个CIDR地址块可以包括多个A、B、C类地址，这种地址的聚合称为路由聚合，或称为构成超网。路由聚合使得路由表中的一个表项可以表示很多个原来传统分类地址的路由，有利于减少路由之间的路由选择信息的交换，从而提高网络性能。 例1：CIDR地址块192.168.10.0/20所能包含主机的最大地址范围是多少？ 答案：192.168.0.1~192.168.15.254 CIDR地址由网络前缀和主机号构成。CIDR将网络前缀都相同的连续的IP地址组成&quot;CIDR&quot;地址块。 本题中，网络前缀的长度为20，把IP的第17~24bit写成二进制位00001010，这8bit中的前4bit为前缀，后4bit为主机号。 由于主机号不能为全0或全1，因此地址块所能包含的主机最大范围为192.168.0.1~192.168.15.254。 问：ARP是地址解析协议，简单语言解释一下工作原理。在实际网络的数据链路上传送数据时，最终必须使用硬件地址。所以需要一种方法来完成IP地址到MAC地址的映射，这就需要用到地址解析协议(ARP)。 每个主机(或路由器)都有一个ARP高速缓存，存放本局域网上各主机或路由器的IP地址到MAC地址的映射表，称为ARP表，主机(或路由器)使用ARP协议来动态维护此ARP表。 ARP工作在网络层，其工作原理是(广播发送ARP请求，单播发送ARP响应)： (1) 当主机源欲向本局域网上的某个目的主机发送IP数据报时，就先在其ARP高速缓存中查看有无目的主机的IP地址，如果有，就可以查出其对应的MAC地址，并将此地址写入MAC帧，然后通过局域网将该MAC帧发往此地址；如果没有，就通过使用目的MAC地址为FF-FF-FF-FF-FF-FF的帧来封装并广播ARP请求数据包(该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP地址)，可以使同一个局域网中的所有主机收到ARP请求。 (2) 当本局域网中的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后向源主机发出ARP响应包，该响应包中包含自己的IP地址与MAC地址的映射关系。 (3) 源主机收到ARP响应包后,将目的主机的IP和MAC地址的映射写入ARP表，然后按查询到的MAC地址发送MAC帧。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。 问：描述RARP协议RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。 工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。 问：ICMP协议(因特网控制报文协议，TCP/IP协议族IP层子协议)为了提高IP数据报交付成功的机会，网络层使用ICMP协议来允许主机或路由器报告差错和异常情况。ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去。 问：在局域网内使用ping www.nowcoder.com时，使用了哪些协议？Ping命令工作在应用层，它直接使用网络层的ICMP协议，而没有使用传输层的TCP或UDP协议。 (1) 首先将域名转换为IP地址，用到了应用层的DNS协议，而DNS协议使用了传输层的UDP协议。 (2) ping功能是测试另一台主机是否可达，程序发送一份ICMP回显请求给目标主机，并等待返回ICMP回显应答 (3) 数据在局域网中，根据MAC地址通过数据链路层传输，所以要用到ARP解析服务，获取到目的主机的MAC地址 问：IPv6IPv6由128bit构成，通常使用冒号十六进制记法表示IPv6地址，每个16bit的值用四位十六进制值表示，各值之间用冒号分割，如68E6:8C64:FFFF:FFFF:0:1180:960A:FFFF。该表示方法允许使用零压缩，即一连串连续的零可以为一对冒号所取代，如DE08:0:0:0:0:0:0:B3可以写成DE08::B3。IP地址0:0:0:0:0:0:118.17.23.1可以写成::118.17.23.10。 IPv6所引入的主要变化: 更大的地址空间。IPv6将地址从IPv4的32bit增大到了128bit; 扩展的地址层次结构； 灵活的首部格式； 改进的选项。这一特征加快了分组处理速度； 允许协议继续扩充； 支持即插即用； 支持资源的预分配； 增加了安全性，身份验证和保密验证是IPv6的关键特征； 分片限制为由源点来完成，是端到端的，路由途中的路由器不允许进行分片。 问：TTL例1：当路由器接收的IP报文的TTL值等于1时，采取的策略是什么？ 答案：丢掉该分组 问：广播风暴一个数据帧或包被传输到本地网段上的每个节点就是广播；由于网络拓扑的设计和连接问题，或其他原因导致广播在网段内大量复制，传播数据帧，导致网络性能下降，甚至网络瘫痪，这就是广播风暴。所以需要有能够隔离广播域的设备才可以抑制广播风暴。 五、 传输层问：UDP用户数据报协议(User Datagram Protocol)。UDP是一种无连接协议，因为UDP客户与服务器不必存在长期的关系，例如一个UDP客户创建一个套接字并发送一个数据报给一个服务器，然后立即用同一个套接字发送另一个数据报给另外一个服务器。同样，一个UDP服务器可以使用同一个套接字从若干不同的客户一连串接受多个数据报。 UDP不是可靠的，不能保证最终到达它们的目的地，不保证各个数据报的先后顺序跨越网络保持不变，也不保证每个数据报只到达一次。 UDP既可以使用IPv4，也可以使用IPv6。 问：TCP传输控制协议(Transmission Control Protocol)。 (1) TCP是一种面向连接的协议，提供客户与服务器的连接。 (2) TCP提供可靠性。当使用TCP向另一端发送数据时，它要求对端返回一个确认。如果没有收到确认，TCP自动重传数据并等待更长时间。在数次重传失败后，TCP才放弃。 (3) TCP通过给所发送数据的每一个字节关联一个序列号进行排序。UDP提供不可靠的数据报传送，不提供确认、序列号、超时重传等机制。 (4) TCP提供流量控制，而UDP不提供流量控制。TCP总是告诉对端它能够接收多少字节的数据，这称为通信窗口。该窗口在任何时刻都指出接收缓冲区中的可用空间，从而确保发送端发送的数据不会溢出接收缓冲区。 (5) TCP的连接是全双工的。UDP也可以是全双工的。 TCP既可以使用IPv4，也可以使用IPv6 0 UDP与TCP的主要区别在于UDP不一定提供可靠的数据传输。事实上，该协议不能保证数据准确无误地到达目的地。UDP在许多方面非常有效，如UDP具有对系统资源要求较少、具有较好的实时性、网络开销小的优点。当某个程序的目标是尽快地传输尽可能多的信息时(其中任意给定数据的重要性相对较低)，可使用UDP。 问：TCP和UDP的区别？TCP和UDP的区别： (1) TCP提供面向连接的、可靠的数据流传输，而UDP提供的是面向无连接的、不可靠的数据流传输。 (2) TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。 (3) TCP由于提供面向连接的可靠的传输服务，因此不可避免地增加了许多开销，如确认、流量控制、计时器以及连接管理，这不仅使协议数据单元的头部增加很多，还占用许多处理机资源，因此TCP主要适用于可靠性更重要的场合，如文件传输协议FTP、超文本传输协议HTTP、远程登陆TELNET等；UDP由于在传送数据之前不需要先建立连接，远程主机的传输层收到UDP报文后，不需要给出任何确认，执行速度比较快、实时性较好，因此UDP主要适用于实时性要求高的场合，如小文件传输协议(TFTP)、DNS、SNMP和实时协议(RTP)。 例1 TCP对应的协议和UDP对应的协议 (1) TCP对应的协议： FTP：定义了文件传输协议，使用21端口。https://www.nowcoder.com/profile/7404313/test/8114836/23235?onlyWrong=0 Telnet：一个通过创建虚拟终端提供登陆到远程主机终端的协议，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。 SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。 POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。 HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。HTTP协议所用的是80端口。 (2) UDP对应的协议： DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。 SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。 TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。 问：TCP三次握手和四次挥手的全过程 (1) 三次握手 第一次握手(SYN=1，seq=x)：客户端首先向服务器发送一个连接请求报文段，并进入SYN_SEND状态，等待服务器确认。这个报文段不含应用层数据，其首部中的SYN标志位被置为1，另外，客户端会随机选择一个起始序号seq=x。(连接请求报文段不携带数据，但要消耗一个序号) 第二次握手(SYN=1, ACK=1, seq=y, ack=x+1)：服务器收到连接请求报文段，如同意建立连接，就向客户端发回确认，并为该TCP连接分配TCP缓存和变量，此时服务器进入SYN_RECV状态。在确认报文段中，SYN和ACK位都被置为1，确认号字段的值为x+1，并且服务器随机产生起始序号seq=y。确认报文段同样不包含应用层数据。 第三次握手(ACK=1, seq=x+1, ack=y+1)：当客户端收到确认报文段后，还要向服务器给出确认，并且也要给该连接分配缓存和变量，客户端和服务器进入ESTABLISHED状态，完成三次握手。这个报文段的ACK标志位被置1，序号字段为x+1，确认号字段ack=y+1。(该报文段可以携带数据，如果不携带数据则不消耗序号)。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。 例1 四次挥手 与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。 第一次挥手(FIN=1，seq=u)：主动关闭方打算关闭连接，就向被动关闭方发送一个连接释放报文段并停止再发送数据，进入FIN_WAIT1状态，主动关闭TCP连接。该报文段的FIN标志位被置为1，seq=u，它等于前面已传送过的数据的最后一个字节的序号加1(FIN报文段即使不携带数据，也要消耗一个序号)。当发送FIN报文时，发送FIN的一方就不能再发送数据了(当然，在FIN包之前发送出去的数据，如果没有收到对应的确认报文，主动关闭方依然会重发这些数据)，也就是关闭了其中一条数据通路，但此时对方还可以发送数据，主动关闭方还可以接受数据。 第二次挥手(ACK=1，seq=v，ack=u+1)：被动关闭方收到连接释放报文段后即发出确认，并进入CLOSE_WAIT状态，确认号是ack=u+1，而这个报文段自己的序号是v，等于它前面已经传送过的数据最后一个字节的序号加1。此时，从主动关闭方到被动关闭方这个方向的连接就释放了，TCP连接处于半关闭状态，但被动关闭方若发送数据，主动关闭方仍要接收。 第三次挥手(FIN=1，ACK=1，seq=w，ack=u+1)：若被动关闭方已经没有要向主动关闭方发送的数据，就通知TCP释放连接，此时其发出FIN=1的连接释放报文段。 第四次挥手(ACK=1，seq=u+1，ack=w+1)：主动关闭方收到连接释放报文段后，必须发出确认。在确认报文段中，ACK字段被置1，确认号ack=w+1，序号seq=u+1。至此，完成四次挥手。 此时，TCP连接还没有释放掉，必须经过时间等待计时器设置的时间2MSL后，主动关闭方才进入连接关闭状态。 例1:看评论中的图，例2，例3，例4 问：TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。 采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。 考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，若不采用三次握手，新的连接就建立了，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。 采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。 例1 问：TCP拥塞控制-慢启动和拥塞避免例1 六、 应用层问：FTP协议问：DNS域名系统，简单描述其工作原理。域名系统DNS(Domain Name System)是因特网使用的命名系统，用来把便于人们记忆的含有特定含义的主机名(如www.baidu.com)转换成便于机器处理的IP地址。DNS系统采用客户/服务器模型，其协议运行在UDP之上，使用53号端口。该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。 工作原理 当客户端需要域名解析时，通过本机的DNS客户端构造一个DNS请求报文，以UDP数据报方式发往本地域名服务器。域名解析有两种方式：递归查询(实际中几乎不使用)和迭代查询。 (1) 递归查询 如果本地主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向根域名服务器继续发出查询请求报文(即替该主机继续查询)，而不是让主机自己进行下一步的查询。在这种情况下，本地域名服务器只需向根域名服务器查询一次，后面的几次查询都是递归地在其他几个域名服务器之间进行的(如图a步骤3-6)。在步骤7中，本地域名服务器从根域名服务器得到了所需的IP地址，最后在步骤8中，本地域名服务器把查询结果告诉主机。 (2) 迭代查询 当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地域名服务器：“你下一次应当向哪个顶级域名服务器进行查询”，然后让本地域名服务器向这个顶级域名服务器进行后续的查询，如图b所示。同样，顶级域名服务器收到查询报文后，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步应当向哪一个域名服务器查询。最后，本地域名服务器知道了所要解析的域名的IP地址，然后把查询结果返回给发起查询的主机。 问：HTTP协议的特点例1，例2 问：在浏览器中输入www.baidu.com后执行的全部过程事件顺序 (1) 浏览器获取输入的域名www.baidu.com (2) 浏览器向DNS请求解析www.baidu.com对应的IP地址 (3) 域名系统DNS解析出百度服务器的IP地址 (4) 浏览器与该服务器建立TCP连接(默认端口号80)，并向服务器发送HTTP请求，请求百度首页 (6) 服务器通过HTTP响应把首页文件发送给浏览器 (7) TCP连接释放 (8) 浏览器将首页文件进行解析，并将Web页显示给用户。 涉及到的协议 (1) 应用层：HTTP(WWW访问协议)，DNS(域名解析服务) (2) 传输层：TCP(为HTTP提供可靠的数据传输)，UDP(DNS使用UDP传输) (3) 网络层：IP(IP数据数据包传输和路由选择)，ICMP(提供网络传输过程中的差错检测)，ARP(将本机的默认网关IP地址映射成物理MAC地址) 问：常见的http协议状态码网络上的一份总结 http1.1状态吗分为五类，所有状态码的第一个数字代表了响应的五种状态之一。 1xx:消息，这一类型的状态码，代表请求已被接受，需要继续处理。其中100表示客户端应当继续发送请求。 2xx:成功，这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。其中200表示请求已成功，请求所希望的响应头或数据体将随此响应返回。 3xx:重定向。 302 临时重定向，(此时浏览器会产生两次http请求) 4xx:客户端错误。其中400表示:语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求；或者请求参数有误。 400 请求报文存在语法错误 403 禁止访问，资源不可用 404 请求的资源不存在 5xx:服务器错误。 500 服务器内部错误 503 服务器繁忙 问：HTTP请求方法OPTIONS、HEAD、GET、POST、PUT、DELETE、TRACE、CONNECT 七、 常用网络测试工具问：pingping是用来检查网络是否通畅或者网络连接速度的命令。 它所利用的原理是这样的:利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通、时延是多少。ping命令是控制台命令，例如Ping百度的用法如下: ping www:baidu.com 问：tracerttracert是路由跟踪实用程序，用于确定IP数据包访问目标所采取的路径。 tracert命令用IP生存时间(TTL)字段和ICMP错误消息来确定从一个主机到网络上其他主机的路由。其命令格式如下: tracert[-d] [-h maximum_hops] [-j computer_list] [-w timeout] target_name 可以使用tracert命令确定数据包在网络上的停留位置。例如:tracert www:baidu.com则会打印出从当前主机到目的主机所经过的路由地址。 问：telnettelnet在网络测试中十分有用，例如可以用telnet测试80端口的Web服务器是否正常工作。输入: telnet www.hitsz .edu.cn 80 然后服务器响应: Trying 219.223.252.3... Connected to www.hitsz.edu.cn Eseape character is &apos;^]&apos;. 然后输入: GET / HTTP1.1 如果Web服务器正常工作的话，就会返回服务器的响应头，以便你确认服务器的情况。 问：netstatnetstat是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每个网络接口设备的状态信息。 netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。使用格式为: netstat [-a] [-e] [-n] [-o] [-p Protocol] [-r] [-s] [Interval] 一般用netstat -an来显示所有连接的端口并用数字表示。 例1：某校园网用户无法访问外部站点210.102.58.74，管理人员在Windows操作系统下可以使用()命令判断故障发生在校园网内还是校园网外。 A. ping 210.102.58.74 B. tracert 210.102.58.74 C. netstat 210.102.58.74 D. arp 210.102.58.74 答案：B 八、 其他东西问：往返时延和网络延迟往返时延(Round-Trip Time, RTT):表示从发送端发送数据开始，到发送端收到来自接收端的确认(接收端收到数据后便立即发送确认)，总共经历的时延。 网络延迟是数据进入网络到离开网络所花费的总时间。 使用最广泛是的B通路B通路：具有定时的64Kbit/s通路，用于传递广泛的各种用户信息流，不传递ISDN电路交换的信令信息。 D通路：主要用于传递ISDN电路交换的信令信息，也可以传递遥信信息和分组交换数 据。D通路可以有不同的比特率， H通路：H通路有以下几种传输速率： H0通路：384Kbit/s H11通路：1536 Kbit/s H12通路：1920 Kbit/s H通路用于传递各种用户信息流，例如高速传真、电视影像、高质量音频或声音节目、高速数据、分组交换信息等，不传递ISDN电路交换的信令信息。 https://www.nowcoder.com/profile/7404313/test/8046849/14529?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/7959409/3989?onlyWrong=0","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://hepsilion.github.io/tags/计算机网络/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"操作系统","slug":"操作系统","date":"2017-03-16T10:53:28.000Z","updated":"2017-07-22T13:13:12.003Z","comments":true,"path":"2017/03/16/操作系统/","link":"","permalink":"https://hepsilion.github.io/2017/03/16/操作系统/","excerpt":"操作系统","text":"操作系统 一、 概述二、 进程管理问：进程进程(Process)是计算机中已运行程序的实体。程序本身只是指令的集合，进程才是程序(那些指令)的真正运行。用户下达运行程序的命令后，就会产生进程。同一程序可产生多个进程(一对多关系)，以允许同时有多位用户运行同一程序，却不会相互冲突。进程需要一些资源才能完成工作，如CPU使用时间、存储器、文件以及I/O设备，且为依序逐一进行，也就是任何时间内仅能运行一项进程。 通常进程有如下5种状态，其中前3种是进程的基本状态。 运行状态:进程正在处理器上运行。在单处理器环境下，每一时刻最多只有一个进程处于运行状态。 就绪状态:进程已处于准备运行的状态，即进程获得了除处理器之外的一切所需资源，一旦得到处理器即可运行。 阻塞状态:又称为等待状态，进程正在等待某一事件而暂停运行，如等待某资源为可用(不包括处理器)或等待输入/输出完成。即使处理器空闲，该进程也不能运行。 创建状态:进程正在被创建，尚未转到就绪状态。 结束状态:进程正从系统中消失。可能是进程正常结束或其他原因中断退出运行。 进程的三个基本状态之间是可以相互转换的。具体地说，当一个就绪进程获得处理机时，其状态由就绪变为执行；当一个运行进程被剥夺处理机时，如用完系统分给它的时间片、出现更高优先级别的其他进程，其状态由运行变为就绪；当一个运行进程因某事件受阻时，如所申请的资源被占用、启动I/O传输未完成，其状态由执行变为阻塞；当所等待事件发生时，如得到申请的资源、I/O传输完成，其状态由阻塞变为就绪。 问：进程的特征 并发性：指多个进程实体同存于内存中，且在一段时间内同时运行。并发性是进程的重要特征，同时也成为操作系统的重要特征。 动态性：进程的实质是进程实体的一次执行过程，因此，动态性是进程最基本的特征。 独立性：进程实体是一个独立运行、独立分配资源和独立接受调度的基本单位。 异步性：指进程按各自独立的、不可预知的速度向前推进，或者说实体按异步方式运行。 问：进程与程序的区别 进程是程序及其数据在计算机上的一次运行活动，是一个动态的概念。进程的运行实体是程序、离开程序的进程没有存在的意义。从静态角度看，进程是由程序、数据和进程控制块(PCB)三部分组成的。而程序是一组有序的指令集合，是一种静态的概念。 进程是程序的一次执行过程，它是动态地创建和消亡的，具有一定的生命期，是暂时存在的；而程序则是一组代码的集合，它是永久存在的，可长期保存。 一个进程一可以执行一个或几个程序，一个程序也可以构成多个进程。进程可创建进程，而程序不可能形成新的程序。 进程与程序的组成不同。进程的组成包括程序、数据和进程控制块。 创建新进程时会创建新的地址空间:子进程是父进程的复制品，在fork之后子进程获得父进程的数据空间、堆和栈的复制。而线程使用当前的地址空间。 例1：请问下面的程序一共输出多少个”-“() #include&lt;stdio.h&gt; #include&lt;sys/types.h&gt; #include&lt;unistd.h&gt; int main(void){ int i; for(i=0; i&lt;2; i++){ fork(); printf(&quot;-&quot;); } return 0; } 答案：8个。 程序一开始，产生一个进程P1执行此程序，P1进入程序后，此时i=0，于是进入循环体，fork()产生一个子进程P2，接着P1执行下一条语句输出一个&quot;-&quot;(其实是放入缓冲区，等合适的时候再输出，我们将此&quot;-&quot;记为a)； P2成为一个独立的子进程，继承P1的诸如环境变量、PC等环境，P2也执行下一条语句输出一个&quot;-&quot;(其实是放入缓冲区，等合适的时候再输出，我们将此&quot;-&quot;记为b)，同时P2中此时i=1，继续执行for循环---P2先fork()出一个子进程P3，然后P2再执行下一条语句输出一个&quot;-&quot;(其实是放入缓冲区，等合适的时候再输出，我们将此&quot;-&quot;记为c)。 P3进程为P2的子进程，它会复制其父进程P2的诸如环境变量、PC等环境，它执行下一条语句(输出语句)本应该输出一个&quot;-&quot;，但事实上因为这里P3会继承P2的缓冲区，而P2的缓冲区中有个&apos;-&apos;(P2调用fork产生P3时缓冲区里有b)，所以P3会输出两个&apos;-&apos;。 P1产生子进程P2后，继续下一轮循环，当i=1时，fork()产生另一个它的子进程P4，同时P1执行输出语句输出一个&apos;-&apos;。 P4为P1的一个子进程，它会继承P1的缓冲区，P1缓冲区中已经有一个&apos;-&apos;(P1调用fork产生P4时缓冲区里有a)，所以P4执行输出语句时会输出两个&apos;-&apos;。 上述输出语句本应该都输出一个&apos;-&apos;，有时却输出两个&apos;-&apos;，是因为&quot;printf(&quot;-&quot;)&quot;语句不是立即输出，而是先将输出放入缓冲区。所以，在fork的时候，缓存被复制到了子进程空间，导致子进程的输出缓冲区己经有了一个&apos;-&apos;。 例2：请问下而的程序一共输出多少个”-“()？ #include&lt;stdio.h&gt; #include&lt;sysltypes.h&gt; #include&lt;unistd.h&gt; int main(void){ int i; for(i=0; i&lt;2; i++){ fork(); printf(&quot;-\\n&quot;); } return 0 } 答案：6个 输出&apos;\\n&apos;会刷新缓冲区，故正常输出6个。 问：线程线程，有时被称为轻量级进程(Light weight Process，LWP)，是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针(PC)、寄存器集合和堆栈(stack)组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的资源。 线程共享的进程环境包括:进程代码段、进程的公有数据(如全局变量，利用这些共享的数据，线程很容易的实现相互之间的通信)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。 线程拥有这许多共性的同时，还拥有自己的个性。有了这些个性，线程才能实现并发性。这些个性包括: 线程ID：每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程。 寄存器组的值：由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有线程的寄存器集合的状态进行保存，以便将来该线程在被重新切换时能得以恢复。 线程的堆栈(stack)：堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影啊。在一个进程的线程共享堆区(heap)。 错误返回码 线程的信号屏蔽码 线程的优先级 一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。线程是程序中一个单的顺序控制流程。在单个程序中同时运行多个线程完成不同的工作，称为多线程。 引入线程后，进程的内涵发生了改变，进程只作为除CPU以外系统资源的分配单元，线程则作为处理器的分配单元。在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，将会引起进程的切换。 例1：有关多线程，多进程的描述错误的是()。 A.子进程获得父进程的数据空间，堆和栈的复制品 B.线程可以与同进程的其他线程共享数据，但是它拥有自己的栈空间且拥有独立的执行序列 C.线程执行开销小，但是不利于资源管理和保护 D.进程适合在SMP机器上进行，而线程则可以跨机器迁移 答案：D。 线程不能跨机器迁移。 问：进程与线程的区别(1) 调度:在传统操作系统中，拥有资源和独立调度的基本单位都是进程。引入线程后，线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行的线程切换，则会引起进程切换。 (2) 拥有资源:不论是传统的还是引入线程的操作系统，进程都是拥有资源的基本单位，线程不拥有资源(也有一点必不可少的资源)，但线程可以共享其隶属进程的系统资源。 (3) 并发性:在引入线程的操作系统中，不仅进程可以并发执行，而且同一进程内的多个线程也可以并发执行，从而使操作系统具有更好的并发性，大大提高了系统吞吐量。 (4) 系统开销:创建和撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，因此操作系统所付出的开销远远大于创建或撤销线程的开销。类似地，在进程切换时，涉及当前执行进程CPU环境的保存以及新调度的进程CPU环境的设置；而线程切换时只需保存和设置少量寄存器内容，因此开销很小。另外，由于同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信比较容易实现，甚至无须操作系统的干预。 (5) 地址空间和其他资源(如打开的文件):进程的地址空间之间互相独立，同一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见。 (6) 通信方面:进程间通信需要借助操作系统，而线程间可以直接读/写进程数据段(如全局变量)来进行通信。 举例：若系统中只有用户级线程，则处理机调度单位是进程。 原因：如果系统只有用户态线程，则线程对操作系统是不可见的，操作系统只能调度进程；如果系统中有内核态线程，则操作系统可以按线程进行调度； 例1 问：进程的重要性与进程的销毁顺序进程的重要性依次是：前台进程&gt;可见进程&gt;服务进程&gt;后台进程&gt;空进程。进程销毁的顺序为逆方向。 问：进程控制原语原语是由若干条机器指令所构成，用以完成特定功能的一段程序，为保证其操作的正确性，它应当是原子操作，即原语是一个不可分割的操作。所以，原语在执行的过程中，是不可以被中断的。 操作系统对进程的管理和控制主要是通过控制原语言实现的，包括：进程创建，进程阻塞，唤醒进程和进程终止四个原语。 问：调度的基本准则调度的基本准则包括CPU利用率、系统吞吐量、周转时间、等待时间、响应时间等。 系统吞吐量表示单位时间内CPU完成作业的数量。 周转时间为作业完成时刻减去作业到达的时刻。 等待时间是指进程处于等待处理器状态的时间之和，等待时间越长，用户满意度越低。 响应时间是指从用户提交请求到系统首次产生响应所用的时间。 问：调度算法典型调度算法包括：先来先服务算法(FCFS)，短作业优先算法(SJF)、优先级调度算法、高响应比优先调度算法、时间片轮转算法、多级反馈队列调度算法。 注意： 高响应比优先调度算法中，响应比=(等待时间+服务时间)/服务时间 短作业优先算法的平均等待时间、平均周转时间最少。 一道很好的题目： 问：进程通信与进程同步多个进程可以共享系统中的各种资源，但其中许多资源一次只能被一个进程使用，我们把一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。对临界资源的访问，必须互斥的进行，在每个进程中，访问临界资源的那段代码称为临界区(Critical Section)。 (1) 进程通信与同步有如下一些目的 数据传输:一个进程需要将它的数据发送给另一个进程; 共享数据:多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到; 通知事件:一个进程需要向另一个或一组进程发送消息，通知它(它们)发生了某种事件(如进程终止时要通知父进程)。 资源共享:多个进程之间共享同样的资源。为了做到这一点，需要内核提供锁和同步机制; 进程控制:有些进程希望完全控制另一个进程的执行(如Debug进程)，此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。 (2) 进程间、线程间的通信方式 Linux下进程间通信的方式 管道(Pipe)及有名管道(named pipe):管道可用于具有亲缘关系的进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信; 信号(Signal):信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；Linux除了支持UNIX早期信号语义函数sigal外，还支持语义符合Posix标准的信号函数sigaction； Message(消息队列):消息队列是消息的链表，包括Posix消息队列System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。 共享内存:使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其他通信机制，如信号量结合使用，来达到进程间的同步及互斥。 信号量(semaphore)：主要作为进程间以及同一进程不同线程之间的同步手段。 套接字(Socket)：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由UNIX系统的BSD分支开发出来的，但现在一般可以移植到其他类UNIX系统上:Linux和System V的变种都支持套接字。 Linux线程间通信的方式：互斥量(Mutex)，信号量，条件变量。 Windows进程间通信的方式：管道、共享内存、消息队列、信号量、socket Windows线程间通信的方式：临界区(Critical Section)，互斥量(Mutex)、信号量(Semaphore)和事件(Event)。 例1 (3) 临界区(Critical section)与互斥量(Mutex)的区别 临界区只能用来同步本进程内的线程，而不可用来同步多个进程中的线程；互斥量(Mutex)、信号量(Semaphore)、事件(Event)都可以被跨越进程使用来进行同步数据操作; 临界区是非内核对象，只在用户态进行锁操作，速度快；互斥体是内核对象，在核心态进行锁操作，速度慢。 临界区和互斥体在Windows平台都下可用，Linux下只有互斥量可以使用。 例1： 在win32平台下，Event、Semaphore、Mutex能够实现进程同步，Critical Section无法实现进程同步。 问：死锁(1) 死锁的概念 所谓死锁是指多个进程因竞争资源而造成的一种僵局(相互等待)，若无外力作用，这些进程都将无法向前推进。现实生活中一个简单的例子:交通阻塞，两股相向而行的车流都想通过已被对方占用的道路，结果双方都不能前进。 (2) 死锁的原因 系统资源的竟争 进程推进顺序非法 (3) 死锁产生的必要条件 产生死锁必须同时满足以下四个条件，只要其中任意一个条件不成立，死锁就不会发生。 互斥条件:进程要求对所分配的资源进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。 不剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放。 请求和保持条件:又称为部分分配条件。进程每次申请它所需要的一部分资源，在等待新资源的同时，进程继续占有已分配到的资源。 循环等待条件:存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所清求。即存在一个处于等待状态的进程集合{P1，P2，P3，…，Pn}，其中Pi等待的资源被P(i+1)占有，Pn等待的资源被P0占有。 (4) 死锁处理策略 预防死锁:设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个。 避免死锁:在资源的动态分配过程中，用某种方法防止系统进入不安全状态。银行家算法是著名的死锁避免算法。 死锁的检测及解除:无须采取任何限制性措施，允许进程在运行过程中发生死锁，通过系统的检测机制及时地检测出死锁的发生，然后采取某种措施解除死锁。 死锁的检测可利用资源分配图来描述。 死锁的解除主要方法如下：资源剥夺法、撤销进程法、进程回退法。 问：锁的类型例1 三、 内存管理操作系统对内存的划分和动态分配，就是内存管理的概念。内存管理的功能有: 内存空间的分配与回收，包括内存的管理和共享。 地址转换，把逻辑地址转换成相应的物理地址。 内存空间的扩充，利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存。 存储保护，保证各道作业在各自的存储空间内运行，互不干扰。 问：GB、MB和KB换算1GB=1024MB 1MB=1024KB 问：逻辑地址空间与物理地址空间编译后，每个目标模块都是从0号单元开始编址，称为该目标模块的相对地址(或逻辑地址)。当链接程序将各个模块链接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从0号单元开始编址的逻辑地址空间。 物理地址空间是指内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据都要通过物理地址来存取主存。当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为地址重定位。 问：静态重定位和动态重定位对程序进行重定位的技术按重定位的时机可分为两种：静态重定位和动态重定位。现在一般计算机系统中都采用动态重定位方法。 (1) 静态重定位：是在目标程序装入内存时，由装入程序对目标程序中的指令和数据的地址进行修改，即把程序的逻辑地址都改成实际的地址。对每个程序来说，这种地址变换只是在装入时一次完成，在程序运行期间不再进行重定位。 优点：是无需增加硬件地址转换机构，便于实现程序的静态连接。在早期计算机系统中大多采用这种方案。 缺点： 程序的存储空间只能是连续的一片区域，而且在重定位之后就不能再移动。这不利于内存空间的有效使用。 各个用户进程很难共享内存中的同一程序的副本。 (2) 动态重定位：是在程序执行期间每次访问内存之前进行重定位。这种变换是靠硬件地址变换机构实现的。通常采用一个重定位寄存器，其中放有当前正在执行的程序在内存空间中的起始地址，而地址空间中的代码在装入过程中不发生变化。 优点： 程序占用的内存空间动态可变，不必连续存放在一处。 比较容易实现几个进程对同一程序副本的共享使用。 缺点：是需要附加的硬件支持，增加了机器成本，而且实现存储管理的软件算法比较复杂。 例1：能实现紧凑技术的存储管理方式为？ A. 可变分区管理 B. 分区存储管理 C. 页式存储管理 D. 可重定位存储管理 答案：D 内存分配管理方式内存分配管理方式包括连续分配管理方式与非连续分配管理方式。 连续分配方式，是指为一个用户程序分配一个连续的内存空间。它主要包括单一连续分配、固定分区分配和动态分区分配。 非连续分配管理方式允许一个程序分散地装入到不相邻的内存分区中，根据分区的大小是否固定分为分页存储管理方式和分段存储管理方式。分页存储管理方式中，又根据运行作业时是否要把作业的所有页而都装入内存才能运行分为基本分页存储管理方式和请求分页存储管理方式。 问：动态分区分配(1) 首次适应(First Fit)算法 空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。 该算法优先使用低址部分空闲区，在低址空间造成许多小的空闲区，在高地址空间保留大的空闲区。 (2) 最佳适应(Best Fit)算法 空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。 (3) 最坏适应(Worst Fit)算法，又称为最大适应(Largest Fit)算法 空闲分区按容量递减形成分区链，找到第一个能满足要求的空闲分区，也就是找出最大的分区。 (4) 邻近适应(Next Fit)算法，又称为循环首次适应算法 该算法是首次适应算法的变种，不同之处是分配时从上次查找结束的位置开始继续查找。 该算法能使内存中的空闲区分布得较均匀。 问：基本分页存储管理方式固定分区会产生内部碎片，动态分区会产生外部碎片，这两种技术对内存的利用率都比较低。我们希望内存的使用能尽量避免碎片的产生，这就引入了分页的思想:把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。 分页的方法从形式上看，像分区相等的固定分区技术，分页管理不会产生外部碎片。但它又有本质的不同点:块的大小相对分区要小很多，而且进程也按照块进行划分，进程运行时按块申请主存可用空间并执行。这样，进程只会在为最后一个不完整的块申请一个主存块空间时，才产生主存碎片，所以尽管会产生内部碎片，但是这种碎片相对于进程来说也是很小的，每个进程平均只产生半个块大小的内部碎片(也称页内碎片)。 分页存储的几个基本概念： (1) 页面和页面大小。 进程中的块称为页(Page)，内存中的块称为页框(Page Frame，或页帧)。外存也以同样的单位进行划分，称为块(Block)。进程在执行时需要申请主存空间，就是要为每个页面分配主存中的可用页框，这就产生了页和页框的一一对应。 为方便地址转换，页面大小应是2的整数幂。同时页面大小应该适中，如果页面太小，会使进程的页面数过多，这样页表就过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面换入/换出的效率；页面过大又会使页面内碎片增大，降低内存的利用率。所以页面的大小应该适中，考虑到空间效率和时间效率的权衡。 (2) 地址结构。 分页存储管理的逻辑地址结构如下图所示： 地址结构包含两部分:前一部分为页号P，后一部分为页内偏移量M。地址长度为32位，其中0~11位为页内地址，即每页大小为4KB;12~31位为页号，地址空间最多允许有2^20页。 (3) 页表。 为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般存放在内存中。在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射。 问：基本分段存储管理方式段式管理方式按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段，每段从0开始编址，并分配一段连续的地址空间(段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的)。其逻辑地址由段号S与段内偏移量W两部分组成。 在下图中，段号为16位，段内偏移量为16位，则一个作业最多可有2^16=65536个段，最大段长为64KB。 在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在段式系统中，段号和段内偏移量必须由用户显示提供，在高级程序设计语言中，这个工作由编译程序完成。 问：段页式管理方式页式存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享。如果将这两种存储管理方法结合起来，就形成了段页式存储竹理方式。 在段页式系统中，作业的地址空间首先被分成若干逻辑段，每段都有自己的段号，然后再将每一段分成若干大小固定的页。对内存空间的管理仍然和分页存储管理一样，将其分成若干和页面大小相同的存储块，对内存的分配以存储块为单位。 在段页式系统中，作业的逻辑地址分为三部分:段号、页号和页内偏移量。为了实现地址变换，系统为每个进程建立一张段表，而每个分段有一张页表。段表表项中至少包括段号、页表长度和页表起始地址，页表表项中至少包括页号和块号。此外，系统中还应有一个段表寄存器，指出作业的段表起始地址和段表长度。在进行地址变换时，首先通过段表查到页表起始地址，然后通过页表找到页帧号，最后形成物理地址。 问：虚拟存储器的定义和特征基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。之所以将其称为虚拟存储器，是因为这种存储器实际上并不存在，只足由于系统提供了部分装入、请求调入和置换功能后(对用户完全透明)，给用户的感觉是好像存在一个比实际物理内存人得多的存储器。 虚拟内存的实现有以下三种方式: 请求分页存储管理 请求分段存储管理 请求段页式存储管理 段页式虚拟存储器一方面具有段式虚拟存储器的主要优点。例如，用户程序可以模块化编写，程序段的共享和信息的保护都比较方便，程序可以在执行时再动态链接等。另一方面也具有页式虚拟存储器的主要优点。例如:主存储器的利用率比较高，对辅助存储器的管理比较容易等。 不管哪种方式，都需要有一定的硬件支持。一般需要的硬件支持有以下个方面： 一定容量的内存和外存； 页表机制(或段表机制)，作为主要的数据结构； 中断机构，当用户程序要访问的部分尚未调入内存，则产生中断； 地址变换机构，逻辑地址到物理地址的变换。 例1： 问：请求分页管理方式请求分页系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。 在请求分页系统中，只要求将当前需要的一部分页面装入内存，便可以启动作业运行。在作业执行过程中，当所要访问的页面不在内存时，再通过调页功能将其调入，同时还可以通过置换功能将暂时不用的页面换出到外存上，以便腾出内存空间。为了实现请求分页，系统必须提供一定的硬件支持。除了需要一定容量的内存及外存的计算机系统，还需要有页表机制、缺页中断机构和地址变换机构。 常见的置换算法有一下三种:最佳置换算法(OPT)、先进先出页面置换算法(FIFO)、最近最久未使用置换算法(LRU)。 问：页面置换算法 OPT(Optimal Replacement) FIFO(First in First out) LRU(Least Recently Used)，和使用时间相关，和使用次数（频率）无关 LFU(Least Frequently Used)，和使用次数(频率)相关，和使用时间无关 网络上的一个简要的总结 (1) 最佳置换算法(OPT) 最佳置换算法(Optimal, OPT)所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。 最佳置换算法可以用来评价其他算法。假定系统为某进程分配一了三个物理块，并考虑有以下页面号引用串:7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1，进程运行时，先将7，0，1三个页面依次装入内存。进程要访问页面2时，产生缺页中断，根据最佳置换算法，选择第18次访问才需调入的页面7予以淘汰。然后，访问页面0时，因为已在内存中所以不必产生缺页中断。访问页面3时又会根据最佳置换算法将页面淘汰，以此类推，如下图所示。从图中可以看出采用最佳置换算法时页面置换情况。 (2) 先进先出页面置换算法(FIFO) 优先淘汰最早进入内存的页而，亦即在内存中驻留时间最久的页面。该算法实现简单，只需把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最旱的页面。但该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。 这里仍用上而的实例，采用FIFO算法进行页面置换。进程访问页面2时，把最一早进入内存的页面7换出。然后访问页面3时，再把2，0，1中最先进入内存的页面0换出。由图2_2可以看出，利用FIFO算法时进行了12次页面置换，比最佳置换算法正好多一倍。 (3) 最近最久未使用置换算法(LRU) 选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内末访问过的页面，在最近的将来可能也不会被访问。该算法为每个页而设置个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。 再对上面的实例采用LRU算法进行页面置换，如图2-4所示。进程第一次对页面2访问时，将最近最久未被访问的页而7置换出去。然后访问页而3时，将最近最久未使用的页面1换出。 在上图中，前5次置换的情况与最佳置换算法相同，但两种算法并无必然联系。实际上，LRU算法根据各页以前的情况，是”向前看”的，而最佳置换算法则根据各页以后的使用情况，是”向后看”的。LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类的算法。理沦上可以证明，堆栈类算法不可能出现Belady异常。FIFO算法基于队列实现，不是堆栈类算法。 问：Belady’s AnomalyBelady’s Anomaly，即Belady异常或者Belady现象。 所谓Belady现象是指：在页面置换中，当发生缺页时的置换算法采用FIFO(先进先出)算法时，有时会出现分配的页面数增多但缺页率不减反增的异常现象。只有FIFO算法可能出现Belady异常，而LRU和OPT算法永远不会出现Belady异常。 例如：访问页面序列为：1，2，3，4，1，2，5，1，2，3，4，5。当分配页面数位3时，缺页9次；当分配页面数位4时，缺页10次。 问：抖动在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为抖动，或颠簸。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。 频繁的发生缺页中断，其主要原因是某个进程频繁访问的页面数目高于可用的物理页帧数目。虚拟内存技术可以在内存中保留更多的进程以提高系统效率。但系统必须很”聪明”地管理页面分配方案。在稳定状态，几乎主存的所有空间都被进程块占据，处理机和操作系统可以直接访问到尽可能多的进程。但如果处理不当，处理机的大部分时间都将用于交换块，即请求调入页面的操作，而不是执行进程的指令，这就会大大降低系统效率。 问：工作集工作集(或驻留集)是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。 工作集模型的原理是:让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。如果还有空闲物理块，则可以再调一个进程到内存以增加多道程序数。如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会暂停一个进程，将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象。 正确选择工作集的大小，对一存储器的利用率和系统吞吐量的提高，都将产生重要影响。 问：磁盘磁盘是可共享设备，一段时间内允许多个用户进行交叉访问，同一时刻只能有一个进程访问。 问：磁盘平均存取时间平均存取时间=寻道时间+延迟时间+传输时间 例1 问：RAID阵列RAID 0：无差错控制的带区组 要实现RAID0必须要有两个以上硬盘驱动器，RAID0实现了带区组，数据并不是保存在一个硬盘上，而是分成数据块保存在不同驱动器上。在所有的级别中，RAID 0的速度是最快的。但是RAID 0没有冗余功能的，如果一个磁盘(物理)损坏，则所有的数据都无法使用。 RAID 1：镜象结构 当主硬盘损坏时，镜像硬盘就可以代替主硬盘工作。镜像硬盘相当于一个备份盘，可想而知，这种硬盘模式的安全性是非常高的，RAID 1的数据安全性在所有的RAID级别上来说是最好的。但是其磁盘的利用率却只有50%，是所有RAID级别中最低的。 RAID5：分布式奇偶校验的独立磁盘结构 RAID5最大的好处是在一块盘掉线的情况下，RAID照常工作，相对于RAID0必须每一块盘都正常才可以正常工作的状况容错性能好多了。因此 RAID5是RAID级别中最常见的一个类型。RAID5校验位即P位是通过其它条带数据做异或(xor)求得的。计算公式为 P=D0xorD1xorD2…xorDn，其中p代表校验块，Dn代表相应的数据块，xor是数学运算符号异或。 RAID10：高可靠性与高效磁盘结构 RAID 10是先镜射再分区数据。是将所有硬盘分为两组，视为是RAID 0的最低组合，然后将这两组各自视为RAID 1运作。RAID 10有着不错的读取速度，而且拥有比RAID 0更高的数据保护性。 四、 文件管理硬链接和软链接https://www.nowcoder.com/profile/7404313/test/8129531/15818?onlyWrong=0 五、 输入输出(I/O)管理问：I/O控制方式 程序直接控制方式 中断驱动方式：允许I/O设备主动打断CPU的运行并请求服务，从而解放CPU，使得CPU向I/O控制器发送读命令后可以继续做其他有用的工作。 DMA方式：在中断驱动方式中，I/O设备与内存之间的数据交换必须要经过CPU中的寄存器，所以速度受限，而DMA(直接存储器存取)方式的基本思想是在I/O设备和内存之间开辟直接的数据交换通路，彻底解放CPU。 DMA方式的特点： (1) 基本单位是数据块 (2) 所传送的数据，是从设备直接送入内存的，或者相反。 (3) 仅在传送一个或多个数据块的开始和结束时，才需要CPU干预，整块数据的传送是在DMA控制器的控制下完成的。 通道方式 通道能够完成内存与外设之间数据的传输。 问：独享设备、共享设备和虚拟设备 独享设备：在一个用户作业未完成或退出之前，此设备不能分配给其他作业用。所有字符设备都是独享设备。如输入机、磁带机、打印机等。——很明显：需要装驱动。 共享设备：多个用户作业或多个进程可以”同时”从这些设备上存取信息。软硬盘、光盘等块设备都是共享设备。——无需驱动。 虚拟设备：通过软件技术将独享设备改造成共享设备。例如：通过SPOOLing技术将一台打印机虚拟成多台打印机。——实质还是独享设备，需要驱动。 问：单缓冲和双缓冲https://www.nowcoder.com/profile/7404313/test/8073949/24035?onlyWrong=0 问：I/O子系统的层次结构操作系统的I/O 子系统通常由 4 个层次组成，每一层明确定义了与邻近层次的接口，其合理的层次组织排列顺序是：用户级 I/O 软件、设备无关软件、设备驱动程序、中断处理程序 七、 其他进程间的通信方式 管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。 套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 RPC 内存分配方式有三种： （1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。 （2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 （3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多 相联存储器相联存储器（associative memory),也称为按内容访问存储器（content addressed memory)或简称为TLB(Translation Lookaside Buffer)，它是一种不根据地址而是根据存储内容来进行存取的存储器,可以实现快速地查找块表 大端存储和小端存储https://www.nowcoder.com/profile/7404313/test/7907952/14799?onlyWrong=0 案例1： union X{ int x; char y[4]; }; 在小端序的机器中,如果定义X a; a.x=0x11223344;//16 进制，则a.y[3]=0x11 在union 中所有的数据成员共用一个空间，同一时间只能储存其中一个数据成员，所有的数据成员具有相同的起始地址。 管道管道是指用于连接一个读进程和一个写进程以实现进程之间通信的一种共享文件。向管道提供输入的是发送进程，也称为 写进程，负责向管道输入数据，数据的格式是字符流。接受管道 数据的接受进程为读进程。 12. 零碎的东西孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上 ，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。 因此孤儿进程并不会有什么危害。 链接：https://www.nowcoder.com/questionTerminal/8c8bcba738eb4facbdfdb22f47961bee来源：牛客网 Redhat 9所支持的安装方式有光盘安装 (常规情况) 硬盘安装 (无光驱情况)网络安装-NFS方式 (适合于批量安装大量服务器，和kickstart自动安装一起使用)网络安装-FTP方式 (适合于批量安装大量服务器，和kickstart自动安装一起使网络安装-HTTP方式 (适合于批量安装大量服务器，和kickstart自动安装一起使 问：可重入函数https://www.nowcoder.com/profile/7404313/test/8114731/56534?onlyWrong=0 问：并发https://www.nowcoder.com/profile/7404313/test/8114731/44749?onlyWrong=0","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://hepsilion.github.io/tags/操作系统/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"数据结构","slug":"数据结构","date":"2017-03-15T10:38:35.000Z","updated":"2017-07-22T13:13:06.558Z","comments":true,"path":"2017/03/15/数据结构/","link":"","permalink":"https://hepsilion.github.io/2017/03/15/数据结构/","excerpt":"数据结构","text":"数据结构 一、绪论问：数据项、数据元素、数据对象、数据(了解)(1) 数据元素是数据的基本单位。一个数据元素可由若干个数据项组成，数据项是构成数据元素的不可分割的最小单位。 例如，学生记录就是一个数据元素，它由学号、姓名、性别等数据项组成。 (2) 数据对象是具有相同性质的数据元素的集合，是数据的一个子集。 问：抽象数据类型(了解)一个数学模型以及定义在此模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。通常用(数据对象、数据关系和基本操作)三元组来表示抽象数据类型。 问：数据结构的三要素：逻辑结构、存储结构和数据的运算。问：数据的逻辑结构与存储结构逻辑结构：指是数据元素之间的逻辑关系，通常分为线性结构和非线性结构。 存储结构：也称为物理结构，指数据结构在计算机中的表示，也称为存储结构，通常分为顺序结构，链式结构，索引结构，哈希结构。 问：线性结构与非线性结构线性结构与非线性结构，主要看元素之间的关系，如果是一对一的关系则是线性表，如果不是一对一的关系则是非线性表。 数据结构中线性结构指的是数据元素之间存在着“一对一”的线性关系的数据结构。常用的线性结构有：线性表，栈，队列，双队列，数组，串。 线性结构是一个数据元素的有序（次序）集合。它有四个基本特征： (1) 集合中必存在唯一的一个”第一个元素”； (2) 集合中必存在唯一的一个”最后的元素”； (3) 除最后元素之外，其它数据元素均有唯一的”后继”； (4) 除第一元素之外，其它数据元素均有唯一的”前驱”。 相对应于线性结构，非线性结构的逻辑特征是一个结点元素可能对应多个直接前驱和多个直接后继。如树，广义表，图，多维数组等 问：顺序存储结构和链式存储结构顺序存储结构的主要特点： (1) 结点中只有自身的信息域，没有关联信息域。因此，顺序存储结构的存储密度大、存储空间利用率高。 (2) 通过计算地址直接访问任何数据元素，即可以随机访问。 (3) 插入和删除操作会引起大量元素的移动。 链式存储结构的主要特点是： (1) 结点除自身的信息域外，还有表示关联信息的指针域。因此，链式存储结构的存储密度小、存储空间利用率低。 (2) 在逻辑上相邻的结点在物理上不必相邻，因此，不可以随机存取，只能顺序存取。 (3) 插入和删除操作方便灵活，不必移动结点只需修改结点中的指针域即可。 问：广义表如果广义表LS=(a1, a2, …, an)非空，则a1是LS的表头，其余元素组成的表(a2,a3,..an)是称为LS的表尾，所以非空广义表尾一定是个表。 例1： 已知广义表LS＝((a,b,c),(d,e,f)),运用head和tail函数取出LS中原子e的运算是：head(tail(head(tail(LS)))) tail(LS)＝((d,e,f)) head(tail(LS))=(d,e,f) tail(head(tail(LS)))=(e,f) head(tail(head(tail(LS))))=e 广义表可以是自身的子表。(没理解) 例2： 例3：判断正误。 若一个广义表的表头为空表,则此广义表亦为空表。 错误。 例4：判断正误。 对长度为无穷大的广义表,由于存储空间的限制,不能在计算机中实现. 正确。 问：算法的5个基本特征有穷性、确定性、可行性、输入、输出。 问：主定理图 1 二、线性表问：静态链表用数组描述线性表的链式存储结构，即称为静态链表，它的节点有数据域和指针域，指针是节点的相对地址(数组下标)。 例1： 用数组r存储静态链表，结点的next域指向后继，工作指针j指向链中结点，使j沿链移动的操作为：j=r[j].next 三、栈和队列栈有n个数依次入栈，则出栈序列有Cn种，Cn=C(2n,n)/(n+1)。 例1： 问：顺序存储结构的循环队列假设循环队列的队尾指针是rear，队头是front，其中QueueSize为循环队列的最大长度。 (1) 入队时队尾指针前进1：(rear+1)%QueueSize (2) 出队时队头指针前进1：(front+1)%QueueSize 例1，例2 (3) 队列长度：(rear-front+QueueSize)%QueueSize 例1： 现有一循环队列，其队头指针为front，队尾指针为rear；循环队列长度为N。其队内有效长度为？(假设队头不存放数据) 答案：(rear-front+N)%N (4) 队空和队满的条件 为了区分队空还是堆满的情况，有多种处理方式： 方式1： 牺牲一个单元来区分队空和队满，入队时少用一个队列单元，即约定以”队头指针在队尾指针的下一位置作为队满的标志”。 队满条件为：(rear+1)%QueueSize==front 队空条件为：front==rear 队列长度为：(rear-front++QueueSize)%QueueSize 方式2： 增设表示队列元素个数的数据成员size，此时，队空和队满时都有front==rear。 队满条件为：size==QueueSize 队空条件为：size==0 方式3： 增设tag数据成员以区分队满还是队空 tag表示0的情况下，若因删除导致front==rear，则队空； tag等于1的情况，若因插入导致front==rear则队满 例1： 循环队列的存储空间为Q(1:50)，初始状态为front=rear=50。 经过一系列正常的入队与退队操作后，front=rear=25。此后又插入一个元素，则循环队列中的元素个数为多少？ 答案：1，或50且产生上溢错误 例2： 循环队列的存储空间为Q(1:40)，初始状态为front=rear=40。 经过一系列正常的入队与退队操作后，front=rear=15，此后又退出一个元素，则循环队列中的元素个数为多少？ 答案：39，或0且产生下溢错误 例3： 设循环队列的存储空间为Q(1:35)，初始状态为front=rear=35。现经过一系列入队与退队运算后，front=15，rear=15，则循环队列中的元素个数为多少？ 答案：0或35 例4： 循环队列的存储空间为Q(1:200)，初始状态为front=rear=200。经过一系列正常的入队与退队操作后，front=rear=1 则循环队列中的元素个数为多少？ 答案：0或200 例：个人觉得这一题条件不全 最大容量为n的循环队列,队尾指针是rear,队头是front,则队空的条件是：rear=front 问：算术表达式的中缀表达式、前缀表达式和后缀表达式表达式一般由操作数、运算符组成，例如算术表达式中，通常把运算符放在两个操作数的中间，这称为中缀表达式，如A+B。波兰数学家Jan Lukasiewicz提出了另一种数学表示法，它有两种表示形式：把运算符写在操作数之前，称为波兰表达式或前缀表达式，如+AB；把运算符写在操作数之后，称为逆波兰表达式或后缀表达式，如AB+。 将中缀表达式转换成后缀表达式的算法： 例1：将中缀表达式a+b-a*((c+d)/e-f)+g转化为后缀表达式ab+acd+e/f-*-g+的过程。 图 1 例2：简易方法 中缀表达式：a+b*c-(d+e) (1) 中缀表达式转换为前缀表达式： 第一步：按照运算符的优先级对所有的运算单位加括号，算术表达式变成： ((a+(b*c))-(d+e)) 第二步：把每个运算符号移动到其对应的括号前面，则算术表达式变成了： -( +(a *(bc)) +(de)) 第三部：去掉括号得到前缀表达式： -+a*bc+de (2) 中缀表达式转换为后缀表达式： 第一步：按照运算符的优先级对所有的运算单位加括号，算术表达式变成： ((a+(b*c))-(d+e)) 第二步：把每个运算符号移动到其对应的括号后面，则算术表达式变成了： ((a(bc)* )+ (de)+ )- 第三部：去掉括号得到后缀表达式： abc*+de+- 例3，例4，例5，例6，例7，例8 逆波兰表达式求值算法： 1、循环扫描语法单元的项目。 2、如果扫描的项目是操作数，则将其压入操作数堆栈，并扫描下一个项目。 3、如果扫描的项目是一个二元运算符，则对栈的顶上两个操作数执行该运算。 4、如果扫描的项目是一个一元运算符，则对栈的最顶上操作数执行该运算。 5、将运算结果重新压入堆栈。 6、重复步骤2-5，堆栈中即为结果值。 问：稀疏矩阵的压缩存储方法有：三元组、十字链表四、树与二叉树问：平衡二叉树是平衡二叉排序树问：平衡二叉树的平衡操作图 1 例 问：完全二叉树的几个性质(1) 完全二叉树中，编号为i的结点，其父节点为[i/2]（向下取整）。 (2) 完全二叉树中，编号为i的结点，有如下四个性质（1&lt;=i&lt;=n，n为结点个数） 判断编号为i的结点是叶子结点，还是分支结点：若2*i&lt;=n，则结点i为分支结点，否则为叶子结点。 分支结点的左右孩子情况，以及最大分支结点编号 若n为奇数，则所有分支结点都有左右孩子。 若n为偶数，则编号为[n/2]（向下取整）的结点，只有左孩子，没有右孩子；其余分支结点左右孩子都有。 最大分支结点编号都是[n/2]（向下取整）。 编号为i的结点如果有左孩子，则左孩子编号为2i；如果有右孩子，则右孩子的编号为2i+1 编号为i的结点的父结点编号为[i/2]（向下取整）（根节点除外） 问：二叉树在线索化后,仍不能有效求解的问题例1：王道数据结构2015版118页27题 二叉树在线索化后，仍不能有效求解的问题是(D) A. 先序线索二叉树中求先序后继 B. 中序线索二叉树中求中序后继 C. 中序线索二叉树中求中序前驱 D. 后序线索二叉树中求后序后继 解释：如图所示，节点E的右指针指向右孩子，而在后序序列中E的后继节点为B，在查找E的后继时，后序线索不能起到任何作用，只能按常规方法来查找。 问：红黑树例1 问：森林与二叉树树转换成二叉树的步骤： 森林转换成二叉树的步骤： (1) 先把森林中的每棵树转换成二叉树 (2) 第一颗二叉树不动，从第二颗二叉树开始，依次把后一颗二叉树的根结点作为前一颗二叉树的根结点的右孩子结点，用线连起来。当所有的二叉树连接起来后得到的二叉树就是由森林转换得到的二叉树。 注意： (1) 将森林F转换为对应的二叉树T，F中叶结点的个数等于T中左孩子指针为空的结点个数。 在二叉树中，节点的左指针指向其孩子，节点的右指针指向其兄弟。在一颗二叉树中，如果某个节点的左指针为NULL，就说明这个节点在原来的森林中没有孩子，是叶子节点；如果某个节点的右指针为NULL，就说明这个节点在原来的森林中没有兄弟。 所以森林中的叶子节点=二叉树中左指针为NULL的个数。 问：将森林F转换为对应的二叉树T，F中叶结点的个数等于T中左孩子指针为空的结点个数例1 问：将森林F转换为对应的二叉树T，若F中有n个非终端结点，则T中右指针域为空的结点数为n+1。例1 问：树和森林的遍历与二叉树遍历的对应关系图 1 五、图问：顶点的度有向图中，所有顶点的入度之和等于所有顶点的出度之和 问：连通图与强连通图，连通分量与强连通分量在无向图中，如果从顶点v到顶点w有路径存在，则称v和w连通的。如果图中任意两个顶点之间都连通，则称该图为连通图，否则，称该图为非连通图。无向图的极大连通子图称为连通分量。 在有向图中，如果从顶点v到顶点w和从顶点w到顶点v之间都有路径存在，则称v和w是强连通的。如果图中任意两个顶点之间都是强连通的，则称该图为强连通图。有向图的极大连通子图称为强连通分量。 问：十字链表十字链表(Orthogonal List)是有向图的另一种链式存储结构。该结构可以看成是将有向图的邻接表和逆邻接表结合起来得到的。例子 问：几种算法的时间复杂度(1) Prim算法 例1 在图采用邻接表存储时,求最小生成树的Prim算法的时间复杂度为：O(n+e) (2) Kruskal算法 (3) Dijkstra算法 (4) Floyd算法 (5) 拓扑排序 例1 若初始序列为gbfcdae，那么至少需要()次两两交换，才能使该序列变为abcdefg。 任给一个自由a--g这7个字母组成的排列，最坏的情况下需要至少()次两两交换，才能使序列变为abcdefg。 答案：5 6 本质是图论里的拓扑排序问题，将每个字符现在的位置与其排序后的位置连一条单向边，最小两两交换次数为：字符总数-连接后形成的环数(包括自环) (1) gbfcdae-&gt;abcdefg g b f c d a e a b c d e f g 其中，b为自环，而a-&gt;f-&gt;c-&gt;d-&gt;e-&gt;g-&gt;a为另一个环，所以最小交换次数=7-2=5次 (2) 任意a--g这7个字母组成的排列-&gt;abcdefg 最坏情况下是所有字符形成一个环，如gabcdef需要至少6次交换才能变为abcdefg 问：AOV网和AOE网如果用有向无环图表示一个工程，其定点表示活动，用有向边表示活动Vi必须先于Vj进行的一种关系，则将这种有向图称为表示活动的网络，简称AOV网。 在带权有向图中，以定点表示事件，有向边表示活动，边上的权值表示完成该活动的开销(如完成活动所需要的时间)，则称这种有向图为用边表示活动的网络，简称为AOE网。 问：关键路径在AOE网中，从源点到汇点的所有路径中，具有最大路径长度的路径称为关键路径。 在AOE网中，可以有不止一条的关键路径。 关键路径的计算步骤 问：可以判断出一个有向图是否有环的算法(1) 深度优先遍历 (2) 拓扑排序 六、查找问：折半查找的条件数据有序、顺序存储 (如果数据存储在链式结构的链表中同样可以采用跳表完成二分法查找) 问：分块查找分块查找的平均查找长度为索引查找和块内查找的平均长度之和，设索引查找和块内查找的平均查找长度分别为Li和Ls，则分块查找的平均查找长度为ASL=Li+Ls。 问：B树与B+树的区别(1) B树是一棵多路搜索树。一棵m阶B树或为空树，或为满足如下特性的m叉树： 树中每个节点之多有m棵子树(即最多有m-1个关键字) 若根节点不是叶节点，则至少有两棵子树 除根节点以外的所有非叶节点至少有[m/2]棵子树(即至少含有[m/2]-1个关键字)。([]为(上取整)) 所有非叶节点的关键字为K[1]，K[2]，…，K[n-1]且K[i]&lt;K[i+1]；指向子树的指针为P[1]，P[2]，…，P[M]，其中P[0]指向关键字小于K[1] 的子树，P[n]指向关键字大于K[n]的子树，其它P[i]指向关键字属于(K[i], K[i+1])的子树 所有的叶节点都出现在同一层上，并且不带信息 (2) B+树 (3) B树与B+树的区别 B树只能进行索引查找，B+树既能顺序查找，也能索引查找 问：哈夫曼树最优二叉树是哈夫曼树，而哈夫曼树不一定是完全二叉树。 例1： 解析没看懂 已知三叉树T中6个叶结点的权分别是2，3，4，5，6，7，T的带权(外部)路径长度最小是：46 问：哈希表(1) 构造哈希表时经常使用的哈希函数 直接定址法：取关键字或关键字的某个线性函数值为散列地址，即H(key)=key或H(key)=a·key+b，其中a和b为常数(这种散列函数叫做自身函数) 数字分析法 平方取中法 折叠法 除留余数法 (2) 冲突处理的方法 开哈希表——-链式地址法/拉链法 闭哈希表——-开放地址法：线性探测法、平方探测法、再散列法、伪随机序列法 问：Hash的冲突处理例1，例2，例3，例4 问：KMP算法(1) 先了解使用KMP算法进行字符串匹配的过程 KMP算法的最大特点在于：当一趟匹配过程中出现字符不匹配时，不需回溯主串指针，而是利用已经得到的”部分匹配”结果将模式串向右”滑动”尽可能远的一段距离后，继续进行比较，从而提高匹配效率。 (2) KMP算法代码 #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; void computeNext(string pattern, vector&lt;int&gt;&amp; next){ int len=pattern.size(); next.push_back(0); int matchLength=0; for(int q=1; q&lt;len; q++){ while(matchLength&gt;0 &amp;&amp; pattern[q]!=pattern[matchLength]){ matchLength=next[matchLength-1]; } if(pattern[q]==pattern[matchLength]){ matchLength++; } next.push_back(matchLength); } } int kmp(string str, string pattern){ vector&lt;int&gt; next; computeNext(pattern, next); int m=str.size(); int n=pattern.size(); for(int i=0, matchLength=0; i&lt;m; i++){ while(matchLength&gt;0 &amp;&amp; str[i]!=pattern[matchLength]){ matchLength=next[matchLength-1]; } if(str[i]==pattern[matchLength]){ matchLength++; } if(matchLength==n) return i-n+1; } return -1; } int main(){ string str=&quot;BBC ABCDAB ABCDABCDABDE&quot;; string pattern=&quot;ABCDABD&quot;; cout&lt;&lt;kmp(str, pattern)&lt;&lt;endl; return 0; } (3) next数组求解，本质上在求模式串每一位的最大相同前后缀的长度 来源 void computeNext(string pattern, vector&lt;int&gt;&amp; next){ int len=pattern.size(); next.push_back(0); //模式串P的第一个字符的最大相同前后缀长度为0 int matchLength=0; //当前已经求得的子串的最大相同前后缀长度 for(int q=1; q&lt;len; q++){ //从第二个字符开始，依次计算每一个字符对应的next值 while(matchLength&gt;0 &amp;&amp; pattern[q]!=pattern[matchLength]){//while循环 matchLength=next[matchLength-1]; } if(pattern[q]==pattern[matchLength]){ //如果相等，那么最大相同前后缀长度加1 matchLength++; } next.push_back(matchLength); } } 设有模式串P(代码中表示为pattern)，第一个字符的最大相同前后缀长度为0，即next[0]=0，现在准备求模式串P其他字符位对应的next数组值。 next数组求解最大的难点在于while循环，这里重点解释while循环所做的工作： (1) 假设当前已求得P[0, …, q-1]的最大相同前后缀的长度为k(代码中表示为matchLength)，即next[q-1]=k。 (2) 现在求next[q]，即P[0, …, q]的最大相同前后缀的长度。此时比较模式串P中字符位P[q]和字符位P[k]，如图1所示。 如果P[q]等于P[k]，那么很简单，P[0, …, q]的最大相同前后缀的长度等于P[0, …, q-1]的最大相同前后缀的长度加1，即next[q]=next[q-1]+1，继续求下一个位置的next值。 但如果P[q]不等于P[k]又该怎么办呢？这时我们可以利用已经得到的next[0, …, k-1]，为什么呢？ 原因在于P[k]已经和P[q]失配了，而P[q-k, …, q-1]又与P[0, …, k-1]相同，那么在P[0]···P[k-1]这么长的子串用不了的情况下，我们能不能找到一个同样以P[0]开头、P[k-1]结尾且尽可能长的子串来和P[0, …, q-1]匹配？这样的子串存在吗？当然是存在的，想一想P[0, …, k-1]子串不是有最大相同前后缀吗？next[k-1]不就是P[0, …, k-1]子串的最大相同前后缀的长度嘛！那么我们取这个子串为P[0, …, k-1]的最大前缀不就可以了嘛，即P[0, …, j-1] (j=next[k-1])，然后看它的下一项P[j]能否和P[q]匹配，如图2所示。 注意：在一些笔试题中，经常会让选择正确的next数组值，不同的方法计算出来的next数组可能不一样 这里是其中一种计算方式： 例1：求模式串ababaaababaa的next数组。 i 0 1 2 3 4 5 6 7 8 9 10 11 s a b a b a a a b a b a a next[i]的值等于s[i]之前的子串中最长相同前后缀的长度。next[0]=-1为定值。 next[1]等于s[1]之前的子串&quot;a&quot;中最长相同前后缀的长度，为0，故next[1]=0； next[2]等于s[2]之前的子串&quot;ab&quot;中最长相同前后缀的长度，为0，故next[2]=0； next[3]等于s[3]之前的子串&quot;aba&quot;中最长相同前后缀的长度，s[0]与s[2]为最长相同前后缀，长度为1，故next[3]=1； next[4]等于s[4]之前的子串&quot;abab&quot;中最长相同前后缀的长度，s[01]与s[23]为最长相同前后缀，长度为2，故next[4]=2； next[5]等于s[5]之前的子串&quot;ababa&quot;中最长相同前后缀的长度，s[012]与s[234]为最长相同前后缀，长度为3，故next[5]=3； next[6]等于s[6]之前的子串&quot;ababaa&quot;中最长相同前后缀的长度，s[0]与s[5]为最长相同前后缀，长度为1，故next[6]=1； 类似的，可以求得next[7]、next[8]、next[9]、next[10]、next[11]分别为1和2、3、4、5。 next数组为-1 0 0 1 2 3 1 1 2 3 4 5 如果将这里的所有值加1可以得到另一种next数组，为0 1 1 2 3 4 2 2 3 4 5 6 例2：求模式串xyxyyxxyx的next数组。 采用例1相同的计算方式，得到next数组如下： x y x y y x x y x -1 0 0 1 2 0 1 1 2 0 1 1 2 3 1 2 2 3 例3：字符串S为”abaabaabacacaabaabcc”，模式串为”abaabc”。采用KMP算法进行匹配，第一次出现”失配”(s[i]≠t[j])时，i=j=5，则下次开始匹配时，i和j的值是多少？ 先求的模式串的next数组如下： a b a a b c -1 0 0 1 1 2 0 1 1 2 2 3 依据KMP算法&quot;当失配时，i不变，j回退到next[j-1]的位置并重新比较&quot;，当失配(s[i]≠t[j])时，i=j=5，由上表不难得出next[j]=next[5]=2(位序从0开始)。从而最后结果应为：i=5(i保持不变)，j=next[5-1]=2。 例4：求模式串ababaabab的nextval数组，这里使用了未加1的next数组 先计算前缀next[i]的值如下： s a b a b a a b a b -1 0 0 1 2 3 1 2 3 接下来计算nextval[i]的值，nextval[i]的求解需要比较s中next[i]所在位置的字符是否与s[i]的字符一致: 如果一致则用s[next[i]]的nextval的值作为nextval[i]，如果不一致，则用next[i]做为nextval[i]。 nextval[0]和next[0]的值一样，为-1，即nextval[0]=-1； nextval[1]，比较s[next[1]]和s[1]，next[1]=0，s[0]=a，而s[1]=b，二者不一致，则nextval[1]=next[1]=0； nextval[2]，比较s[next[2]]和s[2]，next[2]=0，s[0]=a，而s[2]=a，二者一致，则nextval[2]=nextval[s[next[2]]]=nextval[s[0]]=-1 (严谨来看这么表述是有问题的，因为nextval[2]表示nextval数组中 第3个数值，而nextval[s[0]]表示的是s[0]对应的字母&apos;a&apos;所对应的nextval值-1，这里nextval[]的用法并不严谨，只是为了表述方便)。 nextval[3]，比较s[next[3]]和s[3]，next[3]=1，s[1]=b，而s[3]=b，二者一致，则nextval[3]=nextval[s[next[3]]]=nextval[s[1]]=0； nextval[4]，比较s[next[4]]和s[4]，next[4]=2，s[2]=a，而s[4]=a，二者一致，则nextval[4]=nextval[s[next[4]]]=nextval[s[2]]=-1； nextval[5]，比较s[next[5]]和s[5]，next[5]=3，s[3]=b，而s[5]=a，二者不一致，则nextval[5]= next[5]=3； 同样的求nextval[6]、nextval[7]、nextval[8]分别为0，-1，0。 这里是nextval的下标从-1开始，如果从1开始，则其余各位均＋1，nextval为0，1，0，1，0，4，1，0，1 问：动态查找表动态查找表的表结构是在查找过程中动态生成的，对于给定key，若表中存在某关键字与key相等则查找成功返回，否则则插入关键字等于key的记录。常见的动态查找表有：二叉排序树、平衡二叉树、B树、B+树。 静态查找表有：有序表、分块有序表、线性链表。 七、排序问：各种内部排序算法性质图 1 备注：这里的冒泡排序是指优化的冒泡排序。 注意： (1) 若记录的初始状态已经按关键码基本有序，则选用直接插入排序或冒泡排序发为宜 (2) 在排序中关键字比较次数同记录初始排列次序无关的算法有：折半插入排序、选择排序、基数排序、 直接插入排序，在完全有序的情况下，每个元素只需要与它左边的元素比较一次就可以确定它的最终位置 快速排序，初始排序会影响划分次数。假设2n+1个数在一趟排序中被分为两部分，各为n个数，则下一趟排序中需要比较的次数为n-1+n-2=2n-2；假设分成的两部分分别有1个数和2n个数，则下一趟排序中需要比较的次数为2n-1。很明显初始排序会影响比较次数。 归并排序，假设在归并的时候，右路有n个元素，右路有n个元素，则一次归并最大比较次数为2n-1，最少比较次数为n，所以与初始排序有关。 (3) 在排序中关键字移动次数同记录初始排列次序无关的算法有： (4) 关键字初始排列顺序对算法的性能无影响的排序算法有：选择排序、(原始的)冒泡排序 例1，例2 (5) 快速排序在被排序的数据基本无序的时候最易发挥其长处，时间复杂度为O(nlogn)；在已经有序或逆序的情况下效率最差，为O(n^2)。 (6) 快速排序是目前基于比较的内部排序中平均时间复杂度最好的排序方法 (7) 希尔排序，也称为递减增量排序算法，是插入排序的一种高速而稳定的改进版本。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可达到线性排序的效率； 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位； (8) 堆排序建堆时间复杂度为O(n)，每次调整时间复杂度为O(h) (9) (假设根节点序号为1)小根堆中最大的数一定在叶子节点上，堆本身是个完全二叉树，完全二叉树的叶子节点的位置大于[n/2] 基于内部排序的最少比较次数 问：快速排序(1) 对n个记录的线性表进行快速排序为减少算法的递归深度，应该在每次分区后，先处理较短的部分解析 (2) 采用递归方式对顺序表进行快速排序，递归次数与每次划分后得到的分区处理顺序无关解析 问：外部排序外排中使用置换选择排序的目的,是为了增加初始归并段的长度解析 问：桶排序问：从n个数里面找最大的一个数理论最少需要比较：n-1次例1： 这道题其实就是一种二叉树结构，1001个员工为叶节点，而比赛次数则是求非叶节点 问：从n个数里面找最大的两个数理论最少需要比较：n+logn-2次解析 没看懂 问：希望用最快的速度从一个无序数组中挑选出其中前m个最大的元素，可以使用堆排序例1，例3，例4 问：在n个数中选出最大的m个数(3&lt;m&lt;n)，时间复杂度最小为O(n)网上的一个解析，例1，例2 例，这一题蛮好 问：在N个乱序数字中查找第k大的数字(未整理，因为还不是特别清楚)例1，例2 问：求n个数中的最大值和最小值，最少的比较次数例1 八、 其他","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://hepsilion.github.io/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"https://hepsilion.github.io/tags/数据结构/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"第九章 网络编程","slug":"09-网络编程","date":"2017-03-09T12:46:32.000Z","updated":"2017-07-22T13:12:00.483Z","comments":true,"path":"2017/03/09/09-网络编程/","link":"","permalink":"https://hepsilion.github.io/2017/03/09/09-网络编程/","excerpt":"Http协议简介 使用Handler进行线程间通信 AsyncTask 使用HttpURLConnection、HttpClient访问网络提交数据 AsyncHttpClient、SmartImageView开源项目的使用 多线程下载文件","text":"Http协议简介 使用Handler进行线程间通信 AsyncTask 使用HttpURLConnection、HttpClient访问网络提交数据 AsyncHttpClient、SmartImageView开源项目的使用 多线程下载文件 Android系统提供了以下几种方式实现网络通信：Socket通信、HTTP通信、URL通信和WebView，其中最常用的是HTTP通信。 一、网络编程入门1. HTTP协议简介HTTP：超文本传输协议，它规定了浏览器和万维网服务器之间互相通信的规则。 当客户端在与服务器端建立连接后，向服务器端发送的请求，被称作HTTP请求。服务器端接收到请求后会做出响应，称为HTTP响应。 2. Handler消息机制原理在使用Android手机下载软件时，通常都能在界面上看到一个下载的进度条，这个进度条用来表示当前软件下载的进度。但是Android4.0以后不能在UI线程中访问网络，子线程也不能更新UI界面。为了根据下载进度实时更新UI界面，就需要用到Handler消息机制来实现线程间的通信。 Handler机制主要包括4个关键对象，分别是Message、Handler、MessageQueue和Looper。 (1) Message Message是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同的线程之间交换数据。 Message的what字段可以用来携带一些整型数据，obj字段可以用来携带一个Object对象。 (2) Handler Handler主要用于发送消息和处理消息。 一般使用Handler对象的sendMessage()方法发送消息，发出的消息经过一系列的辗转处理后，最终会传递到Handler对象的handleMessage()方法中。 (3) MessageQueue MessageQueue主要用来存放通过Handler发送的消息。通过Handler发送的消息会存在Message中等待处理。 每个线程中只会有一个MessageQueue对象。 (4) Looper Looper是每个线程中的MessageQueue的管家。调用Looper的loop()方法后，就会进入一个无限循环中。然后，每当发现MessageQueue中存在一条消息，就会将它取出，并传递到Handler的handleMessage()方法中。 此外，每个线程也只有一个Looper对象。在主线程中创建Handler对象时，系统已经创建了Looper对象，所以不用手动创建Looper对象，而在子线程中的Handler对象，需要调用Looper.loop()方法开启消息循环。 图 9-1 Handler消息机制处理流程如图9-1所示： 在主线程(UI线程)创建一个Handler对象 在子线程中调用Handler的sendMessage()方法发送消息 这个消息会存放在主线程的MessageQueue中，通过Looper对象取出MessageQueue中的消息，最后分发回Handler的handleMessage()方法中进行处理，更新UI。 3. AsyncTask为了方便在子线程中对UI进行操作，Android提供了一些好用的工具类，AsyncTask就是其中之一。利用AsyncTask，可以十分简单地从子线程切换到主线程，它的原理是基于异步消息处理机制实现的。 AsyncTask是一个抽象类，使用它必须创建一个类继承它。在继承AsyncTask时，可以为其执行三个泛型参数，这三个参数的用途如下： Params：在执行AsyncTask时需要传入的参数，用于后台任务中使用。 Progress：后台任务执行时，如果需要在界面上显示当前的进度，则使用该参数作为进度单位。 Result:当任务执行完毕后，如果需要对结果进行返回，则使用该参数作为返回值类型。 下面定义了一个AsyncTask类，它的三个泛型参数分别被指定为Void, Integer, Boolean。第一个参数表示在执行AsyncTask时，不需要传递参数给后台任务；第个参数表示使用整数来作为进度显示单位；第三个参数表示使用布尔值来返回执行结果。 通常在使用AsyncTask时，需要重写它的4个方法： public class MyAsyncTask extends AsyncTask&lt;Void, Integer, Boolean&gt; { // 这个方法在后台任务执行之前调用，一般用于界面上的初始化操作，例如，显示一个进度条对话框 @Override protected void onPreExecute() { super.onPreExecute(); } //这个方法在子线程中运行，用于处理耗时操作，操作一旦完成即可以通过return语句将任务的执行结果返回。 //如果AsyncTask的第三个泛型参数指定的是void，则可以不返回执行结果。 //注意：这个方法不能进行更新UI操作，如果要在该方法中更新UI，可以调用publishProgress()方法来完成。 @Override protected Boolean doInBackground(Void... params) { publishProgress(50); return null; } //如果在doInBackground()方法中调用了publishProgress()方法，这个方法就会很快被调用，方法中携带的参数就是后台任务传递过来的。 //在这个方法中可以对UI进行操作，利用参数values就可以对UI进行相应的更新。 @Override protected void onProgressUpdate(Integer... values) { super.onProgressUpdate(values); } //当doInBackground()方法执行完毕并且通过return语句返回时，这个方法会很快被调用。在doInBackground()中返回的数据会作为参数传递到该方法中。 //此时可以利用返回的参数进行UI操作，例如，提醒某个任务完成了。 @Override protected void onPostExecute(Boolean aBoolean) { super.onPostExecute(aBoolean); } } 最后，我们可以在UI线程中创建AsyncTask实例，并调用它的execute()方法。 new MyAsyncTask().execute(); 以上便士AsyncTask的基本用法，使用AsyncTask可以不使用Handler发送和接收消息，只需要在doInBackground()方法中调用publicProgress()方法，即可实现从子线程切换到UI线程。 二、HttpURLConnection和HttpClient在实际开发中，绝大多数App都需要和服务器进行数据交互，也就是访问网络。 Android客户端访问网络发送HTTP请求的方式一般有两种：HttpURLConnection和HttpClient。 HttpURLConnection是一个标准的Java类，HttpClient是一个开源项目。 1. 使用HttpURLConnection访问网络使用HttpURLConnection，客户端与服务器建立连接并获取服务器返回的数据的过程： try{ //在URL的构造方法中传入要访问资源的路径 URL url=new URL(&quot;https://www.baidu.com/&quot;); HttpURLConnection conn=(HttpURLConnection)url.openConnection(); conn.setRequestMethod(&quot;GET&quot;); //设置请求方式 conn.setConnectionTimeout(5000); //设置超时时间 int code=conn.getResponseCode(); if(code==200){ //请求网络成功后返回码是200 InputStream is=conn.getInputStream(); //获取服务器返回的输入流 //读取流信息，获取服务器返回的数据 conn.disconnect(); //关闭http连接 }else{ //返回码不是200，请求服务器失败 } }catch(Exception e){ } 需要注意的是，在使用HttpURLConnection对象访问网络时，需要设置超时时间。如果没有设置超时时间，在网络异常的情况下，程序会因取不到数据而一直等待，导致程序僵死不往下执行。 案例：Demo0901，网络图片浏览器，演示手机端使用HttpURLConnection和客户端进行通信的过程 2. 使用HttpClient访问网络HttpClient是Apache的一个开源项目，从一开始就被引入到Android的API中。HttpClient可以完成和HttpURLConnection一样的效果，但使用起来更简单。简单来说，HttpClient是HttpURLConnection的增强版。 图9-2是使用HttpClient访问网络时所需要用到的几个常用类的介绍。 图 9-2 使用HttpClient访问网络与HttpURLConnection的过程大致相同，具体步骤如下： 创建HttpClient对象 指定访问网络的方式，创建一个HttpPost对象或者HttpGet对象 如果需要发送请求参数，可调用HttpGet、HttpPost的setParams方法，对于HttpPost对象而言，也可以调用setEntity()方法来设置请求参数 调用HttpClient对象的execute()方法访问网络，并获取HttpResponse对象 调用HttpResponse.getEntity()方法获取HttpEntity对象，该对象包装了服务器的响应内容，即所请求的数据。 使用HttpClient访问服务器并获取返回数据的示例代码： HttpClient client=new DefaultHttpClient(); HttpPost httpPost=new HttpPost(&quot;https://www.baidu.com/&quot;); List&lt;NameValuePair&gt; params=new ArrayList&lt;NameValuePair&gt;(); //创建一个NameValuePair集合，用于添加参数 params.add(new BasicNameValuePair(&quot;username&quot;, &quot;admin&quot;)); UrlEncodedFormEntity entity=new UrlEncodedFormEntity(params, &quot;utf-8&quot;); //给参数设置编码 httpPost.setEntity(entity);//设置参数 HttpResponse httpResponse=client.execute(httpPost); int statusCode=httpResponse.getStatusLine().getStatusCode(); if(statusCode==200){ HttpEntity httpEntity=httpResponse.getEntity();//获取HttpEntity实例 String response=EntityUtils.toString(httpEntity, &quot;utf-8&quot;);//设置编码格式 InputStream content = httpEntity.getContent(); //拿到输入流 } 需要注意的是，使用Post方式设置参数时，需要创建一个NameValuePair的集合来添加参数。在给参数设置编码时，需要与服务器的解码格式保持一致，否则会出现中文乱码的情况。 案例：Demo0902，网络图片浏览器，，演示手机端使用HttpClient和客户端进行通信的过程 3. 数据提交方式HTTP/1.1协议中共定义了8种方法来表明Request-URI指定的资源的不同的操作方式，其中最常用的两种请求方式是GET和POST。 (1) GET方式 GET方式是以实体的方式得到由请求URL所指向的资源信息，它向服务器提交的参数跟在请求URL后面。 使用GET方式访问网络URL的长度是有限制的，HTTP协议规范规定GET方式请求URL的长度不超过4K。但是IE浏览器GET方式请求URL的长度不能超过1K。 示例代码：使用HttpURLConnection GET方式提交数据到服务器： //将用户名和密码拼装在指定资源路径后面，并给用户名和密码进行编码 String path=&quot;http://192.168.1.100:8080/web/LoginServlet?username=&quot; +URLEncoder.encode(&quot;zhangsan&quot;)+&quot;&amp;password=&quot;+URLEncoder.encode(&quot;123&quot;); URL url=new URL(path); HttpURLConnection conn=url.openConnection(); conn.setRequestMethod(&quot;GET&quot;); //设置请求方式 conn.setConnectTimeout(5000); //设置超时时间 int responseCode=conn.getResponseCode(); //获取状态码 if(responseCode==200){//访问成功 InputStream is=conn.getInputStream(); //获取服务器返回的输入流 try{ //读取流里面的信息 }catch(Exception e){ } } (2) POST方式 POST方式在向服务器发出请求时，它向服务器提交的参数跟在请求实体中。 它提交的参数是浏览器通过流的方式直接写给服务器的，用户不能在浏览器中看到向服务器提交的请求参数，因此POST方式比GET方式相对安全。 此外，POST方式对URL的长度没有限制。 示例代码：使用HttpURLConnection POST方式提交数据到服务器： //使用HttpURLConnection String path=&quot;http://192.168.1.100:8080/web/LoginServlet&quot;; //准备数据并给参数进行编码 String data=&quot;username=&quot;+URLEncoder.encode(&quot;zhangsan&quot;)+&quot;&amp;password=&quot;+URLEncoder.encode(&quot;123&quot;); URL url=new URL(path); HttpURLConnection conn=(HttpURLConnection)url.openConnection(); conn.setRequestMethod(&quot;POST&quot;); //设置请求方式 conn.setConnectTimeout(5000); //设置超时时间 //设置请求头-数据提交方式，这里是以form表单方式提交 conn.setRequestProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); //设置请求头-设置提交数据的长度 conn.setRequestProperty(&quot;Content-Length&quot;, data.length()+&quot;&quot;); //post方式，实际上是浏览器把数据写给了服务器 conn.setDoOutput(true); //设置允许向外写数据 OutputStream os=conn.getOutputStream(); os.write(data.getBytes()); //利用输出流往服务器写数据 int code=conn.getResponseCode(); //获取状态码 if(responseCode==200){ //访问成功 InputStream is=conn.getInputStream(); //获取服务器返回的输入流 try{ //读取流里面的信息 }catch(Exception e){ } } 注意：使用HttpURLConnection POST方式提交数据时，是以流的方式直接将参数写到服务器上的，需要设置数据的提交方式和数据的长度。 在实际开发中，手机端和服务器进行交互的过程中，避免不了提交中文到服务器，这时就会出现中文乱码的情况。 无论是GET方式还是POST方式，提交参数时都要给参数进行编码。需要注意的是，编码方式必须与服务器解码方式统一。同样在获取服务器返回的中文数据时，也需要用指定格式进行解码。 案例：Demo0903和Demo0903Server：提交数据到服务器，演示HttpURLConnection/HttpClient分别使用Get方式和Post方式提交数据到服务器 三、开源项目在实际开发中，使用Android自带的API与服务器通信比较麻烦。一些热心的开发者为了节约开发成本、节约开发时间，开发出了一些开源的项目方便大家使用。因此网上出现了各种各样的开源项目。 1. AsyncHttpClient 由于访问网络是一个耗时的操作，放在主线程里面会影响用户体验，因此Google规定Android 4.0以后访问网络的操作都必须放在子线程中。 但是，在Android中，发送、处理HTTP请求十分常见，如果每次和服务器进行交互都需要开启一个子线程，这样是非常麻烦的。为了解决这个问题，一些开发者开发出了一个开源项目：AsyncHttpClient，它是HttpClient的再次包装。 AsyncHttpClient的特点有：发送异步HTTP请求，HTTP请求发生在UI线程之外，内部采用了线程池来处理并发请求。 AsyncHttpClient的常用类： AsyncHttpClient：用来访问网络的类 RequestParams:用来添加参数的类 AsyncHttpResponseHandler：访问网络后的回调接口 使用AsyncHttpClient：创建AsyncHttpClient的实例；设置参数；通过AsyncHttpClient的实例对象访问网络。如果访问成功则会回调AsyncHttpResponseHandler接口中的OnSucess()方法；失败则会回调OnFailure()方法。 使用AsyncHttpClient的GET方式访问网络并提交数据实例代码： //拼接URL，注意将参数编码 String path=&quot;http://192.168.1.100:8080/web/LoginServlet?username=&quot;+URLEncoder.encode(&quot;zhang&quot;)+&quot;&amp;password=&quot;+URLEncoder.encode(&quot;123&quot;); //创建AsyncHttpClient实例 AsyncHttpClient asyncHttpClient = new AsyncHttpClient(); //使用GET方式请求 asyncHttpClient.get(path, new AsyncHttpResponseHandler() { //请求成功 public void onSuccess(String content) { super.onSuccess(content); Toast.makeText(MainActivity.this, &quot;请求成功&quot;+content, Toast.LENGTH_SHORT).show(); } //请求失败 public void onFailure(Throwable error, String content) { super.onFailure(error, content); Toast.makeText(MainActivity.this, &quot;请求失败&quot;+content, Toast.LENGTH_SHORT).show(); } }); 使用AsyncHttpClient的POST方式访问网络并提交数据实例代码： String path=&quot;http://192.168.1.100:8080/web/LoginServlet&quot;; //添加参数 RequestParams params=new RequestParams(); params.put(&quot;username&quot;, &quot;zhang&quot;); params.put(&quot;password&quot;, &quot;123&quot;); //创建AsyncHttpClient实例 AsyncHttpClient asyncHttpClient = new AsyncHttpClient(); //使用GET方式请求 asyncHttpClient.post(&quot;&quot;, new RequestParams(), new AsyncHttpResponseHandler(){ //请求成功 @Override public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) { super.onSuccess(statusCode, headers, responseBody); Toast.makeText(MainActivity.this, &quot;请求成功&quot;+new String(responseBody), Toast.LENGTH_SHORT).show(); } //请求失败 @Override public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) { super.onFailure(statusCode, headers, responseBody, error); Toast.makeText(MainActivity.this, &quot;请求失败&quot;+new String(responseBody), Toast.LENGTH_SHORT).show(); } }); 从上面的实例代码可以看出，使用AsyncHttpClient访问网络并不需要创建子线程，而且不需要切换线程更新UI，使用起来更加方便。 2. SmartImageView 应用市场上的常见软件都加载了大量的网络上的图片。如果使用Android自带的API实现这一功能，首先需要请求网络，然后获取服务器返回的图片信息，转换成输入流，使用BitmapFactory生成Bitmap对象，最后再设置到指定的控件中，这种操作步骤十分麻烦而且耗时。为了，开发者们开发了一个开源项目：SmartImageView。它继承自ImageView，支持根据URL地址加载图片、支持异步加载图片、支持图片缓存等。 使用SmartImageView加载网络图片的实例代码： (1) 在布局文件中添加SmartImageView控件 &lt;com.loopj.android.image.SmartImageView android:id=&quot;@+id/siv_icon&quot; android:layout_width=&quot;80dip&quot; android:layout_height=&quot;60dip&quot; android:layout_alignParentLeft=&quot;true&quot; android:layout_marginBottom=&quot;5dip&quot; android:layout_marginLeft=&quot;5dip&quot; android:layout_marginTop=&quot;5dip&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@drawable/ic_launcher&quot; /&gt; (2) 在Activity中使用SmartImageView控件 SmartImageView siv = (SmartImageView) view.findViewById(R.id.siv_icon); //SmartImageView加载指定路径图片 siv.setImageUrl(newsInfo.getIconPath(), R.drawable.ic_launcher, R.drawable.ic_launcher); 在加载指定图片时，setImageUrl()方法指定了图片的路径，加载中显示的图片以及加载失败时显示的图片。 案例：Demo0904，新闻客户端，演示AsyncHttpClient和SmartImageView的综合使用，该案例使用AsyncHttpClient实现获取服务器的XML文件并将其解析出来捆绑显示到ListView上，然后使用SmartImageView获取网络图片 四、多线程下载下载一个文件时，使用多线程下载速度通常比使用单线程下载速度快。 使用多线程下载资源时，先要获取到服务器资源文件的大小，然后在本地创建一个与服务器资源一样大的文件，接着在客户端开启若干个线程去下载服务器资源。需要注意的是，每个线程必须要下载对应的模块，然后将每个线程下载的模块按顺序组装成资源文件。 图 9-3 图9-3展示了多线程下载的原理：从图中可以看出，每个线程下载的区域就是总大小/线程个数，但不能保证每个文件都可以完全平均分配资源，因此最后一个线程需要下载到文件的末尾。 需要注意的是，使用多线程下载时，需要在请求头中设置Range字段获取到指定位置的数据，例如Range:byte=100-200 案例：Demo0905，多线程下载文件，并将每个线程的下载进度显示在界面上","categories":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://hepsilion.github.io/tags/Android/"}],"keywords":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}]},{"title":"第八章 服务","slug":"08-Service","date":"2017-03-08T12:45:55.000Z","updated":"2017-07-22T13:11:57.551Z","comments":true,"path":"2017/03/08/08-Service/","link":"","permalink":"https://hepsilion.github.io/2017/03/08/08-Service/","excerpt":"服务的生命周期 服务的两种启动方式 本地服务通信 远程服务通信(调用其它应用的服务)","text":"服务的生命周期 服务的两种启动方式 本地服务通信 远程服务通信(调用其它应用的服务) 服务(Service)和Activity一样，是Android中的四大组件之一，不同的是服务没有界面，是一个长期运行在后台的组件，即使启动服务的应用程序被切换掉，服务仍可以在后台正常运行。因此服务经常被用来处理一些耗时的任务，例如进行网络传输或者播放音乐等。 一、服务的创建1. 创建服务 服务的创建方式与创建Activity类似，只需要继承Service类即可。 示例代码： public class MyService extends Service{ @Nullable @Override public IBinder onBind(Intent intent) { return null; } } 2. 在清单文件中配置 由于服务是Android四大组件中的一个，因此需要在Androidmanifest.xml文件中进行注册，否则服务是不生效的。 示例代码： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;learning.android.it.org.demo0801&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!--注册服务--&gt; &lt;service android:name=&quot;.MyService&quot;/&gt; &lt;/application&gt; &lt;/manifest&gt; 二、服务的生命周期与其他组件不同，Service不能自己主动运行，需要调用相应的方法来启动。启动服务的方法有两种，分别是Context.startService()和Context.bindService()。如图8-1所示，使用不同的方法启动服务，服务的生命周期也会不同。 图 8-1 1. startService方式开启服务的生命周期 当其他组件调用startService()方法时，服务会先执行onCreate()方法，接着执行onStartCommand()方法，此时服务处于运行状态，直到自身调用stopSelf()方法或者其他组件调用stopService()方法时服务停止，最终被系统销毁。 这种方式开启的服务会长期在后台运行，并且服务的状态与开启者的状态无关。 2. bindService方式开启服务的生命周期 当其他组件调用bindService()方法时，服务被创建，接着客户端通过Ibinder接口与服务通信。客户端通过unbindService()方法关闭连接，多个客户端能绑定到同一个服务上，并且当它们都解绑时，系统将直接销毁服务(服务不需要被停止)。 这种方法开启的服务与开启者的状态有关，当调用者销毁了，服务也会被销毁。 3. 服务声明周期中的重要方法 onCreate() 服务被创建时执行的方法。 onDestroy() 服务被销毁时执行的方法。 onStartCommand() 客户端通过startService()显式启动服务时执行该方法。 onBind() 客户端通过调用bindService()方法启动服务时执行该方法。 onUnbind() 客户端调用unBindService()方法断开服务绑定时执行该方法。 三、服务的启动方式前面讲过，启动服务有两种方式，分别是通过startService()方法启动服务和bindService()方法启动服务。 1. start方式启动服务 使用Context的startService()和stopService()方法来启动、关闭服务，Intent对象用于指定要启动或关闭的服务。 Intent intent=new Intent(this, MyService.class); startService(intent); //开启服务 stopService(intent); //关闭服务 onCreate()方法只有在服务创建时执行，而onStartCommand()方法则是在每次启动服务时调用。 需要注意的是，如果不调用stopService()或stopSelf()方法，这种方式开启的服务会长期运行在后台，除非用户强制停止服务。 案例：Demo0801，start方式启动服务 2. bind方式启动服务 当程序使用startService()和stopService()启动、关闭服务时，服务与调用者之间基本不存在太多的关联，也无法与访问者进行通信、数据交互等。 如果服务需要与调用者进行方法调用和数据交互时，应该使用bindService()和unbindService()方法启动、关闭服务。 使用bindService()方式启动服务的标准步骤： // 1. 创建MyConn类，用于实现连接服务 private MyService.MyBinder myBinder; private class MyConn implements ServiceConnection{ @Override public void onServiceConnected(ComponentName name, IBinder service) { myBinder= (MyService.MyBinder) service; Log.i(&quot;MainActivity&quot;, &quot;服务成功绑定，内存地址为&quot;+myBinder.toString()); } @Override public void onServiceDisconnected(ComponentName name) { } } MyConn myConn; // 2. 绑定服务 Intent intent=new Intent(this, MyService.class); bindService(intent, myConn, BIND_AUTO_CREATE); // 3. 利用myBinder调用服务中的方法 myBinder.callMethodInService(); // 4. 解绑服务 unbindService(myConn); bindService()方法的完整方法名为public boolean bindService(Intent service, ServiceConnection conn, int flags)，该方法的参数解释如下： Intent对象用于指定要启动的Service ServiceConnection对象用于监听调用者与Service之间的连接状态。 当调用者与Service连接成功时，将回调该对象的public void onServiceConnected(ComponentName name, IBinder service)方法； 当调用者与Service断开连接时，将回调该对象的public void onServiceDisconnected(ComponentName name)方法。 flags指定绑定时是否自动创建Service(如果Service还未创建)。该参数可指定为0即不自动创建，也可指定为BIND_AUTO_CREATE_即自动创建。 注意：ServiceConnection中的onServiceConnected()方法有一个参数IBinder service，这个参数是在服务的onBind()方法中返回的。 public class MyService extends Service{ // 创建服务的代理，调用服务中的方法 class MyBinder extends Binder{ public void callMethodInService(){ methodInService(); } } public void methodInService(){ Log.i(&quot;BindService&quot;, &quot;自定义方法methodInService&quot;); } @Nullable @Override public IBinder onBind(Intent intent) { Log.i(&quot;BindService&quot;, &quot;onBind&quot;); return new MyBinder(); } @Override public boolean onUnbind(Intent intent) { Log.i(&quot;BindService&quot;, &quot;onUnbind&quot;); return super.onUnbind(intent); } @Override public void onCreate() { super.onCreate(); Log.i(&quot;BindService&quot;, &quot;onCreate&quot;); } } 案例：Demo0802，bind方式启动服务 四、服务通信在Android系统中，服务的通信方式有两种：一种是本地服务通信，另一种是远程服务通信。本地服务通信是指应用程序内部的通信，而远程服务通信是指两个应用程序之间的通信。使用这两种方式进行通信时必须满足一个前提，就是服务必须以绑定方式开启。 1. 本地服务通信 在使用服务进行本地通信时，首先需要开发一个Service类，该类会提供一个IBinder onBind(Intent intent)方法，onBind()方法返回的IBinder对象会作为参数传递给ServiceConnection类中onServiceConnected(ComponentName name, IBinder service)方法，这样访问者就可以通过IBinder对象与Service进行通信。 使用Ibinder对象进行本地服务通信： 图 8-2 如图8-2所示，服务在进行通信时实际上使用的就是IBinder对象，在ServiceConnection类中得到IBinder对象，通过该对象就可以获取到服务中定义的方法，执行具体的操作。 案例：Demo0803，音乐播放器，演示如何使用服务进行通信 (1) MediaPlayer 在Android中，播放音频文件一般都是使用MediaPlayer类来实现的。 setAudioStreamType() 指定音频文件的类型必须在prepare()方法之前调用 setDataSource() 设置要播放的音频文件的位置 prepare() 在开始播放之前调用这个方法完成准备工作 start() 开始或继续播放音频 pause() 暂停播放音频 reset() 将MediaPlayer对象重置到刚刚创建的状态 seekTo() 从指定的位置开始播放音频 stop() 停止播放音频，调用该方法后MediaPlayer对象就无法再播放音频 release() 释放掉与MediaPlayer对象相关的资源 isPlaying() 判断当前MediaPlayer是否正在播放音频 getDuration() 获取载入音频文件的时长 getCurrentPosition() 获取当前播放音频文件的位置 (2) SeekBar SeekBar与ProgressBar十分类似，它是通过滑块的位置来表示数值的。SeekBar允许用户拖动滑块改变SeekBar的值，例如手机的音量调节，同时SeekBar还允许用户改变滑块外观。 SeekBar的常用方法属性： 属性 android:thumb 指定一个Drawable对象，该对象将作为自定义滑块 监听器OnSeekBarChangeListener 监听滑块位置的改变 方法setProgress() 用来设置SeekBar的当前值 方法setMax() 设置SeekBar的最大值 2. 远程通信服务 在Android系统中，各个应用程序都运行在自己的进程中，进程之间一般无法直接进行通信，如果想要完成不同进程之间的通信，就需要使用远程服务通信。 远程服务通信是通过AIDL(Android Interface Definition Language)实现的，它是一种接口定义语言，其语法格式简单，与Java中接口定义类似，但存在几点差异： AIDL定义接口的源代码文件必须以.aidl结尾 AIDL接口中用到的数据类型，除了基本数据类型、String、List、Map、CharSequence之外，其他类型全部都需要导入包，即使它们在同一个包中。 开发人员定义的AIDL接口只是定义了进程之间的通信接口，服务端、客户端都需要使用Android SDK安装目录下的platform-tools子目录下的aidl.exe工具为该接口提供实现。 远程服务调用的实例： 应用A (1) 定义AIDL接口 package learning.android.it.org.demo0804; interface IService { void callAlipayService(); } AIDL接口定义的方式与Java接口的定义方式类似，都需要包名、接口名以及自定义的方法。不同的是，AIDL没有类型修饰符，在编写ADIL文件时，不能加上类型修饰符，因为它本身就是公有的，例如写为public interface IService是不正确的，正确的写法应该为interface IService。定义好AIDL接口之后，aidl.exe会为IService自动生成实现类IService.Stub。 (2) 创建Service 接着需要在应用程序中创建Service的子类，该Service的onBind()方法所返回的IBinder对象应该是aidl.exe所生成的IService.Stub的子类对象。 public class AlipayService extends Service { private class MyBinder extends IService.Stub { @Override public void callAlipayService() throws RemoteException { methodInService(); } } private void methodInService() { Log.v(TAG, &quot;开始付费，购买装备&quot;); } @Nullable @Override public IBinder onBind(Intent intent) { Log.v(TAG, &quot;绑定支付宝，准备付费&quot;); return new MyBinder(); } } (3) 注册Service 由于该Service需要被其他应用调用，因此需要在注册服务时设置一个action，当其他应用使用隐式Intent调用该服务时，就可以通过这个action匹配上该服务。 &lt;service android:name=&quot;.AlipayService&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;www.baidu.com&quot; /&gt; &lt;/intent-filter&gt; &lt;/service&gt; 应用B (1) 复制应用A的AIDL接口文件 (2) 绑定Service 现在在另一个应用绑定上面应用的服务。注意在调用bindService()方法绑定服务时，使用的Intent设置的action需要和上面应用中服务注册的action一致。 private MyConn conn; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //这里Action需要与Demo04在清单文件中服务注册的Action要一致 service = new Intent(); service.setAction(&quot;www.baidu.com&quot;); } public void bind(View view) { conn = new MyConn(); bindService(service, conn, BIND_AUTO_CREATE); } private class MyConn implements ServiceConnection { @Override public void onServiceConnected(ComponentName name, IBinder service) { iService = IService.Stub.asInterface(service); } @Override public void onServiceDisconnected(ComponentName name) { } } (3) 调用应用A的服务 最后在应用B中调用第一个应用的服务提供的方法 public void call(View view) { try { if (iService != null) { iService.callAlipayService(); } } catch (RemoteException e) { e.printStackTrace(); } } 注意：在调用本地方法时，在onServiceConnected()方法中是通过强制转换将service转换为MyBinder的；但在远程服务调用中，需要通过IService.Stub.asInterface(service)方法转换。IService就是应用A中定义的AIDL接口，需要将这个接口文件复制到应用B相同目录下。 案例：Demo0804与Demo0805，模拟小游戏Demo0805远程调用支付宝Demo0804，演示如何绑定并使用远程服务 注意：两个应用程序中的ADIL文件所在的包名要一致。","categories":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://hepsilion.github.io/tags/Android/"}],"keywords":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}]},{"title":"第七章 广播接收者","slug":"07-BroadcastReceiver","date":"2017-03-07T12:44:40.000Z","updated":"2017-07-22T13:11:54.446Z","comments":true,"path":"2017/03/07/07-BroadcastReceiver/","link":"","permalink":"https://hepsilion.github.io/2017/03/07/07-BroadcastReceiver/","excerpt":"创建广播接收者 自定义广播 有序广播和无序广播 常用广播接收者(如开机启动、短信接收)的使用","text":"创建广播接收者 自定义广播 有序广播和无序广播 常用广播接收者(如开机启动、短信接收)的使用 在Android系统中，广播(Broadcast)是一种在应用程序之间传递消息的机制，广播接收者(BroadcaseReceiver)是用来接收、过滤并响应广播的一类组件。通过广播接收者可以监听系统中的广播消息，在不同组件之间进行通信。 一、广播接收者入门在Android系统中内置了很多系统级别的广播，例如，手机开机完成后会发送一条广播，电池电量不足时也会发送一条广播等。为了监听这些广播事件，Android提供了一个BroadcastReceiver组件，该组件可以监听来自系统或者应用程序的广播。 当Android系统产生一个广播事件时，可以有多个对应的BroadcastReceiver接收并进行处理。 1. 广播接收者创建与注册要使用广播接收者接收其他应用程序发出的广播，先要在本应用中创建一个广播接收者类继承自BroadcastReceiver类，然后在清单文件中或者代码中进行注册并指定要接收的广播事件，最后重写广播接收者类的onReceive()方法，在方法中进行处理广播事件即可。 注册广播接收者有两种方式，常驻型广播和非常驻型广播。 (1) 创建广播接收者 要对监听到的广播事件进行处理，需要创建一个类继承自BroadcastReceiver，然后重写onReceive()方法。 public class OutCallReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { } } 当监听到有广播发出时，就会调用onReceive()方法，在onReceive()方法中可以对事件进行处理。 (2) 注册常驻型广播接收者 常驻型广播接收者是当应用程序关闭后，如果接收到其他应用程序发出的广播，那么该程序会自动重新启动。常驻型广播接收者需要在清单文件中进行注册。 示例代码 &lt;receiver android:name=&quot;learning.android.it.org.demo0701.OutCallReceiver&quot; &gt; &lt;intent-filter android:priority=&quot;20&quot;&gt; &lt;action android:name=&quot;android.intent.action.NEW_OUTGOING_CALL&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 上述代码是在清单文件中注册的监听系统拨打电话的广播。 android:name=”learning.android.it.org.demo0701.OutCallReceiver”是创建的广播接收者的全路径名； 与定义隐式意图一样，广播接收者也需要注册一个&lt;intent-filter&gt;，在过滤器中指定要接收的广播事件； android:name=”android.intent.action.NEW_OUTGOING_CALL”是系统内部定义的拨打电话的广播事件； android:priority=”20”是该广播的优先级，这个值越大代表接收的优先级越高。 (3) 注册非常驻型广播接收者 非常驻型广播接收者依赖于注册广播的组件的生命周期，例如在Activity中注册广播接收者，当Activity销毁后，广播也随之被移除。这种广播接收者需要在代码中注册。 示例代码 MyBroadcastReceiver receiver=new MyBroadcastReceiver(); // 实例化过滤器并设置要过滤的广播 String action=&quot;android.intent.action.NEW_OUTGOING_CALL&quot;; IntentFilter intentFilter=new IntentFilter(action); // 注册广播接收者 registerReceiver(receiver, intentFilter); 与清单文件中注册一样，代码注册广播接收者同样需要进行过滤，IntentFilter接收的是监听的广播事件，最后用registerReceiver方法进行注册。 与清单文件注册不同的是，代码有注册也有移除，比如在Activity的onCreate()中注册广播接收者，就要在onDestroy()方法中进行解除广播。 unregisterReceiver(receiver); 需要注意的是，常驻型广播接收者在应用程序关闭后，接收到广播会重新自动创建。非常驻型广播接收者则依赖于注册广播组件的生命周期和调用unregisterReceiver()方法手动移除。 (4) 案例：Demo0701，IP拨号器，当拨打长途电话时，广播接收者就会监听到这个广播事件，自动在电话号码前加上几个数字，如17911、17951等。 注意：在Android4.0一下的系统中，当进程不存在时，只要有响应广播发出，进程就会自动创建并接收广播进行处理。Google工程师认为这样不安全，为了保护用户隐私，在Android4.0以上系统中，当在任务管理器界面强行停止进程后，再有广播发出也不会打开进程进行接收了。 二、自定义广播Android系统中自带了很多广播，如果需要监听某个广播，只需要创建对应的广播接收者即可。在实际开发中，当这些系统级广播事件不能满足实际需求时，还可以自定义广播。需要注意的是，自定义广播需要由对应的广播接收者去接收，否则这个广播是无意义的。 案例：Demo0702，电台与收音机 创建广播：创建一个Intent对象，然后通过Intent.setAction()语句指定广播事件，最后通过sendBroadcast(intent)发送广播。 Intent intent = new Intent(); // 定义广播的事件类型 intent.setAction(&quot;www.baidu.com&quot;); // 发送广播 sendBroadcast(intent); 接收广播：和接收系统广播事件一样，创建一个广播接收者类继承自BroadcastReceiver类，然后在清单文件中或者代码中进行注册并指定要接收的广播事件，最后重写广播接收者类的onReceive()方法，在方法中进行处理广播事件即可。需要注意的是，自定义的广播事件与广播接收者在清单文件中注册的事件要一致，否则无法接收广播 &lt;receiver android:name=&quot;learning.android.it.org.demo0702.MyBroadcastReceiver&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;www.baidu.com&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 三、广播的类型在Android系统中，根据广播被接收顺序的不同，可以将其分为有序广播和无序广播。 1. 无序广播 无序广播是一种完全异步被接收的广播，在广播发出去之后，所有监听了这个广播事件的广播接收者都会在同一时刻接收到这个广播，它们之间没有任何先后顺序可言，这种广播的效率会比较高，但同时意味着它是无法被截断的。 图7-1 无序广播的工作流程如图7-1所示，当无序广播发送一条广播消息时，所有的广播接收者都可以接收到，不会被拦截。 2. 有序广播 有序广播是一种同步接收的广播，在广播发出之后，同一时刻只会有一个广播接收者能够接收到这条消息，当这个广播接收者中的逻辑执行完后，广播才会继续传递。所以，此时的广播接收者是有先后顺序的，并且可以被拦截。 图7-2 有序广播的工作流程如图7-2所示，当有序广播发送一条消息后，高优先级的广播接收者先接收到广播，低优先级的广播接收者后接收到广播。 Intent intent = new Intent(); // 定义广播的事件类型 intent.setAction(&quot;www.baidu.com&quot;); // 发送有序广播 //第一个参数是指定的意图，设置要发送的广播事件；第二个参数指定接收者的权限，如果不想让所有的接收到看到，可以显示地指定接收者的权限，目前不关心，可以将其设置为null sendOrderedBroadcast(intent, null); 优先级是在清单文件中注册广播接收者时定义的android:priority=””参数，优先级的范围是-1000~1000之间。如果两个广播接收者的优先级相同，则先注册的组件优先接收到广播。如果两个应用程序监听了同一个广播事件并设置了优先级，则优先级高的应用优先接收到广播。 &lt;receiver android:name=&quot;learning.android.it.org.demo0703.MyBroadcastReceiver02&quot; &gt; &lt;intent-filter android:priority=&quot;1000&quot; &gt; &lt;action android:name=&quot;www.baidu.com&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver android:name=&quot;learning.android.it.org.demo0703.MyBroadcastReceiver01&quot; &gt; &lt;intent-filter android:priority=&quot;1000&quot; &gt; &lt;action android:name=&quot;www.baidu.com&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver android:name=&quot;learning.android.it.org.demo0703.MyBroadcastReceiver03&quot; &gt; &lt;intent-filter android:priority=&quot;600&quot; &gt; &lt;action android:name=&quot;www.baidu.com&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 如果高优先级的广播接收者将广播终止，则后面的广播接收者无法接收到广播。想要拦截一条广播不往下发送，可以使用abortBroadcast()方法。 public class MyBroadcastReceiver02 extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { Log.i(&quot;MyBroadcastReceiver02&quot;, &quot;自定义的广播接收者02,接收到了自定义的广播事件&quot;); Log.i(&quot;MyBroadcastReceiver02&quot;, &quot;自定义的广播接收者02，接收到了广播事件&quot;); abortBroadcast(); // 拦截有序广播，这句代码执行完后，广播事件将会被终止。 Log.i(&quot;MyBroadcastReceiver02&quot;, &quot;我是广播接收者02，广播被我终结了&quot;); } } 在实际开发中，还可能遇到这样的情况，当发出了一个有序广播，然后定义多个广播接收者接收这条广播。这些广播接收者的优先级有高有低，需要其中一个广播接收者无论如何都要接收到广播事件，哪怕它的优先级是最低的或者广播被优先级高的接收者强行终止。这时，就可以用一下sendOrderedBroadcast的重载方法，在第三个参数指定要接收的广播接收者。 MyBroadcastReceiver03 receiver03 = new MyBroadcastReceiver03(); sendOrderedBroadcast(intent, null, receiver03, null, 0, null, null); 案例：Demo0704，拦截有序广播 四、常用的广播接收者案例：Demo0704，短信拦截器，监听短信接收的广播事件（拦截没起作用） &lt;receiver android:name=&quot;learning.android.it.org.demo0704.MessageReceiver&quot; &gt; &lt;intent-filter android:priority=&quot;1000&quot; &gt; &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 设置action为android.provider.Telephony.SMS_RECEIVED，接收短信的广播事件 在Windows系统中，有些软件一开机就自动启动，同样在Android系统中也可以实现这种功能，例如杀毒软件程序，每次手机开机便会自动启动，这种功能就是通过广播接收者监听开机启动的广播事件实现的。 案例：Demo0705，杀毒软件，监听开机启动的广播事件 public class BootReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { Intent i = new Intent(context, MainActivity.class); // 由于Activity都是运行在任务栈中的，当开机启动时，任务栈还未创建成功，所以需要设置flag，显示地指定Activity在新的任务栈中运行 i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(i); } } &lt;receiver android:name=&quot;learning.android.it.org.demo0705.BootReceiver&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 设置action为android.intent.action.BOOT_COMPLETED，接收开机启动的广播事件 需要注意的是，在Android3.0以后出现了一个安全机制，如果用户没有启动过这个程序，那么就算该程序注册了开机启动的广播接收者也无法接收到开机启动的广播事件。","categories":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://hepsilion.github.io/tags/Android/"}],"keywords":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}]},{"title":"第六章 ContentProvider","slug":"06-ContentProvider","date":"2017-03-06T12:43:55.000Z","updated":"2017-07-22T13:11:51.690Z","comments":true,"path":"2017/03/06/06-ContentProvider/","link":"","permalink":"https://hepsilion.github.io/2017/03/06/06-ContentProvider/","excerpt":"了解ContentProvider 使用ContentProvider 使用ContentResolver操作其他应用的数据 使用ContentObserver观察其他应用的数据变化","text":"了解ContentProvider 使用ContentProvider 使用ContentResolver操作其他应用的数据 使用ContentObserver观察其他应用的数据变化 在Android开发中，经常需要访问其他应用程序的数据。例如，使用支付宝转账时需要填写收款人的电话号码，此时就需要获取到系统联系人的信息。为了实现这种跨程序共享数据的功能，Android系统提供了一个组件：ContentProvider。 一、ContentProvider简介ContentProvider是Android系统四大组件之一，用于保存和检索数据，是Android系统中不同应用程序之间共享数据的接口。 在Android系统中，应用程序之间是相互独立的，分别运行在自己的进程中，相互之间没有数据交换。若应用程序之间需要共享数据，就需要用到ContentProvider。 ContentProvider是不同应用程序之间进行数据交换的标准API，它以Uri的形式对外提供数据，允许其他应用操作本应用数据。其他应用则使用ContentResolver，并根据ContentProvider提供的Uri操作指定数据。 ContentProvider的工作原理 图6-1 如图6-1所示，A应用需要使用ContentProvider暴露数据，才能被其他应用操作。B应用必须通过ContentResolver操作A应用暴露出来的数据，而A应用会将操作结果返回给ContentResolver，然后ContentResolver再将操作结果返回给B应用。 二、创建ContentProvider1. 创建ContentProvider(1) 创建ContentProvider，暴露数据的增、删、改、查方法 在创建一个ContentProvider时，首先需要定义一个类继承android.content包下的ContentProvider类。ContentProvider类是一个抽象类，在使用该类时，需要重写它的onCreate()、delete()、getType()、insert()、query()和update()这几个抽象方法。 public class PersonDBProvider extends ContentProvider { //当ContentProvider被创建的时候调用，适合数据的初始化 @Override public boolean onCreate() { helper=new PersonSQLiteOpenHelper(getContext()); return false; } //根据传入的Uri查询指定条件下的数据 @Nullable @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { //匹配查询的Uri路径 if(matcher.match(uri)==QUERY){ SQLiteDatabase db=helper.getReadableDatabase(); Cursor cursor=db.query(&quot;person&quot;, projection, selection, selectionArgs, null, null, sortOrder); return cursor; }else if(matcher.match(uri)==QUERYONE){ long id= ContentUris.parseId(uri);//匹配成功,根据id查询数据 SQLiteDatabase db=helper.getReadableDatabase(); Cursor cursor=db.query(&quot;&quot;, projection, &quot;id=?&quot;, new String[]{id+&quot;&quot;}, null, null, sortOrder); return cursor; }else{ throw new IllegalArgumentException(&quot;路径不匹配，不能执行查询操作&quot;); } } // 用于返回指定Uri代表的数据MIME类型，如.jpg和.txt。 // 如果指定数据的类型属于集合型(多条数据)，getType()方法返回的字符串应该以&quot;vnd.android.cursor.dir/&quot;开头； // 如果属于非集合型(单条数据)，则返回的字符串以&quot;vnd.android.cursor.item/&quot;开头。 @Nullable @Override public String getType(Uri uri) { if(matcher.match(uri)==QUERY){ return &quot;vnd.android.cursor.dir/person&quot;;// 返回查询的结果集 }else if(matcher.match(uri)==QUERYONE){ return &quot;vnd.android.cursor.item/person&quot;; } return null; } //根据传入的Uri插入数据 @Nullable @Override public Uri insert(Uri uri, ContentValues values) { if(matcher.match(uri)==INSERT){ SQLiteDatabase db=helper.getWritableDatabase(); db.insert(&quot;person&quot;, null, values); }else{ throw new IllegalArgumentException(&quot;路径不匹配，不能执行插入操作&quot;); } return null; } //根据传入的Uri删除指定条件下的数据 @Override public int delete(Uri uri, String selection, String[] selectionArgs) { if(matcher.match(uri)==DELETE){ SQLiteDatabase db=helper.getWritableDatabase(); db.delete(&quot;person&quot;, selection, selectionArgs); }else{ throw new IllegalArgumentException(&quot;路径不匹配，不能执行删除操作&quot;); } return 0; } //根据传入的Uri更新指定条件下的数据 @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) { if(matcher.match(uri)==UPDATE){ SQLiteDatabase db=helper.getWritableDatabase(); db.update(&quot;person&quot;, values, selection, selectionArgs); }else{ throw new IllegalArgumentException(&quot;路径不匹配，不能执行修改操作&quot;); } return 0; } } (2) 注册ContentProvider ContentProvider是Android的四大组件之一，因此需要和Activity一样在清单文件中注册。 &lt;provider android:authorities=&quot;learning.android.it.org.demo0601.PersonDBProvider&quot; android:name=&quot;learning.android.it.org.demo0601.PersonDBProvider&quot;/&gt; 注册provider时指定了android:name和android:authorities两个属性。 android:name代表继承于ContentProvider类的全路径名 android:authorities代表了访问本provider的路径，这里的路径必须要唯一。 2. Uri简介在ContentProvider的几个抽象方法中，都有一个参数Uri uri，它代表了数据的操作方法。 Uri是由scheme、authorities、path三部分组成。 图6-2 图6-2是一个Uri的实例。 scheme部分content://是一个标准的前缀，表明这个数据被ContentProvider所控制，它不会被修改。 authorities部分learning.android.it.org.demo0601.PersonDBProvider是在清单文件中指定的android:authorities属性值，该值必须唯一，它代表了当前的ContentProvider。 path部分/query代表资源(或者数据)，当访问者需要操作不同数据时，这部分是动态改变的。 Uri.parse(String str)方法可以将字符串转化为Uri对象。为了解析Uri对象，Android系统提供了一个辅助工具类UriMatcher用于匹配Uri。 public UriMatcher(int code) 创建UriMatcher对象时调用，参数通常使用UriMatcher.NO_MATCH，表示路径不满足时返回-1 public void addURI(String authority, String path, int code) 添加一组匹配规则，authority 即Uri的authority部分，path 即Uri的path部分 public int match(Uri uri) 匹配Uri与addURI方法相对应，匹配成功则返回addURI方法中传入的参数code值 使用UriMatcher匹配Uri的实例代码： 在暴露数据的增、删、改、查方法之前，首先需要添加一组用于请求数据操作的Uri，然后在相应的增删改查方法中匹配Uri，匹配成功才能对数据进行操作。 // 定义一个uri的匹配器，用于匹配uri，如果路径不满足条件，则返回 -1 private static UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH); private static final int INSERT = 1; //添加数据Uri路径匹配成功时返回码 private static final int DELETE = 2; //删除数据Uri路径匹配成功时返回码 private static final int UPDATE = 3; //更改数据Uri路径匹配成功时返回码 private static final int QUERY = 4; //查询数据Uri路径匹配成功时返回码 private static final int QUERYONE = 5; //查询一条数据Uri路径匹配成功时返回码 // 添加一组匹配规则 static{ matcher.addURI(&quot;learning.android.it.org.demo0601.PersonDBProvider&quot;, &quot;insert&quot;, INSERT); matcher.addURI(&quot;learning.android.it.org.demo0601.PersonDBProvider&quot;, &quot;delete&quot;, DELETE); matcher.addURI(&quot;learning.android.it.org.demo0601.PersonDBProvider&quot;, &quot;update&quot;, UPDATE); matcher.addURI(&quot;learning.android.it.org.demo0601.PersonDBProvider&quot;, &quot;query&quot;, QUERY); //这里的&quot;#&quot;号为通配符，凡是符合&quot;query/&quot;，皆返回QUERYONE的返回码 matcher.addURI(&quot;learning.android.it.org.demo0601.PersonDBProvider&quot;, &quot;query/#&quot;, QUERYONE); } 案例：Demo0601，本案例实现了查询应用自己暴露的数据，并将数据捆绑到ListView控件中的功能。 三、访问ContentProvider在Android系统中，ContentResolver充当着一个中介的角色。应用程序使用ContentProvider暴露自己的数据，通过ContentResolver可以对应用程序暴露的数据进行操作。 1. ContentResolver的基本用法由于在使用ContentProvider暴露数据时指定了相应数据的Uri，因此在访问现有ContentProvider时需要指定相应的Uri，然后通过ContentResolver对象来实现数据的操作。 示例代码 //利用ContentResolver对象查询使用ContentProvider暴露的数据 private void getPersons(){ //首先要获取查询的uri String path=&quot;content://learning.android.it.org.demo0601.PersonDBProvider/query&quot;; Uri uri= Uri.parse(path); //获取ContentResolver对象 ContentResolver resolver = getContentResolver(); //利用ContentResolver对象查询数据,得到一个Cursor对象 Cursor cursor=contentResolver.query(uri, null, null, null, null, null); persons=new ArrayList&lt;&gt;(); //如果cursor为空立即结束该方法 if(cursor==null){ return; } while(cursor.moveToNext()){ int id=cursor.getInt(cursor.getColumnIndex(&quot;id&quot;)); String name=cursor.getString(cursor.getColumnIndex(&quot;name&quot;)); String number=cursor.getString(cursor.getColumnIndex(&quot;number&quot;)); Person p=new Person(id, name, number); persons.add(p); } //需要注意的是，使用完Cursor之后，一定要关闭，否则会造成内存泄露 cursor.close(); } 案例：Demo0602，本案例实现了使用ContentResolver操作Android系统短信应用暴露的数据，将系统短信的会话内容备份到本地XML文件的功能。 四、内容观察者的使用前面介绍的是当使用ContentProvider将数据共享出来时，可以使用ContentResolver查询ContentProvider共享出来的数据。 如果应用程序需要实时监听ContentProvider共享的数据是否发生变化，可以使用Android系统提供的ContentObserver来实现。 1. 什么是ContentObserverContentObserver用来观察指定Uri所代表的数据。当ContentObserver观察到指定Uri代表的数据发生变化时，就会触发ContentObserver的onChange()方法，此时，在onChange()方法里使用ContentResolver可以查询到变化的数据。 ContentObserver的工作原理： 图6-3 如图6-3所示，使用ContentObserver观察A应用的数据时，首先要在A应用的ContentProvider中调用ContentResolver的notifyChange()方法。调用了这个方法之后，当数据发生变化时，它就会向”消息中心”发送数据变化的消息。然后C应用观察到”消息中心”有数据变化，就会触发ContentObserver的onChange()方法。 ContentObserver的几个方法： public void Observer(Handler handler) ContentObserver的派生类都需要调用该构造方法。参数可以是主线程Handler(可以更新UI)，也可以是任何Handler对象 public void onChange(boolean selfChange) 当观察到Uri代表的数据发生变化时，会触发该方法 2. 使用ContentObserver如果要使用ContentObserver观察数据变化，就必须在ContentProvider中的delete()、insert()、update()方法中调用ContentResolver的notifyChange()方法。 示例代码： public Uri insert(Uri uri, ContentValues values) { if(matcher.match(uri)==INSERT){ SQLiteDatabase db=helper.getWritableDatabase(); db.insert(&quot;person&quot;, null, values); getContext().getContentResolver().notifyChange(Uri.parse(&quot;learning.android.it.org.demo0601.PersonDBProvider&quot;), null); }else{ throw new IllegalArgumentException(&quot;路径不匹配，不能执行插入操作&quot;); } return null; } 上面代码通过调用ContentResolver的notifyChange()方法将数据变化的消息发送至”消息中心”。notifyChange(Uri uri, ContentObserver observer)方法中的observer参数表示指定具体的观察者接收数据发生变化的消息。如果不指定具体的观察者则传入null即可。 接下来在应用中注册ContentObserver监听数据变化。 示例代码： public class MainActivity extends AppCompatActivity { private TextView mSmsTv; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mSmsTv = (TextView) findViewById(R.id.sms_tv); ContentResolver resolver = getContentResolver(); Uri uri = Uri.parse(&quot;content://sms/&quot;); // 注册内容观察者 resolver.registerContentObserver(uri, true, new MyObserver(new Handler())); } // 自定义的内容观察者 private class MyObserver extends ContentObserver { public MyObserver(Handler handler) { super(handler); } // 当ContentObserver观察到是数据库的内容变化了，调用这个方法 // 观察到消息邮箱里面有一条数据库内容变化的通知. public void onChange(boolean selfChange) { super.onChange(selfChange); Toast.makeText(MainActivity.this, &quot;数据库的内容变化了.&quot;, Toast.LENGTH_SHORT).show(); Uri uri = Uri.parse(&quot;content://sms/&quot;); // 获取ContentResolver对象 ContentResolver resolver = getContentResolver(); // 查询变化的数据 Cursor cursor = resolver.query(uri, new String[] { &quot;address&quot;, &quot;date&quot;, &quot;type&quot;, &quot;body&quot; }, null, null, null); // 因为短信是倒序排列 因此获取最新一条就是第一个 cursor.moveToFirst(); String address = cursor.getString(0); String body = cursor.getString(3); // 更改UI界面 mSmsTv.setText(&quot;短信内容：&quot; + body + &quot;\\n&quot; + &quot;短信地址：&quot; + address); cursor.close(); } } } 案例：Demo0603，本案例实现了接收系统短信并将收到的短信显示在界面上的功能","categories":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://hepsilion.github.io/tags/Android/"}],"keywords":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}]},{"title":"第五章 SQLite数据库","slug":"05-SQLite","date":"2017-03-05T12:43:19.000Z","updated":"2017-07-22T13:11:48.766Z","comments":true,"path":"2017/03/05/05-SQLite/","link":"","permalink":"https://hepsilion.github.io/2017/03/05/05-SQLite/","excerpt":"SQLite数据库的基本操作 使用sqlite3工具操作数据库 使用ListView控件展示数据","text":"SQLite数据库的基本操作 使用sqlite3工具操作数据库 使用ListView控件展示数据 一、SQLite数据库简介SQLite是一个轻量级数据库，占用资源少，遵守ACID事务属性，同时还支持SQL语言、事务处理等功能。 SQLite没有服务器进程，它通过文件保存数据，该文件是跨平台的，可以放在其他平台中使用。 在保存数据时，支持NULL、Integer、Real(浮点型数字)、Text(字符串文本)和Blob(二进制对象)5种数据类型。但实际上SQLite也接收varchar(n)、char(n)、decimal(p, s)等数据类型，只不过在运算或保存时会转换成对应的5种数据类型。因此，可以将各种类型的数据保存到任何字段中，而不用关心字段声明的数据类型。这也是SQLite数据库的最大特点。 二、SQLite数据库的使用1. SQLite操作API为了方便使用SQLite数据库，Android SDK提供了一系列对数据库进行操作的类和接口。 (1) SQLiteOpenHelper类 SQLiteOpenHelper是一个抽象类，该类用于创建数据库和数据库版本更新。该类常用方法如图5-1所示 图 5-1 (2) SQLiteDatabase类 SQLiteDatabase是一个数据库访问类，该类封装了一系列数据库操作的API，可以对数据库进行增、删、改、查操作。该类的常用方法如图5-2所示。 图 5-2 (3) Cursor接口 Cursor是一个游标接口，在数据库操作中作为返回值，相当于结果集ResultSet。该类的常用方法如图5-3所示。 图 5-3 2. SQLite常用操作(1) 创建SQLite数据库 Android系统推荐使用SQLiteOpenHelper的子类创建SQLite数据库，因此需要创建一个类继承自SQLiteOpenHelper，重写onCreate()方法，并在该方法中执行创建数据库的命令。 示例代码 public class PersonSQLiteOpenHelper extends SQLiteOpenHelper{ // 构造方法，用来定义数据库的名称，数据库查询的结果集，数据库的版本 public PersonSQLiteOpenHelper(Context context){ super(context, &quot;person.db&quot;, null, 5); } // 数据库第一次被创建时调用该方法 public void onCreate(){ // 初始化数据库的表结构，执行一条建表的SQL语句 db.execSQL(&quot;create table person (id integer primary key autoincrement, name varchar(20), number varchar(20))&quot;); } // 当数据库的版本号增加时调用，如果数据库的版本号不增加，该方法则不会调用 public void onUpgrade(){ db.execSQL(&quot;alter table person add account varchar(20)&quot;); } } 值得注意的是，创建的数据库被放置在/data/data/packagename/databases目录下。 (2) 增 示例代码：使用SQLiteDatabase对象向person表中插入一条数据 public void add(String name, String number){ // 获取一个可读写的SQLiteDatabase对象 SQLiteDatabase db=helper.getWritableDatabase(); // 创建一个ContentValues对象，将参数以key，value的形式添加进去 ContentValues values=new ContentValues(); values.put(&quot;name&quot;, name); values.put(&quot;number&quot;, number); // 插入一条数据到person表中 long id=db.insert(&quot;person&quot;, null, values); // 关闭数据库 db.close(); return id; } 除了上述介绍的方法之外，还有一个方法可以实现该功能： db.execSQL(&quot;insert into person(name, number) values (?, ?)&quot;, new Object[]{name, number}); 需要注意的是，使用完SQLiteDatabase对象后一定要关闭，否则数据库连接会一直存在，不断消耗内存，并且会报出数据库未关闭异常，当系统内存不足时将获取不到SQLiteDatabase对象。 (3) 删 示例代码：使用SQLiteDatabase对象的delete()方法删除person表中的数据 public int delete(String name){ // 获取一个可读写的SQLiteDatabase对象 SQLiteDatabase db=helper.getWritableDatabase(); // 删除数据 int number=db.delete(&quot;person&quot;, &quot;name=?&quot;, new String[]{name}); // 关闭数据库 db.close(); return number; } (4) 改 示例代码：使用SQLiteDatabase对象的update()方法修改person表中的数据 public int update(String name, String newNumber) { // 获取一个可读写的SQLiteDatabase对象 SQLiteDatabase db=helper.getWritableDatabase(); // 创建一个ContentValues对象，将参数以key，value的形式添加进去 ContentValues values=new ContentValues(); values.put(&quot;number&quot;, newNumber); //执行修改 int number=db.update(&quot;person&quot;, values, &quot;name=?&quot;, new String[]{name}); // 关闭数据库 db.close(); return number; } (5) 查 SQLiteDatabase提供两个用于查询数据的方法，一个是rawQuery()方法，另一个是query()方法。 示例代码：使用SQLiteDatabase对象的query()方法查询person表中的数据 public boolean find(String name){ // 获取一个可读的SQLiteDatabase对象 SQLiteDatabase db=helper.getReadableDatabase(); // 查询数据库的操作 // 参数1：表名； 参数2：查询的列名； 参数3：查询条件； // 参数4：查询参数值； 参数5：分组条件； 参数6：having条件； 参数7：排列方式 Cursor cursor=db.query(&quot;&quot;, null, &quot;&quot;, new String[]{name}, null, null, null); // 是否有下一个值 boolean result=cursor.moveToNext(); // 关闭游标 cursor.close(); // 关闭数据库 db.close(); return result; } 使用SQLiteDatabase对象的rawQuery()方法查询person表中的数据 Cursor cursor=db.rawQuery(&quot;select * from person where name=?&quot;, new String[]{name}); 增、删、改操作都可以用execSQL()方法执行SQL语句，而查询却使用rawQuery()，这是因为查询数据库会返回一个结果集Cursor，而execSQL()方法没有返回值。 需要注意的是，在使用完Cursor对象时，一定要及时关闭，否则会造成内存泄露。 3. SQLite事务操作所谓的事务就是针对数据库的一组操作，它可以由一条或多条SQL语句组成，由于事务的操作具备原子性的特点，如果其中有一条语句无法执行，那么所有的语句都不会执行，也就是说，事务中的语句要么都执行，要么都不执行。 示例代码：使用SQLite的事务来模拟转账功能 首先得到一个SQLiteDatabase对象，然后开启事务执行事务操作，最后关闭事务。 PersonSQLiteOpenHelper helper=new PersonSQLiteOpenHelper(getContext()); // 获取一个可读写的SQLiteDatabase对象 SQLiteDatabase db=helper.getWritableDatabase(); // 开始数据库的事务 db.beginTransaction(); try{ //执行转出操作 db.execSQL(&quot;update person set account=account-100 where name=?&quot;, new Object[]{&quot;zhangsan&quot;}); //执行转入操作 db.execSQL(&quot;update person set account=account+100 where name=?&quot;, new Object[]{&quot;wangwu&quot;}); //标记数据库事物执行成功 db.setTransactionSuccessful(); }catch(Exception e){ Log.i(&quot;事务处理失败&quot;, e.toString()); }finally{ db.endTransaction(); //关闭事务 db.close(); //关闭数据库 } 需要注意的是，事务操作完成后，一定要使用endTransaction()方法关闭事务，当执行到endTransaction()方法时，首先会检查是否有事务执行成功的标记，有则提交数据，无则回滚数据。最后会关闭事务，如果不关闭事务，事务只有到超时才自动结束，会降低数据库并发效率。因此，通常情况下，该方法放在finally中执行。 4. sqlite3工具在Android开发中，使用真机进行测试无法进入data目录(只有获得root权限的手机可以进入data目录)，因此也无法直接操作应用程序下的数据库。为了解决这个问题，SQLite数据库为开发者提供了一个sqlite3.exe工具，通过这个工具可以直接操作数据库。 sqlite3.exe是一个简单的SQLite数据库管理工具，位于Android sdk/tools目录下。由于Android在运行时集成了sqlite3.exe，因此在使用sqlite3.exe工具前必须要开启模拟器或者连接真实设备。 使用该工具时，需要在命令行，一次输入如下命令： adb shell (挂载到Linux的目录空间) cd data/data (进入data/data目录) cd packagename (进入应用程序包目录中) ls (列出当前文件夹下的文件) cd databases (进入databases文件夹) ls -l (列出当前文件夹所有文件的详细格式) sqlite3 person.db (使用sqlite3操作应用程序下的数据库) select * from person; (使用SQL语句查询person表中的信息) 三、ListView在Android开发中，ListView是一个比较常用的控件。它以列表的形式展示具体数据内容，并且能够根据数据的长度自适应屏幕显示。 1. ListView控件的使用 ListView的常见属性如图5-4所示。 图 5-4 使用ListView的示例代码： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/ll_root&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;ListView android:id=&quot;@+id/lv&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;/LinearLayout&gt; 图5-5 图形化界面如图5-5所示，ListView是一个列表视图，由很多Item组成，每一个Item的布局都是一样的。需要注意的是，在布局文件中指定了ListView的id之后，ListView才会在图形化视图中显示出来。同时如果不对ListView进行数据适配，那么就无法在界面上看到布局文件中创建的ListView。 2. 常用数据适配器 在使用ListView时，需要对其进行数据适配。为了实现这个功能，Android系统提供了一系列的适配器(Adapter)对ListView进行数据适配。可以将适配器理解为界面数据绑定，适配器就像显示器，把复杂的数据按人们易于接受的方式来展示。 (1) BaseAdapter 它是一个抽象类，该类拥有4个抽象方法。在Android开发中，开发者在适配数据到ListView时，需要创建一个类继承BaseAdapter并重写这4个抽象方法，Android系统再根据这几个抽象方法对ListView进行数据适配。 public int getCount(); 得到ListView中Item的总数 public Object getItem(int position); 根据position得到某个Item对象 public long getItemId(int position); 根据position得到某个Item对象的id public View getView(int position, View convertView, ViewGroup parent); 得到position位置对应的Item视图 (2) SimpleAdapter SimpleAdapter继承自BaseAdapter，实现了BaseAdapter的4个抽象方法。因此，开发者只需在创建SimpleAdapter实例时，在构造方法中传入相应的参数即可。 SimpleAdapter的构造方法： public SimpleAdapter(Context context, List&lt;? extends Map&lt;String, ?&gt; data, int resource, String[] from, int[] to); 构造方法的参数介绍如下： Context context：Context对象，getView()方法中需要用到Context将布局转换成View对象 List&lt;? extends Map&gt; data：数据集合，SimpleAdapter已经在getCount()放啊中实现了将数据集合大小返回。 int resource：Item布局的资源id String[] from：Map集合里面的key int[] to：Item布局对应的空间id 需要注意的是，SimpleAdapter只能适配Checkable、TextView、ImageView，其中Checkable是一个接口，CheckBox控件就实现了该接口，TextView是显示文本的控件，ImageView是显示图片的空间。如果int[] to所代表的控件不是这三种类型则会报IllegalStateException。 (3) ArrayAdapter ArrayAdapter也是BaseAdapter的子类，与SimpleAdapter类似，开发者只需要在构造方法里面传入相应的参数即可适配数据。 // 需要适配的数据 private String[] names = { &quot;京东商城&quot;, &quot;QQ&quot;, &quot;QQ斗地主&quot;, &quot;新浪微博&quot;, &quot;天猫&quot;, &quot;UC浏览器&quot;, &quot;微信&quot; }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 初始化ListView控件 mListView = (ListView) findViewById(R.id.lv); // ArrayAdapter mListView.setAdapter(new ArrayAdapter&lt;String&gt;(this, R.layout.list_item, R.id.tv_list, names)); } ArrayAdapter通常用于适配TextView控件，例如Android系统中的Setting。 ArrayAdapter的构造方法如下所示：public ArrayAdapter(Context context, int resource, int textViewResourceId, T[] objects); 构造方法的参数介绍如下： Context context：Context对象 int resource：Item布局资源的id int textViewResourceId：Item布局相应的TextView控件的id T[] objects：需要适配的数据数组 案例：Demo0501，Android应用市场，演示如何使用ListView以及如何对其进行数据适配。本案例要实现的是将一个字符数组和一组图片资源绑定到ListView上显示。 案例：Demo0502，商品展示，结合ListView和SQLite来实现在界面上操作数据库。 ListView的几个方法： setOnItemClickListener()方法：该方法用于监听Item的点击事件，在使用该方法时需要传入一个OnItemClickListener的实现类对象，并且需要实现onItemClick方法。当点击ListView的Item时就会触发Item的点击事件然后回调onItemClick()方法。 setSelection()方法：该方法用于设置当前选中的条目。 notifyDataSetChange()方法：当数据适配器中的内容发生变化时会调用该方法，重新执行Adapter的getView()方法。","categories":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://hepsilion.github.io/tags/Android/"}],"keywords":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}]},{"title":"第四章 数据存储","slug":"04-数据存储","date":"2017-03-04T12:42:20.000Z","updated":"2017-07-22T13:11:45.779Z","comments":true,"path":"2017/03/04/04-数据存储/","link":"","permalink":"https://hepsilion.github.io/2017/03/04/04-数据存储/","excerpt":"5种数据存储方式的特点 使用文件存储数据 使用SharedPreferences存储数据 XML文件的序列化与解析","text":"5种数据存储方式的特点 使用文件存储数据 使用SharedPreferences存储数据 XML文件的序列化与解析 大部分应用程序都会涉及到数据存储，Android程序也不例外。Android中的数据存储方式有5种，分别为文件存储、SharedPreferences、SQLite数据库、ContentProvider以及网络存储，每种方式都有其不同的特点。 文件存储：以I/O流形式把数据存入手机内存或者SD卡，可以存储大量数据，如音乐、图片或者视频等。 SharedPreferences：它本质上是一个XML文件，以Map形式存入手机内存中。常用于存储较简单的参数设置，如登录帐号密码的存储、窗口功能状态的存储等，使用起来简单、方便。 SQLite数据库：SQLite是一个轻量级、跨平台的数据库。数据库中所有信息都存储在单一文件中，占用内存小，并且支持基本SQL语法，是项目中经常被采用的一种数据存储方式，通常用于存储用户信息等。 ContentProvider：又称为内容提供者，是Android四大组件之一，以数据库形式存入手机内存，可以共享自己的数据给其他应用使用。相对于其他对外共享数据的方式而言，ContentProvicer统一了数据访问方式，使用起来更规范。 网络存储：把数据存储在服务器上，不存储在本地，使用的时候直接从网络获取，避免了手机端信息丢失以及其他的安全隐患。 需要注意的是，Android中应用程序存储的数据都属于应用私有，如果要将程序的私有数据分享给其他应用程序，可以使用文件存储、SharedPreferences以及ContentProvider，推荐使用ContentProvider。 一、文件存储1. 文件存储简介文件存储是Android中最基本的一种数据存储方式，它与Java中的文件存储类似，都是通过I/O流的形式把数据原封不动地存储到文件中。不同的是，Android中的文件存储分为内部存储和外部存储。 (1) 内部存储 内部存储是指将应用程序中的数据以文件方式存储到设备的内部存储空间中(该文件位于data/data/packagename/files/目录下)。 内存存储方式存储的文件为其所创建的应用程序所私有，如果其他应用程序要操作本应用程序中的文件，需要设置权限。 当创建的应用程序被卸载时，其内部存储文件也随之被删除。 内部存储可以使用Context提供的openFileOutput(String name, int mode)方法和openFileInput(String name)方法分别获取FileOutputStream对象和FileInputStream对象。 openFileOutput() 用于打开应用程序中对应的输出流，将数据存储到指定的文件中； openFileInput() 用于打开应用程序中对应的输入流，用于从文件中读取数据。 其中参数name表示文件名，mode表示文件的操作模式，也就是读写文件的方式，它的取值有4种： MODE_PRIVATE：该文件只能被当前程序读写，默认的操作方式； MODE_APPEND：该文件的内容可以追加，常用的一种方式； MODE_WORLD_READABLE：该文件的内容可以被其他程序读取，安全性低，通常不使用； MODE_WORLD_WRITEABLE: 该文件的内容可以被其他文件程序写入，安全性低，通常不使用。 使用FileOutputStream对象将数据存储到文件中的示例代码： String saveinfo = et_info.getText().toString().trim(); FileOutputStream fos; try { fos = openFileOutput(&quot;data.txt&quot;, Context.MODE_APPEND); fos.write(saveinfo.getBytes()); fos.close(); } catch (Exception e) { e.printStackTrace(); } 使用FileInputStream对象从文件中读取数据的示例代码： String content = &quot;&quot;; try { FileInputStream fis = openFileInput(&quot;data.txt&quot;); byte[] buffer = new byte[fis.available()]; fis.read(buffer); content = new String(buffer); } catch (Exception e) { e.printStackTrace(); } 案例：Demo0401，存储用户信息，用文件存储信息以及从文件中读取信息 (2) 外部存储 外部存储是指将文件存储到一些外围设备上(该文件通常位于mnt/sdcard目录下，不同厂商生产的手机这个路径可能会不同)，例如SD卡或者设备内嵌的存储卡，属于永久性的存储方式。 外部存储的文件可以被其他应用程序所共享，当将外围存储设备连接到计算机时，这些文件可以被浏览、修改和删除，因此这种方式不安全。 由于外围存储设备可能被移除、丢失或者处于其他状态，因此在使用外围设备之前必须使用Environment.getExternalStorageState()方法来确认外围设备是否可用，当外围设备可用并且具有读写权限时，就可以通过FileInputStream、FileOutputStream或者FileReader、FileWriter对象来读写外围设备中的文件。 向外围设备(SD卡)中存储数据的示例代码： String state=Environment.getExternalStorageState(); if(state.equals(Environment.MEDIA_MOUNTED)){ File SDPath=Environment.getExternalStorageDirectory(); File file=new File(SDPath, &quot;data.txt&quot;); String data=&quot;Hello World&quot;; FileOutputStream fos; try{ fos=new FileOutputStream(file); fos.write(data.getBytes()); fos.close(); }catch(Exception e){ e.printStackTrace(); } } 上述代码中，使用了Environment.getExternalStorageDirectory()方法获取SD卡根目录的路径。由于不同手机厂商SD卡的根目录路径可能不一致，用这种方法可以避免把路径写死而找不到SD卡。 从外围设备(SD卡)中读取数据的示例代码： String state=Environment.getExternalStorageState(); if(state.equals(Environment.MEDIA_MOUNTED)){ File SDPath=Environment.getExternalStorageDirectory(); File file=new File(SDPath, &quot;data.txt&quot;); FileInputStream fis; try{ fis=new FileInputStream(file); BufferedReader br=new BufferedReader(new InputStreamReader(fis)); String data=br.readLine(); }catch(Exception e){ e.printStackTrace(); } } 需要注意的是，操作SD卡中数据时，需要在清单文件的节点中配置权限信息，指定应用程序具有读或写SD卡中数据的权限。 &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt; 2. XML序列化与解析文件存储有很多方式，XML就是其中一种。XML存储的数据结构比较清晰，应用比较广泛。 (1) XML序列化 序列化是将对象状态转换为可保持或可传输状态的过程。在序列化对象时，需要使用XmlSerialize序列化器(XmlSerializer类)，它可以将I/O流中传输的对象变得像基本类型数据一样，实现传输的功能，序列化后的对象以XML形式保存。 对象序列化的示例代码： 要将数据序列化，首先要创建与XML文件相对应的序列化器(XmlSerializer)，然后将对象转化为XML。 File file = new File(Environment.getExternalStorageDirectory(), &quot;person.xml&quot;); FileOutputStream os = new FileOutputStream(file); XmlSerializer serializer = Xml.newSerializer(); serializer.setOutput(os, &quot;UTF-8&quot;); // 设置XML文件编码方式 serializer.startDocument(&quot;UTF-8&quot;, true); // 写入XML文件标志，即&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt; serializer.startTag(null, &quot;persons&quot;); int count = 0; for (Person person : userData) { serializer.startTag(null, &quot;person&quot;); serializer.attribute(null, &quot;id&quot;, count + &quot;&quot;); //将Person对象的name属性写入XML文件 serializer.startTag(null, &quot;name&quot;); serializer.text(person.getName()); serializer.endTag(null, &quot;name&quot;); //将Person对象的age属性写入XML文件 serializer.startTag(null, &quot;age&quot;); serializer.text(String.valueOf(person.getAge())); serializer.endTag(null, &quot;age&quot;); //将Person对象的score属性写入XML文件 serializer.startTag(null, &quot;score&quot;); serializer.text(String.valueOf(person.getScore())); serializer.endTag(null, &quot;score&quot;); serializer.endTag(null, &quot;person&quot;); count++; } serializer.endTag(null, &quot;persons&quot;); serializer.endDocument(); serializer.flush(); os.close(); 序列化后的XML文件如下所示： &lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos; standalone=&apos;yes&apos; ?&gt; &lt;persons&gt; &lt;person id=&quot;0&quot;&gt; &lt;name&gt;王0&lt;/name&gt; &lt;age&gt;100&lt;/age&gt; &lt;score&gt;80&lt;/score&gt; &lt;/person&gt; &lt;person id=&quot;1&quot;&gt; &lt;name&gt;王1&lt;/name&gt; &lt;age&gt;99&lt;/age&gt; &lt;score&gt;79&lt;/score&gt; &lt;/person&gt; &lt;person id=&quot;2&quot;&gt; &lt;name&gt;王2&lt;/name&gt; &lt;age&gt;98&lt;/age&gt; &lt;score&gt;78&lt;/score&gt; &lt;/person&gt; &lt;/persons&gt; 在XML文件中，带有&lt;&gt;的是开始标签，serializer.startTag()写入开始标签；带有&lt;/&gt;的是结束标签，用serializer.endTag()写入结束标签。 使用serializer.attribute()向标签写入属性数据；使用serializer.text()向节点写入节点数据。 XML文档的开始和结束分别用serializer.startDocument()和serializer.endDocument()来表示 案例：Demo0402，XML序列化 (2) XML解析 若要操作XML文档，首先需要将XML文档解析出来。通常情况下，解析XML文档有三种方式，分别是SAX解析、DOM解析和PULL解析。 SAX解析 SAX解析会逐行扫描XML文档，当遇到标签时触发解析处理器，采用事件处理的方式解析XML。 它在读取文档的同时即对XML进行处理，不必等到文档加载结束，相对快捷。而且也不需要将整个文档加载进内存，因此不存在占用内存的问题，可以解析超大XML。 但是，SAX解析只能用来读取XML中的数据，无法进行增删改。 DOM解析 DOM(Document Object Mode)解析式一种基于对象的API，它会将XML文件的所有内容以文档树的形式存放在内存中，然后允许使用DOM API遍历XML树、检索所需的数据，这样便能根据树的结构以节点形式对文件进行操作。 使用DOM操作XML的代码看起来是比较直观的，而且在编码方面比SAX解析更加简单。 但是，由于DOM需要将整个XML文件以文档树的形式存放在内存中，消耗内存比较大。因此，较小的XML文件可以采用这种方式解析，但较大的文件不建议采用这种方式解析。 PULL解析 PULL解析器是一个开源的Java项目，既可以用于Android项目，也可以用于JavaEE程序。 Android已经集成了PULL解析器，因此，在Android中最常用的解析方式就是PULL解析。使用PULL解析XML文档，首先要创建XmlPullParser解析器，该解析器提供了很多属性，通过这些属性可以解析出XML文件中的各个节点内容。 XmlPullParser的常用属性： XmlPullParser.START_DOCUMENT：XML文档的开始，如&lt;?xml version=”1.0” encoding=”utf-8”?&gt; XmlPullParser.END_DOCUMENT：XML文档的结束。 XmlPullParser.START_TAG：开始节点，在XML文件中，除了文本之外，带有尖括号&lt;&gt;的都是开始节点，如&lt; weather&gt;。 XmlPullParser.END_TAG：结束节点，带有&lt;/&gt;都是结束节点，如&lt; /weather&gt;。 使用PULL解析器的步骤： 1) 通过调用Xml.newPullParser() 得到一个XmlPullParser对象。 2) 通过parser.getEventType() 获取当前的事件类型。 3) 通过while循环判断当前操作事件类型是否为文档结束，是则跳出while循环。 4) while循环中通过switch语句判断当前事件类型是否为开始标签，是则获取该标签中的内容。 案例：Demo0403，天气预报，演示XML解析 二、SharedPreferencesSharedPreferences是Android平台上一个轻量级的存储类，主要用于存储一些应用程序的配置参数，例如用户名、密码、自定义参数的设置等。 SharedPreferences中存储的数据是以key/value对的形式保存在XML文件中，该文件位于data/data/packagename/shared_prefs文件夹中。 需要注意的是，SharedPreferences中的value值只能是float、int、long、boolean、String、StringSet类型数据。 使用SharedPreferences类存储数据时，首先需要通过context.getSharedPreferences(String name, int mode)获取SharedPreferences的实例对象(在Activity中可以直接使用this代表上下文，如果不是在Activity中则需要传入一个Context对象获取上下文)： SharedPreferences sp=context.getSharedPreferences(String name, int mode); 在该代码中，name表示文件名，mode表示文件的操作模式，该模式有多个值可供选择： MODE_PRIVATE：指定该SharedPreferences中的数据只能被本应用程序读写。 MODE_APPEND：该文件的内容可以追加。 MODE_WORLD_READABLE：指定该SharedPreferences中的数据可以被其他应用程序读。 MODE_WORLD_WRITEABLE：指定该SharedPreferences中的数据可以被其他应用程序写。 如图4-1所示，SharedPreferences提供了一系列方法用于获取应用程序中的数据，但需要注意的是，SharedPreferences对象本身只能获取数据，并不支持数据的存储和修改。 图 4-1 数据的存储和修改需要通过SharedPreferences.Editor对象实现。要想获取Editor实例对象，需要调用SharedPreferences.Editor.edit()方法。 图 4-2 向SharedPreferences对象中存储数据的示例代码： 使用SharedPreferences存储数据时，需要先获取SharedPreferences对象，通过该对象获取到Editor对象，然后通过Editor对象的相关方法(如图4-2所示)存储数据。 SharedPreferences sp=getSharedPreferences(&quot;config&quot;, MODE_PRIVATE); Editor editor=sp.edit(); //获取编辑器 editor.putString(&quot;name&quot;, &quot;value1&quot;); //存入String类型数据 editor.putInt(&quot;age&quot;, 8); //存入int类型数据 editor.commit(); //提交修改 从SharedPreferences对象中获取数据的示例代码： 创建SharedPreferences对象，使用该对象获取相应key的值。 SharedPreferences sp=context.getSharedPreferences(); String data=sp.getString(&quot;name&quot;, &quot;&quot;); 从SharedPreferences对象中删除数据的示例代码： 与存储数据类似，先要获取到Editor对象，然后通过该对象删除数据，最后提交。 SharedPreferences sp=getSharedPreferences(&quot;config&quot;, MODE_PRIVATE); Editor editor=sp.edit(); //获取编辑器 editor.remove(&quot;name&quot;); //删除一条数据 editor.clear(); //删除所有数据 editor.commit(); //提交修改 注意：SharedPreferences使用很简单，但一定要注意以下几点： 存入数据和删除数据时，一定要在最后使用editor.commit()方法提交修改 获取数据的key值与存入数据的key值的数据类型要一致，否则查找不到数据。 保存SharedPreferences的key值时，可以用静态变量保存，以免存储、删除时写错了，如 private static final String key=”key1”; 案例：Demo0404，QQ登陆，演示使用SharedPreferences存储数据","categories":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://hepsilion.github.io/tags/Android/"}],"keywords":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}]},{"title":"第三章 Activity","slug":"03-Activity","date":"2017-03-03T12:40:47.000Z","updated":"2017-07-22T13:11:41.962Z","comments":true,"path":"2017/03/03/03-Activity/","link":"","permalink":"https://hepsilion.github.io/2017/03/03/03-Activity/","excerpt":"Activity的生命周期 Activity的4种启动模式 隐式意图和显式意图的使用 使用Intent传递数据","text":"Activity的生命周期 Activity的4种启动模式 隐式意图和显式意图的使用 使用Intent传递数据 一、Activity入门1. Activity简介Activity是Android应用程序的四大组件之一，它负责管理Android应用程序的用户界面。 一个应用程序一般会包含若干个Activity，每一个Activity组件负责一个用户界面的展现。 Activity是通过调用setContentView()方法来显示指定组件的，setContentView()方法既可以接收View对象为参数，也可以接受布局文件对应的id为参数。 在应用程序中，Activity就像一个界面管理员，用户在界面上的操作是通过Activity管理的。 2. Activity的创建(1) 定义一个类继承自android.app.Activity或者其子类； (2) 在res/layout目录中创建一个xml布局文件，用于创建Activity的布局； (3) 在AndroidManifest.xml文件中注册Activity； &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;!--表示将当前Activity设置为程序最先启动的Activity--&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;!--表示让当前Activity在桌面上创建图标--&gt; &lt;/intent-filter&gt; &lt;/activity&gt; (4) 重写Activity的onCreate()方法，并在该方法中使用setContentView()加载指定的布局文件。 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } 案例：Demo0301，演示Activity的按键按下、按键松开、点击屏幕事件 3. Activity的生命周期Activity的生命周期是指Activity从创建到销毁的过程，Activity的生命周期中存在三种状态：运行状态、暂停状态和停止状态。 运行状态：当Activity在屏幕的最前端时，它是可见的、有焦点的，可以用来处理用户的常见操作，如点击、双击、长按事件等，这种状态称为运行状态。 暂停状态：在某些情况下，Activity对用户来说仍然是可见的，但它不再拥有焦点，即用户对它的操作是没有实际意义的。例如，当最上面的Activity没有完全覆盖屏幕或者是透明的，被覆盖的Activity仍然对用户可见，并且存活(它保留着所有的状态和成员信息并保持与Activity管理器的连接)。但当内存不足时，这个暂停状态的Activity可能会被杀死。 停止状态：当Activity完全不可见时，它就处于停止状态，但仍然保留着当前状态和成员信息。然而这些对用户来说都是不可见的，当系统内存不足时，这个Activity很容易被杀死。 Activity从一种状态转变到另一种状态时会触发一些事件，执行一些回调函数来通知状态的变化： onCreate() 当Activity被创建的时候调用的方法 onStart() 当Activity变成用户可见的时候调用的方法 onResume() 当Activity获取到焦点的时候调用的方法 onPause() 当Activity失去焦点的时候调用的方法 onStop() 当Activity变成用户不可见的时候调用的方法 onDestroy() 当Activity被销毁的时候调用的方法 onRestart() 当Activity重新回到前台，再次可见时调用的方法。 图 3-1 图3-1所示是一个Activity的生命周期模型，当Activity从启动到关闭时，会依次执行： onCreate() -&gt; onStart() -&gt; onResume() -&gt; onPause() -&gt; onStop() -&gt; onDestroy()方法。 当Activity执行到onPause()方法失去焦点时，重新回到前台会执行onResume()方法。 当Activity执行到onStop()方法变成用户不可见时，再次回到前台会执行onRestart()方法、onStart()方法和onResume()方法。 如果进程被杀死，Activity重新回到前台时会重新执行onCreate()方法。 案例：Demo0302，使用两个Activity之间的跳转演示Activity生命周期方法变化的过程 4. 横竖屏切换时的生命周期现实生活中，使用手机时会根据不同情况进行横竖屏切换。默认情况下，当手机横竖屏切换时，Activity会销毁重建。 这种情况对实际开发肯定会有影响，如果不希望在横竖屏切换时Activity被销毁重建，可以在AndroidManifest.xml文件中设置Activity的android:configChanges的属性，这样无论怎样切换Activity都不会销毁重建： android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; 如果希望某一个界面一直处于竖屏或者横屏状态，不随手机的晃动而改变，同样可以在清单文件中通过设置Activity的参数来完成： 竖屏： android:screenOrientation=&quot;portrait&quot; 横屏： android:screenOrientation=&quot;landscape&quot; 二、Activity的启动模式Android采用任务栈的方式来管理Activity的实例。 当启动一个应用时，Android就会为之创建一个任务栈，先启动的Activity压在栈底，后启动的Activity放在栈顶，通过启动模式可以控制Activity在任务栈中的加载情况。 1. Android下的任务栈 在开发Android应用时，经常会涉及一些消耗大量系统内存的情况，例如视频播放、大量图片或者程序中开启多个Activity没有及时关闭等，会导致程序出现错误。为了避免这种问题，Google提供了一套完整的机制让开发人员控制Android中的任务栈。 图 3-2 Android中的任务栈，类似于一个容器，用于管理所有的Activity实例。在存放Activity时，满足”先进后出”的原则。如图3-2所示，先加入任务栈中的Activity会处于容器下面，后加入的处于容器上面，而从任务栈中取出的Activity是从最顶端先取出，最后取出的是最底端的Activity。 2. Activity的4种启动模式 在实际开发中，应根据特定的需求为Activity指定恰当的启动模式。 Android的启动模式有4种，分别是standard、singleTop、singleTask和singleInstance。 在AndroidManifest.xml中，通过&lt; activity&gt;标签的android:launchMode属性可以设置启动模式. (1) standard模式 standard是Activity默认的启动模式，在不指定Activity启动模式的情况下，所有Activity使用的都是standard模式。 在standard模式下，每当启动一个新的Activity，它就会进入任务栈，并处于栈顶的位置，对于使用standard模式的Activity，系统不会判断该Activity在栈中是否存在，每次启动都会创建一个新的实例。 图 3-3 如图3-3所示，在standard启动模式下，Activity01最先进栈，其次是Activity02，最后是Activity03；出栈时，Activity03最先出栈，其次是Activity02，最后是Activity01，满足”先进后出”原则。 (2) singleTop模式 singleTop模式与standard类似，不同的是，当启动的Activity已经位于栈顶时，则直接使用它而不创建新的实例。如果启动的Activity没有位于栈顶时，则创建一个新的实例位于栈顶。 图 3-4 如图3-4所示，当前栈顶的元素是Activity03，如果再次启动的界面还是Activity03，则复用当前栈顶的Activity实例，如果再次启动的界面没有位于栈顶，则会重新创建一个实例。 (3) singleTask模式 如果希望Activity在整个应用程序中只存在一个实例，可以使用singleTask模式。 当Activity的启动模式指定为singleTask，每次启动该Activity时，系统首先会查找栈中是否存在该Activity的实例，如果发现已经存在则直接使用该实例，并将当前Activity之上的所有Activity出栈，如果没有发现则创建一个新的实例。 图 3-5 如图3-5所示，当再次启动Activity02时，并没有创建Activity02的新实例，而是将Activity03实例移除，复用Activity02实例，这就是singleTask模式，让某个Activity在当前栈中只存在一个实例。 (4) singleInstance模式 在程序开发中，如果需要Activity在整个系统中都只有一个实例，这时就需要用到singleInstance模式。不同于上述模式，指定为singleInstance模式的Acitivity会启动一个新的任务栈来管理这个Activity。 singleInstance模式加载Activity时，无论从哪个任务栈中启动该Activity，只会创建一个Activity实例，并且会使用一个全新的任务栈来装载该Activity实例。 采用这种模式启动Activity会分为以下两种情况： 第一种：如果要启动的Activity不存在，系统会先创建一个新的任务栈，再创建该Activity的实例，并把该Activity加入栈顶，如图3-6所示。 第二种：如果要启动的Activity已经存在，无论位于哪个应用程序或者哪个任务栈中，系统都会把该Activity所在的任务栈转到前台，从而使该Activity显示出来。 图 3-6 三、在Activity中使用Intent1. Intent介绍Android系统常使用Intent绑定应用程序组件，并在应用程序之间完成通信功能。 Intent一般用于启动Activity、启动服务、发送广播等，承担了Android应用程序三大核心组件间的通信功能。 图 3-7 图3-7列举了通过Intent来开启不同组件的常用方法。需要注意的是，使用Intent开启Activity和开启Service只有两个方法，而开启BroadcastReceiver有多个方法，这里只列举了三个常用的方法。 2. 显式意图和隐式意图Android中Intent寻找目标组件的方式分为两种，一种是显式意图，另一种是隐式意图。 (1) 显式意图：在通过Intent启动Activity时，明确指定激活组件的名称 第一种方式 //指定目标组件的包名、全路径名 Intent intent=new Intent(); intent.setClassName(&quot;learning.android.it.org.demo0303&quot;, &quot;learning.android.it.org.demo0303.Activity02&quot;); startActivity(intent); 第二种方式 //第一个参数Content要求提供一个启动Activity的上下文，第二个参数Class则是指定要启动的目标Activity Intent intent=new Intent(MainActivity.this, Activity02.class); startActivity(intent); (2) 隐式意图：没有明确指定组件名的Intent成为隐式意图。 Android系统会根据隐式意图中设置的动作(action)、类别(category)、数据(Uri和数据类型)找到最合适的组件 &lt;activity android:name=&quot;.Activity02&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.media.action.IMAGE_CAPTURE&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; //使用隐式意图开启Activity，只有当action和category的内容同时匹配时，Activity才会被开启 Intent intent = new Intent(); intent.setAction(&quot;android.media.action.IMAGE_CAPTURE&quot;); intent.addCategory(&quot;android.intent.category.DEFAULT&quot;); startActivity(intent); 案例：Demo0303，打开系统照相机，演示如果使用隐式意图 显式意图和隐式意图的比较： 显式意图开启组件时，必须要指定组件的名称，一般只在本应用程序切换组件时使用。 隐式意图的功能要比显式意图强大，不仅可以开启本应用的组件，还可以开启其他应用的组件，例如打开系统自带的照相机、浏览器等。 四、Activity中的数据传递1. 数据传递方式在Android开发中，经常要在Activity之间传递数据，这个功能可以通过Intent来实现。 使用Intent传递数据只需调用putExtra()方法将想要传递的数据存在Intent中，当启动了另一个Activity后，再把这些数据从Intent中取出即可。 方法一： // Activity01通过Intent使用putExtra将数据传递到Activity02 String str=&quot;Data from Activity01 to Activity02&quot;; Intent intent=new Intent(this, Activity02.class); intent.putExtra(&quot;data&quot;, data); //第一个参数是key，第二个参数是value startActivity(intent); // Activity02取出Activity01传递过来的数据 Intent intent=getIntent(); String str=intent.getStringExtra(&quot;data&quot;); //通过key获取value 方法二： // Activity01通过Intent使用putExtras将数据传递到Activity02 Bundle bundle=new Bundle(); bundle.putString(&quot;name&quot;, &quot;Linda&quot;); bundle.putInt(&quot;age&quot;, 20); Intent intent=new Intent(this, Activity02.class); intent.putExtras(bundle); startActivity(intent); // Activity02取出Activity01传递过来的数据 Intent intent=getIntent(); Bundle bundle=intent.getExtras(); String name=bundle.getString(&quot;name&quot;); int age=bundle.getInt(&quot;age&quot;); 案例：Demo0304，用户注册，演示Activity中的数据传递 2. 回传数据Android提供了一个startActivityForResult()方法，来实现Activity之间的回传数据。 (1) Activity01使用startActivityForResult(intent, requestCode)启动Activity02 Intent intent=new Intent(this, Activity02.class); startActivityForResult(intent, 1); startActivityForResult()方法接收两个参数，第一个参数是Intent；第二个参数是请求码，用于在Activity02中判断数据的来源。 (2) 在Activity02中使用setResult(resultCode, data)添加要返回的数据，并销毁当前Activity Intent intent=new Intent(); intent.putExtra(&quot;key&quot;, &quot;Hello&quot;); setResult(1, intent); finish(); setResult()方法接收两个参数，第一个参数resultCode结果码，一般使用0或1；第二个参数则是把带有数据的Intent传递回去 (3) 由于Activity01使用startActivityForResult方法启动Activity02，当Activity02销毁并返回时，会回调Activity01中的onActivityResult()方法，因此需要在Activity01中重写onActivityResult(requestCode, resultCode, data)方法获取Activity02返回的数据 protected void onActivityResult(int requestCode, int resultCode, Intent data){ super.onActivityResult(requestCode, resultCode, data); if(resultCode==1){ String value=data.getStringExtra(&quot;key&quot;); } } onActivityResult()方法有三个参数： 第一个参数requestCode表示在启动Activity02时传递的请求码； 第二个参数resultCode表示在返回数据时传入的结果码； 第三个参数data表示携带返回数据的Intent。 注意：在一个Activity中很可能调用startActivityForResult()方法启动多个Activity，每一个Activity返回的数据都会回调到onActivityResult()方法中，因此，首先要做的是通过检查requestCode的值来判断数据来源，确定数据是从Activity02返回的，然后再通过resultCode的值来判断数据处理结果是否成功，最后再把数据从data中取出。 案例：Demo0305，装备选择，演示Activity之间的数据回传 小知识：ProgressBar进度条 ProgressBar通常用于访问网络展示Loading对话框以及下载文件时显示的进度。 它有两种表现形式，一种是水平的，另一种是环形的。它的表现形式是由style属性控制的，ProgressBar的几个常用属性如下所示： style属性：控制ProgressBar的表现形式。 水平进度条的style属性值为”?android:attr/progressBarStyleHorizontal” 环形进度条的style属性值为”?android:attr/progressBarStyleLarge” setMax()方法：设置进度条的最大值 setProgress()方法：设置当前进度 getProgress()方法：获取当前进度","categories":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://hepsilion.github.io/tags/Android/"}],"keywords":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}]},{"title":"12-JDBC","slug":"12-JDBC","date":"2017-02-24T10:27:20.000Z","updated":"2017-07-22T13:10:35.149Z","comments":true,"path":"2017/02/24/12-JDBC/","link":"","permalink":"https://hepsilion.github.io/2017/02/24/12-JDBC/","excerpt":"JDBC","text":"JDBC 问：什么是JDBC？JDBC是一套面向对象的应用程序接口(API)，制定了访问各类关系数据库的统一标准接口，为访问各个数据库厂商的关系数据库提供了标准的实现，它由一组用Java语言编写的类和接口组成。JDBC允许开发者用Java编写访问数据库的应用程序，而不需要关心底层特定数据库的细节。 问：JDBC访问数据库的步骤//1. 加载JDBC驱动 Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); //Class.forName(&quot;com.mysql.jdbc.driver&quot;); //Mysql //2. 连接Oracle数据库 String url=&quot;jdbc:oracle:thin:@localhost:1521:DataBaseName&quot;; //String url=&quot;jdbc:mysql://localhost:1521/DataBaseName&quot;; // Mysql String username=&quot;admin&quot;; String password=&quot;root&quot;; Connection conn=DriverManager.openConnection(url, username, password); //3. 利用JDBC检索出表中的数据 PreparedStatment ps=conn.preparedStatment(&quot;select * from users;&quot;); ResultSet rs=ps.executeQuery(); while(rs.next){ rs.getString(1); //或rs.getString(&quot;name&quot;) } //4. 关闭数据库连接 conn.close(); 问：Class.forName()方法有什么作用？通过反射机制初始化参数指定的类，并且返回此类对应的Class对象。这个方法可以用来载入并注册跟数据库建立连接的驱动。 问：解释下驱动(Driver)在JDBC中的角色。JDBC驱动提供了特定厂商对JDBC API接口类的实现，驱动必须要提供java.sql包下面这些类的实现：Connection, Statement, PreparedStatement,CallableStatement, ResultSet和Driver。 加载驱动的几种方法： (1) 调用Class.forName()方法注册：Class.forName(“com.microsoft.sqlserver.jdbc.SQLServerDriver”); (2) 通过添加jdbc.drivers系统属性注册：System.setProperty(“jdbc.drivers”, “com.mysql.jdbc.Driver”); (3) 通过registerDriver方法注册：DriverManager.registerDriver(new com.mysql.jdbc.Driver()); 问：Statement、PreparedSatement和CallableStatement 问：PreparedStatement比Statement有什么优势？PreparedStatement接口继承自Statement (1) 使用Statement的方式： Statement stmt=conn.createStatement(); ResultSet rs=stmt.executeQuery(&quot;select * from book;&quot;); (2) 使用PreparedStatement的方式： PreparedStatement pstmt=conn.prepareStatement(&quot;select * from book;&quot;); ResultSet rs=pstmt.executeQuery(); (3) PreparedStatement比Statement的对比 PreparedStatement实例包含预编译的SQL语句，执行速度要快于Statement对象，因此，性能会更好。 PreparedStatements是预编译的，可以避免不良用户直接敲sql语句产生sql注入攻击，安全性更强。 对于不同的查询参数值，PreparedStatement可以重用。 例1，例2 问：什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？CallableStatement接口继承自PreparedStatement CallableStatement用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。如果有输出参数要注册说明是输出参数。非常鼓励使用存储过程，因为它提供了安全性和模块化。 准备一个CallableStatement的方法是：Connection.prepareCall()，实例代码如下： CallableStatement cs=conn.prepareCall(&quot;{call getCustomerName(?,?)}&quot;); cs.setString(1, &quot;1&quot;); cs.registerOutParameter(2, java.sql.Types.VARCHAR); cs.execute(); cs.getString(2); 问：数据库连接池是什么意思？像打开、关闭数据库连接这种和数据库的交互是很费时间的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本非常高。 可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供服务。在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求。 问：ResultSet例1 问：JDBC如何做事务处理？conn.setAutoCommit(false) conn.commit(); conn.rollback(); conn.setAutoCommit(true) 问：Jdo是什么？(没用过)JDO是Java对象持久化的新的规范，为java data object的简称，也是一个用于存取某种数据仓库中的对象的标准化API。JDO提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如JDBC API的使用）。这些繁琐的例行工作已经转移到JDO产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上。另外，JDO很灵活，因为它可以在任何数据底层上运行。JDBC只是面向关系数据库（RDBMS)JDO更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML以及对象数据库（ODBMS）等等，使得应用可移植性更强。(o/rMapping工具集合处理) 问：在ORACLE大数据量下的分页解决方法。(没用过)create or replace package myPack is type c_type is ref cursor; procedure getPage(v_sql varchar2,pageSize number,pageIndex number,c out c_type); end; create or replace package body myPack is procedure getPage(v_sql varchar2,pageSize number,pageIndex number,c out c_type) is pageTotal int:=0; pageFirstRow int:=0; pageLastRow int:=0; rowTotal int:=0; begin execute immediate &apos;select count(*) from (&apos;||v_sql||&apos;)&apos; into rowTotal; pageTotal:=ceil(rowTotal/pageSize); if(pageIndex&lt;1) then raise_application_error(-20001,&apos;页数不能小于1&apos;); end if; if(pageIndex&gt;pageTotal) then raise_application_error(-20001,&apos;页数太大，不能读取&apos;); end if; pageFirstRow:=(pageIndex-1)*pageIndex+1; pageLastRow:=pageFirstRow+pageSize; open c for &apos; select * from &apos;||v_sql||&apos; where rownum&lt;&apos;|| pageLastRow||&apos;minus select * from &apos;||v_sql ||&apos; where rownum&lt;&apos;||pageFirstRow; end; end;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"11-反射","slug":"11-反射","date":"2017-02-23T10:26:12.000Z","updated":"2017-07-22T13:10:31.174Z","comments":true,"path":"2017/02/23/11-反射/","link":"","permalink":"https://hepsilion.github.io/2017/02/23/11-反射/","excerpt":"反射","text":"反射 问：ClassloaderJava中类的加载是由ClassLoader和它的子类来实现的，它负责在运行时查找和装入类文件中的类。 ClassLoader是一个重要的Java运行时系统组件，它主要包括：引导类加载器(BootStrap ClassLoader)、扩展类加载器(Extension ClassLoader)、应用类加载器(Application ClassLoader)和用户自定义类加载器(java.lang.ClassLoader的子类)。 Bootstrap ClassLoader：它负责加载放在\\jre\\lib/目录中的，或者-Xbootclasspath参数所指定路径中的Java核心库(如rt.jar)，是用原生代码来实现的； Extension ClassLoader：它负责加载\\jre\\lib\\ext目录中，或系统变量java.ext.dirs所指定路径中的所有类库； Application ClassLoader：它负责加载Java应用的CLASSPATH所指定的类库。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它是应用最广泛的类加载器。开发者可以直接使用这个类加载器，如果应用程序中没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器； Custom ClassLoader：应用程序根据自身需要自定义的ClassLoader，是java.lang.ClassLoader的子类，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader。 例1，例2 例3：能不能自己写个类，也叫java.lang.String？ 可以，但在应用的时候，需要用自己的类加载器去加载，否则，系统的类加载器永远只是去加载rt.jar包中的那个java.lang.String。 由于在tomcat的web应用程序中，都是由webapp自己的类加载器先自己加载WEB-INF/classess目录中的类，然后才委托上级的类加载器加载。 如果我们在tomcat的web应用程序中写一个java.lang.String，这时候Servlet程序加载的就是我们自己写的java.lang.String， 但是这么干就会出很多潜在的问题，原来所有用了java.lang.String类的都将出现问题。 问：JVM的类加载机制 (还不怎么懂，暂时保留)推荐阅读 Java类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中准备、验证、解析3个部分统称为连接（Linking）。 图 1 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定） 例1 问：动态语言问：Class对象Java虚拟机有一个运行时数据区，这个数据区又被分为方法区，堆区和栈区等，其中方法区的主要作用是存储被JVM加载的类信息、常量、静态变量等。当JVM加载某个类的时候，需要类加载器定位相应的class文件，然后将其读入到JVM，紧接着JVM提取class中的类型信息，将这些信息存储到方法区中。 在Java的世界里，一切皆对象。从某种意义上说，在Java中有两种对象：实例对象和Class对象。实例对象就是我们平常定义的一个类的实例，例如定义一个类Person，然后使用new Person()定义Person类的一个实例对象；而Class对象是没办法用new关键字得到的，每当加载一个新的类的时候，JVM都会在Java堆中创建一个对应于该类的Class对象，该对象就代表该类，通过该Class对象我们就可以访问该类的基本信息。 获取Class对象一般有三种方式 (1) 通过类对象的getClass()方法获取 public class test { public static void main(String[] args) { Dog dog = new Dog(); Class clazz = dog.getClass(); } } (2) 通过类的.class属性获取 public class test { public static void main(String[] args) { Class clazz = Dog.class; } } 通过这种方式时，只会加载Dog类，并不会触发Dog类构造器的初始化。 (3) 使用Class.forName(String className)动态加载类，className需要是类的全限定名(最常用) public class ClassTest { public static void main(String[] args) { try { Class clazz = Class.forName(&quot;packageName.Dog&quot;); } catch (ClassNotFoundException e) {} } } 问：反射机制所谓的反射是Java语言在运行时拥有一项自观的能力，反射使您的程序代码能够得到装载到JVM中的类的内部信息，允许您执行程序时才得到所需类的内部信息，而不是在编写代码的时候就必须要知道所需类的内部信息。这样，在程序运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够访问它的任意一个属性和方法；这种动态获取信息以及动态调用对象的方法的功能称为Java语言的反射机制。 问：反射机制的基本使用请看文章 Java反射机制的实现要借助于4个类：Class，Constructor，Field，Method；其中Class代表的是类的Class对象，Constructor是代表类构造方法的对象，Field是代表类属性的对象，Method是代表类方法的对象，通过这四个对象我们可以粗略的看到一个类的各个组成部分。其中最核心的就是Class对象，它是实现反射的基础。 反射机制的作用 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法； 在运行时调用任意一个对象的方法； 生成动态代理 Spring、Struts、Hibernate等框架都是通过类的反射进行开发的。 例1 应用反射的基本步骤: (1) 获得你想操作的类的Class对象； (2) 调用Class对象中的方法获取你想要的信息集合，如调用getDeclaredFields()方法得到类的所有属性； (3) 处理第2步中得到的信息，然后进行你想做的实际操作。 Class对象的常用方法 (1) 获得类的构造方法 Constructor getConstructor(Class[] parameterTypes) Constructor[] getConstructors() Constructor getDeclaredConstructor(Class[] parameterTypes) Constructor[] getDeclaredConstructors() (2) 获得类的字段信息 Field getField(String name) Field[] getFields() Field getDeclaredField(String name) Field[] getDeclaredFields() (3) 获得类的方法信息 Method getMethod(String name, Class[] parameterTypes) Method[] getMethods() Method getDeclaredMethod(String name, Class[] parameterTypes) Method[] getDeclaredMethods() 注意： (1) getFields()与getDeclaredFields()区别 getFields() 只能返回类中所有的公有属性，包括从父类继承的公有属性； getDeclaredFields() 返回类中声明的所有属性，包括public/private/protect/default属性，不包括从父类继承的属性 (2) getMethods()与getDeclaredMethods()区别 getMethods() 只能返回类中所有的公有方法，包括从父类继承的公有方法； getDeclaredFields() 返回类中声明的所有方法，包括public/private/protect/default方法，不包括从父类继承的方法 (3) getConstructors()与getDeclaredConstructors()区别 getConstructors() 只能返回类中所有的公有构造方法 getDeclaredConstructors() 返回类中声明的所有构造方法，包括public/private/protect/default构造方法 例1 具体如何使用反射，请看两篇文章 反射文章1 反射文章2","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"10-网络编程","slug":"10-网络编程","date":"2017-02-22T10:25:25.000Z","updated":"2017-07-22T13:10:27.500Z","comments":true,"path":"2017/02/22/10-网络编程/","link":"","permalink":"https://hepsilion.github.io/2017/02/22/10-网络编程/","excerpt":"网络编程","text":"网络编程 问：Java Socket的几个方法getInetAddress() Returns the address to which the socket is connected. getLocalAddress() Gets the local address to which the socket is bound. getReuseAddress() Tests if SO_RESUSADDR is enabled. getRemotePort() Returns the remote port number to which this socket is connected.","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"09-多线程","slug":"09-多线程","date":"2017-02-21T10:23:52.000Z","updated":"2017-07-22T13:10:23.978Z","comments":true,"path":"2017/02/21/09-多线程/","link":"","permalink":"https://hepsilion.github.io/2017/02/21/09-多线程/","excerpt":"多线程","text":"多线程 推荐阅读：嘟嘟独立博客 推荐阅读：Java多线程锁机制 推荐阅读：40个Java多线程问题总结 问：进程和线程的区别是什么？进程是资源分配的基本单位，而线程是CPU调度的基本单位。 一个进程可以有多个线程，多个线程共享进程的资源，线程又叫做轻量级进程。 问：线程的几种状态 (1) 新建(new)：新创建了一个线程对象。 (2) 可运行(runnable)：线程对象创建后，其他线程(比如main线程)调用了该对象的start()方法，该状态的线程便位于可运行线程池中，等待被线程调度选中，获取cpu的使用权。 (3) 运行(running)：可运行状态(runnable)的线程获得了cpu时间片(timeslice)，执行程序代码。 (4) 阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种： 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。 其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。 当sleep()状态超时、 join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。 (5) 死亡(dead)：线程run()、 main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。 例1：此题有疑问，感觉下面这句话是不对的。 Java线程调度算法是平台独立的。 问：创建线程有几种不同的方式？你喜欢哪一种？为什么？(1) 继承Thread类，重写run()方法 public class ThreadTest1 { public static void main(String[] args){ MyThread thread=new MyThread(&quot;T1&quot;); thread.start(); System.out.println(&quot;The main thread is running.&quot;); } } class MyThread extends Thread{ private String name; public MyThread(String name) { this.name = name; } @Override public void run() { System.out.println(&quot;The thread &quot;+this.name+&quot; is running.&quot;); } } (2) 实现Runnable接口，重写run()方法 public class ThreadTest2 { public static void main(String[] args){ Thread thread=new Thread(new MyThread2(&quot;T2&quot;)); thread.start(); System.out.println(&quot;The main thread is running.&quot;); } } class MyThread2 implements Runnable{ private String name; public MyThread2(String name) { this.name = name; } @Override public void run() { System.out.println(&quot;The thread &quot;+this.name+&quot; is running.&quot;); } } (3) 使用ExecutorService、Callable、Future实现有返回结果的多线程 例1：例2：注意评论 实现Runnable接口这种方式更受欢迎。在应用设计中线程类已经继承了别的类的情况下，需要多继承，只能实现接口（而Java不支持多继承，却支持实现多个接口），这样就不再需要继承Thread类，避免单继承的局限。同时，线程池也是非常高效的，很容易实现和使用。 问：start()和run()无论是通过继承Thread类还是实现Runnable接口来创建线程，都必须调用start()方法启动线程。线程启动后，线程进入就绪状态，当CPU分配时间给它时，它才开始运行，并不是一调用start()方法线程就立即运行。 run()方法是线程关联的需要执行的代码。 问：Java四种线程池的使用请阅读这篇文章 应用程序可以使用Executor/Callable/Future框架来创建线程池。 (1) ExecutorService java.util.concurrent.Executors.newSingleThreadExecutor() Creates an Executor that uses a single worker thread operating off an unbounded queue. (Note however that if this single thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks.) Tasks are guaranteed to execute sequentially, and no more than one task will be active at any given time. Unlike the otherwise equivalent newFixedThreadPool(1) the returned executor is guaranteed not to be reconfigurable to use additional threads. Returns:the newly created single-threaded Executor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 示例代码： import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class NewSingleThreadExecutor { public static void main(String[] args) { ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 10; i++) { final int index = i; singleThreadExecutor.execute(new Runnable() { public void run() { try { System.out.println(index); Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } } }); } } } // 顺序执行各个任务，依次输出结果 (2) ExecutorService java.util.concurrent.Executors.newFixedThreadPool(int nThreads) 创建一个含有固定数量线程的线程池，可控制最大并发任务数，超出的任务会在队列中等待。 `Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue. At any point, at most nThreads threads will be active processing tasks. If additional tasks are submitted when all threads are active, they will wait in the queue until a thread is available. If any thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks. The threads in the pool will exist until it is explicitly shutdown. Parameters:nThreads the number of threads in the pool Returns:the newly created thread pool import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class NewFixedThreadPool { public static void main(String[] args) { ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3); for (int i = 0; i &lt; 10; i++) { final int index = i; fixedThreadPool.execute(new Runnable() { public void run() { try { System.out.println(index); Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } } }); } } } // 因为线程池大小为3，每个线程输出index后sleep 2秒，所以每隔两秒打印3个数字 (3) ExecutorService java.util.concurrent.Executors.newCachedThreadPool() Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available. These pools will typically improve the performance of programs that execute many short-lived asynchronous tasks. Calls to execute will reuse previously constructed threads if available. If no existing thread is available, a new thread will be created and added to the pool. Threads that have not been used for sixty seconds are terminated and removed from the cache. Thus, a pool that remains idle for long enough will not consume any resources. Note that pools with similar properties but different details (for example, timeout parameters) may be created using ThreadPoolExecutor constructors. Returns:the newly created thread pool import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class ThreadPoolExecutorTest { public static void main(String[] args) { ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) { final int index = i; try { Thread.sleep(index * 1000); } catch (InterruptedException e) { e.printStackTrace(); } cachedThreadPool.execute(new Runnable() { public void run() { System.out.println(index); } }); } } } (4) ScheduledExecutorService java.util.concurrent.Executors.newScheduledThreadPool(int corePoolSize) 创建一个含有固定数量线程的线程池，支持延时任务或周期性任务的执行。 Creates a thread pool that can schedule commands to run after a given delay, or to execute periodically. Parameters:corePoolSize the number of threads to keep in the pool, even if they are idleReturns:a newly created scheduled thread poolThrows:IllegalArgumentException - if corePoolSize &lt; 0 执行延时任务的示例代码： import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class NewScheduledThreadPool1 { public static void main(String[] args) { ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); scheduledThreadPool.schedule(new Runnable() { public void run() { System.out.println(&quot;delay 3 seconds&quot;); } }, 3, TimeUnit.SECONDS); } } // 表示延迟3秒执行任务 执行定期性任务的示例代码： import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class NewScheduledThreadPool2 { public static void main(String[] args) { ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); scheduledThreadPool.scheduleAtFixedRate(new Runnable() { public void run() { System.out.println(&quot;delay 1 seconds, and excute every 3 seconds&quot;); } }, 1, 3, TimeUnit.SECONDS); } } // 表示延迟1秒后，每3秒执行一次任务 问：同步和异步同步：上一段代码没完成，下一段必须等到上一段代码完成后才可以执行。例如：两个线程共享数据，要求一个线程读取另一个线程写的数据，此时必须要求两个线程同步执行。 异步：上一段代码没完成，下一段不必等到上一段代码完成就可以执行。例如：当程序在某一个对象上调用了一个需要很长时间才能执行完的方法，如果我们不希望让程序等待方法的返回，此时可以使用异步编程。 问：synchronized关键字推荐阅读：嘟嘟独立博客 在Java中，每一个对象都拥有一个锁标记，也称为监视器。一旦一个方法或一个代码块被synchronized修饰，那么这个部分就放入了监视器的监视区域，确保在同一时刻最多只有一个线程执行该部分代码，线程在获取锁之前不允许执行该部分的代码。 例1： java实现进程之间的同步执行采用的机制是：监视器 当两个并发线程访问同一个对象的synchronized方法或代码块时，两个线程间是互斥的，在同一时刻只能有一个线程得到执行，另一个线程被阻塞，因为在执行synchronized方法或代码块的线程会锁定当前对象，只有在当前线程执行完这些代码并释放该对象的锁时，下一个线程才能锁定并执行该对象的synchronized方法或代码块。 (1) 当一个线程访问对象的一个synchronized方法或代码块时，另一个线程仍然可以访问该对象的非synchronized方法或代码块。(两个线程使用的是同一个对象) (2) 当一个线程访问对象的一个synchronized方法或代码块时，其他线程对该对象的所有其它synchronized方法或代码块的访问将被阻塞(同上，两个线程使用的是同一个对象)。 例2： 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法? 答： (1) 其它线程可以进入该对象的非synchronized方法； (2) 如果这个synchronized方法内部调用了wait()，则其它线程可以进入此对象的其他synchronized方法； 如果这个synchronized方法内部没有调用wait()，则其它线程不可以进入该对象的其他synchronized方法。 如果其他方法是static方法(当然它不属于对象，而是属于类)，它用的同步锁是当前类的字节码，与非静态的方法不能同步，其它线程可以进入这些方法。 例3：看评论 public class HelloSogou{ public static synchronized void main(String[] a){ Thread t=new Thread(){ public void run(){ Sogou(); } }; t.run(); System.out.print(&quot;Hello&quot;); } static synchronized void Sogou(){ System.out.print(&quot;Sogou&quot;); } } 上面JAVA程序的输出是：SogouHello (3) 如果父类中的某个方法使用了synchronized关键字，而子类中覆盖了这个方法，默认情况下子类中的这个方法并不是同步的，必须显示的在子类的这个方法中加上synchronized关键字之后该方法才同步。当然，也可以在子类中调用父类中相应的方法，这样虽然子类中的方法并不是同步的，但子类调用了父类中的同步方法，也就相当子类方法也同步了。 例4：判断正误 构造方法不需要同步化。(正确) 一个子类不可以覆盖掉父类的同步方法。(错误) 问：同步方法和同步代码块的区别是什么？Java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时(增删改查)，将会导致数据的不准确，相互之间产生冲突。因此加入了同步锁，以避免在该线程没有结束前，其他线程操作该资源变量，从而保证了变量的唯一性，准确性。 Java中每个对象都有一把锁，线程可以通过synchronized关键字来获取对象上的锁。 (1) 同步方法(粗粒度锁)：由synchronized关键字修饰的方法 修饰一般方法:public synchronized void method(){…}，获取的是当前被调用对象的锁修饰静态方法:public static synchronized void method(){…}，获取当前类的字节码对象上的锁 举例：如果一个线程执行一个对象的非static的synchronized方法，另外一个线程执行这个对象所属类的static的synchronized方法，此时不会发生互斥现象，因为访问static的synchronized方法占用的是类的字节码对象锁，而访问非static的synchronized方法占用的是对象锁，所以不存在互斥现象。 public class SychronizedTest { public static void main(String[] args){ SynObj obj=new SynObj(); Thread01 thread01=new Thread01(&quot;Thread01&quot;, obj); Thread01 thread02=new Thread01(&quot;Thread02&quot;, obj); Thread02 thread03=new Thread02(&quot;Thread03&quot;); Thread02 thread04=new Thread02(&quot;Thread04&quot;); thread01.start(); thread02.start(); thread03.start(); thread04.start(); } } class Thread01 extends Thread{ private String threadName; private SynObj obj; public Thread01(String threadName, SynObj obj) { this.threadName=threadName; this.obj = obj; } @Override public void run() { this.obj.run1(this.threadName); } } class Thread02 extends Thread{ private String threadName; public Thread02(String threadName) { this.threadName=threadName; } @Override public void run() { SynObj.run2(this.threadName); } } class SynObj{ // 同步方法 public synchronized void run1(String threadName){ for(int i=0; i&lt;3; i++){ try { Thread.sleep(1000); System.out.println(threadName+&quot; run1 i=&quot;+i); } catch (InterruptedException e) { e.printStackTrace(); } } } // 同步static方法 public static synchronized void run2(String threadName){ for(int i=0; i&lt;3; i++){ try { Thread.sleep(1000); System.out.println(threadName+&quot; run2 i=&quot;+i); } catch (InterruptedException e) { e.printStackTrace(); } } } } Thread01和Thread02之间存在互斥关系，Thread03和Thread03之间存在互斥关系，但是Thread01/Thread02和Thread03/Thread04之间不存在互斥关系。 一种可能的输出： Thread01 run1 i=0 Thread03 run2 i=0 Thread03 run2 i=1 Thread01 run1 i=1 Thread03 run2 i=2 Thread01 run1 i=2 Thread02 run1 i=0 Thread04 run2 i=0 Thread04 run2 i=1 Thread02 run1 i=1 Thread02 run1 i=2 Thread04 run2 i=2 (2) 同步代码块(细粒度锁)：: 由synchronized关键字修饰的语句块，同步代码块可以选择以什么语句块来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法 synchronized(obj) {…}，同步代码块可以指定获取某个对象上的锁。 public class SychronizedTest { public static void main(String[] args){ SynObj synObj1=new SynObj(); SynObj synObj2=new SynObj(); Obj obj1=new Obj(); Obj obj2=new Obj(); Thread01 thread01=new Thread01(&quot;Thread01&quot;, synObj1); Thread01 thread02=new Thread01(&quot;Thread02&quot;, synObj1); Thread01 thread03=new Thread01(&quot;Thread03&quot;, synObj2); Thread02 thread04=new Thread02(&quot;Thread04&quot;, synObj1, obj1); Thread02 thread05=new Thread02(&quot;Thread05&quot;, synObj1, obj1); Thread02 thread06=new Thread02(&quot;Thread06&quot;, synObj2, obj2); thread01.start(); thread02.start(); thread03.start(); thread04.start(); thread05.start(); thread06.start(); } } class Thread01 extends Thread{ private String threadName; private SynObj obj; public Thread01(String threadName, SynObj obj) { this.threadName=threadName; this.obj = obj; } @Override public void run() { this.obj.run1(this.threadName); } } class Thread02 extends Thread{ private String threadName; private SynObj synObj; private Obj obj; public Thread02(String threadName, SynObj synObj, Obj obj) { this.threadName=threadName; this.synObj=synObj; this.obj=obj; } @Override public void run() { this.synObj.run2(this.threadName, this.obj); } } class SynObj{ public void run1(String threadName){ // 同步代码块，锁住的是对象本身 synchronized(this){ for(int i=0; i&lt;3; i++){ try { Thread.sleep(1000); System.out.println(threadName+&quot; run1 i=&quot;+i); } catch (InterruptedException e) { e.printStackTrace(); } } } } public void run2(String threadName, Obj obj){ // 同步代码块，锁住的是对象obj synchronized(obj){ for(int i=0; i&lt;3; i++){ try { Thread.sleep(1000); System.out.println(threadName+&quot; run1 i=&quot;+i); } catch (InterruptedException e) { e.printStackTrace(); } } } } } class Obj{} Thread01和Thread02之间存在互斥关系，但是Thread01/Thread02和Thread03之间不存在互斥关系。 注释掉thread04，thread05和thread06的启动代码 //thread04.start(); //thread05.start(); //thread06.start(); 一种可能的输出： Thread01 run1 i=0 Thread03 run1 i=0 Thread01 run1 i=1 Thread03 run1 i=1 Thread01 run1 i=2 Thread03 run1 i=2 Thread02 run1 i=0 Thread02 run1 i=1 Thread02 run1 i=2 Thread04和Thread05之间存在互斥关系，但是Thread04/Thread05和Thread06之间不存在互斥关系。 注释掉thread01，thread02和thread03的启动代码 //thread01.start(); //thread02.start(); //thread03.start(); 一种可能的输出： Thread04 run1 i=0 Thread06 run1 i=0 Thread06 run1 i=1 Thread04 run1 i=1 Thread04 run1 i=2 Thread06 run1 i=2 Thread05 run1 i=0 Thread05 run1 i=1 Thread05 run1 i=2 将SynObj的run2方法的被锁对象换成obj.getClass()之后，此时Thread04、Thread05和Thread06之间存在互斥关系。因此Synchronized后面括号括起来的部分为synchronized(className.class)，作用的对象是这个类的所有对象 public void run2(String threadName, Obj obj){ // 同步代码块，锁住的是对象obj synchronized(obj.getClass()){ for(int i=0; i&lt;3; i++){ try { Thread.sleep(1000); System.out.println(threadName+&quot; run1 i=&quot;+i); } catch (InterruptedException e) { e.printStackTrace(); } } } } 一种可能的输出为： Thread04 run1 i=0 Thread04 run1 i=1 Thread04 run1 i=2 Thread06 run1 i=0 Thread06 run1 i=1 Thread06 run1 i=2 Thread05 run1 i=0 Thread05 run1 i=1 Thread05 run1 i=2 问：Java支持并发编程的同步机制例1： JDK提供的用于并发编程的同步器有：Semaphore、CyclicBarrier、CountDownLatch 例2： CyclicBarrier让一组线程等待其他线程；CountDownLatch让一组线程等待某个事件发生 Callable类的call()方法可以返回值和抛出异常 线程调用start()方法后进行就绪状态，等待获取CPU的使用权 例3： CopyOnWriteArrayList适合于读操作远远大于写操作的场景里，比如缓存。 ReadWriteLock 当写操作时，其他线程无法读取或写入数据，而当读操作时，其它线程无法写入数据，但却可以读取数据。适用于读取远远大于写入的操作。 ConcurrentHashMap是一个线程安全的HashTable，它的主要功能是提供了一组和HashTable功能相同但是线程安全的方法。 ConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，不用对整个ConcurrentHashMap加锁。 问：synchronized和java.util.concurrent.locks.Lock的异同相同点：Lock能完成synchronized所实现的所有功能 不同点： Lock有比synchronized更精确的线程语义和更好的性能。 synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。 Lock还有更强大的功能，例如，它的tryLock()方法可以以非阻塞方式去拿锁。 例1：请写出程序，实现如下功能：子线程循环10次，接着主线程循环100，接着又回到子线程循环10次，接着再回到主线程又循环100，如此循环50次。 方法一：使用synchronized public class Test { public static boolean isMain=false; public static void main(String[] args){ Object object=new Object(); Thread thread=new Thread(new Runnable(){ @Override public void run() { for(int i=0; i&lt;50; i++){ synchronized(object){ if(isMain){ try { object.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } for(int k=0; k&lt;10; k++){ System.out.println(Thread.currentThread().getName()+&quot;, i=&quot;+i+&quot;, k=&quot;+k); } isMain=true; object.notify(); } } } }); thread.start(); for(int i=0; i&lt;50; i++){ synchronized (object){ if(!isMain){ try { object.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } for(int j=0; j&lt;100; j++){ System.out.println(Thread.currentThread().getName()+&quot;, i=&quot;+i+&quot;, j=&quot;+j); } isMain=false; object.notify(); } } } } 方法二：使用并发库 import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class Test { private static Lock lock = new ReentrantLock(); private static Condition condition = lock.newCondition(); public static boolean isMain = false; public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i &lt; 50; i++) { lock.lock(); try { if (isMain) { condition.await(); } for (int k = 0; k &lt; 10; k++) { System.out.println(Thread.currentThread().getName() + &quot;, i=&quot; + i + &quot;, k=&quot; + k); } isMain = true; condition.signal(); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } } }); thread.start(); for (int i = 0; i &lt; 50; i++) { lock.lock(); try { if (!isMain) { condition.await(); } for (int j = 0; j &lt; 100; j++) { System.out.println(Thread.currentThread().getName() + &quot;, i=&quot; + i + &quot;, j=&quot; + j); } isMain = false; condition.signal(); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } } } 问：wait、notify、notifyAll wait() (1) 该方法用来让当前线程进入休眠状态，直到被唤醒或被中断为止。 (2) 在调用wait()之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait()方法。如果调用wait()时，线程没有持有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch结构。 (3) 进入wait()方法后，当前线程释放锁。在从 wait()返回前，线程与其他线程竞争重新获得锁。 notify() (1) 该方法也要在同步方法或同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁，如果调用notify()时线程没有持有适当的锁，也会抛出IllegalMonitorStateException。 (2) 该方法用来唤醒那些可能等待该对象的对象锁的其他线程。如果有多个线程等待，该方法并不能确切的唤醒某一个等待的线程，线程调度器任意挑选出其中一个wait()状态的线程来发出通知，并使它等待获取该对象的对象锁（notify后，发出通知的当前线程不会马上释放该对象锁，wait所在的线程并不能马上获取该对象锁，要等到程序退出synchronized代码块后，当前线程才会释放锁，wait所在的线程也才可以获取该对象锁），但不惊动其他同样在等待被该对象notify的线程们。 (3) 当第一个获得了该对象锁的wait线程运行完毕以后，它会释放掉该对象锁，此时如果该对象没有再次使用notify 语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，会继续阻塞在wait状态，直到这个对象发出一个notify或notifyAll。这里需要注意：它们等待的是被notify或notifyAll，而不是锁。这与下面的 notifyAll()方法执行后的情况不同。 notifyAll() 该方法与 notify ()方法的工作方式相同，重要的一点差异是：notifyAll 使所有原来在该对象上 wait 的线程统统退出 wait 的状态（即全部被唤醒，不再等待notify或notifyAll，但由于此时还没有获取到该对象锁，因此还不能继续往下执行），开始等待获取该对象上的锁，一旦该对象锁被释放（notifyAll线程退出调用了notifyAll的synchronized代码块的时候），他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出synchronized代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。 总结：如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。 案例：当前线程调用对象的notify后，当前线程不会马上释放该对象锁，wait所在的线程并不能马上获取该对象锁，要等到程序退出synchronized代码块后，当前线程才会释放锁，wait所在的线程也才可以获取该对象锁。 public static void main(String[]args)throws Exception { final Object obj = new Object(); Thread t1 = new Thread() { public void run() { synchronized (obj) { try { obj.wait(); System.out.println(&quot;Thread 1 wake up.&quot;); } catch (InterruptedException e) { } } } }; t1.start(); Thread.sleep(1000);//We assume thread 1 must start up within 1 sec. Thread t2 = new Thread() { public void run() { synchronized (obj) { obj.notifyAll(); System.out.println(&quot;Thread 2 sent notify.&quot;); } } }; t2.start(); } output: Thread 2 sent notify. Thread 1 wake up 例1：找出代码中错误的地方。 void waitForSignal(){ Object obj = new Object(); synchronized(Thread.currentThread()){ obj.wait(); obj.notify(); } } 第一个错误是wait()方法要以try/catch包覆，或是掷出InterruptedException才行 第二个错误是wait或者notify方法被调用的对象必须与synchronized中的对象一致，否则会有IllegalMonitorStateException 例2： 可用来实现线程间通知和唤醒的方式： Object.wait/notify/notifyAll Condition.await/signal/signalAll 问：sleep()方法和wait()方法的区别sleep()：该方法让线程休眠指定的时间，当这个时间达到之后，线程会再次醒来。它是Thread类一个静态方法，调用此方法需要捕捉InterruptedException异常。 wait()：该方法用来让当前线程进入休眠状态，直到被唤醒或被中断为止。 (1) sleep()是Thread类的方法，wait()是Object类的方法 (2) wait()，notify()和notifyAll()只能在同步方法或同步代码块中使用，而sleep()可以在任何地方使用 (3) 调用sleep()方法后，线程进入睡眠状态，但不会释放对象锁，休眠时间结束后会自动进入就绪状态；调用wait()方法后，线程会释放对象锁，进入此对象的等待池(wait pool)中，直到其他线程调用对象的notify()方法(或notifyAll()方法)时才能唤醒等待池中的线程进入等锁池(lock pool)，准备获得对象锁，如果线程重新获得对象的锁就可以进入就绪状态。 例1：sleep()和wait()的对比 问：sleep()方法和yield()方法的区别调用线程yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制交出CPU的具体时间，另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。 注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。 sleep()方法和yield()方法的区别: (1) sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会； (2) 线程执行sleep()方法后转入阻塞(blocked)状态，而执行yield()方法后转入就绪(ready)状态； (3) sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常； (4) sleep()方法比yield()方法(跟操作系统CPU调度相关)具有更好的可移植性。 问：join()方法方法join()的作用是让调用join()方法的线程等待被调用线程结束，再继续往下执行。 问：volatile关键字推荐阅读：嘟嘟独立博客 volatile是java中的一个关键字，可以用来修饰被不同线程访问和修改的变量。 出于运行速率的考虑，Java编译器会把经常经常访问的变量放到缓存（严格讲应该是工作内存）中，读取变量则从缓存中读。但是在多线程编程中,内存中的值和缓存中的值可能会出现不一致。volatile用于限定变量只能从内存中读取，保证对所有线程而言，值都是一致的。但是volatile不能保证原子性，也就不能保证线程安全。 一旦一个共享变量(类的成员变量、类的静态成员变量)被volatile修饰之后，那么就具备了两层语义：1）可见性：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。2）禁止进行指令重排序：volatile只提供了保证访问该变量时，每次都是从内存中读取最新值，并不会使用寄存器缓存该值，每次都会从内存中读取。 例1，例2 问：ThreadLocalThreadLocal类为每一个线程都维护了自己独有的变量拷贝。在Thread中有一个成员变量ThreadLocals，该变量的类型是ThreadLocalMap,也就是一个Map，它的键是threadLocal，值为就是变量的副本。因此ThreadLocal不是使用在多线程之间共享数据，而是让变量在每个线程中都有独立拷贝，使得不会出现一个线程读取变量时，该变量而被另一个线程修改的现象。 由于每个线程在访问该变量时，读取和修改的，都是自己独有的那一份变量拷贝，不会被其他线程访问，变量被彻底封闭在每个访问的线程中 例1，例2：这题A答案似乎是错的 问：什么是死锁(deadlock)？两个线程或两个以上线程因争夺资源而都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是若无外力作用，这些线程都陷入了无限的等待中。 问：如何确保N个线程可以访问N个资源同时又不导致死锁？使用多线程的时候，一种非常简单的避免死锁的方式就是：指定访问资源的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"08-流","slug":"08-流","date":"2017-02-20T10:22:25.000Z","updated":"2017-07-22T13:10:19.653Z","comments":true,"path":"2017/02/20/08-流/","link":"","permalink":"https://hepsilion.github.io/2017/02/20/08-流/","excerpt":"流","text":"流 问：Java中有几种类型的流？在Java使用流的机制进行数据的传送，从文件到内存是输入流，从内存到文件是输出流。 Java中有字节流和字符流。字节流继承于InputStream/OutputStream，字符流继承于Reader/Writer。 在java.io包中还有许多其他的流，低层流与高层流，高层流主要是为了提高性能和使用方便。 图 1 问：字符流与字节流要把一片二进制数据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式即为IO流，对应的抽象类为OutputStream和InputStream，它们都是针对字节进行操作的。 在应用中，经常要将完全是字符的一段文本输出去或读进来，直接用字节流可以吗？计算机中的一切最终都是以二进制的字节形式存在。对于“中国”这些字符，首先需要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，人家专门提供了字符流的包装类。 底层设备永远只接受字节数据，有时候要将字符串写到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，它直接接受字符串，内部将字符转换成字节，再写入底层设备，这为我们向IO设备写入或读取字符串提供了一点点方便。 在将字符转换为字节时，需要注意编码问题：因为字符串转换成字节数组，其实是将每个字符转换成某种编码的字节形式，读取也是反之的道理。 例1：字节流和字符流的使用 String str=&quot;Hello World!&quot;; 字节流： FileOutputStream fos=new FileOutputStream(&quot;content.txt&quot;); fos.write(str.getBytes(&quot;UTF-8&quot;)); fos.close(); FileInputStream fis = new FileInputStream(&quot;content.txt&quot;); byte[] buf = new byte[1024]; int len =fis.read(buf); String myStr = new String(buf, 0, len, &quot;UTF-8&quot;); System.out.println(myStr); 字符流： FileWriter fw =new FileWriter(&quot;content.txt&quot;); fw.write(str); fw.close(); FileReader fr =new FileReader(&quot;content.txt&quot;); char[] buf = new char[1024]; int len =fr.read(buf); String myStr = new String(buf, 0, len); System.out.println(myStr); 问：节点流与处理流流可以分为节点流和处理流： 节点流可以从一个特定的数据源(如文件、内存等)读写数据； 图 1 而处理流则是连接在已存在的节点流或处理流之上，通过对数据的处理为程序提供更强大的读写功能。 图 2 常用的节点流 图 1 常用的处理流 图 2 节点流向处理流转换的实例： FileInputStream(System.in) -&gt; InputSteamReader -&gt; BufferReader OutputSteam(System.out) -&gt; PrintStream FileReader -&gt; BufferedReader FileWriter -&gt; PrintWriter或bufferWriter 例1：处理流的使用 String str=&quot;Hello World!&quot;; PrintWriter pw =new PrintWriter(&quot;content.txt&quot;, &quot;utf-8&quot;); pw.write(str); pw.close(); BufferedReader br =new BufferedReader(new InputStreamReader(new FileInputStream(&quot;content.txt&quot;), &quot;UTF-8&quot;)); String myStr =br.readLine(); br.close(); System.out.println(myStr); 问：序列化序列化是为了解决在对对象流进行读写操作时所引发的问题。处理对象流的机制：所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。 有时候我们需要将一个java对象转换成字节流或者从一个字节流中恢复一个java对象，例如，要将java对象存储到硬盘上或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个java对象变成某种格式的字节流再传输。 但是，JRE本身就提供了这种支持，我们可以让要被传输的对象实现java.io.Serializable接口，实现该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，javac编译时会进行特殊处理，这样我们就可以使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法将参数为obj的对象写出(即保存其状态)，要写入的话则使用输入流(ObjectInputStream)，这就是所谓的序列化。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"07-集合类","slug":"07-集合类","date":"2017-02-19T10:20:30.000Z","updated":"2017-07-22T13:10:16.544Z","comments":true,"path":"2017/02/19/07-集合类/","link":"","permalink":"https://hepsilion.github.io/2017/02/19/07-集合类/","excerpt":"集合类","text":"集合类 问：Java的集合类框架Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和操作(增、删、改、查)。有的集合类允许重复的元素，有些不允许。 Java集合类有两大接口：Collection和Map，一个是元素集合，另一个是键值对集合且键不能重复。 图 1 图 2 List和Set接口继承了Collection接口。List是有序元素集合(即每个元素都可以按index访问)，元素可以重复；Set是无序元素集合(即每个元素都不可以按index访问)，元素不可以重复。ArrayList、LinkedList和Vector实现了List接口，HashSet和TreeSet实现了Set接口，这几个都比较常用； Map是key/value对集合，key不可以重复。HashMap和HashTable实现了Map接口。HashMap不是线程安全的，HashTable是线程安全的，但是HashMap性能更好； ArrayList和Vector都以数组的方式存储，增、删慢，查、改快；ArrayList:线程不安全，速度快；Vector:线程安全，速度慢；LinkedList: 以单链表的方式存储，操作慢 注意： Arrays.asList()将一个数组转化为一个List对象，这个方法会返回一个ArrayList类型的对象，这个ArrayList类并非java.util.ArrayList类，而是Arrays类的静态内部类！对这个对象进行添加删除更新操作，会报UnsupportedOperationException异常。 ConcurrentHashMap使用segment来分段和管理锁，而不是用synchronized 问：List、Set和Map三个接口存取元素时，各有什么特点？List和Set继承自Collection接口，是单列元素集合；Map是双列元素集合，即key/value对集合。 (1) List是有序元素集合(即每个元素都可以按index访问)，元素可以重复； 同一个对象可以被反复存储进List中，每调用一次add方法，这个对象就被插入进集合一次，size()也增大1。其实，并不是把这个对象本身存储进了集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被add多次时，相当于在集合中有多个索引指向了这个对象。 可以使用add(Object obj)方法将元素放到集合的末尾； 可以使用add(int index, Object obj)方法将元素放到集合中的指定位置； 可以使用Iterator接口获得集合中的所有元素，再逐一遍历各个元素； 可以使用get(index i)方法获得集合中指定位置的元素。 (2) Set是无序元素集合(即每个元素都不可以按index访问)，元素不可以重复，元素重复与否是使用equals()方法进行判断的。 可以使用add(Object obj)方法将元素存储进集合。该方法有一个boolean类型的返回值，当集合中没有某个元素时，add方法可以成功加入该元素并且返回true；当集合已经含有与某个元素equals()相等的元素时，此时add方法无法加入该元素并且返回false； 由于Set中元素是无序的，无法按index访问，所以只能用Iterator接口取得所有的元素，再逐一遍历各个元素 (3) Map是key/value对集合，key不可以重复，这个重复的规则是根据equals()方法比较相等的 可以使用put(Object key, Object value)方法存储key/value对，key不可以重复 可以使用get(Object key)方法获得与key相对应的value； 可以使用keySet()方法获得所有key的集合； 可以使用values()方法获得所有value的集合； 可以使用entrySet()方法获得所有key和value组合成的Map.Entry对象的集合。 问：Java语言中的几种数组复制方法效率比较System.arraycopy &gt; clone &gt; Arrays.copyOf &gt; for循环 问：Java集合框架中线程安全的类Vector、Stack(它继承了Vector)、Hashtable、Properties、Enumeration、(非集合类的StringBuffer) 问：ArrayList和LinkedList有什么区别？ArrayList和LinkedList都实现了List接口，两者都是线程不安全的，他们有以下的不同点： (1) ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以链表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。 (2) 相对于ArrayList，LinkedList的插入、添加、删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。 (3) LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。 (4) LinkedList提供了一些方法，使得LinkedList可以被当作堆栈和队列来使用。 问：数组(Array)和列表(ArrayList)的区别？什么时候应该使用Array而不是ArrayList？(1) Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。(但是需要注意的是：Array数组中存放的一定是同种类型的元素；ArrayList就不一定了，因为ArrayList可以存储Object。) (2) Array大小是固定的，ArrayList的大小是动态变化的。 (3) ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。 对于基本类型数据，ArrayList使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。 问：Vector和ArrayList的异同相同点：都实现了List接口，使用数组方式存储数据，因此都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，可以按位置索引取出某个元素，并且其中的数据是允许重复的 不同点： (1) Vector是同步的，而ArrayList不是同步的。即Vector是线程安全的，而ArrayList是线程不安全的。 因此如果只有一个线程会访问集合，最好使用ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问集合，最好使用Vector，因为我们不需要自己去编写和线程安全相关的代码。 (2) 在元素增加，容量需要增长时，Vector容量默认增长原来的一倍，而ArrayList增长原来的50%，这样，ArrayList就有利于节约内存空间。 (3) 如果涉及到堆栈、队列等操作，应该考虑用Vector；如果需要快速随机访问元素，应该使用ArrayList。 例1：如何去掉一个Vector集合中重复的元素？ private Vector&lt;Integer&gt; fun(Vector&lt;Integer&gt; oVector){ Vector&lt;Integer&gt; vector = new Vector&lt;Integer&gt;(); for (int i = 0; i &lt; oVector.size(); i++) { Integer obj = oVector.get(i); if (!vector.contains(obj)) { vector.add(obj); } } return vector; } 或者 private Vector&lt;Integer&gt; fun(Vector&lt;Integer&gt; oVector){ Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(oVector); Vector&lt;Integer&gt; vector=new Vector&lt;Integer&gt;(set); return vector; } 问：ArrayList容量ArrayList的构造函数总共有三个 ArrayList()构造一个初始容量为 10 的空列表，动态增长时，容量增长到当前容量的1.5倍 ArrayList(Collection&lt;? extends E&gt; c)构造一个包含指定collection的元素的列表，这些元素是按照该collection的迭代器返回它们的顺序排列的。 ArrayList(int initialCapacity)构造一个具有指定初始容量的空列表。 问：什么是Java优先级队列(Priority Queue)？PriorityQueue是一个基于堆排序的无界队列，此队列按照在构造时所指定的顺序对元素排序，既可以根据元素的自然顺序来指定排序，也可以给它提供一个负责给元素排序的比较器来指定，这取决于使用哪种构造方法。 PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。 最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。 问：什么是迭代器(Iterator)？Iterator接口提供了很多对集合中元素进行迭代的方法，每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的remove(Object Obj)删除，可以通过迭代器的remove()方法删除。 问：Enumeration接口和Iterator接口的区别有哪些？(1) Enumeration速度是Iterator的2倍，同时占用更少的内存。 (2) 但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。 (3) 同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。 例1：list是一个ArrayList的对象，为了能够在Iterator遍历的过程中正确并安全的删除一个list中保存的对象，//todo delete处可以可以填写什么代码？ Iterator it = list.iterator(); int index = 0; while (it.hasNext()){ Object obj = it.next(); if (needDelete(obj)){//needDelete返回boolean，决定是否要删除 //todo delete } index ++; } 正确答案：it.remove(); 问：Iterator和ListIterator的区别是什么？(1) Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 (2) Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 (3) ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。 问：快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个ConcurrentModification异常。 安全失败：你在迭代的时候会对底层集合做一个拷贝，所以有另一个线程在修改上层集合的时候，访问是不会受影响的，不会抛出ConcurrentModification异常。 迭代器的安全失败是基于对底层集合做拷贝，因此，它不受原集合上修改的影响。 java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。 快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。 问：HashMap和Hashtable有什么区别？HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点： (1) HashMap允许键和值是null（但是最多只能有一个键为null，可以有一个或多个键所对应的值都为null。当get()方法返回null值时，既可以表示HashMap中没有该键，又可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断 HashMap中是否存在某个键，而应该用containsKey()方法来判断）；而Hashtable不允许键或者值是null。 (2) Hashtable是同步的(使用synchronized)，而HashMap不是，即HashMap是非线程安全的，HashTable是线程安全的。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。因为线程安全的问题，HashMap效率比HashTable的要高。 (3) HashMap提供了可供应用于迭代键的Iterator，因此，HashMap是快速失败的。Hashtable也使用了Iterator，另一方面，由于历史原因，Hashtable还提供了对键的Enumeration，是安全失败的。 (4) 哈希值的使用不同，HashTable直接使用对象的hashCode，而HashMap重新计算hash值。 (5) Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式不同。HashTable中hash数组默认大小是11，增加的方式是old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数 例1，例2，看两道题的评论 一般现在不建议用HashTable： (1) HashTable是遗留类，内部实现很多没优化和冗余。 (2) 即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。 问：Java中的HashMap的工作原理是什么？Java中的HashMap是以键值对(key-value)的形式存储元素的。 HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。 HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。 HashMap中解决哈希冲突的方法是链地址法。HashMap的底层结构是一个数组，数组中的每一项是一条链表。 例1 问：HashSetHashSet子类依靠hashCode()和equal()方法来区分重复元素 HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值前，会去判断当前Map中是否含有该key对象，内部是先通过key的hashCode，确定有相同的hashCode之后，再通过equals方法判断是否相同。 例1 问：HashSet和TreeSet有什么区别？HashSet的底层是由哈希表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。 TreeSet的底层是由红黑树来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。 问：Set中的元素不可重复Set中的元素是不允许重复的。因此Set再插入或删除元素时，需要对两个元素进行比较。比较时，Set会先调用hashCode方法，判断两个元素是否有相同的hashCode，如果不相同，证明不相等；如果hashcode相同，再调用equals方法，如果equals方法判断返回true，则两个元素是相同的，否则两个元素不相同。 判断Set中是否包含某一个元素是通过contains来判断的。 问：hashCode()和equals()方法的重要性体现在什么地方？Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。 例1：两个对象值相同(x.equals(y)==true)，但却可以有不同的hashcode，这句话对不对? 对。 如果对象保存在HashSet或HashMap中，它们equals()相等，那么它们的hashcode值就必须相等。 如果对象不是保存在HashSet或HashMap，则equals()与hashcode就没有什么关系了，这时候hashcode不相等也是可以的。 例如ArrayList中存储的对象就不用实现hashcode()方法，当然，我们没有理由不实现，通常都会去实现的。 问：Comparable和Comparator接口是干什么的？列出它们的区别。Java提供了只包含一个compareTo()方法的Comparable接口。 这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。 Java提供了包含compare()和equals()两个方法的Comparator接口。 compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。 equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。 (1) Comparable和Comparator都是用来实现集合中元素的比较、排序的，只是Comparable是在集合内部定义方法实现排序，Comparator是在集合外部定义方法实现排序，所以，如果想要实现对集合中元素的排序，就需要在集合外定义实现Comparator接口的方法或在集合内实现Comparable接口的方法compareTo()。Comparator位于包java.util下，而Comparable位于包java.lang下。 (2) Comparable是一个对象本身就已经支持自比较所需要实现的接口（如 String、Integer自己就可以完成比较大小操作，已经实现了Comparable接口），自定义的类要在加入list容器中后能够排序，可以实现Comparable接口，在用Collections类的sort方法排序时，如果不指定Comparator，那么就以自然顺序排序，这里的自然顺序就是实现Comparable接口设定的排序方式。 (3) Comparator是一个专用的比较器，当这个对象不支持自比较或者自比较函数不能满足你的要求时，你可以写一个比较器来完成两个对象之间大小的比较。 问：Collection和CollectionsCollection是java.util下的接口，它是各种集合类的父接口，继承于它的接口有set及list Collections是java.util下的类，是针对集合类的一个帮助类，它提供了一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。 问：Java集合类框架的最佳实践有哪些？根据应用的需要正确选择要使用的集合的类型对性能非常重要 (1) 假如元素的大小是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。 (2) 有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。 (3) 为了类型安全、可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。 (4) 使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。 (5) 编程的时候接口优先于实现。 (6) 底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。 问：装箱与拆箱自动装箱是Java编译器在基本数据类型和对应的包装类型之间做的一个转化，例如把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。 问：装箱与拆箱中的==和equals()下面的规则基本意思是对的，但语言尚不严格正确 (1) 基本数据类型变量和基本数据类型包装类对象进行”==”运算符的比较，基本数据类型封装类对象将会自动拆箱变为基本数据类型后再进行比较。例如Integer(0)和0比较时，Integer(0)会自动拆箱为int类型再进行比较。 (2) 两个Integer类型变量进行”==”比较，如果这两个对象的值在-128至127且值相等，那么返回true，否则返回false，这跟Integer.valueOf()方法的缓冲对象有关。请看这篇文章 (3) (4) 两个基本数据类型封装类变量进行equals()比较，equals()会首先比较对象的类型，如果类型相同，继续比较值，如果值也相同，返回true，否则返回false。 (5) 基本数据类型封装类对象调用equals()，但是参数是基本数据类型变量，这时候，基本数据类型变量会先进行自动装箱转换为其封装类型对象，再进行4中的比较。 例1： int a=257; Integer b1=257; //Integer b1=257会先调用Integer.valueOf()方法将257转化为new Integer(257)对象 Integer b2=57; //Integer b2=57会先调用Integer.valueOf()方法返回缓存中的57 Integer b3=257; Integer b4=57; Integer c=new Integer(257); Integer d=new Integer(257); Integer e1=Integer.valueOf(257); //Integer.valueOf()方法将257转化为new Integer(257)对象 Integer e2=Integer.valueOf(57); //Integer.valueOf()方法返回缓存中的57 // int和Integer(无论new否)比，都为true System.out.println(a==b1); // true，规则(1) System.out.println(a==c); // true，规则(1) // 两个都是非new出来的Integer，如果数在-128到127之间，则是true，否则为false System.out.println(b1==b3); // false，规则(2) System.out.println(b2==b4); // true，规则(2) System.out.println(b1==e1); // false，规则(3) System.out.println(b2==e2); // true，规则(3) // Integer与new Integer比较，结果为false；两个都是new出来的,都为false System.out.println(b1==c); // false，规则(3) System.out.println(c==d); // false，规则(3) //System.out.println(a.equals(b1)); 编译出错，基本型不能调用equals() System.out.println(b1.equals(b3)); // true，规则(4) System.out.println(c.equals(d)); // true，规则(4) System.out.println(b1.equals(257.0)); // false，规则(5)，257.0先封装成Double对象再进行比较 例2： public static void main(String[] args){ Boolean flag=false;//先调用Boolean.valueOf(boolean b)返回false对应的Boolean对象Boolean.FALSE，然后赋值给flag，flag值为Boolean.FALSE /* 先赋值，遇到if条件表达式自动拆箱 * 1. 先调用Boolean.valueOf(boolean b)返回true对应的Boolean对象Boolean.TRUE，然后赋值给flag，flag值为Boolean.TRUE * 2. 调用booleanValue()返回flag值对应的基础数据类型值true * 3. 结果输出true */ if (flag=true){ System.out.println(&quot;true&quot;); }else{ System.out.println(&quot;false&quot;); } } 例3，例4，例5，例6：重要的题目 问：为什么集合类没有实现Cloneable和Serializable接口？克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的，因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。 问：泛型例1：重要的题目 class A {} class B extends A {} class C extends A {} class D extends B {} Which four statements are true? (A) The type List&lt;A&gt; is assignable to List. (B) The type List&lt;B&gt; is assignable to List&lt;A&gt;. (C) The type List&lt;Object&gt; is assignable to List&lt;?&gt;. (D) The type List&lt;D&gt; is assignable to List&lt;?extends B&gt;. (E) The type List&lt;?extends A&gt; is assignable to List&lt;A&gt;. (F) The type List&lt;Object&gt; is assignable to any List reference. (G) The type List&lt;?extends B&gt; is assignable to List&lt;?extends A&gt;. 正确答案：ACDG","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"06-常用类","slug":"06-常用类","date":"2017-02-18T10:19:20.000Z","updated":"2017-07-22T13:10:12.560Z","comments":true,"path":"2017/02/18/06-常用类/","link":"","permalink":"https://hepsilion.github.io/2017/02/18/06-常用类/","excerpt":"常用类","text":"常用类 问：String、StringBuffer和StringBuilder(1) String：不可变的字符序列 String类不是基本数据类型，是引用数据类型 String是被final修饰的类，因此一旦一个String对象被创建并初始化后，包含在这个对象里的字符序列是不可改变的，直到这个对象被销毁，即本身的内容不可改变、长度不可改变； String类不可以被继承； String变量作为参数时相当于基本数据类型的值传递 对String对象的任何改变都不影响到原对象，每次操作都会生成新的String对象，然后将引用指向新的String对象，因此不推荐频繁改变String内容，会增加内存压力。为了提高效率节省空间，我们应该用StringBuffer类 当多个字符串联合时会先转为StringBuffer，再联合，最后生成String对象，速度较慢。 例1：Java中的字符串都是常量，字符串一旦被初始化，就不可以被改变，因为是常量，存放在方法区中的常量池中，可以实现共享。 // 双引号引起的数据都是字符串对象，存放在常量池中。s1指向的内存中只有一个对象，在常量池中。 String s1=&quot;abc&quot;; // 在内存中生成两个对象，&quot;abc&quot;存放在常量池中，new String()存放在堆内存中。s2指向的内存中有两个对象，分别在常量池中和堆内存中。 String s2=new String(&quot;abc&quot;); /*&quot;abc&quot;是字符串常量，被存在堆区的常量池中，当定义String s3=&quot;abc&quot;时，不会马上创建字符串&quot;abc&quot;对象，而是会先查找常量池中是否存在相同常量， 如果有，则s3指向同一内存空间，否则创建新的字符串对象。*/ String s3=&quot;abc&quot;; System.out.println(s1==s2); //false System.out.println(s1==s3); //true //String类重写了Object类的equals()方法，使其由比较引用变为了比较引用所指向的字符串内容是否一样。 System.out.println(s1.equals(s2)); //true 例2，例3，例4，例5：编译器优化 例6：String s=”a”+”b”+”c”+”d”;这条语句一共创建了多少个对象？ String s1 = &quot;a&quot;; String s2 = s1 + &quot;b&quot;; String s3 = &quot;a&quot; + &quot;b&quot;; System.out.println(s2 == &quot;ab&quot;); System.out.println(s3 == &quot;ab&quot;); 第一条语句打印的结果为false，第二条语句打印的结果为true 这说明Java可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。 因此String s=&quot;a&quot;+&quot;b&quot;+&quot;c&quot;+&quot;d&quot;;只创建了一个String对象 (2) StringBuffer：线程安全的可变字符序列 对StringBuffer对象进行操作都是对其本身的字符序列进行操作，而不是生成新的对象。因此StringBuffer对象内容可变、长度可变，可以将多个字符串值直接联合，效率高 String覆盖了equals方法和hashCode方法，而StringBuffer没有覆盖equals方法和hashCode方法，所以，将StringBuffer对象存储进Java集合类中时会出现问题。 例1 定义有StringBuffer s1=new StringBuffer(10);s1.append(&quot;1234&quot;)则s1.length()和s1.capacity()分别是：4和10 (3) StringBuilder：非线程安全的可变字符序列 问：数组有没有length()方法? String有没有length()方法？数组没有length()方法，但有length属性；String有length()方法。 问：String的几个方法例1：易错的题目：replaceAll()方法 public static void main (String[] args) { String classFile = &quot;com.jd.&quot;. replaceAll(&quot;.&quot;, &quot;/&quot;) + &quot;MyClass.class&quot;; System.out.println(classFile); } 输出为：/////////MyClass.class replaceAll方法的第一个参数是一个正则表达式，而&quot;.&quot;在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成&quot;/&quot;。 如果想替换的只是&quot;.&quot;的话，正则表达式那里就要写成&quot;\\\\.&quot;或者是&quot;[.]&quot;。前者将&quot;.&quot;转义为&quot;.&quot;这个具体字符，后者则匹配&quot;[]&quot;中的任意字符。 例2：字符串分割，如何把一段逗号分割的字符串转换成一个数组？ 方法一：使用正则表达式 String str=&quot;abc,edg,efd,adfa&quot;; String [] result = str.split(&quot;,&quot;); 方法二：使用StingTokenizer String str=&quot;abc,edg,efd,adfa&quot;; StringTokenizer tokener = new StringTokenizer(str, &quot;,&quot;); int length=tokener.countTokens(); String [] result =new String[length]; for(int i=0; i&lt;length; i++){ result[i]=tokener.nextToken(); } 问：String的编码转换编码转换，实现将GB2312编码的字符串转换为ISO-8859-1编码的字符串： String a=new String(&quot;中&quot;.getBytes(&quot;gb2312&quot;), &quot;iso-8859-1&quot;); 编码转换，实现将GBK编码字节流转换为UTF-8编码字节流： byte[] src, dst; dst=new String (src, &quot;GBK&quot;).getbytes(&quot;UTF-8&quot;); 问：Math类(1) Math.floor(a) 求小于或等于a的最大整数，返回double类型。 Math.floor(11.6)=11.0; Math.floor(-11.3)=-12.0; // 如果参数值总是等于某个整数，那么结果与该参数相同 Math.floor(1)=1.0 // 如果参数是NaN、无穷、正0、负0，那么结果与参数相同 Math.floor(Double.NaN)=Double.NaN Math.floor(Double.POSITIVE_INFINITY)=Double.POSITIVE_INFINITY Math.floor(Double.NEGATIVE_INFINITY)=Double.NEGATIVE_INFINITY Math.floor(0.0)=0.0 Math.floor(-0.0)=-0.0 (2) Math.ceil(a) 求大于或等于a的最小整数，返回double类型。 Math.ceil(11.3)=12.0 Math.ceil(-11.3)=-11.0; // 如果参数值总是等于某个整数，那么结果与该参数相同 Math.ceil(1)=1.0 // 如果参数是NaN、无穷、正0、负0，那么结果与参数相同 Math.ceil(Double.NaN)=Double.NaN Math.ceil(Double.POSITIVE_INFINITY)=Double.POSITIVE_INFINITY Math.ceil(Double.NEGATIVE_INFINITY)=Double.NEGATIVE_INFINITY Math.ceil(0.0)=0.0 Math.ceil(-0.0)=-0.0 //如果参数小于0但大于-1.0，那么结果为-0.0(重要) Math.ceil(-0.5)=-0.0 (3) Math.round(a)=(long)floor(a+0.5d)；将原来的数字加上0.5后再向下取整，返回long类型，注意向下取整是指小于或等于它的最大整数。 Math.round(6.4)=(long)floor(6.4+0.5d)=(long)floor(6.9)=6 Math.round(6.9)=(long)floor(6.9+0.5d)=(long)floor(7.4)=7 Math.round(6.5)=(long)floor(6.5+0.5d)=(long)floor(7.0)=7 Math.round(-6.4)=(long)floor(-6.4+0.5d)=(long)floor(-5.9)=-6 Math.round(-6.9)=(long)floor(-6.9+0.5d)=(long)floor(-6.4)=-7 Math.round(-6.5)=(long)floor(-6.5+0.5d)=(long)floor(-6.0)=-6 // 了解 Math.round(NaN)=0 Math.round(Math.round(Double.NEGATIVE_INFINITY或&lt;=Long.MIN_VALUE))=Long.MIN_VALUE Math.round(Math.round(Double.POSITIVE_INFINITY或&gt;=Long.MAX_VALUE))=Long.MAX_VALUE 问：枚举类型Java中创建枚举类型要使用enum关键字，所有的枚举值都默认为static，在初始化时会对所有的枚举值对象调用一次构造函数进行初始化。 例1： enum AccountType{ SAVING, FIXED, CURRENT; private AccountType(){ System.out.println(&quot;It is a account type&quot;); } } class EnumOne{ public static void main(String[]args){ System.out.println(AccountType.FIXED); } } 程序输出如下： It is a account type It is a account type It is a account type FIXED 问：基本数据类型的包装类Java语言是一个面向对象的语言，但Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，即包装类。 例1： class Two{ Byte x; } class PassO{ public static void main(String[] args){ PassO p=new PassO(); p.start(); } void start(){ Two t=new Two(); System.out.print(t.x+””); Two t2=fix(t); System.out.print(t.x+” ” +t2.x); } Two fix(Two tt){ tt.x=42; return tt; } } 上面代码的输出为：null 42 42 基本数据类型的包装类型，属于引用类型。如果包装类成员变量没有显示初始化，那么Java默认初始化为null。 问：如何将数值型字符串转换为对应类型的数字？例1： Integer.parseInt(&quot;1234&quot;); Double.parseDouble(&quot;123.2&quot;); 问：日期类例1： 使用Java编程，打印昨天的当前时刻 public class YesterdayCurrent{ public static void main(String[] args){ Calendar cal = Calendar.getInstance(); cal.add(Calendar.DAY_OF_MONTH, -1);//从当前日期减去一天 System.out.println(cal.getTime()); } } 例2： 如何获取当前时间对应的年月日时分秒? public class CurrentTime{ public static void main(String[] args){ Calendar c=Calendar.getInstance(); System.out.print(c.get(Calendar.YEAR)+&quot;年&quot;+(c.get(Calendar.MONTH)+1)+&quot;月&quot;+c.get(Calendar.DAY_OF_MONTH)+&quot;日, &quot;; System.out.println(c.get(Calendar.HOUR_OF_DAY)+&quot;:&quot;+c.get(Calendar.MINUTE)+&quot;:&quot;+c.get(Calendar.SECOND)); } } 或 public class CurrentTime{ public static void main(String[] args){ Date date=new Date(); System.out.println(date); } } 例3： 如何取得从1970年到现在的毫秒数 public static void main(String[] args){ System.out.println(System.currentTimeMillis()); } 例4： 如何格式化日期？SimpleDateFormat public static void main(String[] args){ SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); Date date=new Date(); String dateStr=sdf.format(date);//把日期按指定格式转化为字符串 System.out.println(dateStr); }","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"05-数组","slug":"05-数组","date":"2017-02-17T10:18:25.000Z","updated":"2017-07-22T13:10:09.316Z","comments":true,"path":"2017/02/17/05-数组/","link":"","permalink":"https://hepsilion.github.io/2017/02/17/05-数组/","excerpt":"数组","text":"数组","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"04-异常处理","slug":"04-异常处理","date":"2017-02-16T10:15:57.000Z","updated":"2017-07-22T13:10:04.888Z","comments":true,"path":"2017/02/16/04-异常处理/","link":"","permalink":"https://hepsilion.github.io/2017/02/16/04-异常处理/","excerpt":"异常处理","text":"异常处理 问：Java中的两种异常类型是什么？他们有什么区别？Throwable包含了错误(Error)和异常(Excetion)两类。 图 1 (1) Error： 由Java虚拟机生成并抛出，属于JVM底层或者运行时环境的错误，程序无法预测和捕获处理，如OutOfMemoryError，如果出现Error，Java虚拟机会终止执行。 (2) Exception: 用户程序可以捕获的异常情况，Java中有两种异常，分别为运行时异常(RuntimeException, 又叫非检查异常)和非运行时异常(又叫检查异常)。 运行时异常：RuntimeException类及其子类，如ArithmeticException、NullPointerException、IndexOutOfBoundsException、ClassCastException、BufferOverflowException、ConcurrentModificationException、IllegalArgumentException、NoSuchElementException、UnsupportedOperationException等，这类异常是在程序运行的时候可能会发生的，Java编译器不去检查它，也就是说，当程序中可能出现这类异常时，即使没有用try…catch语句捕获它，也没有用throws子句声明抛出它，还是会编译通过。所以程序可以捕捉，也可以不捕捉。这些异常一般是由程序的逻辑错误引起的，其产生频繁，处理麻烦，若显示申明或者捕获将会对程序的可读性和运行效率影响很大，建议不要用try…catch…捕获处理，程序应该在开发调试的过程中从逻辑角度去尽量避免，例如：空值处理。 非运行时异常：运行时异常以外的异常，也是Exception及其子类，这些异常从程序的角度来说是必须经过捕捉检查处理的(要么用 try…catch捕获处理，要么用throws语句声明抛出)，否则不能通过编译。如IOException、SQLException、NoSuchMetodException、ClassNotFoundException、FileNotFoundException等。 问：异常处理语句的语法规则 try是用于检测被包住的语句块是否出现异常，如果有异常，则抛出异常，并执行catch语句 cacth用于捕获从try中抛出的异常并作出处理 finally语句块是不管有没有出现异常都要执行的内容 throw用于抛出异常 throws关键字可以在方法上声明该方法要抛出的异常 (1) try代码块中包含可能产生异常的代码，其后跟一个或多个catch代码块，每个catch代码块用于捕获并处理一种特定类型的异常。 (2) 当try代码块中产生异常时，程序会终止当前的执行流程，Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个catch代码块，然后其他的catch代码块将不会再执行，即一个异常只能被一个catch代码块捕获执行。如果try代码块没有异常产生，所有的catch代码块将跳过不执行。 (3) catch代码块后可以跟finally代码块，无论try代码块中是否抛出异常，finally代码块都会被执行，因此finally代码块为异常处理提供一个统一的出口，使得在控制流程跳转到程序的其他部分之前，能够对程序的状态作统一的管理。通常在finally代码块中可以进行资源的清除工作。 (4) try代码块后基类异常的捕获语句不可以写在子类异常捕获语句的上面。 (5) 在try-catch-finally结构中，可重新抛出异常。 (6) try-catch-finally结构可嵌套。 (7) try不必一定有catch，只要catch和finally有一个存在就行，但是catch和finally不可以同时省略 (8) 自定义异常要继承Exception或Exception的子类。 问：异常处理完成以后，Exception对象会发生什么变化？Exception对象会在下一个垃圾回收过程中被回收掉。 问：throw和throws有什么区别？ throw关键字用来在方法内部明确地抛出异常，后面跟的是要抛出的异常对象且只能跟一个异常对象； throws关键字用在声明方法上，表示该方法可能要抛出的、该方法不能处理的异常，后面跟的是异常类名，可以有多个，用逗号隔开，这样方法的调用者才能够确保处理可能发生的异常。 问：finallyfinally作为异常处理的一部分，只能用在try/catch语句块后，无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。 例1：当程序执行到try{}语句中的return方法时，它将要返回的结果存储到一个临时栈中，然后程序不会立即返回，而是去执行finally{}中的代码，在执行a = 2时，程序仅仅是覆盖了a的值，但不会去更新临时栈中的那个要返回的值。finally{}执行完之后，程序就会将临时栈中的值取出来返回。 public abstract class Test { public static void main(String[] args) { System.out.println(beforeFinally()); // output: 1 } public static int beforeFinally(){ int a = 0; try{ a = 1; return a; }finally{ a = 2; } } } 例2：这里finally{}里也有一个return，那么在执行这个return时，就会更新临时栈中的值。同样，在执行完finally之后，程序将临时栈中的值取出来返回，即返回值是2. public abstract class Test { public static void main(String[] args) { System.out.println(beforeFinally()); //output: 2 } public static int beforeFinally(){ int a = 0; try{ a = 1; return a; }finally{ a = 2; return a; } } } 例3：try/catch可以捕获并处理异常，异常被捕获后程序可以继续向后执行 public class Test { public static void main(String[] args) { try { int i = 100 / 0; System.out.print(i); } catch (Exception e) { System.out.print(1); } finally { System.out.print(2); } System.out.print(3); } } // output: 123 例4：catch语句块里面，打印完1之后，又抛出了一个RuntimeException，程序并没有处理它，而是直接抛出，因此执行完finally语句块之后，程序便不往下执行直接终止了 public class Test { public static void main(String[] args) { try { int i = 100 / 0; System.out.print(i); } catch (Exception e) { System.out.print(1); throw new RuntimeException(); } finally { System.out.print(2); } System.out.print(3); } } // output: 12 例5：catch语句块里面，打印完1之后，程序先执行完finally语句块，然后return。 public class Test { public static void main(String[] args) { try { int i = 100 / 0; System.out.print(i); } catch (Exception e) { System.out.print(1); return; } finally { System.out.print(2); } System.out.print(3); } } // output: 12 问：final关键字、finally代码块和finalize()方法有什么区别？ final关键字用于声明变量、方法和类，分别表示变量的值不可被修改、方法不可被重写、类不可被继承。 finally作为异常处理的一部分，只能用在try/catch语句块后，无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。 finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由垃圾收集器来调用的。可以覆盖此方法在垃圾收集时的进行其他资源回收，例如关闭文件等。但是JVM不保证此方法总会被调用。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"03-面向对象编程","slug":"03-面向对象编程","date":"2017-02-15T10:14:04.000Z","updated":"2017-07-22T13:10:01.260Z","comments":true,"path":"2017/02/15/03-面向对象编程/","link":"","permalink":"https://hepsilion.github.io/2017/02/15/03-面向对象编程/","excerpt":"面向对象编程","text":"面向对象编程 问：面向对象的基本特征(1) 封装：利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过其对外已授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外提供的接口来访问该对象。 (2) 继承：继承是使用已存在的类作为基础定义新类，新类的定义可以增加新的数据或新的操作，也可以复用父类的操作，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。 (3) 多态：多态就是指程序中定义的引用变量所指向的对象的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。 问：类例1 问：new关键字例1 问：访问控制符Java类的成员没有写任何访问修饰符时，表示friendly访问权限，后面写作default。 图 1 访问权限大小：public&gt;protected&gt;default&gt;private 例1：分析下面代码的运行结果 class Person{ private String name = &quot;Person&quot;; int age=0; } public class Child extends Person{ public String grade; public static void main(String[] args){ Person p = new Child(); System.out.println(p.name); } } 答案：程序编译错误。子类无法访问父类的私有成员。 例2：Java代码查错 public class Something { void doSomething() { private String s = &quot;&quot;; int l = s.length(); } } 局部变量前不能放置任何访问修饰符(private，public和protected)。final可以用来修饰局部变量 问：Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？Java中每一个类都有构造方法，当使用关键字new实例化一个对象时，类的构造方法就会被自动调用，完成对象的初始化工作。 构造方法是一种特殊的方法，具有以下特点: (1) 构造方法的方法名必须与类名相同； (2) 构造方法没有返回值类型，也不能定义为void； (3) 构造方法不能被static、final、synchronized、abstract、native等关键字修饰，但可以被public、private、protected修饰 (4) 一个类可以定义多个构造方法，如果在定义类时没有定义构造方法，则编译系统会自动插入一个无参数的默认构造方法，这个构造器不执行任何代码； (5) 构造方法可以被重载，以参数的个数、类型、顺序进行区分； (6) 构造方法不能被继承，因此不能被重写，子类使用父类的构造方法需要使用super关键字 例1： Java中构造方法重载和方法重载很相似，可以为一个类创建多个构造方法，每一个构造方法必须有它自己唯一的参数列表。 Java不支持像C++中那样的复制构造方法，但是这并不代表Java中没有这种机制，Java中Object类的clone()方法就是这种机制的体现。 问：this关键字问：static关键字“static”关键字可以用于修饰类的成员变量和成员方法，被其修饰的成员变量被称为类变量，被其修饰的成员方法称为类方法，它们随着类的加载而加载，使得这些变量和方法可以在类没有被实例化的情况下直接通过类名进行访问。 (1) 被static修饰的成员方法只能访问static成员，不可以访问非static成员 Java中,非static成员是与对象关联在一起的，必须创建一个对象后，才可以访问该对象的方法或属性；而被static修饰的变量和方法是属于类的，它们随着类的加载而加载，同时对static变量进行初始化并执行static代码块。如果static环境中的代码尝试访问非static的变量，编译器会报错，因为类的加载先于变量的创建，类加载的时候这些变量还没有被创建出来，例如，在static方法中访问某对象的非static方法，此时尚不能保证对象已经被实例化。因此在static环境中不能访问非static变量。 例1 package NowCoder; class Test { public static void hello() { System.out.println(&quot;hello&quot;); } } public class MyApplication { public static void main(String[] args) { Test test=null; test.hello(); } } 上述代码：能编译通过，并正确运行 (2) Java中静态变量只能在类主体中定义，不能在方法中定义。 静态变量属于类所有而不属于方法所有。静态变量是在方法之前被加载的，在static加载时，对象还没有创建，方法也还没有分配空间。所以static变量只能是类成员变量，而不能是局部变量。 例1：分析下面代码的执行结果。 public class Test { public int aMethod() { static int i = 0; i++; return i; } public static void main (String args[]) { Test test = new Test(); test.aMethod(); int j = test.aMethod(); System.out.println(j); } } 答案：程序编译失败 问：继承继承时类的实例化问题：在实例化一个类时，一定是先创建其父类对象，即先执行父类的构造函数，然后再创建当前类对象。如果子类没有显示地调用父类的构造函数，编译器会自动加入父类的无参的构造函数super()(这也要求父类要有无参数的构造函数，否咋将出现编译出错)。 例1： package test; class FatherClass { public FatherClass() { System.out.println(&quot;FatherClass Create&quot;); } } class ChildClass extends FatherClass { public ChildClass() { System.out.println(&quot;ChildClass Create&quot;); } public static void main(String[] args) { FatherClass fc = new FatherClass(); ChildClass cc = new ChildClass(); } } 程序的输出结果如下： FatherClass Create FatherClass Create ChildClass Create 例2 问：Java支持多继承么？Java中的类不支持多继承，只支持单继承(即一个类只有一个父类)。 但是Java中的接口支持多继承，即一个子接口可以有多个父接口。(接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能)。 问：super和thisthis代表当前类对象，super代表当前类对象的父类对象。 在子类构造方法中，使用super()调用的是其父类的构造方法，而使用this()调用的是同一个类中重载的构造方法 super关键字 (1) Java中子类不能继承父类的构造方法，只能调用父类构造方法； (2) 子类的构造方法可以显示地使用super调用父类构造方法； (3) 当子类构造方法中没有显示地使用super来调用父类构造方法时，系统会默认采用super()调用父类的无参构造方法，这时父类必须提供无参构造方法，否则编译出错。 例1，例2，例3，例4 例5：下面程序的输出结果是多少？ import java.util.Date; public class Test extends Date{ public static void main(String[] args) { new Test().test(); } public void test(){ System.out.println(super.getClass().getName()); } } 在test方法中其实在调用从父类继承的getClass()方法 输出为: Test 如果想得到父类的名称，应该使用：getClass().getSuperClass().getName(); this关键字 注意： (1) 使用super()或this()时，它们必须放在构造方法的第一行，否则编译通不过。 (2) 由于this()调用的构造函数默认调用super()方法，所以规定this()和super()不能同时出现在一个构造函数中。 (3) static环境，包括static方法和static语句块，在执行时还没有构造对象实例，因此不能在static环境中使用this和super 问：Java中的方法重写(或覆盖，Overriding)和方法重载(Overloading)是什么意思？方法重写和方法重载都是Java多态性的不同表现(动态绑定 dynamic binding) (1) 方法重载是一个类中多态性的一种表现，发生在同一个类里面两个或多个方法的方法名相同但是参数列表不同的情况。 函数名必须相同； 函数参数列表必须不相同：可以是参数个数、参数类型或者参数顺序不同； 函数的返回值类型、访问权限、异常类型可以相同，也可以不相同。即不能通过返回值类型、访问权限和异常类型对方法进行重载。 (2) 方法重写是父类与子类之间多态性的一种表现，是说子类重新定义了父类的方法；方法的重写满足两同两小一大原则 方法名相同，参数列表相同 子类方法返回值类型小于或等于父类方法返回值类型； 子类方法抛出的异常类型小于或等于父类方法抛出的异常类型 (小于：子类方法抛出的异常时父类方法抛出异常的子类)； 子类方法访问权限大于或等于父类方法访问权限 (public&gt;protected&gt;defualt(默认修饰符)&gt;private)。如果父类的方法是private访问权限，则子类并没有重写父类的方法，只是在子类中定义了一个全新的方法。 注意：Java不支持运算符重载。 例1 问：Java中是否可以覆盖(override)一个被private或static修饰的方法？private修饰的方法不能被覆盖，因为被private修饰的父类方法在子类中是不可见的。 Java中静态方法在形式上可以被重写，即子类中可以重写父类中静态的方法。但是实际上从内存的角度上静态方法不可以被重写，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。 问：final关键字final关键字可以用于修饰类、变量和方法。 (1) final修饰的类不可被继承(因此一个类不能同时被final和abstract关键字修饰)； (2) final修饰的方法不可被重写； (3) final修饰的变量的值不可被修改，一旦获得初始值，该变量就不能被重新赋值。 例1： 使用final关键字修饰一个引用变量时，引用变量的值不可被修改，但引用变量所指向的对象的内容是可以改变的。例如: final StringBuffer sb=new StringBuffer(&quot;immutable&quot;); 当执行sb.append(&quot; broken!&quot;)；时，编译正确； 但是当执行sb=new StringBuffer(&quot;&quot;);时，将报告编译错误。 例2，例3，例4 (4) 形式参数只能用final修饰符，任何其它修饰符都会引起编译错误。但是用这个修饰符也有一定的限制，就是在方法中不能修改参数的值(但是从上面例1可以看出，参数引用的对象仍然是可以修改的)。不过在一般情况下，一个方法的形参不用final修饰。只有在特殊情况下：方法内部类，一个方法的内部类如果使用了这个方法的参数或局部变量，这个参数或局部变量应该是final。 (5) final修饰的成员变量既可以在定义时显示地初始化，也可以先声明而不初始化，这种成员变量称为blank final，此时可以在构造代码块或构造函数中对其赋初值，(必须在constructor结束之前)，否则使用未赋初值的final变量时编译会报错。 例1： class Foo { final int i; int j; public void doSomething() { System.out.println(++j + i); // 编译出错，因为final成员变量在使用前没有赋初值 } } 例2：这一题解释尚不明确，不知道final方法在子类中继承了没有。 public class Car extends Vehicle{ public static void main(String[] args){ new Car().run(); //输出：Car } private final void run(){ System.out.println(&quot;Car&quot;); } } class Vehicle{ private final void run(){ System.out.println(&quot;Vehicle&quot;); } } 问题已解决：子类会继承父类的所有属性和方法，或者说子类拥有父类的所有属性和方法，但是子类无法直接访问父类的私有属性和私有方法。 这里由于子类无法访问父类的run()方法，因此子类并没有重写父类的run()方法，而是自己重新定义了run()方法。 (6) 被fianl修饰的变量参与运算时不会自动改变类型；当2个final修饰的变量相操作时，结果会根据左边变量的类型进行转化 例1： byte b1=1,b2=2,b3,b6,b8; final byte b4=4,b5=6,b7; b3=(b1+b2); /*语句1*/ b6=b4+b5; /*语句2*/ b8=(b1+b4); /*语句3*/ b7=(b2+b5); /*语句4*/ System.out.println(b3+b6); 代码片段中，存在编辑错误的语句是：语句1、语句3和语句4 语句1错误：b3=(b1+b2);自动转为int，所以正确写法为b3=(byte)(b1+b2);或者将b3定义为int； 语句2正确：b6=b4+b5;b4、b5为final类型，不会自动提升，计算结果任然是byte类型，然后结果的类型视左边变量类型而定，即b6可以是任意数值类型； 语句3错误：b8=(b1+b4);虽然b4不会自动提升，但b1仍会自动提升，所以结果需要强转，b8=(byte)(b1+b4); 语句4错误：b7=(b2+b5); 同上。同时注意b7是final修饰，即只可赋值一次，便不可再改变。 问：Object类Java中Object是所有类的祖先类，Object类中包含如下方法： 图 1 例1：重写clone()方法时，通常都会有一行代码，是什么？ super.clone(); 重写clone()方法时，首先要把父类中成员复制到位，然后才是复制子类的成员。 问：equals()方法和==的区别(1) ==运算符：比较两个变量的值是否相等，也就是两个变量所对应的内存中存储的数值是否相同，即栈中的内容是否相同。 对于基本数据类型变量比较的是两个变量的值是否相等； 对于引用型变量表示的是两个变量指向的对象在堆中存储的地址是否相同，即两个变量是否指向同一个对象 (2) equals()方法：继承自Object类，默认调用==进行比较。通常比较两个对象的内容是否相同，判断两个对象是否相等需要覆盖equals()方法和hashcode()方法。 例1： String a=new String(&quot;foo&quot;); String b=new String(&quot;foo&quot;); System.out.println(a==b); //false System.out.println(a.equals(b)); //true 例2：寻找代码错误 if(username.equals(&quot;zhangsan&quot;)){ } username可能为null，此时编译器会报告空指针异常，因此需要改为&quot;zhangsan&quot;.equals(username) 问：finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？finalize()是Object类的一个方法，垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法。 但是很不幸的是，在Java中，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说finalize()可能永远不会被执行，显然指望它做收尾工作是靠不住的。 那么finalize()究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。 问：clone，没遇到过，暂时存放42、写clone()方法时，通常都有一行代码，是什么？Clone有缺省行为，super.clone();他负责产生正确大小的空间，并逐位复制。 问：多态的实现方式(1) 静态的多态：方法重载 (2) 动态的多态：子类覆盖父类的方法，将子类的实例赋值给父类的引用，此时调用的是子类的方法；实现接口的实例赋值给接口的引用，此时调用的实现类的方法。 例1：判断对错 在java的多态调用中，new的是哪一个类就是调用的哪个类的方法。 答案：错误。 没看懂题目后面的评论，不知道跟重载有什么关系。目前我觉得下面例子是一个反例。 class Father { public static void run(){ System.out.println(&quot;Father run&quot;); } } public class Child extends Father { public static void run(){ System.out.println(&quot;Child run&quot;); } public static void main(String[] args) { Person p = new Child(); p.run(); //这里调用的实际上是父类的run()方法 } } 问：抽象类和接口的区别Java提供和支持创建抽象类和接口。 (1) 抽象类：含有abstract修饰符的class即为抽象类，abstract类不能创建类的实例对象。 含有abstract方法的类必须定义为abstract class 抽象类中的抽象方法，需要由子类实现，如果子类不实现所有抽象方法，则子类也需要定义为抽象类； 抽象方法既不能是static的，也不能是native的，还不能是synchronized的 构造方法和静态方法不可以为抽象的。 (2) 接口：接口(interface)可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。 接口中的方法默认定义为public abstract类型，接口中的成员变量默认为public static final 接口中定义的方法都需要由实现类来实现，如果实现类不能实现接口中的所有方法，则实现类需要定义为抽象类 他们的共同点在于： 抽象类和接口都不可以被实例化 类可以不实现抽象类和接口中声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的 它们的不同点在于：从设计层面来说，抽象是对类的抽象，是一种模板设计；接口是行为的抽象，是一种行为的规范。 抽象类中可以有构造方法，其作用是初始化抽象类的成员；接口中不能有构造方法 抽象类中可以有普通成员变量；而接口中没有普通成员变量，只能有静态成员变量 抽象类中可以包含静态方法；而接口中不能包含静态方法(Java8开始接口可以有静态方法) 抽象类中可以同时包含抽象方法和非抽象方法，也可以没有抽象方法，但如果一个类中有一个抽象方法，那么当前类一定是抽象类；而接口中只有方法的声明、没有方法体，即接口中的所有方法必须都是抽象的，不能有非抽象的普通方法(Java8中接口可以有非抽象的default方法) 抽象类和接口中都可以包含静态成员变量。抽象类中静态成员变量的访问类型可以任意；而接口中声明的成员变量默认为public static final类型，且只能是public static final类型 抽象类中的普通成员方法的访问类型可以为public、protected和private，抽象方法必须为public或protected；而接口中的成员方法的访问类型默认为public abstract类型，且只能是public abstract 一个类最多只能继承一个类，但一个类可以实现多个接口 抽象类可以implements接口；接口可以继承接口，并且接口可以实现多继承(一个接口可以继承多个接口) 例1，例2，例3，例4 例5：Java代码查错 abstract class Something { private abstract String doSomething(); } 编译错误：abstract修饰的方法需要由子类实现，不能用private修饰。 同理，abstract方法前不能加final。 例6：Java代码查错 interface A { int x = 0; } class B { int x = 1; } class C extends B implements A { public void fun() { System.out.println(x); } public static void main(String[] args) { new C().fun(); } } 编译错误：未明确的x调用 例7： class Toy{ } interface Rollable { Toy toy = new Toy(); void play(); } class Ball implements Rollable { public void play() { toy = new Toy(); } } 编译错误：任何在interface里声明的interface variable默认为public static final，不能被重新赋值。 例8： 接口可以继承接口；抽象类可以实现接口；抽象类可以继承具体类；抽象类中可以有静态的main方法。 问：instanceof关键字instanceof前一个参数通常是一个引用类型变量，后一个操作数通常是一个类（也可以是一个接口）。它用于判断前面的变量引用的对象是否是后面的类(也可以是一个接口)或者其子类的实例。 例1： public static void main(String args[]) { List Listlist1 = new ArrayList(); Listlist1.add(0); List Listlist2 = Listlist1; System.out.println(Listlist1.get(0) instanceof Integer); System.out.println(Listlist2.get(0) instanceof Integer); } 上面代码将输出：true true Collection类型的集合（ArrayList,LinkedList）只能装入对象类型的数据 该题中需要装入0，是一个基本类型，但是JDK5以后提供了自动装箱与自动拆箱，所以int类型自动装箱变为了Integer类型。 List没有使用泛型，因此使用get(0)取出的元素的编译类型是Object型的，但运行时类型是Integer，所以打印true，这里体现了多态的应用。 而Listlist1把引用赋给了Listlist2，说明两个指向同一个对象，因此第二个打印的也是true。 问：内部类内部类就是在一个类的内部定义的类。 内部类中不能定义静态成员 内部类可以直接访问外部类中的成员 内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中 例1：内部类中可以访问外部类的成员？有没有什么限制？ 如果内部类不是静态嵌套类，则内部类可以直接访问外部类的成员； 但是如果把静态嵌套类当作内部类的一种特例，则它不可以直接访问外部类的普通成员，只能访问外部类中的静态成员。 例2：内部类中是否一定不可以定义静态成员？ 同样的，静态嵌套类可以定义静态成员 内部类分类，来自例2中评论部分BlueFish的总结。 (1) 成员内部类 public class Outer{ private String name=&quot;Outer&quot;; private int age=99; public static void main(String[] args){ Outer outer=new Outer(); Inner inner=outer.new Inner(); inner.show(); } private class Inner{ private String name=&quot;Inner&quot;; private final int num=10; public void show(){ System.out.println(Outer.this.name); System.out.println(this.name); System.out.println(age); } } } Inner类定义在Outer类的内部(相当于Outer类的一个成员变量的位置处)，Inner类可以使用任意访问控制符，如public、protected、private或default等，跟成员变量有4种访问权限一样； Inner 类中定义的show()方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问Outer类中的私有属性age； 定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去new一个内部类对象，即：内部类 对象名=外部类对象.new 内部类(); 编译上面的程序后，会发现产生了两个.class文件: Outer.class和Outer$Inner.class 成员内部类中不能存在任何static的变量和方法，但可以定义常量: 因为非静态内部类的存在是依赖于外部类的实例的，而静态变量和方法是不依赖于对象的，仅与类相关。而在加载静态域时，根本没有外部类实例，所在在非静态内部类中不能定义静态变量或方法，编译不通过;非静态内部类的作用域是实例级别 常量是在编译器时确定的，放到所谓的常量池了，因此可以定义常量。 注意： 外部类是不能直接使用内部类的成员和方法的，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法； 如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用this关键字，如:Outer.this.name (2) 方法内部类，访问仅限于方法内或者该作用域内 public class Outer { public static void main(String[] args) { Outer outer = new Outer(); outer.print(); } public void print() { final int a = 25; class Inner { private int c = 2; public void show() { System.out.println(a); System.out.println(c); } } Inner inner = new Inner(); inner.show(); } } 方法内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的；但这种内部类的前面可以使用final或abstract修饰符。 方法内部类对其他外部类是不可见的 方法内部类不能修改方法中定义的局部变量(解释看原评论，原评论这部分，我测试有点问题，大概原因是内部类访问方法局部变量时会拷贝局部变量，对局部变量修改会造成拷贝的局部变量值与方法中局部变量值不一致，为了保持局部变量值的一致性，可以将被内部类访问的局部变量声明为final) (3) 匿名内部类：定义某一接口的实现类或定义某一类的子类的同时，还创建了该实现类或子类的实例对象，且没有为该实现类或子类定义名称 public class Outer{ public static void main(String[] args){ Outer outer=new Outer(); InnerClass inner=outer.getInnerClass(2, &quot;inner&quot;); System.out.println(inner.getNumber()); } public InnerClass getInnerClass(int num, String str){ return new InnerClass(){ int count; int number=num+1; { count=100; } @Override public int getNumber() { return number; } }; } private interface InnerClass{ int getNumber(); } } 匿名内部类是直接使用 new 来生成一个对象的引用； 对于匿名内部类的使用，它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用； 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，即只能继承一个类或者实现一个接口； 匿名内部类中是不能定义构造函数的，匿名内部类中不能存在任何的静态成员变量和静态方法； 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法； 匿名内部类初始化:使用构造代码块! 利用构造代码块能够达到为匿名内部类创建一个构造器的效果 内部类的作用 隐藏内部操作细节 解决多重继承的问题 第二点作用是使用内部类最吸引人的原因，它的存在使得Java的继承机制更加完善。众所周知，Java中的类只能继承一个类，它的多重继承在我们没有学习内部类之前是用接口来实现的，但是使用接口会存在很多不方便的地方，比如我们实现一个接口就必须实现它里面的所有方法；而有了内部类情况就不一样了，它可以让我们的类间接地继承多个抽象类或具体类：我们可以在外部类中定义多个内部类，每个内部类都可以独立地继承一个抽象类或具体类，然后再外部类中创建内部类的对象，并使用内部类的方法，这样就可以变相地实现了多继承。 例如我们有两个类Class1和Class2: class Class1{ public void fun1(){ System.out.println(&quot;Class1 fun1()&quot;); } } class Class2{ public void fun2(){ System.out.println(&quot;Class2 fun2()&quot;); } } 如果我们想要类Test既有Class1的特性，又有Class2的特性，就必须让Test类既继承Class1，又继承Class2，可是这在Java的单继承使得这种方式不可实现。那又怎么办呢？我们可以在Test中实现两个内部类InnerClass1和InnerClass2，让他们分别继承Class1和Class2，然后在Test中创建InnerClass1和InnerClass2的对象，通过这些对象调用Class1和Class2的方法，间接实现多继承。 public class Test { public void fun1(){ new InnerClass1().fun1(); } public void fun2(){ new InnerClass2().fun2(); } class InnerClass1 extends Class1{ } class InnerClass2 extends Class2{ } } 使用内部类还能够为我们带来如下特性: 内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立； 在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类； 创建内部类对象的时刻并不依赖于外围类对象的创建； 内部类并没有令人迷惑的”is-a”关系，他就是一个独立的实体； 内部类提供了更好的封装，除了该外围类，其他类都不能访问。 说实话，上面的特性没读懂，为了保持内容完整性，姑且放在这里吧。 例1： 重要 非静态内部类是属于对象的，所以初始化时需要先初始化一个外部类实例对象，然后使用此对象调用内部类的构造方法。静态内部类属于类本身，初始化时直接使用外部类调用静态内部类的构造方法即可 public class Test{ public static void main(String[] args){ EnclosingOne.InsideOne obj1=new EnclosingOne().new InsideOne(); //非静态内部类 EnclosingOne.InsideTwo obj2=new EnclosingOne.InsideTwo(); //静态内部类 } } class EnclosingOne { //非静态内部类 public class InsideOne { } //静态内部类 public static class InsideTwo{ } } 例2：往OuterClass类的代码段中插入内部类声明，哪一个是错误的？ public class OuterClass{ private float f=1.0f; //插入代码到这里 } A. class InnerClass{ public static float func(){ return f; } } B. abstract class InnerClass{ public abstract float func(){} } C. static class InnerClass{ protected static float func(){ return f; } } D. public class InnerClass{ static float func(){ return f; } } 答案：ABCD 例3 问：Static Nested Class和Inner Class的不同？在方法外部定义的内部类前面加上static关键字，成为static Nested Class，它不再具备内部类的特性，侠义上讲，它不是内部类。它与普通类在运行时的行为和功能没有什么区别，只是编程引用时的语法有一些区别。 public class Outer{ private static String name=&quot;Outer&quot;; private static String tag=&quot;tag&quot;; private int age=99; public static void main(String[] args){ Inner inner=new Inner(); inner.show(); } private static class Inner{ private String name=&quot;Inner&quot;; public void show(){ System.out.println(Outer.name); System.out.println(this.name); System.out.println(tag); System.out.println(new Outer().age); } } } 静态内部类不能直接访问外部类的非静态成员，但可以通过new 外部类().成员的方式访问 如果外部类的静态成员与内部类的成员名称相同，可通过类名.静态成员的方式访问外部类的静态成员； 如果外部类的静态成员与内部类的成员名称不相同，则可通过成员名直接调用外部类的静态成员； 创建静态内部类的对象时，不需要外部类的对象，可以直接创建内部类 对象名=new 内部类(); (1) Static Nested Class可以定义为public、protected、default和private (2) Static Nested Class可以不依赖于外部类实例被实例化，而通常的内部类需要在外部类实例化后才能实例化。 在外部类的外面引用Static Nested Class的方式为”外部类名.内部类名”，即在外部类的外面不需要创建外部类的实例对象，就可以直接创建Static Nested Class的实例。例如，假设Inner是定义在Outer类中的Static Nested Class，那么可以使用如下语句创建Inner类的实例：Outer.Inner inner = new Outer.Inner(); static Nested Class能访问外部类的非static成员变量(不能直接访问，需要创建外部类实例才能访问非静态变量)。 (3) 当在外部类中访问Static Nested Class时，可以直接使用Static Nested Class的名字，而不需要加上外部类的名字了，在Static Nested Class中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字。 (4) 在静态方法中定义的内部类也是Static Nested Class，这时候不能在类前面加static关键字，静态方法中的Static Nested Class与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的static的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加final修饰符。 问：Java类加载时的初始化顺序(1) 初始化父类中的静态成员变量和静态代码块(按照在程序中出现的顺序初始化) (2) 初始化子类中的静态成员变量和静态代码块(按照在程序中出现的顺序初始化) (3) 初始化父类中的普通成员变量和构造代码块(按照在程序中出现的顺序初始化)，然后再执行父类中的构造方法 (4) 初始化子类中的普通成员变量和构造代码块(按照在程序中出现的顺序初始化)，然后再执行子类中的构造方法 例1： class Member { Member(String str) { System.out.println(str); } } class A { static { System.out.println(&quot;父类静态代码块&quot;); } public A() { System.out.println(&quot;父类构造函数&quot;); } { System.out.println(&quot;父类构造代码块&quot;); } Member member=new Member(&quot;父类成员变量&quot;); } class B extends A { Member member=new Member(&quot;子类成员变量&quot;); static { System.out.println(&quot;子类静态代码块&quot;); } public B() { System.out.println(&quot;子类构造函数&quot;); } { System.out.println(&quot;子类构造代码块&quot;); } } public class Test{ public static void main(String[] args) { new B(); } } //输出： 父类静态代码块 子类静态代码块 父类构造代码块 父类成员变量 父类构造函数 子类成员变量 子类构造代码块 子类构造函数 例2：下面代码的输出是什么？(易错) public class B { public static B t1 = new B(); public static B t2 = new B(); { System.out.println(&quot;构造块&quot;); } static { System.out.println(&quot;静态块&quot;); } public static void main(String[] args) { B t = new B(); } } // 输出 构造块 构造块 静态块 构造块 例3：下面代码的输出是什么？(易错) public class Base { private String baseName = &quot;base&quot;; public Base() { callName(); } public void callName() { System.out.println(baseName); } static class Sub extends Base { private String baseName = &quot;sub&quot;; public void callName() { System.out.println(baseName); } } public static void main(String[] args) { Base b = new Sub(); } } // 输出：null 实例化子类对象时会先调用父类构造方法，由于父类构造方法调用了callName()方法并且子类重写了此方法，因此父类构造方法将调用子类的callName()方法将输出子类成员变量baseName的值。 但是由于子类的成员变量在父类构造方法调用完才会赋初值，因此调用callName()方法时，baseName值为null，所以输出结果为null。 问：JNI(Java Native Interface) (没怎么遇到过，暂时保留)Java的不足除了体现在运行速度上要比传统的C++慢许多之外，还体现在Java无法直接访问底层操作系统（如系统硬件等)，为此Java使用native方法来扩展Java程序的功能。 native是方法修饰符，native方法是由另外一种语言（如C/C++,汇编等）实现的本地方法，因为在外部实现了方法，所以在java代码中，就不需要声明了，有点类似于接口中的抽象方法。其实现步骤为： 在Java中声明native()方法，然后编译； 用javah产生一个.h文件； 写一个.cpp文件实现native导出方法，其中需要包含第二步产生的.h文件（注意其中又包含了JDK带的jni.h文件）； 将第三步的.cpp文件编译成动态链接库文件； 在Java中用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问了。 例1：以下声明合法的是： A. default String s B. public final static native int w() C. abstract double d D. abstract final double hyperbolicCosine() 答案：B native可以和任何修饰符连用，abstract除外。因为native暗示这个方法时有实现体的，而abstract却显式指明了这个方法没有实现体。 例2：Which of the following can be applied to constructors? A. final B. static C. synchronized D. native E. None of these. 答案：E abstract方法和native方法都是方法的声明，一个把方法实现移交给子类，另一个移交给本地操作系统。 如果同时出现，就相当于既把实现移交给子类，又把实现移交给本地操作系统，那就会产生混乱。 Java构造方法可以有任何访问的修饰：public，protected，private或者没有修饰。 但是不能有以下非访问性质的修饰：abstract，final，native，static，或者synchronized。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"02-基础语法","slug":"02-基础语法","date":"2017-02-14T09:26:00.000Z","updated":"2017-07-22T13:09:56.932Z","comments":true,"path":"2017/02/14/02-基础语法/","link":"","permalink":"https://hepsilion.github.io/2017/02/14/02-基础语法/","excerpt":"基础语法","text":"基础语法 问：关键字和保留字(1) Java关键字列表(依字母排序共50组) abstract, assert, boolean, break, byte, case, catch, char, class, const(保留关键字), continue, default, do, double, else, enum, extends, final, finally, float, for, goto(保留关键字), if, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while (2) 保留字列表(依字母排序共14组)，Java保留字是指现有Java版本尚未使用，但以后版本可能会作为关键字使用 byValue, cast, false, future, generic, inner, operator, outer, rest, true, var, goto(保留关键字), const(保留关键字), null 注意： (1) const和goto既是保留字又是关键字 (2) 除了const和goto，其余保留字和关键字是严格区分开的。 问：Java支持的数据类型有哪些？Java语言支持8种基本数据类型是：byte、short、int、long、float、double、boolean、char；支持3种引用数据类型：类、接口和数组。 (1) Java中整数值默认为int型，如果要指定整数为long型需要加L；浮点数值默认为double型，如果要指定浮点数为float型需要加F。 float f=3.4; //错误，3.4默认为double型。 float f=3.4F; //正确 float f=3; //正确 (2) Java中在定义类的成员变量时可以对其初始化，如果不对其初始化，Java使用默认值对其初始化；而局部变量在使用前则必须进行初始化，JVM不会进行默认值初始化。 (3) Java中基本数据类型变量默认初始化值如表所示，引用变量默认初始化值为null。 图 2 例1： int类型变量的默认值为0；Integer类型变量的默认值为null。 问：Java中的中文字符Java语言中，中文字符所占的字节数取决于字符的编码方式，默认使用GBK编码方式。 当采用ISO8859-1编码方式时，一个中文字符占1个字节； 当采用GB2312或GBK编码方式时，一个中文字符占2个字节； 当采用UTF-8编码方式时，一个中文字符会占3个字节。 Java字符默认使用unicode编码，每个字符占用两个字节，所以char型变量可以存放一个中文字符。 Unicode字符编码标准是固定长度的字符编码方案。Unicode根据要编码的数据类型使用两种编码格式：8 位和16位。缺省编码格式是16位，即每个字符是16位(两个字节)宽。 注意：char与byte在Java和C++中的区别： 在C++中，char是基础数据类型，占1个字节；byte不是基础数据类型，一般定义为typedef unsigned char byte;也就是说，byte其实是unsigned char类型，那么也是占1个字节。不同的是，char可以表示的范围是-128-127，而byte可以表示的范围是0-255。 在java中，char和byte都是基础数据类型，其中的byte占1个字节，可以表示的范围是-128-127。而char占2个字节，可以表示的范围是’\\u0000’-‘\\uFFFF’。 例1： Java中实现国际化应用常用的手段是利用ResourceBundle类。 这个题目解答没看懂 问：类型转换(1) byte\\char\\short -&gt; int -&gt; long -&gt; float -&gt; double (2) Java中如果碰到char、byte和short参与运算时，会自动将这些值转换为int类型值然后再进行运算。 例1： short s1 = 1; s1 = s1 + 1; //错误，s1+1运算结果是int型，需要强制转换类型 short s1 = 1; s1 += 1; //正确 short s = 16; byte a2 = s; //错误 例2: short s=1; s=s+1; 编译错误：由于s+1运算结果为int型，再赋值给short类型s，编译器会报告需要强制类型转换的错误。 short s=1; s+=1; 编译正确：Java编译器会对+=特殊处理 (3) 低级向高级是隐式类型转换，高级向低级必须强制类型转换 (4) 两个数值进行二元操作时，会有如下的转换操作： 如果两个操作数其中有一个是double类型，另一个操作数将会转换为double类型； 否则，如果其中一个操作数是float类型，另一个操作数将会转换为float类型； 否则，如果其中一个操作数是long类型，另一个操作数会转换为long类型； 否则，两个操作数都转换为int类型。 例1： public static void main(String[] args){ int i=42; double d=42.0000; long l=42; float f=42.0f; float f2=42.00f; System.out.println(d==i); //true System.out.println(f==i); //true System.out.println(f==f2); //true System.out.println(l==i); //true System.out.println(l==f); //true System.out.println(d==f); //true } 例2： 对于java类型变量char c，short s，float f，double d，表达式c*s+f+d的结果类型为double 问：进制表示 八进制： 012 十六进制：0x12 问：源码、反码和补码例1： 变量a是一个64位有符号的整数，初始值用16进制表示为：0Xf000000000000000； 变量b是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF。 则a-b的结果用10进制表示为多少？ 计算机是用补码进行存储和计算的，因此a和b的初始值即为a和b在计算机中的补码形式，即：a的补码为0Xf000000000000000，b的补码为0x7FFFFFFFFFFFFFFF 0Xf000000000000000=1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x7FFFFFFFFFFFFFFF=0111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 a-b=a+(-b) 由于b是正数，原码与其补码相同，都为0x7FFFFFFFFFFFFFFF，则-b的原码为0xFFFFFFFFFFFFFFFF，是负数 现在求-b的补码，先对它的原码(除符号位外)各位取反得到-b的反码，然后反码尾部加1得到-b的补码，为 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001 所以a-b=a+(-b)= 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000+ 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001= 10111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001(最高位溢出，舍去，结果变成了正数) 则结果为0111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001=2^62+2^61+2^60+1 例2： 变量a是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF; 变量b是一个64位有符号的整数，初始值用16进制表示为：0x8000000000000000。 则a+b的结果用10进制表示为多少？ 计算机中是以补码形式存储数据，则a和b的初始值即为a和b在计算机中的补码形式。 0x7FFFFFFFFFFFFFFF+0x8000000000000000=0xFFFFFFFFFFFFFFFF 结果最高位符号位为1，说明结果为负数，现在求结果的原码值。 保持符号位不变，补码减1，得到结果的反码；保持符号位不变，反码取反，得到结果的原码：-1 例3： short a=128； byte b=(byte)a; 此时，变量a，b的值分别为128和-128 计算机是用补码进行存储和计算的，Java中short占2个字节，16位，因此a在内存中补码形式为0000 0000 1000 0000 Java中byte占1个字节，8位。将short变量强制类型转换时会截断前8位，得到1000 0000，即为b的补码形式。 现在已知a的补码为10000000，求原码。因为最高位表示符号位，所以首先这个数为负数。 保持符号位不变，补码减1，得到结果的反码1111 1111；保持符号位不变，反码取反，得到结果的原码1 0000 0000：-128 问：常见的运算符 +，%，~，三目运算符，++，&amp;&amp;和&amp;，&gt;&gt;和&gt;&gt;&gt; +： 例1： public class Test { public static void main(String args[]) { System.out.println(8+8+&quot;88&quot;+8+8); //168888 } } 例2： 若有定义语句：int a=10; double b=3.14;则表达式&apos;A&apos;+a+b 值的类型是double 例3： 假定x和y为double型，则表达式x=2，y=x+3/2的输出为3.000000 %：取模运算符，要求操作数为整型。 ~：按位取反运算符 例1： 若int j = 10; 则~j为多少？ 计算机是用补码进行存储和计算的，因此10在计算机中补码存储为：00000000 00000000 00000000 00001010 ~j操作是对j的补码取反，然后得到结果即为~j的补码： 11111111 11111111 11111111 11110101 现在通过~j的补码反推出~j的原码，~j最高位符号位为1，表明它是一个负数 保持符号位不变，补码减1，得到~j的反码： 11111111 11111111 11111111 11110100 保持符号位不变，反码取反，得到~j的原码： 10000000 00000000 00000000 00001011 换算为整数，~j大小为-11 三目运算符 例1： boolean b=true?false:true==true?false:true; System.out.println(b); //false 例2：下列代码输出是什么？ public static void main(String[] args){ boolean result1=true1()?true2():true3()==true4()?false1():true5(); System.out.println(result1); boolean result2=false1()?true2():true3()==true4()?false2():true5(); System.out.println(result2); } public static boolean true1(){ System.out.print(&quot;true1 &quot;); return true; } public static boolean true2(){ System.out.print(&quot;true2 &quot;); return true; } public static boolean true3(){ System.out.print(&quot;true3 &quot;); return true; } public static boolean true4(){ System.out.print(&quot;true4 &quot;); return true; } public static boolean true5(){ System.out.print(&quot;true5 &quot;); return true; } public static boolean false1(){ System.out.print(&quot;false1 &quot;); return false; } public static boolean false2(){ System.out.print(&quot;false2 &quot;); return false; } 输出如下： true1 true2 true false1 true3 true4 false2 false 从输出结果可以看出例1中b=true?false:true...，true成立使得结果b为false，表达式返回，后面的表达式不再执行。 结论：(1) ==优先级大于三目运算符 (2) 写复杂表达式时，请记得加括号，便于阅读 ++ i=i++问题 Java使用了中间缓存变量机制，JVM运行这条语句时过程如下： 步骤1 JVM把i值拷贝到临时变量区； 步骤2 i值加1； 步骤3 返回临时变量区的值，注意这个值步骤1中没修改过的i值。 步骤4 返回值赋值给i，此时count值被重置成原来的值。 例1： package algorithms.com.guan.javajicu; public class Inc { public static void main(String[] args) { Inc inc = new Inc(); int i = 0; inc.fermin(i); i= i ++; System.out.println(i); } void fermin(int i){ i++; } } 程序输出结果为0 例3： public class Test2{ public void add(Byte b){ b = b++; } public void test(){ Byte a = 127; Byte b = 127; add(++a); System.out.print(a + &quot; &quot;); add(b); System.out.print(b + &quot;&quot;); } } 执行test()函数后，程序输出为：-128 127 &amp;&amp;和&amp; 两者都可以用作逻辑与运算符。当运算符两边的表达式都为true时，整个运算结果才为true；否则只要有一边表达式为false，则运算结果为false。 两者的区别如下： (1) &amp;&amp;具有短路的功能，若该运算符左边为false，运算符右边表达式不执行；而&amp;作为逻辑与运算符时不具备短路功能，若该运算符左边为false，运算符右边表达式还会继续执行。 (2) &amp;还可以作为按位与运算符，当&amp;运算符两边的表达式都不是boolean类型时，&amp;表示按位与操作。例如 0x31 &amp; 0x0f = 0x01。 &lt;&lt; 将一个数左移n位，相当于这个数乘以2的n次方 2 &lt;&lt; 3 = 16 >>和&gt;&gt;&gt; >&gt; 表示带符号右移，正数结果为正，高位补0；负数结果为负，高位补1 int x1=5&gt;&gt;2; int x2=-5&gt;&gt;2; 5在计算机中补码表示为： 0 0000000 00000000 00000000 00000101 5为正数，5&gt;&gt;2，高位补0： 0 0000000 00000000 00000000 00000001，5为正数，符号位保留为0，结果x1=1 -5在计算机中补码表示为： 1 1111111 11111111 11111111 11111011 -5为正数，-5&gt;&gt;2，高位补1：1 1111111 11111111 11111111 11111110，-5为负数，符号位保留位1，结果x2=-2 >&gt;&gt; 表示无符号右移，左边空出的位以0填充 int y1=5&gt;&gt;&gt;2; int y2=-5&gt;&gt;&gt;2; 5在计算机中补码表示为： 00000000 00000000 00000000 00000101 5&gt;&gt;&gt;2，左边空出的位补0： 00000000 00000000 00000000 00000001，结果y1=1 -5在计算机中补码表示为： 11111111 11111111 11111111 11111011 -5&gt;&gt;&gt;2，左边空出的位补0：00111111 11111111 11111111 11111110，结果为y2=1073741822 问：switchswitch(expr)中，expr是一个整数表达式，因此传递给switch和case语句的参数应该是int、short、char、byte或者其对应的封装类以及Enum类型(byte，short，char都可以隐式转换为int，因此也可以作为expr)，long、String(在Java7中，也支持了String类型)都不能用于swtich表达式。 在switch语句中，表达式的值不能是null，否则会在运行时抛出NullPointerException。在case子句中也不能使用null，否则会出现编译错误。 问：switch与breakswitch结构中匹配的case子句中如果没有break跳出执行，那么程序执行完case子句后不会跳出，将会继续执行后续的case子句，直到遇到break跳出switch；如果一直没有遇到break，程序将一直执行到整个结构结束。 例1： public class SwitchTest{//1 public static void main(String[] args) { System.out.println(switchit(4)); } public static int switchit(int x) { int j=1; switch (x) { case 1:j++; case 2:j++; case 3:j++; case 4:j++; case 5:j++; default:j++; } return j+x; } } 程序将会输出8 例2： public static int getValue(int i) { int result = 0; switch (i) { case 1: result = result + i; case 2: result = result + i * 2; case 3: result = result + i * 3; } return result; } 调用getValue(2)将返回10 问：值传递和引用传递？java内的传递都是值传递。 (1) 对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。 (2) 对引用型变量而言的，传递的是该对象地址的一个副本，所以对引用型变量进行操作会同时改变原对象。 例1： public class Tester{ public static void main(String[] args){ Integer var1=new Integer(1); Integer var2=var1; doSomething(var2); System.out.println(var1.intValue()); System.out.println(var1==var2); } public static void doSomething(Integer integer){ integer=new Integer(2); } } 程序运行输出如下： 1 true 例2：注意下一评论","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"01-Java概述","slug":"01-Java概述","date":"2017-02-13T09:22:19.000Z","updated":"2017-07-22T13:08:14.492Z","comments":true,"path":"2017/02/13/01-Java概述/","link":"","permalink":"https://hepsilion.github.io/2017/02/13/01-Java概述/","excerpt":"Java概述","text":"Java概述 推荐阅读：近5年133个Java面试问题列表 问：什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？Java源文件被javac编译成能被Java虚拟机执行的.class字节码文件，Java虚拟机是一个可以执行Java字节码的虚拟机进程，它拥有自己完善的硬件架构，如堆栈、寄存器，还具有相应的指令系统。 Java虚拟机对开发者屏蔽了与具体操作系统平台相关的信息，使得Java源文件只需要被编译成可以在JVM上运行的字节码文件，就可以由相应平台的虚拟机在具体平台上解释运行，从而实现一次编译，处处执行。这样，Java被设计成允许应用程序可以运行在任意的平台上，而不需要程序员为每一个平台单独重写或者是重新编译。 问：动态语言和静态语言动态语言：运行时执行类型检查，如PHP、Ruby、Python等。 静态语言：编译时执行类型检查，如C、C++、Java和C#等。 问：编译型语言和解释型语言例1 问：JDK和JRE的区别是什么？Java运行时环境(JRE)包括Java虚拟机、Java核心类库和支持文件，JVM对Java字节码文件进行解释执行。只有JRE只能执行Java程序，不能进行java程序的开发。 Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。 例1： JRE判断程序是否执行结束的标准是：所有的前台线程执行完毕 问：一个”.java”源文件中是否可以包含多个类(不是内部类)？有什么限制？一个”.java”源文件中可以包含多个类，但最多只能有一个public类。如果某一个类的修饰符是public，其类名与文件名必须相同。 例1：Java代码查错 Something类的文件名叫OtherThing.java，其中定义的代码如下： class Something { public static void main(String[] args) { System.out.println(&quot;Do something ...&quot;); } } 正确。Java中Class名字不一定要和其文件名相同，但public class的名字必须和文件名相同。 但是这里的main方法不是程序的入口，只能被Something对象调用。 问：javac例1：下列说法正确的有哪些？ A. 环境变量可在编译source code时指定 B. 在编译程序时，所能指定的环境变量不包括class path C. javac一次可同时编译数个Java源文件 D. javac.exe能指定编译结果要置于哪个目录（directory） 答案：A C D 问：JAVA的事件委托机制和垃圾回收机制Java事件委托机制：一个源产生一个事件并将它送到一个或多个监听器那里。在这种方案中，监听器简单的等待，直到它收到一个事件。一旦事件被接受，监听器将处理这个事件，然后返回。 垃圾回收机制：垃圾收集是将分配给对象但不再使用的内存回收或释放的过程。如果一个对象没有指向它的引用或者其赋值为null，则此对象适合进行垃圾回收。 问：Java运行时数据区Java运行时数据区包括：虚拟机栈区，堆区，方法区，本地方法栈，程序计数器 虚拟机栈区：也就是我们常说的栈区，线程私有，在编译期间完成分配，为虚拟机执行Java方法(也就是字节码)服务，每个方法在执行时会创建一个栈帧用于存放局部变量表、操作数栈、动态链接和方法出口等信息，每个方法的调用直至执行完成对应于栈帧的入栈和出栈； 本地方法栈(Native Method Stacks)：线程私有，与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 堆区：JAVA堆，也称GC堆，在JVM启动时创建，所有线程共享，存放对象的实例和数组，是垃圾收集器管理的主要区域。”GC堆”，可以细分为新生代和老年代，新生代又可以细分为Eden空间、From Survivor空间和To Survivor空间；物理上可以不连续，但逻辑上连续，可以选择固定大小或者扩展。 程序计数器：线程私有，每个线程都有自己独立的程序计数器，用来指示下一条指令的地址，是当前线程所执行的字节码的行号指示器，如果线程正执行一个java方法，计数器记录下一条执行的虚拟机字节码指令的地址；如果线程正在执行的是Native方法，则计数器值为空； 方法区：所有线程共享，用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池中的对象的回收和堆类型的卸载。方法区被称为“永久代”，是因为HotSpot虚拟机的设计团队把GC分代收集扩展到方法区，即使用永久代来实现方法区，像GC管理Java堆一样管理方法区，从而省去专门为方法区编写内存管理代码， 运行时常量池：线程共享，是方法区的一部分，存放编译期Class文件中生成的各种字面量和符号引用。 例1 问：堆和栈的区别Java的内存分为两类，一类是栈内存，一类是堆内存。 栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。栈内存由操作系统来分配，只要栈剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用new创建的对象都放在堆里，所以，它不会随方法的结束而消失。堆内存由程序员自己来申请分配。 例1： class A { private String a = &quot;aa&quot;; public boolean methodB() { String b = &quot;bb&quot;; final String c = &quot;cc&quot;; } } 上述Java代码中的变量a、b、c分别在内存的：堆区、栈区、栈区 问：Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)? 需要整理使答案更简洁JVM的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在JVM启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。 堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。 虚拟机中的堆内存共划分为三个代：年轻代（Young Generation）、年老代（Old Generation）和持久代（Permanent Generation）。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。 Java的垃圾收集机制主要针对新生代和老年代的内存进行回收，不同的垃圾收集算法针对不同的区域。所以Java的垃圾收集算法使用的是分代回收。一般java的对象首先进入新生代的Eden区域，当进行GC的时候会回收新生代的区域，新生代一般采用复制收集算法，将活着的对象复制到survivor区域中，如果survivor区域装在不下，就查看老年代是否有足够的空间装下新生代中的对象，如果能装下就装下，否则老年代就执行FULL GC回收自己，老年代还是装不下，就会抛出OutOfMemory的异常。 (1) 年轻代:所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。Minor GC是针对新生代的回收。 年轻代分三个区:一个Eden区，两个Survivor区(一般而言)。 大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区(两个中的一个)，当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。 (2) 年老代:在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。Major GC/Full GC是针对年老代的回收。 (3) 持久代:用于存放静态文件，如类、方法、final常量、static变量等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=进行设置。 例1：JVM中垃圾回收分为scanvenge gc和full GC，其中full GC触发的条件可能有哪些？ 答案：老年代满、持久代满、System.gc() 例2：以下哪些jvm的垃圾回收方式采用的是复制算法回收? A. 新生代串行收集器 B. 老年代串行收集器 C. 并行收集器 D. 新生代并行回收收集器 E. 老年代并行回收收集器 F. cms收集器 答案：A D 例3：下面哪种情况会导致持久区jvm堆内存溢出？ A. 循环上万次的字符串处理 B. 在一段代码内申请上百M甚至上G的内存 C. 使用CGLib技术直接操作字节码运行，生成大量的动态类 D. 不断创建对象 答案：C 问：JVM内存配置参数-Xmx：最大堆大小 -Xms：初始堆大小 -Xmn:年轻代大小 -XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值 例1： 当-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3时，其最小内存值和Survivor区总大小分别是() -Xms初始堆大小即最小内存值，即最小内存值为10240m JVM一般根据对象的生存周期将堆内存分为若干不同的区域，一般情况将新生代分为Eden，两块Survivor； 由-XXSurvivorRatio=3可知Eden:Survivor=3，年轻带总大小为5120m，那么Survivor区总大小为2048m 问：Java中垃圾回收(GC)有什么目的？什么时候进行垃圾回收？GC是垃圾收集的意思(Gabage Collection)，内存处理是编程人员容易出现问题的地方，忘记或者错误地内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的。Java语言没有提供显示地释放已分配内存的操作方法。 垃圾回收器通常是作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。 垃圾回收的目的是识别并回收堆内存中不再使用的对象所占的内存，释放资源。而栈区的内存是随着线程结束而释放的。 对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。 触发主GC(Garbage Collector，垃圾回收)的条件： (1) 当应用程序空闲时，即没有应用线程在运行时，GC会被调用。 (2) Java堆内存不足时，GC会被调用。 问：System.gc()和Runtime.gc()会做什么事情？Java提供了垃圾回收机制来帮助我们不定时的回收堆中不再使用的对象。当JVM启动时，除了启动我们的主线程外，还会启动垃圾回收线程，它运行优先非常低，会在JVM空闲时，自动回收我们不再使用的对象，释放内存空间。 程序员不能强制执行垃圾回收，可以用这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM，即垃圾回收的具体时间和顺序是无法预知的。 问：垃圾回收器的演化 问：如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？不会立即释放对象占用的内存，如果对象的引用被置为null，只是断开了当前线程栈帧中对该对象的引用关系，在下一个垃圾回收周期中，这个对象将是可被回收的。 问：串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？吞吐量收集器使用并行版本的新生代垃圾收集器，它适合于吞吐量要求较高的场合，用于中等规模和大规模数据的应用程序。 串行收集器整个扫描和复制过程均采用单线程的方式，相对于吞吐量GC来说简单；适合于单CPU、客户端级别。串行对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。 问：在Java中，对象什么时候可以被垃圾回收？当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。 问：JVM的永久代中会发生垃圾回收么？(没看懂)垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。 请参考下Java8：从永久代到元数据区(注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区) 问：内存泄漏内存泄露(Memory Leak)是指一个不再被使用的对象或者变量还在内存中占有存储空间。在C/C++语言中，内存泄露出现在开发人员忘记释放已分配的内存就会造成内存泄露。在java语言中引入垃圾回收机制，有GC负责进行回收不再使用的对象，释放内存。但是还是会存在内存泄露的问题。 检查Java中的内存泄露，一定要让程序将各种分支都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。 Java中内存泄露的情况： 长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致它不能被回收，这就是java中内存泄露的发生场景。通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，但是这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是java中可能出现内存泄露的情况。例如，在缓存系统中，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用。 (1) 在堆中申请的空间没有释放； (2) 对象已不再被使用(注意：这里的不再被使用是指对程序来说没有用处，如数据库连接使用后没有关，但是还是存在着引用)，但是仍然在内存中保留着。 GC机制的引入只能解决第一种情况，对于第2种情况无法保证不再使用的对象会被释放。Java语言中的内存泄露主要指第2种情况。 内存泄露的主要场景： (1) 静态集合类。如HashMap和Vector。这些容器是静态的，生命周期和程序的生命周期一致，那么在容器中对象的生命周期也和其一样，对象在程序结束之前将不能被释放，从而会造成内存泄露。 (2) 各种连接。如数据库连接，网络连接，IO连接，不再使用时如果连接不释放容易造成内存泄露。 (3) 监听器。释放对象时往往没有相应的删除监听器，可能会导致内存泄露。 例1：内存泄露举例 class Stack { private Object[] elements = new Object[10]; private int size = 0; public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if (size == 0) throw new EmptyStackException(); return elements[--size]; } private void ensureCapacity() { if (elements.length == size) { Object[] oldElements = elements; elements = new Object[2 * elements.length + 1]; System.arraycopy(oldElements, 0, elements, 0, size); } } } 这个类主要特点就是清空堆栈中的某个元素，并不是彻底把它从数组中拿掉，而是把存储的总数减少。 假如堆栈放了10个元素，然后全部弹出来，虽然堆栈是空的，没有我们要的东西，但是这是个对象是无法回收的，这种情况符合内存泄露的两个条件：无用且无法回收。 正确的做法：在弹出某个元素时，将那个元素所在的位置的值设置为null，让它从数组中消失。 例2：内存泄露举例 public class Test { public static Stack&lt;Object&gt; s= new Stack&lt;Object&gt;(); static{ s.push(new Object()); s.pop(); //这里有一个对象发生内存泄露 s.push(new Object()); //上面的对象可以被回收了，等于是自愈了 } } 因为s是static的，会一直存在直到程序退出，因此其中存储的对象在程序结束之前都不会被释放，存在内存泄漏。 但是我们也可以看到它有自愈功能，例如：如果你的Stack最多有100个对象，那么最多也就只有100个对象无法被回收，Stack内部持有100个引用，最坏的情况就是他们都是无用的。 但是如果我们一旦放新的对象进去，那么对之前对象的引用就会自然消失！ 例3：内存泄露举例 当一个对象被存储进HashSet集合中后，就不能再修改这个对象中的参与计算哈希值的那些字段了。 否则，修改后的对象的哈希值与最初存储进HashSet集合中时的哈希值就不同了。 在这种情况下，即使在contains()方法使用该对象的当前引用作为参数去HashSet集合中检索对象，也将返回找不到对象的结果， 这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露。 内存溢出（OOM）是指程序在申请内存时没有足够的内存供使用，进而导致程序崩溃。内存泄露（Memory Leak）最终会导致内存溢出。 推荐阅读：动手探究Java内存泄露问题 问：assertion(断言)assertion(断言)是软件开发中常用的一种调试方式，很多开发语言都支持这种机制。 在实现中，assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，assert将给出警告或退出。 一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启；为了提高性能，在软件发布后，assertion检查通常是关闭的。 例1： public class Test { public static void main(String[] args) throws Exception { int i = 0; for (i = 0; i &lt; 5; i++) { System.out.println(i); } // 假设程序不小心多了一句--i; --i; assert i == 5; } } 运行：Run --&gt; Run Configurations... --&gt; 选择Arguments选项卡 --&gt; 在VM arguments文本框中输入：-ea 注意：中间没有空格，如果输入 -da 表示禁止断言。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]}]}