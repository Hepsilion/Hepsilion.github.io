<!DOCTYPE html>
<html lang=zh>
<head>
    <meta charset="utf-8">
    
    <title>03-面向对象编程 | Hepsilion</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="author" content="Hepsilion">
    <meta name="email" content="2428091608@qq.com">
    <meta name="keywords" lang="zh-cn" content="博客, 计算机, Java">
    <meta name="description" content="Hepsilion的博客">

    
        <link rel="alternate" href="/" title="Hepsilion" type="application/atom+xml" />
    

    

    <link rel="stylesheet" href="/blog/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/blog/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/blog/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/blog/css/style.css">

    <script src="/blog/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/blog/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/blog/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    
        <script>
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?d08353c90accd3d0f9b4a0e8e62244ab";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>

    


</head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">Hepsilion</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/blog/home">Home</a>
                
                    <a class="main-nav-link" href="/blog/.">Content</a>
                
                    <a class="main-nav-link" href="/blog/archives">Archives</a>
                
                    <a class="main-nav-link" href="/blog/categories">Categories</a>
                
                    <a class="main-nav-link" href="/blog/tags">Tags</a>
                
                    <a class="main-nav-link" href="/blog/about">About</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/blog/css/images/avatar.png" />
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/blog/home">Home</a></td>
                
                    <td><a class="main-nav-link" href="/blog/.">Content</a></td>
                
                    <td><a class="main-nav-link" href="/blog/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/blog/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/blog/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="/blog/about">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer" id="mybody">
            
                

<aside id="profile">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/blog/css/images/avatar.png" />
            <h2 id="name">Hepsilion</h2>
            <h3 id="title">Software Engineer</h3>
            <span id="location"><i class="fa fa-map-marker"></i>Shanghai, China</span>
            <a id="follow" target="_blank" href="https://github.com/Hepsilion">关注我</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                40
                <span>文章</span>
            </div>
            <div class="article-info-block">
                21
                <span>标签</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="/blog/" target="_blank" title="weixin" class=tooltip>
                            <i class="fa fa-weixin"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="http://weibo.com/u/2472060560" target="_blank" title="weibo" class=tooltip>
                            <i class="fa fa-weibo"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="https://www.facebook.com/profile.php?id=100011380133616" target="_blank" title="facebook" class=tooltip>
                            <i class="fa fa-facebook"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/blog/" target="_blank" title="dribbble" class=tooltip>
                            <i class="fa fa-dribbble"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/blog/" target="_blank" title="rss" class=tooltip>
                            <i class="fa fa-rss"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main"><article id="post-03-面向对象编程" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
            03-面向对象编程
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/blog/2017/05/28/03-面向对象编程/">
            <time datetime="2017-05-28T10:14:04.000Z" itemprop="datePublished">2017-05-28</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/blog/categories/Java基础/">Java基础</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/blog/tags/Java/">Java</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>面向对象编程</p>
<a id="more"></a>
<h4 id="问：面向对象的基本特征"><a href="#问：面向对象的基本特征" class="headerlink" title="问：面向对象的基本特征"></a>问：面向对象的基本特征</h4><p>(1) 封装：利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过其对外已授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外提供的接口来访问该对象。</p>
<p>(2) 继承：继承是使用已存在的类作为基础定义新类，新类的定义可以增加新的数据或新的操作，也可以复用父类的操作，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。</p>
<p>(3) 多态：多态就是指程序中定义的引用变量所指向的对象的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p>
<h3 id="问：类"><a href="#问：类" class="headerlink" title="问：类"></a>问：类</h3><p><a href="https://www.nowcoder.com/profile/7404313/test/8066549/979?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a></p>
<h3 id="问：访问控制符"><a href="#问：访问控制符" class="headerlink" title="问：访问控制符"></a>问：访问控制符</h3><p>Java类的成员默认为default访问权限。</p>
<center><br><img src="/blog/2017/05/28/03-面向对象编程/AccessSpecifiers.JPG" width="60%">图 1<br></center>

<p>访问权限大小：public&gt;protected&gt;default&gt;private</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8078128/56331?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a>：分析下面代码的运行结果</p>
<pre><code>class Person{
    private String name = &quot;Person&quot;;
    int age=0;
}
public class Child extends Person{
    public String grade;
    public static void main(String[] args){
        Person p = new Child();
        System.out.println(p.name);
    }
}

答案：程序编译错误。子类无法访问父类的私有成员。
</code></pre><h3 id="问：Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"><a href="#问：Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？" class="headerlink" title="问：Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"></a>问：Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？</h3><p>Java中每一个类都有构造方法，当使用关键字new实例化一个对象时，类的构造方法就会被自动调用，完成对象的初始化工作。</p>
<p>构造方法是一种特殊的方法，具有以下特点:</p>
<p>(1) 构造方法的方法名必须与类名相同；</p>
<p>(2) 构造方法没有返回值类型，也不能定义为void；</p>
<p>(3) 构造方法不能被static、final、synchronized、abstract、native等关键字修饰，但可以被public、private、protected修饰</p>
<p>(4) 一个类可以定义多个构造方法，如果在定义类时没有定义构造方法，则编译系统会自动插入一个无参数的默认构造方法，这个构造器不执行任何代码；</p>
<p>(5) 构造方法可以被重载，以参数的个数、类型、顺序进行区分；</p>
<p>(6) 构造方法不能被继承，因此不能被重写，子类使用父类的构造方法需要使用super关键字</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8066549/25830?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a></p>
<p>Java中构造方法重载和方法重载很相似，可以为一个类创建多个构造方法，每一个构造方法必须有它自己唯一的参数列表。</p>
<p>Java不支持像C++中那样的复制构造方法，但是这并不代表Java中没有这种机制，Java中Object类的clone()方法就是这种机制的体现。</p>
<h3 id="问：new关键字"><a href="#问：new关键字" class="headerlink" title="问：new关键字"></a>问：new关键字</h3><p><a href="https://www.nowcoder.com/profile/7404313/test/8049404/56502?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a></p>
<h3 id="问：this关键字"><a href="#问：this关键字" class="headerlink" title="问：this关键字"></a>问：this关键字</h3><h3 id="问：static关键字"><a href="#问：static关键字" class="headerlink" title="问：static关键字"></a>问：static关键字</h3><p>“static”关键字可以用于修饰类的成员变量和成员方法，被其修饰的成员变量被称为类变量，被其修饰的成员方法称为类方法，它们随着类的加载而加载，使得这些变量和方法可以在类没有被实例化的情况下直接通过类名进行访问。</p>
<p>(1) 被static修饰的成员方法只能访问static成员，不可以访问非static成员</p>
<p>Java中被static修饰的变量和方法是属于类的，它们随着类的加载而加载，同时对static变量进行初始化并执行static代码块。如果static环境中的代码尝试访问非static的变量，编译器会报错，因为<strong>类的加载先于变量的创建，类加载的时候这些变量还没有被创建出来</strong>，例如，在static方法中访问某对象的非static方法，此时尚不能保证对象已经被实例化。因此在static环境中不能访问非static变量。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/7958772/56439?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a></p>
<pre><code>package NowCoder;
class Test {
    public static void hello() {
        System.out.println(&quot;hello&quot;);
    }
}
public class MyApplication {
    public static void main(String[] args) {
        Test test=null;
        test.hello();
    }
}

上述代码：能编译通过，并正确运行
</code></pre><p>(2) Java中静态变量只能在类主体中定义，不能在方法中定义。</p>
<p>静态变量属于类所有而不属于方法所有。静态变量是在方法之前被加载的，在static加载时，方法还没有分配空间。所以static变量只能是类成员变量，而不能是局部变量。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8109636/56377?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a>分析下面代码的执行结果。</p>
<pre><code>public class Test {
    public int aMethod() {
        static int i = 0;
        i++;
        return i;
    }
    public static void main (String args[]) {
        Test test = new Test();
        test.aMethod();
        int j = test.aMethod();
        System.out.println(j);
    }
}

答案：程序编译失败
</code></pre><h3 id="问：继承"><a href="#问：继承" class="headerlink" title="问：继承"></a>问：继承</h3><p>继承时类的实例化问题：在实例化一个类时，一定是先创建其父类对象，即先执行父类的构造函数，然后再创建当前类对象。如果子类没有显示地调用父类的构造函数，编译器会自动加入父类的无参的构造函数super()(这也要求父类要有无参数的构造函数，否咋将出现编译出错)。</p>
<p><a href="" title="Title">例1：</a></p>
<pre><code>package test; 
class FatherClass { 
    public FatherClass() { 
        System.out.println(&quot;FatherClass Create&quot;); 
    } 
} 

class ChildClass extends FatherClass { 
    public ChildClass() { 
        System.out.println(&quot;ChildClass Create&quot;); 
    } 
    public static void main(String[] args) { 
        FatherClass fc = new FatherClass(); 
        ChildClass cc = new ChildClass(); 
    } 
} 

程序的输出结果如下：
FatherClass Create 
FatherClass Create 
ChildClass Create
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/8070641/56330" title="Title" target="_blank" rel="external">例2</a></p>
<h3 id="问：Java支持多继承么？"><a href="#问：Java支持多继承么？" class="headerlink" title="问：Java支持多继承么？"></a>问：Java支持多继承么？</h3><p>Java中的类不支持多继承，只支持单继承(即一个类只有一个父类)。 但是Java中的接口支持多继承，即一个子接口可以有多个父接口。(接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能)。</p>
<h3 id="问：super和this"><a href="#问：super和this" class="headerlink" title="问：super和this"></a>问：super和this</h3><p>this代表当前类对象，super代表当前类对象的父类对象。</p>
<p>在子类构造方法中，使用super()调用的是其父类的构造方法，而使用this()调用的是同一个类中重载的构造方法</p>
<p><strong>super关键字</strong></p>
<p>(1) Java中子类不能继承父类的构造方法，只能调用父类构造方法；</p>
<p>(2) 子类的构造方法可以显示地使用super调用父类构造方法；</p>
<p>(3) 当子类构造方法中没有显示地使用super来调用父类构造方法时，系统会默认采用super()调用父类的无参构造方法，这时父类必须提供无参构造方法，否则编译出错。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8066549/15538?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a>，<a href="https://www.nowcoder.com/profile/7404313/test/7958772/55361?onlyWrong=0" title="Title" target="_blank" rel="external">例2</a>，<a href="https://www.nowcoder.com/profile/7404313/test/8049404/15324?onlyWrong=0" title="Title" target="_blank" rel="external">例3</a>，<a href="https://www.nowcoder.com/profile/7404313/test/7977669/22482?onlyWrong=0" title="Title" target="_blank" rel="external">例4</a>    </p>
<p><strong>this关键字</strong></p>
<p><strong>注意：</strong></p>
<p>(1) 使用super()或this()时，它们必须放在构造方法的第一行，否则编译通不过。</p>
<p>(2) 由于this()调用的构造函数默认调用super()方法，所以规定this()和super()不能同时出现在一个构造函数中。</p>
<p>(3) static环境，包括static方法和static语句块，在执行时还没有构造对象实例，因此<strong>不能在static环境中使用this和super</strong></p>
<h3 id="问：Java中的方法重写-Overriding-和方法重载-Overloading-是什么意思？"><a href="#问：Java中的方法重写-Overriding-和方法重载-Overloading-是什么意思？" class="headerlink" title="问：Java中的方法重写(Overriding)和方法重载(Overloading)是什么意思？"></a>问：Java中的方法重写(Overriding)和方法重载(Overloading)是什么意思？</h3><p>方法重写和方法重载都是Java多态性的不同表现(动态绑定 dynamic binding)</p>
<p>(1) 方法重载是一个类中多态性的一种表现，发生在同一个类里面两个或多个方法的方法名相同但是参数列表不同的情况。</p>
<ul>
<li>函数名必须相同；</li>
<li>函数参数列表必须不相同，可以是参数个数、参数类型或者参数顺序不同；</li>
<li>函数的返回值类型、修饰符可以相同，也可以不相同；</li>
</ul>
<p>(2) 方法重写是父类与子类之间多态性的一种表现，是说子类重新定义了父类的方法；方法的重写满足两同两小一大原则</p>
<ul>
<li>方法名相同，参数类型相同</li>
<li>子类方法返回值类型小于或等于父类方法返回值类型；</li>
<li>子类方法抛出的异常类型小于或等于父类方法抛出的异常类型；</li>
<li>子类方法访问权限大于或等于父类方法访问权限 (public&gt;protected&gt;defualt(默认修饰符)&gt;private)。</li>
</ul>
<p>注意：Java不支持运算符重载。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/7993658/44624?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a></p>
<h3 id="问：Java中是否可以覆盖-override-一个被private或static修饰的方法？"><a href="#问：Java中是否可以覆盖-override-一个被private或static修饰的方法？" class="headerlink" title="问：Java中是否可以覆盖(override)一个被private或static修饰的方法？"></a>问：Java中是否可以覆盖(override)一个被private或static修饰的方法？</h3><p>private修饰的方法不能被覆盖，因为被private修饰的父类方法在子类中是不可见的。</p>
<p>Java中静态方法在形式上可以被重写，即子类中可以重写父类中静态的方法。但是实际上从内存的角度上静态方法不可以被重写，因为<strong>方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的</strong>。static方法跟类的任何实例都不相关，所以概念上不适用。</p>
<h3 id="问：final关键字"><a href="#问：final关键字" class="headerlink" title="问：final关键字"></a>问：final关键字</h3><p>final关键字可以用于修饰类、变量和方法。</p>
<p>(1) final修饰的类不可被继承(因此一个类不能同时被final和abstract修饰)；</p>
<p>(2) final修饰的方法不可被重写；</p>
<p>(3) final修饰的变量的值不可被修改，一旦获得初始值，该变量就不能被重新赋值。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8070641/15311?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a>，<a href="https://www.nowcoder.com/profile/7404313/test/8073294/22481?onlyWrong=0" title="Title" target="_blank" rel="external">例2</a>，<a href="https://www.nowcoder.com/profile/7404313/test/8078128/14994?onlyWrong=0" title="Title" target="_blank" rel="external">例3</a></p>
<p>(4) 形式参数只能用final修饰符，任何其它修饰符都会引起编译错误。但是用这个修饰符也有一定的限制，就是在方法中不能对参数做任何修改。不过在一般情况下，一个方法的形参不用final修饰。只有在特殊情况下：方法内部类，一个方法的内部类如果使用了这个方法的参数或局部变量，这个参数或局部变量应该是final。</p>
<p>(5) final修饰的成员变量既可以在定义时显示地初始化，也可以先声明而不初始化，这种成员变量称为blank final，此时可以在构造代码块或构造函数中对其赋初值，否则使用未赋初值的final变量时编译会报错。</p>
<p><a href="" title="Title">例1：</a></p>
<pre><code>class Foo {
    final int i;
    int j;
    public void doSomething() {
        System.out.println(++j + i);  // 编译出错，因为final成员变量在使用前没有赋初值
    }
}
</code></pre><p><a href="https://www.nowcoder.com/questionTerminal/48f183240e8d4ec3aeecc90337a396a0" title="Title" target="_blank" rel="external">例2：</a>这一题解释尚不明确，不知道final方法在子类中继承了没有。</p>
<pre><code>public class Car extends Vehicle{
    public static void main(String[] args){
        new Car().run();    //输出：Car
    }
    private final void run(){
        System.out.println(&quot;Car&quot;);
    }
}
class Vehicle{
    private final void run(){
        System.out.println(&quot;Vehicle&quot;);
    }
}
</code></pre><p>问题已解决：子类会继承父类的所有属性和方法，或者说子类拥有父类的所有属性和方法，但是子类无法直接访问父类的私有属性和私有方法。</p>
<p>这里由于子类无法访问父类的run()方法，因此子类并没有重写父类的run()方法，而是自己重新定义了run()方法。</p>
<p>(6) 被fianl修饰的变量参与运算时不会自动改变类型；当2个final修饰的变量相操作时，结果会根据左边变量的类型进行转化</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8109636/44646?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a></p>
<pre><code>byte b1=1,b2=2,b3,b6,b8;
final byte b4=4,b5=6,b7;
b3=(b1+b2);  /*语句1*/
b6=b4+b5;    /*语句2*/
b8=(b1+b4);  /*语句3*/
b7=(b2+b5);  /*语句4*/
System.out.println(b3+b6);

代码片段中，存在编辑错误的语句是：语句1、语句3和语句4
语句1错误：b3=(b1+b2);自动转为int，所以正确写法为b3=(byte)(b1+b2);或者将b3定义为int；
语句2正确：b6=b4+b5;b4、b5为final类型，不会自动提升，计算结果任然是byte类型，然后结果的类型视左边变量类型而定，即b6可以是任意数值类型；
语句3错误：b8=(b1+b4);虽然b4不会自动提升，但b1仍会自动提升，所以结果需要强转，b8=(byte)(b1+b4);
语句4错误：b7=(b2+b5); 同上。同时注意b7是final修饰，即只可赋值一次，便不可再改变。
</code></pre><h3 id="问：Object类"><a href="#问：Object类" class="headerlink" title="问：Object类"></a>问：Object类</h3><p>Java中Object是所有类的祖先类，Object类中包含如下方法：</p>
<center><br><img src="/blog/2017/05/28/03-面向对象编程/Object-Methods.png" width="100%">图 1<br></center>

<h3 id="问：equals-方法和-的区别"><a href="#问：equals-方法和-的区别" class="headerlink" title="问：equals()方法和==的区别"></a>问：equals()方法和==的区别</h3><ul>
<li><p>==运算符：对于基本数据类型变量比较的是两个变量的值是否相等；对于引用型变量表示的是两个变量指向的对象在堆中存储的地址是否相同，即栈中的内容是否相同</p>
</li>
<li><p>equals()方法：继承自Object类，默认调用==进行比较。判断两个对象是否相等需要覆盖equals()方法和hashcode()方法。</p>
</li>
</ul>
<h3 id="问：finalize-方法什么时候被调用？析构函数-finalization-的目的是什么？"><a href="#问：finalize-方法什么时候被调用？析构函数-finalization-的目的是什么？" class="headerlink" title="问：finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？"></a>问：finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？</h3><p>finalize()是Object类的一个方法，垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法。</p>
<p>但是很不幸的是，在Java中，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说finalize()可能永远不会被执行，显然指望它做收尾工作是靠不住的。 那么finalize()究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。</p>
<h3 id="问：clone，没遇到过，暂时存放"><a href="#问：clone，没遇到过，暂时存放" class="headerlink" title="问：clone，没遇到过，暂时存放"></a>问：clone，没遇到过，暂时存放</h3><p>42、写clone()方法时，通常都有一行代码，是什么？<br>Clone有缺省行为，super.clone();他负责产生正确大小的空间，并逐位复制。</p>
<h3 id="问：多态的实现方式"><a href="#问：多态的实现方式" class="headerlink" title="问：多态的实现方式"></a>问：多态的实现方式</h3><p>(1) 静态的多态：方法重载</p>
<p>(2) 动态的多态：子类覆盖父类的方法，将子类的实例赋值给父类的引用，此时调用的是子类的方法；实现接口的实例赋值给接口的引用，此时调用的实现类的方法。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8049404/14992?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a>判断对错</p>
<pre><code>在java的多态调用中，new的是哪一个类就是调用的哪个类的方法。

答案：错误。

没看懂题目后面的评论，不知道跟重载有什么关系。目前我觉得下面例子是一个反例。

class Father {
    public static void run(){
        System.out.println(&quot;Father run&quot;);
    }
}
public class Child extends Father {
    public static void run(){
        System.out.println(&quot;Child run&quot;);
    }
    public static void main(String[] args) {
        Person p = new Child();
        p.run(); //这里调用的实际上是父类的run()方法
    }
}
</code></pre><h3 id="问：抽象类和接口的区别"><a href="#问：抽象类和接口的区别" class="headerlink" title="问：抽象类和接口的区别"></a>问：抽象类和接口的区别</h3><p>Java提供和支持创建抽象类和接口。</p>
<p>含有abstract修饰符的class即为抽象类，abstract类不能创建类的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中定义的抽象方法必须在具体(Concrete)子类中实现，如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。构造方法和静态方法不可以为抽象的。</p>
<p>接口(interface)可以说成是抽象类的一种特例</p>
<p>它们的不同点在于：</p>
<p>从设计层面来说，抽象是对类的抽象，是一种模板设计；接口是行为的抽象，是一种行为的规范。</p>
<p><strong>理解即可</strong></p>
<p>(1) 抽象类和接口都不可以被实例化</p>
<p><strong>(2)</strong> 抽象类中可以包含普通成员变量、静态成员变量；而接口中没有普通成员变量、只有常量，接口中声明的成员变量默认为public static final类型，且只能是public static final类型；</p>
<p><strong>(3)</strong> 抽象类中可以同时包含抽象方法和非抽象方法，也可以没有抽象方法，但如果一个类中有一个抽象方法，那么当前类一定是抽象类；而接口中只有方法的声明、没有方法体，即接口中的所有方法必须都是抽象的，不能有非抽象的普通方法(<strong>Java8中接口可以有非抽象的default方法</strong>)</p>
<p>(4) 抽象类中的抽象方法，需要由子类实现，如果子类不实现所有抽象方法，则子类也需要定义为抽象类；接口中定义的方法都需要由实现类来实现，如果实现类不能实现接口中的所有方法，则实现类需要定义为抽象类</p>
<p><strong>(5)</strong> 抽象类中可以有构造方法，其作用是初始化抽象类的成员；接口中不能有构造方法</p>
<p><strong>(6)</strong> 抽象类中的成员方法的访问类型可以为public、protected和private，抽象方法必须为public或protected；而接口中的成员方法的访问类型默认为public abstract类型，且只能是public abstract</p>
<p>(7) 抽象类中可以包含静态方法；而接口中不能包含静态方法(<strong>Java8开始接口可以有静态方法</strong>) </p>
<p>(8) 抽象类可以implements接口；接口可以继承接口，并且接口可以实现多继承(一个接口可以继承多个接口)</p>
<p>(9) 一个类最多只能继承一个类，但一个类可以实现多个接口</p>
<p>(10) 类可以不实现抽象类和接口中声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的</p>
<p>(11) 抽象方法既不能是static的，也不能是native的，还不能是synchronized的</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/7906972/15179?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a>，<a href="https://www.nowcoder.com/profile/7404313/test/8073294/14303?onlyWrong=0" title="Title" target="_blank" rel="external">例2</a>，<a href="https://www.nowcoder.com/profile/7404313/test/8100292/15000?onlyWrong=0" title="Title" target="_blank" rel="external">例3</a>，<a href="https://www.nowcoder.com/profile/7404313/test/8078128/36678?onlyWrong=0" title="Title" target="_blank" rel="external">例4</a></p>
<h3 id="问：instanceof关键字"><a href="#问：instanceof关键字" class="headerlink" title="问：instanceof关键字"></a>问：instanceof关键字</h3><p>instanceof前一个参数通常是一个引用类型变量，后一个操作数通常是一个类（也可以是一个接口）。它用于判断前面的变量引用的对象是否是后面的类(也可以是一个接口)或者其子类的实例。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/7964595/3035?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a></p>
<pre><code>public static void main(String args[]) {
    List  Listlist1 = new ArrayList();
    Listlist1.add(0);
    List Listlist2 = Listlist1;
    System.out.println(Listlist1.get(0) instanceof Integer);
    System.out.println(Listlist2.get(0) instanceof Integer);
}

上面代码将输出：true true
Collection类型的集合（ArrayList,LinkedList）只能装入对象类型的数据
该题中需要装入0，是一个基本类型，但是JDK5以后提供了自动装箱与自动拆箱，所以int类型自动装箱变为了Integer类型。
List没有使用泛型，因此使用get(0)取出的元素的编译类型是Object型的，但运行时类型是Integer，所以打印true，这里体现了多态的应用。
而Listlist1把引用赋给了Listlist2，说明两个指向同一个对象，因此第二个打印的也是true。
</code></pre><h3 id="问：内部类"><a href="#问：内部类" class="headerlink" title="问：内部类"></a>问：内部类</h3><p><strong>内部类分类</strong>，来自例2中评论部分BlueFish的总结。</p>
<p>(1) 成员内部类</p>
<pre><code>public class Outer{
    private String name=&quot;Outer&quot;;
    private int age=99;

    public static void main(String[] args){
        Outer outer=new Outer();
        Inner inner=outer.new Inner();
        inner.show();
    }

    private class Inner{
        private String name=&quot;Inner&quot;;
        private final int num=10;
        public void show(){
            System.out.println(Outer.this.name);
            System.out.println(this.name);
            System.out.println(age);
        }
    }
}
</code></pre><ul>
<li>Inner类定义在Outer类的内部(相当于Outer类的一个成员变量的位置处)，Inner类可以使用任意访问控制符，如public、protected、private等；</li>
<li>Inner 类中定义的show()方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问Outer类中的私有属性age；</li>
<li>定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去new一个内部类对象，即：<strong>内部类 对象名=外部类对象.new 内部类()</strong>;</li>
<li>编译上面的程序后，会发现产生了两个.class文件: Outer.class和Outer$Inner.class</li>
<li>成员内部类中不能存在任何static的变量和方法，但可以定义常量:<ul>
<li>因为非静态内部类的存在是依赖于外部类的实例的，而静态变量和方法是不依赖于对象的，仅与类相关。而在加载静态域时，根本没有外部类实例，所在在非静态内部类中不能定义静态变量或方法，编译不通过;非静态内部类的作用域是实例级别</li>
<li>常量是在编译器时确定的，放到所谓的常量池了，因此可以定义常量。</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ul>
<li>外部类是不能直接使用内部类的成员和方法的，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法；</li>
<li>如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用this关键字，如:Outer.this.name</li>
</ul>
<p>(2) 静态内部类，static修饰的内部类</p>
<pre><code>public class Outer{
    private static String name=&quot;Outer&quot;;
    private static String tag=&quot;tag&quot;;
    private int age=99;

    public static void main(String[] args){
        Inner inner=new Inner();
        inner.show();
    }

    private static class Inner{
        private String name=&quot;Inner&quot;;
        public void show(){
            System.out.println(Outer.name);
            System.out.println(this.name);
            System.out.println(tag);
            System.out.println(new Outer().age);
        }
    }
}
</code></pre><ul>
<li>静态内部类不能直接访问外部类的非静态成员，但可以通过<strong>new 外部类().成员</strong>的方式访问 </li>
<li>如果外部类的静态成员与内部类的成员名称相同，可通过<strong>类名.静态成员</strong>的方式访问外部类的静态成员；</li>
<li>如果外部类的静态成员与内部类的成员名称不相同，则可通过<strong>成员名</strong>直接调用外部类的静态成员；</li>
<li>创建静态内部类的对象时，不需要外部类的对象，可以直接创建<strong>内部类 对象名=new 内部类()</strong>;</li>
</ul>
<p>(3) 方法内部类，访问仅限于方法内或者该作用域内</p>
<pre><code>public class Outer {
    public static void main(String[] args) {
        Outer outer = new Outer();
        outer.print();
    }

    public void print() {
        final int a = 25;
        class Inner {
            private int c = 2;

            public void show() {
                System.out.println(a);
                System.out.println(c);
            }
        }
        Inner inner = new Inner();
        inner.show();
    }
}
</code></pre><ul>
<li>方法内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的</li>
<li>方法内部类不能修改方法中定义的局部变量(<strong>解释看原评论，原评论这部分，我测试有点问题</strong>，大概原因是内部类访问方法局部变量时会拷贝局部变量，对局部变量修改会造成拷贝的局部变量值与方法中局部变量值不一致，为了保持局部变量值的一致性，可以将被内部类访问的局部变量声明为final)</li>
</ul>
<p>(4) 匿名内部类</p>
<pre><code>public class Outer{
    public static void main(String[] args){
        Outer outer=new Outer();
        InnerClass inner=outer.getInnerClass(2, &quot;inner&quot;);
        System.out.println(inner.getNumber());
    }

    public InnerClass getInnerClass(int num, String str){
        return new InnerClass(){
            int count;
            int number=num+1;

            {
                count=100;
            }

            @Override
            public int getNumber() {
                return number;
            }
        };
    }

    private interface InnerClass{
        int getNumber();
    }
}
</code></pre><ul>
<li>匿名内部类是直接使用 new 来生成一个对象的引用；</li>
<li>对于匿名内部类的使用，它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用；</li>
<li>使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口；</li>
<li>匿名内部类中是不能定义构造函数的，匿名内部类中不能存在任何的静态成员变量和静态方法；</li>
<li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法；</li>
<li><strong>匿名内部类初始化:使用构造代码块!</strong> 利用构造代码块能够达到为匿名内部类创建一个构造器的效果</li>
</ul>
<p><strong>内部类的作用</strong></p>
<ul>
<li>隐藏内部操作细节</li>
<li>解决多重继承的问题</li>
</ul>
<p>第二点作用是使用内部类最吸引人的原因，它的存在使得Java的继承机制更加完善。众所周知，Java中的类只能继承一个类，它的多重继承在我们没有学习内部类之前是用接口来实现的，但是使用接口会存在很多不方便的地方，比如我们实现一个接口就必须实现它里面的所有方法；而有了内部类情况就不一样了，它可以让我们的类间接地继承多个抽象类或具体类：我们可以在外部类中定义多个内部类，每个内部类都可以独立地继承一个抽象类或具体类，然后再外部类中创建内部类的对象，并使用内部类的方法，这样就可以变相地实现了多继承。</p>
<p>例如我们有两个类Class1和Class2:</p>
<pre><code>class Class1{
    public void fun1(){
        System.out.println(&quot;Class1 fun1()&quot;);
    }
}
class Class2{
    public void fun2(){
        System.out.println(&quot;Class2 fun2()&quot;);
    }
}
</code></pre><p>如果我们想要类Test既有Class1的特性，又有Class2的特性，就必须让Test类既继承Class1，又继承Class2，可是这在Java的单继承使得这种方式不可实现。那又怎么办呢？我们可以在Test中实现两个内部类InnerClass1和InnerClass2，让他们分别继承Class1和Class2，然后在Test中创建InnerClass1和InnerClass2的对象，通过这些对象调用Class1和Class2的方法，间接实现多继承。</p>
<pre><code>public class Test {
    public void fun1(){
        new InnerClass1().fun1();
    }
    public void fun2(){
        new InnerClass2().fun2();
    }

    class InnerClass1 extends Class1{
    }
    class InnerClass2 extends Class2{
    }
}
</code></pre><p>使用内部类还能够为我们带来如下特性:</p>
<ul>
<li>内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立；</li>
<li>在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类；</li>
<li>创建内部类对象的时刻并不依赖于外围类对象的创建；</li>
<li>内部类并没有令人迷惑的”is-a”关系，他就是一个独立的实体；</li>
<li>内部类提供了更好的封装，除了该外围类，其他类都不能访问。</li>
</ul>
<p>说实话，上面的特性没读懂，为了保持内容完整性，姑且放在这里吧。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8045843/7673?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a> 重要</p>
<p>非静态内部类是属于对象的，所以初始化时需要先初始化一个外部类实例对象，然后使用此对象调用内部类的构造方法。静态内部类属于类本身，初始化时直接使用外部类调用静态内部类的构造方法即可</p>
<pre><code>public class Test{
    public static void main(String[] args){
        EnclosingOne.InsideOne obj1=new EnclosingOne().new InsideOne(); //非静态内部类
        EnclosingOne.InsideTwo obj2=new EnclosingOne.InsideTwo();       //静态内部类
    }
}
class EnclosingOne {
    //非静态内部类
    public class InsideOne {
    }
    //静态内部类
    public static class InsideTwo{
    }
}
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/8066549/5120?onlyWrong=0" title="Title" target="_blank" rel="external">例2：</a>往OuterClass类的代码段中插入内部类声明，哪一个是错误的？</p>
<pre><code>public class OuterClass{
    private float f=1.0f;
    //插入代码到这里
}

A.    class InnerClass{
        public static float func(){
            return f;
        }
    }
B.    abstract class InnerClass{
        public abstract float func(){}
    }
C.    static class InnerClass{
        protected static float func(){
            return f;
        }
    }
D.    public class InnerClass{
        static float func(){
            return f;
        }
    }

答案：ABCD
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/8073294/4332?onlyWrong=0" title="Title" target="_blank" rel="external">例3</a></p>
<h3 id="问：Static-Nested-Class和Inner-Class的不同？"><a href="#问：Static-Nested-Class和Inner-Class的不同？" class="headerlink" title="问：Static Nested Class和Inner Class的不同？"></a>问：Static Nested Class和Inner Class的不同？</h3><p>Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化，而通常的内部类需要在外部类实例化后才能实例化。 </p>
<h3 id="问：Java类加载时的初始化顺序"><a href="#问：Java类加载时的初始化顺序" class="headerlink" title="问：Java类加载时的初始化顺序"></a>问：Java类加载时的初始化顺序</h3><p>(1) 初始化父类中的静态成员变量和静态代码块(按照在程序中出现的顺序初始化)</p>
<p>(2) 初始化子类中的静态成员变量和静态代码块(按照在程序中出现的顺序初始化)</p>
<p>(3) 初始化父类中的普通成员变量和构造代码块(按照在程序中出现的顺序初始化)，然后再执行父类中的构造方法</p>
<p>(4) 初始化子类中的普通成员变量和构造代码块(按照在程序中出现的顺序初始化)，然后再执行子类中的构造方法</p>
<p>例1：</p>
<pre><code>class Member {
    Member(String str) {
        System.out.println(str);
    }
}
class A {
    static {
        System.out.println(&quot;父类静态代码块&quot;);
    }
    public A() {
        System.out.println(&quot;父类构造函数&quot;);
    }
    {
        System.out.println(&quot;父类构造代码块&quot;);
    }
    Member member=new Member(&quot;父类成员变量&quot;);
}
class B extends A {
    Member member=new Member(&quot;子类成员变量&quot;);
    static {
        System.out.println(&quot;子类静态代码块&quot;);
    }
    public B() {
        System.out.println(&quot;子类构造函数&quot;);
    }
    {
        System.out.println(&quot;子类构造代码块&quot;);
    }
}
public class Test{
    public static void main(String[] args) {
        new B();
    }
}

//输出：
父类静态代码块
子类静态代码块
父类构造代码块
父类成员变量
父类构造函数
子类成员变量
子类构造代码块
子类构造函数
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/7964595/14700?onlyWrong=0" title="Title" target="_blank" rel="external">例2：</a>下面代码的输出是什么？(易错)</p>
<pre><code>public class B {
    public static B t1 = new B();
    public static B t2 = new B();
    {
        System.out.println(&quot;构造块&quot;);
    }
    static {
        System.out.println(&quot;静态块&quot;);
    }
    public static void main(String[] args) {
        B t = new B();
    }
}

// 输出

构造块
构造块
静态块
构造块
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/8066549/3212?onlyWrong=0" title="Title" target="_blank" rel="external">例3：</a>下面代码的输出是什么？(易错)</p>
<pre><code>public class Base {
    private String baseName = &quot;base&quot;;

    public Base() {
        callName();
    }

    public void callName() {
        System.out.println(baseName);
    }

    static class Sub extends Base {
        private String baseName = &quot;sub&quot;;

        public void callName() {
            System.out.println(baseName);
        }
    }

    public static void main(String[] args) {
        Base b = new Sub();
    }
}

// 输出：null

实例化子类对象时会先调用父类构造方法，由于父类构造方法调用了callName()方法并且子类重写了此方法，因此父类构造方法将调用子类的callName()方法将输出子类成员变量baseName的值。
但是由于子类的成员变量在父类构造方法调用完才会赋初值，因此调用callName()方法时，baseName值为null，所以输出结果为null。
</code></pre><h3 id="问：JNI-Java-Native-Interface-没怎么遇到过，暂时保留"><a href="#问：JNI-Java-Native-Interface-没怎么遇到过，暂时保留" class="headerlink" title="问：JNI(Java Native Interface) (没怎么遇到过，暂时保留)"></a>问：JNI(Java Native Interface) (没怎么遇到过，暂时保留)</h3><p>Java的不足除了体现在运行速度上要比传统的C++慢许多之外，还体现在Java无法直接访问底层操作系统（如系统硬件等)，为此Java使用native方法来扩展Java程序的功能。</p>
<p>native是方法修饰符，native方法是由另外一种语言（如C/C++,汇编等）实现的本地方法，因为在外部实现了方法，所以在java代码中，就不需要声明了，有点类似于接口中的抽象方法。其实现步骤为：</p>
<ul>
<li>在Java中声明native()方法，然后编译；</li>
<li>用javah产生一个.h文件；</li>
<li>写一个.cpp文件实现native导出方法，其中需要包含第二步产生的.h文件（注意其中又包含了JDK带的jni.h文件）；</li>
<li>将第三步的.cpp文件编译成动态链接库文件；</li>
<li>在Java中用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问了。</li>
</ul>
<p><a href="https://www.nowcoder.com/profile/7404313/test/7964595/22484?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a>以下声明合法的是：</p>
<pre><code>A. default String s
B. public final static native int w()
C. abstract double d
D. abstract final double hyperbolicCosine()

答案：B
native可以和任何修饰符连用，abstract除外。因为native暗示这个方法时有实现体的，而abstract却显式指明了这个方法没有实现体。
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/7971730/7665?onlyWrong=0" title="Title" target="_blank" rel="external">例2：</a>Which of the following can be applied to constructors?</p>
<pre><code>A. final  B. static  C. synchronized  D. native  E. None of these.

答案：E

abstract方法和native方法都是方法的声明，一个把方法实现移交给子类，另一个移交给本地操作系统。
如果同时出现，就相当于既把实现移交给子类，又把实现移交给本地操作系统，那就会产生混乱。

Java构造方法可以有任何访问的修饰：public，protected，private或者没有修饰。
但是不能有以下非访问性质的修饰：abstract，final，native，static，或者synchronized。
</code></pre>
        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="https://hepsilion.github.io/2017/05/28/03-面向对象编程/" data-id="cj59o3wsj000udgwr7amimlh0" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="https://hepsilion.github.io/2017/05/28/03-面向对象编程/#comments" class="article-comment-link disqus-comment-count" data-disqus-url="https://hepsilion.github.io/2017/05/28/03-面向对象编程/">评论</a>
    

        </footer>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/blog/2017/05/28/02-基础语法/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">上一篇</strong>
            <div class="article-nav-title">
                
                    02-基础语法
                
            </div>
        </a>
    
    
        <a href="/blog/2017/05/28/04-异常处理/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">下一篇</strong>
            <div class="article-nav-title">04-异常处理</div>
        </a>
    
</nav>


    
</article>


    
    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>

    
    </section>

</section>
            
                <aside id="sidebar">
   <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/blog/',
        CONTENT_URL: '/blog/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/blog/js/insight.js"></script>

</div> 
   
        
    <div class="widget-wrap">
        <h3 class="widget-title"><i class="fa fa-edit"></i>最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/blog/2017/06/06/MapReduce/" class="thumbnail">
    
    
        <span style="background-image:url(https://wx2.sinaimg.cn/small/e3dde130ly1fft6ucav3vj20zk0iyq5v.jpg)" alt="MapReduce" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/blog/2017/06/06/MapReduce/" class="title">MapReduce</a></p>
                            <p class="item-date"><time datetime="2017-06-06T14:06:35.000Z" itemprop="datePublished">2017-06-06</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/blog/2017/06/01/09-网络编程/" class="thumbnail">
    
    
        <span style="background-image:url(https://cdn.pixabay.com/photo/2017/01/11/08/31/icon-1971128__340.png)" alt="第九章 网络编程" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/blog/categories/Android基础/">Android基础</a></p>
                            <p class="item-title"><a href="/blog/2017/06/01/09-网络编程/" class="title">第九章 网络编程</a></p>
                            <p class="item-date"><time datetime="2017-06-01T12:46:32.000Z" itemprop="datePublished">2017-06-01</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/blog/2017/06/01/08-Service/" class="thumbnail">
    
    
        <span style="background-image:url(https://cdn.pixabay.com/photo/2017/01/11/08/31/icon-1971128__340.png)" alt="第八章 服务" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/blog/categories/Android基础/">Android基础</a></p>
                            <p class="item-title"><a href="/blog/2017/06/01/08-Service/" class="title">第八章 服务</a></p>
                            <p class="item-date"><time datetime="2017-06-01T12:45:55.000Z" itemprop="datePublished">2017-06-01</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/blog/2017/06/01/07-BroadcastReceiver/" class="thumbnail">
    
    
        <span style="background-image:url(https://cdn.pixabay.com/photo/2017/01/11/08/31/icon-1971128__340.png)" alt="第七章 广播接收者" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/blog/categories/Android基础/">Android基础</a></p>
                            <p class="item-title"><a href="/blog/2017/06/01/07-BroadcastReceiver/" class="title">第七章 广播接收者</a></p>
                            <p class="item-date"><time datetime="2017-06-01T12:44:40.000Z" itemprop="datePublished">2017-06-01</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/blog/2017/06/01/06-ContentProvider/" class="thumbnail">
    
    
        <span style="background-image:url(https://cdn.pixabay.com/photo/2017/01/11/08/31/icon-1971128__340.png)" alt="第六章 ContentProvider" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/blog/categories/Android基础/">Android基础</a></p>
                            <p class="item-title"><a href="/blog/2017/06/01/06-ContentProvider/" class="title">第六章 ContentProvider</a></p>
                            <p class="item-date"><time datetime="2017-06-01T12:43:55.000Z" itemprop="datePublished">2017-06-01</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title"><i class="fa fa-folder"></i>分类</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Android基础/">Android基础</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/C-C/">C/C++</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Java-Web/">Java Web</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Java基础/">Java基础</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/并发/">并发</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/概率论与数理统计/">概率论与数理统计</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/环境配置/">环境配置</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/算法/">算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/计算机基础/">计算机基础</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title"><i class="fa fa-archive"></i>归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/06/">六月 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/05/">五月 2017</a><span class="archive-list-count">32</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title"><i class="fa fa-tag"></i>标签</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Android/">Android</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/C/">C++</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Java/">Java</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Linux/">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/SQL/">SQL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Web/">Web</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/docker/">docker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/hadoop/">hadoop</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/信息安全/">信息安全</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/并发/">并发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/操作系统/">操作系统</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/数据库/">数据库</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/数据结构/">数据结构</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/数理统计/">数理统计</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/概率论/">概率论</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/算法/">算法</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/计算机组成原理/">计算机组成原理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/计算机网络/">计算机网络</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/设计模式/">设计模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/软件工程/">软件工程</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/软件测试/">软件测试</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title"><i class="fa fa-link"></i>友链</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://hexo.io" target="_blank">Hexo</a>
                    </li>
                
                    <li>
                        <a href="http://yuren.space/blog" target="_blank">渔人</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2017 Hepsilion<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        
    
    <script>
    var disqus_config = function () {
        
            this.page.url = 'https://hepsilion.github.io/2017/05/28/03-面向对象编程/';
        
        this.page.identifier = '03-面向对象编程';
    };
    (function() { 
        var d = document, s = d.createElement('script');  
        s.src = '//' + 'hepsilion-github-io' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>




    
        <script src="/blog/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/blog/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/blog/js/main.js"></script>

    </div>
</body>
</html>