<!DOCTYPE html>
<html lang=zh>
<head>
    <meta charset="utf-8">
    
    <title>Java | Hepsilion</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="author" content="Hepsilion">
    <meta name="email" content="2428091608@qq.com">
    <meta name="keywords" lang="zh-cn" content="博客, 计算机, Java">
    <meta name="description" content="Hepsilion的博客">

    
        <link rel="alternate" href="/" title="Hepsilion" type="application/atom+xml" />
    

    

    <link rel="stylesheet" href="/blog/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/blog/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/blog/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/blog/css/style.css">

    <script src="/blog/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/blog/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/blog/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    
        <script>
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?d08353c90accd3d0f9b4a0e8e62244ab";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>

    


</head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">Hepsilion</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/blog/home">Home</a>
                
                    <a class="main-nav-link" href="/blog/.">Content</a>
                
                    <a class="main-nav-link" href="/blog/archives">Archives</a>
                
                    <a class="main-nav-link" href="/blog/categories">Categories</a>
                
                    <a class="main-nav-link" href="/blog/tags">Tags</a>
                
                    <a class="main-nav-link" href="/blog/about">About</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/blog/css/images/avatar.png" />
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/blog/home">Home</a></td>
                
                    <td><a class="main-nav-link" href="/blog/.">Content</a></td>
                
                    <td><a class="main-nav-link" href="/blog/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/blog/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/blog/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="/blog/about">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer" id="mybody">
            
                

<aside id="profile">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/blog/css/images/avatar.png" />
            <h2 id="name">Hepsilion</h2>
            <h3 id="title">Software Engineer</h3>
            <span id="location"><i class="fa fa-map-marker"></i>Shanghai, China</span>
            <a id="follow" target="_blank" href="https://github.com/Hepsilion">关注我</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                32
                <span>文章</span>
            </div>
            <div class="article-info-block">
                20
                <span>标签</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="/blog/" target="_blank" title="weixin" class=tooltip>
                            <i class="fa fa-weixin"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="http://weibo.com/u/2472060560" target="_blank" title="weibo" class=tooltip>
                            <i class="fa fa-weibo"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="https://www.facebook.com/profile.php?id=100011380133616" target="_blank" title="facebook" class=tooltip>
                            <i class="fa fa-facebook"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/blog/" target="_blank" title="dribbble" class=tooltip>
                            <i class="fa fa-dribbble"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/blog/" target="_blank" title="rss" class=tooltip>
                            <i class="fa fa-rss"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main"><article id="post-Java" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
            Java
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/blog/2017/05/28/Java/">
            <time datetime="2017-05-28T10:47:23.000Z" itemprop="datePublished">2017-05-28</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/blog/categories/Java/">Java</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/blog/tags/Java/">Java</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>Java整合</p>
<a id="more"></a>
<h2 id="一、-Java概述"><a href="#一、-Java概述" class="headerlink" title="一、 Java概述"></a>一、 Java概述</h2><h3 id="问：什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"><a href="#问：什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？" class="headerlink" title="问：什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"></a>问：什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h3><p>Java源文件被javac编译成能被Java虚拟机执行的.class字节码文件，Java虚拟机是一个可以执行Java字节码的虚拟机进程，它拥有自己完善的硬体架构，如堆栈、寄存器，还具有相应的指令系统。</p>
<p>Java虚拟机对开发者屏蔽了与具体操作系统平台相关的信息，使得Java源文件只需要被编译成可以在JVM上运行的字节码文件，就可以由<strong>相应平台的虚拟机</strong>在具体平台上解释运行，从而实现一次编译，处处执行。这样，Java被设计成允许应用程序可以运行在任意的平台上，而不需要程序员为每一个平台单独重写或者是重新编译。</p>
<h3 id="问：动态语言和静态语言"><a href="#问：动态语言和静态语言" class="headerlink" title="问：动态语言和静态语言"></a>问：动态语言和静态语言</h3><p>动态语言：运行时执行类型检查，如PHP、Ruby、Python等。</p>
<p>静态语言：编译时执行类型检查，如C、C++、Java和C#等。</p>
<h3 id="问：编译型语言和解释型语言"><a href="#问：编译型语言和解释型语言" class="headerlink" title="问：编译型语言和解释型语言"></a>问：编译型语言和解释型语言</h3><p><a href="https://www.nowcoder.com/profile/7404313/test/8049404/3231?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a></p>
<h3 id="问：JDK和JRE的区别是什么？"><a href="#问：JDK和JRE的区别是什么？" class="headerlink" title="问：JDK和JRE的区别是什么？"></a>问：JDK和JRE的区别是什么？</h3><p>Java运行时环境(JRE)包括Java虚拟机、Java核心类库和支持文件，JVM对Java字节码文件进行解释执行。只有JRE只能执行Java程序，不能进行java程序的开发。</p>
<p>Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8078128/56325?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a></p>
<pre><code>JRE判断程序是否执行结束的标准是：所有的前台线程执行完毕
</code></pre><h3 id="问：一个”-java”源文件中是否可以包括多个类-不是内部类-？有什么限制？"><a href="#问：一个”-java”源文件中是否可以包括多个类-不是内部类-？有什么限制？" class="headerlink" title="问：一个”.java”源文件中是否可以包括多个类(不是内部类)？有什么限制？"></a>问：一个”.java”源文件中是否可以包括多个类(不是内部类)？有什么限制？</h3><p>一个”.java”源文件中可以包括多个类。如果这个类的修饰符是public，其类名与文件名必须相同。</p>
<h3 id="问：javac"><a href="#问：javac" class="headerlink" title="问：javac"></a>问：javac</h3><p><a href="https://www.nowcoder.com/profile/7404313/test/8078128/973?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a>下列说法正确的有哪些？</p>
<pre><code>A. 环境变量可在编译source code时指定
B. 在编译程序时，所能指定的环境变量不包括class path
C. javac一次可同时编译数个Java源文件
D. javac.exe能指定编译结果要置于哪个目录（directory）

答案：A C D
</code></pre><h3 id="问：JAVA的事件委托机制和垃圾回收机制"><a href="#问：JAVA的事件委托机制和垃圾回收机制" class="headerlink" title="问：JAVA的事件委托机制和垃圾回收机制"></a>问：JAVA的事件委托机制和垃圾回收机制</h3><p>Java事件委托机制：一个源产生一个事件并将它送到一个或多个监听器那里。在这种方案中，监听器简单的等待，直到它收到一个事件。一旦事件被接受，监听器将处理这个事件，然后返回。</p>
<p>垃圾回收机制：垃圾收集是将分配给对象但不再使用的内存回收或释放的过程。如果一个对象没有指向它的引用或者其赋值为null，则此对象适合进行垃圾回收。</p>
<h3 id="问：Java运行时数据区"><a href="#问：Java运行时数据区" class="headerlink" title="问：Java运行时数据区"></a>问：Java运行时数据区</h3><p>Java运行时数据区包括：虚拟机栈区，堆区，方法区，本地方法栈，程序计数器</p>
<ul>
<li><p>虚拟机栈区：也就是我们常说的栈区，<strong>线程私有</strong>，在编译期间完成分配，为虚拟机执行Java方法(也就是字节码)服务，每个方法在执行时会创建一个栈帧用于存放局部变量表、操作数栈、动态链接和方法出口等信息，每个方法的调用直至执行完成对应于栈帧的入栈和出栈；</p>
</li>
<li><p>堆区：JAVA堆，也称GC堆，在JVM启动时创建，<strong>所有线程共享</strong>，存放对象的实例和数组，是垃圾收集器管理的主要区域。”GC堆”，可以细分为新生代和老年代，新生代又可以细分为Eden空间、From Survivor空间和To Survivor空间；物理上可以不连续，但逻辑上连续，可以选择固定大小或者扩展。</p>
</li>
<li><p>方法区：<strong>所有线程共享</strong>，用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池中的对象的回收和堆类型的卸载。方法区被称为“永久代”，是因为HotSpot虚拟机的设计团队把GC分代收集扩展到方法区，即使用永久代来实现方法区，像GC管理Java堆一样管理方法区，从而省去专门为方法区编写内存管理代码，</p>
</li>
<li><p>本地方法栈(Native Method Stacks)：<strong>线程私有</strong>，与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
</li>
<li><p>程序计数器：<strong>线程私有</strong>，每个线程都有自己独立的程序计数器，用来指示下一条指令的地址，是当前线程所执行的字节码的行号指示器，如果线程正执行一个java方法，计数器记录下一条执行的虚拟机字节码指令的地址；如果线程正在执行的是Native方法，则计数器值为空；</p>
</li>
<li><p>运行时常量池：<strong>线程共享</strong>，是方法区的一部分，存放编译期Class文件中生成的各种字面量和符号引用。</p>
</li>
</ul>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8045843/14817?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a></p>
<h3 id="问：堆和栈的区别"><a href="#问：堆和栈的区别" class="headerlink" title="问：堆和栈的区别"></a>问：堆和栈的区别</h3><p>栈内存由操作系统来分配，只要栈剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出</p>
<p>堆内存由程序员自己来申请分配</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8045843/23410?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a></p>
<pre><code>class A {
    private String a = &quot;aa&quot;;
    public boolean methodB() {
        String b = &quot;bb&quot;;
        final String c = &quot;cc&quot;;
    }
}

上述Java代码中的变量a、b、c分别在内存的：堆区、栈区、栈区
</code></pre><h3 id="问：Java堆的结构是什么样子的？什么是堆中的永久代-Perm-Gen-space-需要整理使答案更简洁"><a href="#问：Java堆的结构是什么样子的？什么是堆中的永久代-Perm-Gen-space-需要整理使答案更简洁" class="headerlink" title="问：Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)? 需要整理使答案更简洁"></a>问：Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)? 需要整理使答案更简洁</h3><p>JVM的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在JVM启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。</p>
<p>堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。</p>
<p>虚拟机中的堆内存共划分为三个代：<strong>年轻代（Young Generation）、年老代（Old Generation）和持久代（Permanent Generation）</strong>。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。</p>
<p>Java的垃圾收集机制主要针对新生代和老年代的内存进行回收，不同的垃圾收集算法针对不同的区域。所以java的垃圾收集算法使用的是分代回收。一般java的对象首先进入新生代的Eden区域，当进行GC的时候会回收新生代的区域，新生代一般采用复制收集算法，将活着的对象复制到survivor区域中，如果survivor区域装在不下，就查看老年代是否有足够的空间装下新生代中的对象，如果能装下就装下，否则老年代就执行FULL GC回收自己，老年代还是装不下，就会抛出OUtOfMemory的异常。</p>
<p>(1) <strong>年轻代</strong>:所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。Minor GC是针对新生代的回收。</p>
<p>年轻代分三个区:一个Eden区，两个Survivor区(一般而言)。</p>
<p>大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区(两个中的一个)，当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p>
<p>(2) <strong>年老代</strong>:在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。Major GC/Full GC是针对年老代的回收。</p>
<p>(3) <strong>持久代</strong>:用于存放静态文件，如类、方法、final常量、static变量等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=<n>进行设置。</n></p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/7932407/50975?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a>JVM中垃圾回收分为scanvenge gc和full GC，其中full GC触发的条件可能有哪些？</p>
<pre><code>答案：老年代满、持久代满、System.gc()
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/7945971/36411?onlyWrong=0" title="Title" target="_blank" rel="external">例2：</a>以下哪些jvm的垃圾回收方式采用的是复制算法回收?</p>
<pre><code>A. 新生代串行收集器  B. 老年代串行收集器  C. 并行收集器  D. 新生代并行回收收集器  E. 老年代并行回收收集器  F. cms收集器

答案：A D
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/7964595/14849?onlyWrong=0" title="Title" target="_blank" rel="external">例3：</a>下面哪种情况会导致持久区jvm堆内存溢出？</p>
<pre><code>A. 循环上万次的字符串处理 
B. 在一段代码内申请上百M甚至上G的内存
C. 使用CGLib技术直接操作字节码运行，生成大量的动态类
D. 不断创建对象

答案：C
</code></pre><h3 id="问：JVM内存配置参数"><a href="#问：JVM内存配置参数" class="headerlink" title="问：JVM内存配置参数"></a>问：JVM内存配置参数</h3><pre><code>-Xmx：最大堆大小
-Xms：初始堆大小
-Xmn:年轻代大小
-XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值
</code></pre><p>例1：</p>
<pre><code>当-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3时，其最小内存值和Survivor区总大小分别是()

-Xms初始堆大小即最小内存值，即最小内存值为10240m
JVM一般根据对象的生存周期将堆内存分为若干不同的区域，一般情况将新生代分为Eden，两块Survivor；
由-XXSurvivorRatio=3可知Eden:Survivor=3，年轻带总大小为5120m，那么Survivor区总大小为2048m
</code></pre><h3 id="问：Java中垃圾回收-GC-有什么目的？什么时候进行垃圾回收？"><a href="#问：Java中垃圾回收-GC-有什么目的？什么时候进行垃圾回收？" class="headerlink" title="问：Java中垃圾回收(GC)有什么目的？什么时候进行垃圾回收？"></a>问：Java中垃圾回收(GC)有什么目的？什么时候进行垃圾回收？</h3><p>GC是垃圾收集的意思(Gabage Collection)，内存处理是编程人员容易出现问题的地方，忘记或者错误地内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的。</p>
<p>垃圾回收的目的是<strong>识别并回收堆内存</strong>中不再使用的对象所占的内存，释放资源。而栈区的内存是随着线程结束而释放的。</p>
<p>触发主GC(Garbage Collector，垃圾回收)的条件：</p>
<p>(1) 当应用程序空闲时，即没有应用线程在运行时，GC会被调用。</p>
<p>(2) Java堆内存不足时，GC会被调用。</p>
<h3 id="问：System-gc-和Runtime-gc-会做什么事情？"><a href="#问：System-gc-和Runtime-gc-会做什么事情？" class="headerlink" title="问：System.gc()和Runtime.gc()会做什么事情？"></a>问：System.gc()和Runtime.gc()会做什么事情？</h3><p>Java提供了垃圾回收机制来帮助我们不定时的回收堆中不再使用的对象。当JVM启动时，除了启动我们的主线程外，还会启动垃圾回收线程，它运行优先非常低，会在JVM空闲时，自动回收我们不再使用的对象，释放内存空间。</p>
<p>程序员不能强制执行垃圾回收，可以用这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM，即垃圾回收的具体时间和顺序是无法预知的。</p>
<h3 id="问：垃圾回收器的演化"><a href="#问：垃圾回收器的演化" class="headerlink" title="问：垃圾回收器的演化"></a>问：垃圾回收器的演化</h3><center><br><img src="/2017/05/28/Java/GabageCollector.jpg" width="60%">图 1<br></center>

<h4 id="问：如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"><a href="#问：如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？" class="headerlink" title="问：如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"></a>问：如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</h4><p>不会立即释放对象占用的内存，如果对象的引用被置为null，只是断开了当前线程栈帧中对该对象的引用关系，在下一个垃圾回收周期中，这个对象将是可被回收的。</p>
<h4 id="问：串行-serial-收集器和吞吐量-throughput-收集器的区别是什么？"><a href="#问：串行-serial-收集器和吞吐量-throughput-收集器的区别是什么？" class="headerlink" title="问：串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？"></a>问：串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？</h4><p>吞吐量收集器使用并行版本的新生代垃圾收集器，它适合于吞吐量要求较高的场合，用于中等规模和大规模数据的应用程序。</p>
<p>串行收集器整个扫描和复制过程均采用单线程的方式，相对于吞吐量GC来说简单；适合于单CPU、客户端级别。串行对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。</p>
<h3 id="问：在Java中，对象什么时候可以被垃圾回收？"><a href="#问：在Java中，对象什么时候可以被垃圾回收？" class="headerlink" title="问：在Java中，对象什么时候可以被垃圾回收？"></a>问：在Java中，对象什么时候可以被垃圾回收？</h3><p>当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。</p>
<h3 id="问：JVM的永久代中会发生垃圾回收么？-没看懂"><a href="#问：JVM的永久代中会发生垃圾回收么？-没看懂" class="headerlink" title="问：JVM的永久代中会发生垃圾回收么？(没看懂)"></a>问：JVM的永久代中会发生垃圾回收么？(没看懂)</h3><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。</p>
<p>请参考下Java8：从永久代到元数据区(注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)</p>
<h3 id="问：内存泄漏"><a href="#问：内存泄漏" class="headerlink" title="问：内存泄漏"></a>问：内存泄漏</h3><p>内存泄露(Memory Leak)是指一个不再被使用的对象或者变量还在内存中占有存储空间。在C/C++语言中，内存泄露出现在开发人员忘记释放已分配的内存就会造成内存泄露。在java语言中引入垃圾回收机制，有GC负责进行回收不再使用的对象，释放内存。但是还是会存在内存泄露的问题。</p>
<p><strong>内存泄露主要有两种情况</strong></p>
<p>(1) 在堆中申请的空间没有释放。</p>
<p>(2) 对象已不再被使用(注意：这里的不再被使用是指对程序来说没有用处，如数据库连接使用后没有关，但是还是存在着引用)，但是仍然在内存中保留着。</p>
<p>GC机制的引入只能解决第一种情况，对于第2种情况无法保证不再使用的对象会被释放。java语言中的内存泄露主要指第2种情况。</p>
<p><strong>内存泄露的原因</strong></p>
<p>(1) 静态集合类。如HashMap和Vector。这些容器是静态的，生命周期和程序的生命周期一致，那么在容器中对象的生命周期也和其一样，对象在程序结束之前将不能被释放，从而会造成内存泄露。</p>
<p>(2) 各种连接。如数据库连接，网络连接，IO连接，不再使用时如果连接不释放容易造成内存泄露。</p>
<p>(3) 监听器。释放对象时往往没有相应的删除监听器，可能会导致内存泄露。</p>
<p>内存溢出（OOM）是指程序在申请内存时没有足够的内存供使用，进而导致程序崩溃这是结果描述。内存泄露（Memory Leak）最终会导致内存溢出。</p>
<h2 id="二、-基础语法"><a href="#二、-基础语法" class="headerlink" title="二、 基础语法"></a>二、 基础语法</h2><h3 id="问：关键字和保留字"><a href="#问：关键字和保留字" class="headerlink" title="问：关键字和保留字"></a>问：关键字和保留字</h3><p>(1) Java关键字列表(依字母排序共50组)</p>
<pre><code>abstract, assert, boolean, break, byte, case, catch, char, class, const(保留关键字), continue, default, do, double, else, enum, extends, 
final, finally, float, for, goto(保留关键字), if, implements, import, instanceof, int, interface, long, native, new, package, private, 
protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while 
</code></pre><p>(2) 保留字列表(依字母排序共14组)，Java保留字是指现有Java版本尚未使用，但以后版本可能会作为关键字使用 </p>
<pre><code>byValue, cast, false, future, generic, inner, operator, outer, rest, true, var, goto(保留关键字), const(保留关键字), null
</code></pre><p>注意：</p>
<p>(1) const和goto既是保留字又是关键字</p>
<p>(2) 除了const和goto，其余保留字和关键字是严格区分开的。</p>
<h3 id="问：Java支持的数据类型有哪些？"><a href="#问：Java支持的数据类型有哪些？" class="headerlink" title="问：Java支持的数据类型有哪些？"></a>问：Java支持的数据类型有哪些？</h3><p>Java语言支持8种基本数据类型是：byte、short、int、long、float、double、boolean、char；支持3种引用数据类型：类、接口和数组。</p>
<p>(1) Java中整数值默认为int型，如果要指定整数为long型需要加L；浮点数值默认为double型，如果要指定浮点数为float型需要加F。</p>
<pre><code>float f=3.4;  //错误，3.4默认为double型。
float f=3.4F; //正确
float f=3;    //正确
</code></pre><p>(2) Java中在定义类的成员变量时可以对其初始化，如果不对其初始化，Java使用默认值对其初始化；而局部变量在使用前则必须进行初始化，JVM不会进行默认值初始化。<br>(3) Java中基本数据类型变量默认初始化值如表所示，对象引用默认初始化值为null。</p>
<center><br><img src="/2017/05/28/Java/PrimitiveType.JPG" width="70%">图 2<br></center>

<h3 id="问：Java中的中文字符"><a href="#问：Java中的中文字符" class="headerlink" title="问：Java中的中文字符"></a>问：Java中的中文字符</h3><p>Java语言中，中文字符所占的字节数取决于字符的编码方式，默认使用GBK编码方式。</p>
<pre><code>当采用ISO8859-1编码方式时，一个中文字符占1个字节；

当采用GB2312或GBK编码方式时，一个中文字符占2个字节；

当采用UTF-8编码方式时，一个中文字符会占3个字节。
</code></pre><p>Java字符默认使用unicode编码，每个字符占用两个字节，所以char型变量可以存放一个中文字符。</p>
<blockquote>
<p>Unicode字符编码标准是固定长度的字符编码方案。Unicode根据要编码的数据类型使用两种编码格式：8 位和16位。缺省编码格式是16位，即每个字符是16位(两个字节)宽。</p>
</blockquote>
<p>注意：char与byte在Java和C++中的区别：</p>
<blockquote>
<p>在C++中，char是基础数据类型，占1个字节；byte不是基础数据类型，一般定义为typedef unsigned char byte;也就是说，byte其实是unsigned char类型，那么也是占1个字节。不同的是，char可以表示的范围是-128-127，而byte可以表示的范围是0-255。</p>
<p>在java中，char和byte都是基础数据类型，其中的byte占1个字节，可以表示的范围是-128-127。而char占2个字节，可以表示的范围是’\u0000’-‘\uFFFF’。</p>
</blockquote>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8070641/3412?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a></p>
<pre><code>Java中实现国际化应用常用的手段是利用ResourceBundle类。

这个题目解答没看懂
</code></pre><h3 id="问：类型转换"><a href="#问：类型转换" class="headerlink" title="问：类型转换"></a>问：类型转换</h3><p>(1) byte\char\short -&gt; int -&gt; long -&gt; float -&gt; double</p>
<p>(2) Java中如果碰到char、byte和short参与运算时，会自动将这些值转换为int类型值然后再进行运算。</p>
<pre><code>short s1 = 1; 
s1 = s1 + 1; //错误，s1+1运算结果是int型，需要强制转换类型

short s1 = 1; 
s1 += 1;    //正确

short s = 16;
byte a2 = s; //错误
</code></pre><p>(3) 低级向高级是隐式类型转换，高级向低级必须强制类型转换</p>
<p>(4) 两个数值进行二元操作时，会有如下的转换操作：</p>
<ul>
<li>如果两个操作数其中有一个是double类型，另一个操作数将会转换为double类型；</li>
<li>否则，如果其中一个操作数是float类型，另一个操作数将会转换为float类型；</li>
<li>否则，如果其中一个操作数是long类型，另一个操作数会转换为long类型；</li>
<li>否则，两个操作数都转换为int类型。</li>
</ul>
<p><a href="https://www.nowcoder.com/profile/7404313/test/7993658/25900?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a></p>
<pre><code>public static void main(String[] args){
    int i=42;
    double d=42.0000;
    long l=42;
    float f=42.0f;
    float f2=42.00f;
    System.out.println(d==i);   //true
    System.out.println(f==i);   //true
    System.out.println(f==f2);  //true
    System.out.println(l==i);   //true
    System.out.println(l==f);   //true
    System.out.println(d==f);   //true
}
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/8004321/25817?onlyWrong=0" title="Title" target="_blank" rel="external">例2：</a></p>
<pre><code>对于java类型变量char c，short s，float f，double d，表达式c*s+f+d的结果类型为double
</code></pre><h3 id="问：进制表示"><a href="#问：进制表示" class="headerlink" title="问：进制表示"></a>问：进制表示</h3><ul>
<li>八进制： 012</li>
<li>十六进制：0x12</li>
</ul>
<h3 id="问：源码、反码和补码"><a href="#问：源码、反码和补码" class="headerlink" title="问：源码、反码和补码"></a>问：源码、反码和补码</h3><p><a href="https://www.nowcoder.com/questionTerminal/c4b42ebc2e4b44f693b3a8372e7c1ee1" title="Title" target="_blank" rel="external">例1：</a></p>
<pre><code>变量a是一个64位有符号的整数，初始值用16进制表示为：0Xf000000000000000；
变量b是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF。
则a-b的结果用10进制表示为多少？

计算机是用补码进行存储和计算的，因此a和b的初始值即为a和b在计算机中的补码形式，即：a的补码为0Xf000000000000000，b的补码为0x7FFFFFFFFFFFFFFF
0Xf000000000000000=1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
0x7FFFFFFFFFFFFFFF=0111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111

a-b=a+(-b)
由于b是正数，原码与其补码相同，都为0x7FFFFFFFFFFFFFFF，则-b的原码为0xFFFFFFFFFFFFFFFF，是负数
现在求-b的补码，先对它的原码(除符号位外)各位取反得到-b的反码，然后反码尾部加1得到-b的补码，为
1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001

所以a-b=a+(-b)=
1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000+
1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001=
10111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001(最高位溢出，舍去，结果变成了正数)
则结果为0111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001=2^62+2^61+2^60+1
</code></pre><p><br><br><a href="https://www.nowcoder.com/profile/7404313/test/7977669/55201" title="Title" target="_blank" rel="external">例2：</a></p>
<pre><code>变量a是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF;
变量b是一个64位有符号的整数，初始值用16进制表示为：0x8000000000000000。
则a+b的结果用10进制表示为多少？

计算机中是以补码形式存储数据，则a和b的初始值即为a和b在计算机中的补码形式。
0x7FFFFFFFFFFFFFFF+0x8000000000000000=0xFFFFFFFFFFFFFFFF
结果最高位符号位为1，说明结果为负数，现在求结果的原码值。
保持符号位不变，补码减1，得到结果的反码；保持符号位不变，反码取反，得到结果的原码：-1
</code></pre><p><br><br><a href="https://www.nowcoder.com/profile/7404313/test/8100292/3459?onlyWrong=0" title="Title" target="_blank" rel="external">例3：</a></p>
<pre><code>short a=128；
byte b=(byte)a;
此时，变量a，b的值分别为128和-128

计算机是用补码进行存储和计算的，Java中short占2个字节，16位，因此a在内存中补码形式为0000 0000 1000 0000
Java中byte占1个字节，8位。将short变量强制类型转换时会截断前8位，得到1000 0000，即为b的补码形式。
现在已知a的补码为10000000，求原码。因为最高位表示符号位，所以首先这个数为负数。
保持符号位不变，补码减1，得到结果的反码1111 1111；保持符号位不变，反码取反，得到结果的原码1 0000 0000：-128
</code></pre><h3 id="问：常见的运算符-，-，-，三目运算符，-，-amp-amp-和-amp-，-gt-gt-和-gt-gt-gt"><a href="#问：常见的运算符-，-，-，三目运算符，-，-amp-amp-和-amp-，-gt-gt-和-gt-gt-gt" class="headerlink" title="问：常见的运算符 +，%，~，三目运算符，++，&amp;&amp;和&amp;，&gt;&gt;和&gt;&gt;&gt;"></a>问：常见的运算符 +，%，~，三目运算符，++，&amp;&amp;和&amp;，&gt;&gt;和&gt;&gt;&gt;</h3><ul>
<li>+：</li>
</ul>
<p>例1：</p>
<pre><code>public class Test {
    public static void main(String args[]) {
        System.out.println(8+8+&quot;88&quot;+8+8);  //168888
    }
}
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/7958772/56865?onlyWrong=0" title="Title" target="_blank" rel="external">例2：</a></p>
<pre><code>若有定义语句：int a=10; double b=3.14;则表达式&apos;A&apos;+a+b 值的类型是double
</code></pre><ul>
<li><p>%：取模运算符，要求操作数为整型。</p>
</li>
<li><p>~：按位取反运算符</p>
</li>
</ul>
<p>例1：</p>
<pre><code>若int j = 10; 则~j为多少？

计算机是用补码进行存储和计算的，因此10在计算机中补码存储为：00000000 00000000 00000000 00001010
~j操作是对j的补码取反，然后得到结果即为~j的补码：         11111111 11111111 11111111 11110101
现在通过~j的补码反推出~j的原码，~j最高位符号位为1，表明它是一个负数
保持符号位不变，补码减1，得到~j的反码：                  11111111 11111111 11111111 11110100
保持符号位不变，反码取反，得到~j的原码：                 10000000 00000000 00000000 00001011
换算为整数，~j大小为-11
</code></pre><ul>
<li>三目运算符</li>
</ul>
<p><a href="https://www.nowcoder.com/profile/7404313/test/7964595/36740?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a></p>
<pre><code>boolean b=true?false:true==true?false:true;
System.out.println(b);  //false
</code></pre><ul>
<li>++</li>
</ul>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8073949/56289?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a></p>
<pre><code>假定x和y为double型，则表达式x=2，y=x+3/2的输出为3.000000
</code></pre><p><strong>i=i++问题</strong></p>
<p>Java使用了中间缓存变量机制，JVM运行这条语句时过程如下：</p>
<p>步骤1 JVM把i值拷贝到临时变量区；</p>
<p>步骤2　i值加1；</p>
<p>步骤3　返回临时变量区的值，注意这个值步骤1中没修改过的i值。 </p>
<p>步骤4　返回值赋值给i，此时count值被重置成原来的值。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8049404/14765?onlyWrong=0" title="Title" target="_blank" rel="external">例2：</a></p>
<pre><code>package algorithms.com.guan.javajicu; 
public class Inc { 
    public static void main(String[] args) { 
       Inc inc = new Inc(); 
       int i = 0; 
       inc.fermin(i); 
       i= i ++; 
       System.out.println(i);
    } 
    void fermin(int i){ 
       i++; 
    } 
}

程序输出结果为0
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/8070641/16022?onlyWrong=0" title="Title" target="_blank" rel="external">例3：</a></p>
<pre><code>public class Test2{
    public void add(Byte b){
        b = b++;
    }
    public void test(){
        Byte a = 127;
        Byte b = 127;
        add(++a);
        System.out.print(a + &quot; &quot;);
        add(b);
        System.out.print(b + &quot;&quot;);
    }
}

执行test()函数后，程序输出为：-128 127
</code></pre><ul>
<li>&amp;&amp;和&amp;</li>
</ul>
<p>&amp;&amp;:短路与，若该运算符左边为false，运算符右边表达式不执行。</p>
<p>&amp;: 按位与，若该运算符左边为false，运算符右边表达式还会继续执行。</p>
<ul>
<li>>&gt;和&gt;&gt;&gt;</li>
</ul>
<p>>&gt; 表示带符号右移</p>
<p>>&gt;&gt; 表示无符号右移，左边空出的位以0填充</p>
<pre><code>int x=5&gt;&gt;2;  // &gt;&gt;表示带符号右移，5&gt;&gt;2相当于5除于2的平方，等于1
int y=1&gt;&gt;&gt;2; // &gt;&gt;&gt;表示无符号右移，高位用0填充，0001右移两位为0000，等于0
</code></pre><h3 id="问：switch"><a href="#问：switch" class="headerlink" title="问：switch"></a>问：switch</h3><p>switch(expr)中，expr是一个整数表达式，因此传递给switch和case语句的参数应该是int、short、char、byte或者其对应的封装类以及Enum类型，long、String(<strong>在Java7中，也支持了String类型</strong>)都不能用于swtich表达式。</p>
<p>在switch语句中，表达式的值不能是null，否则会在运行时抛出NullPointerException。在case子句中也不能使用null，否则会出现编译错误。</p>
<h3 id="问：switch与break"><a href="#问：switch与break" class="headerlink" title="问：switch与break"></a>问：switch与break</h3><p>switch结构中匹配的case子句中如果没有break跳出执行，那么程序执行完case子句后不会跳出，将会继续执行后续的case子句，直到遇到break跳出switch；如果一直没有遇到break，程序将一直执行到整个结构结束。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8100292/26058?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a></p>
<pre><code>public class SwitchTest{//1
    public static void main(String[] args) {
        System.out.println(switchit(4));
    }
    public static int switchit(int x) {
        int j=1;
        switch (x) {
        case 1:j++;
        case 2:j++;
        case 3:j++;
        case 4:j++;
        case 5:j++;
        default:j++;
        }
        return j+x;
    }
}
程序将会输出8
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/8066549/22459?onlyWrong=0" title="Title" target="_blank" rel="external">例2：</a></p>
<pre><code>public static int getValue(int i) {
    int result = 0;
    switch (i) {
    case 1:
        result = result + i;
    case 2:
        result = result + i * 2;
    case 3:
        result = result + i * 3;
    }
    return result;
}
调用getValue(2)将返回10
</code></pre><h4 id="问：值传递和引用传递？"><a href="#问：值传递和引用传递？" class="headerlink" title="问：值传递和引用传递？"></a>问：值传递和引用传递？</h4><p>java内的传递都是值传递。</p>
<p>(1) 对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。</p>
<p>(2) 对引用型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身，所以对引用对象进行操作会同时改变原对象。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/7977669/5119?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a></p>
<pre><code>public class Tester{
public static void main(String[] args){
   Integer var1=new Integer(1);
   Integer var2=var1;
   doSomething(var2);
   System.out.println(var1.intValue());
   System.out.println(var1==var2);
}
public static void doSomething(Integer integer){
    integer=new Integer(2);
    }
}

程序运行输出如下：
1
true
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/8045843/22461?onlyWrong=0" title="Title" target="_blank" rel="external">例2：</a>注意下一评论</p>
<h2 id="三、-面向对象编程"><a href="#三、-面向对象编程" class="headerlink" title="三、 面向对象编程"></a>三、 面向对象编程</h2><h4 id="问：面向对象的基本特征"><a href="#问：面向对象的基本特征" class="headerlink" title="问：面向对象的基本特征"></a>问：面向对象的基本特征</h4><p>(1) 封装：利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过对外已授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。</p>
<p>(2) 继承：继承是使用已存在的类作为基础定义新类，新类的定义可以增加新的数据或新的操作，也可以复用父类的操作，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。</p>
<p>(3) 多态：多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p>
<h3 id="问：类"><a href="#问：类" class="headerlink" title="问：类"></a>问：类</h3><p><a href="https://www.nowcoder.com/profile/7404313/test/8066549/979?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a></p>
<h3 id="问：访问控制符"><a href="#问：访问控制符" class="headerlink" title="问：访问控制符"></a>问：访问控制符</h3><p>Java类的成员默认为default访问权限。</p>
<center><br><img src="/2017/05/28/Java/AccessSpecifiers.JPG" width="60%">图 1<br></center>

<p>访问权限大小：public&gt;protected&gt;default&gt;private</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8078128/56331?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a></p>
<h3 id="问：Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"><a href="#问：Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？" class="headerlink" title="问：Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"></a>问：Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？</h3><p>Java中每一个类都有构造方法，当使用关键字new实例化一个对象时，类的构造方法就会被自动调用，完成对象的初始化工作。</p>
<p>构造方法是一种特殊的方法，具有以下特点:</p>
<p>(1) 构造方法的方法名必须与类名相同；</p>
<p>(2) 构造方法没有返回值类型，也不能定义为void；</p>
<p>(3) 构造方法不能被static、final、synchronized、abstract、native等关键字修饰，但可以被public、private、protected修饰</p>
<p>(4) 一个类可以定义多个构造方法，如果在定义类时没有定义构造方法，则编译系统会自动插入一个无参数的默认构造方法，这个构造器不执行任何代码；</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8070641/56330" title="Title" target="_blank" rel="external">例1：</a></p>
<p>(5) 构造方法可以被重载，以参数的个数、类型、顺序进行区分；</p>
<p>(6) 构造方法不能被继承，因此不能被重写，子类使用父类的构造方法需要使用super关键字</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8066549/25830?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a></p>
<p>Java中构造方法重载和方法重载很相似，可以为一个类创建多个构造方法，每一个构造方法必须有它自己唯一的参数列表。</p>
<p>Java不支持像C++中那样的复制构造方法，但是这并不代表Java中没有这种机制，Java中Object类的clone()方法就是这种机制的体现。</p>
<h3 id="问：new关键字"><a href="#问：new关键字" class="headerlink" title="问：new关键字"></a>问：new关键字</h3><p><a href="https://www.nowcoder.com/profile/7404313/test/8049404/56502?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a></p>
<h3 id="问：this关键字"><a href="#问：this关键字" class="headerlink" title="问：this关键字"></a>问：this关键字</h3><h3 id="问：static关键字"><a href="#问：static关键字" class="headerlink" title="问：static关键字"></a>问：static关键字</h3><p>“static”关键字可以用于修饰类的成员变量和成员方法，被其修饰的成员变量被称为类变量，被其修饰的成员方法成为类方法，它们随着类的加载而加载，使得该变量和方法可以在类没有实例化的情况下可以直接通过类名进行访问。</p>
<p>(1) 被static修饰的成员方法只能访问static成员，不可以访问非static成员</p>
<p>Java中被static修饰的变量和方法是属于类的，它们随着类的加载而加载，同时对static变量进行初始化并执行static代码块。如果static环境中的代码尝试访问非static的变量，编译器会报错，因为<strong>类的加载先于变量的创建，类加载的时候这些变量还没有被创建出来</strong>，例如，在static方法中访问某对象的非static方法，此时尚不能保证对象已经被实例化。因此在static环境中不能访问非static变量。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/7958772/56439?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a></p>
<pre><code>package NowCoder;
class Test {
    public static void hello() {
        System.out.println(&quot;hello&quot;);
    }
}
public class MyApplication {
    public static void main(String[] args) {
        Test test=null;
        test.hello();
    }
}

上述代码：能编译通过，并正确运行
</code></pre><p>(2) Java中静态变量只能在类主体中定义，不能在方法中定义。</p>
<p> 静态变量属于类所有而不属于方法。静态变量是在方法之前被加载的，所以static变量只能是类成员变量，而不能是局部变量，因为在static加载时，方法还没有分配空间。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8109636/56377?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a></p>
<pre><code>public class Test {
    public int aMethod() {
        static int i = 0;
        i++;
        return i;
    }
    public static void main (String args[]) {
        Test test = new Test();
        test.aMethod();
        int j = test.aMethod();
        System.out.println(j);
    }
}

程序编译失败
</code></pre><h3 id="问：继承"><a href="#问：继承" class="headerlink" title="问：继承"></a>问：继承</h3><p>继承时类的实例化问题：在实例化一个类时，一定是先创建其父类对象，即先执行父类的构造函数，然后再创建当前类对象。如果子类没有显示地调用父类的构造函数，编译器会自动加入父类的无参的构造函数super()</p>
<p><a href="" title="Title">例1：</a></p>
<pre><code>package test; 
class FatherClass { 
    public FatherClass() { 
        System.out.println(&quot;FatherClass Create&quot;); 
    } 
} 

class ChildClass extends FatherClass { 
    public ChildClass() { 
        System.out.println(&quot;ChildClass Create&quot;); 
    } 
    public static void main(String[] args) { 
        FatherClass fc = new FatherClass(); 
        ChildClass cc = new ChildClass(); 
    } 
} 

程序的输出结果如下：
FatherClass Create 
FatherClass Create 
ChildClass Create
</code></pre><h3 id="问：Java支持多继承么？"><a href="#问：Java支持多继承么？" class="headerlink" title="问：Java支持多继承么？"></a>问：Java支持多继承么？</h3><p>Java中的类不支持多继承，只支持单继承(即一个类只有一个父类)。 但是Java中的接口支持多继承，即一个子接口可以有多个父接口。(接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能)。</p>
<h3 id="问：super和this"><a href="#问：super和this" class="headerlink" title="问：super和this"></a>问：super和this</h3><p>this代表当前类对象，super代表当前类对象的父类对象。</p>
<p>在子类构造方法中，使用super()调用的是其父类的构造方法，而使用this()调用的是同一个类中重载的构造方法</p>
<p><strong>super关键字</strong></p>
<p>(1) Java中子类不能继承父类的构造方法，只能调用父类构造方法；</p>
<p>(2) 子类的构造方法可以使用super显示地调用父类构造方法；</p>
<p>(3) 当子类构造方法中没有使用super来显示地调用父类构造方法时，系统会默认采用super()调用父类的无参构造方法，这时父类必须提供无参构造参数，否则编译出错。</p>
<p>案例：</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8066549/15538?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a>，<a href="https://www.nowcoder.com/profile/7404313/test/7958772/55361?onlyWrong=0" title="Title" target="_blank" rel="external">例2</a>，<a href="https://www.nowcoder.com/profile/7404313/test/8049404/15324?onlyWrong=0" title="Title" target="_blank" rel="external">例3</a>，<a href="https://www.nowcoder.com/profile/7404313/test/7977669/22482?onlyWrong=0" title="Title" target="_blank" rel="external">例4</a>    </p>
<p><strong>this关键字</strong></p>
<p><strong>注意：</strong></p>
<p>(1) 使用super()或this()时，它们必须放在构造方法的第一行，否则编译通不过。</p>
<p>(2) 由于this()调用的构造函数默认调用super()方法，所以规定this()和super()不能同时出现在一个构造函数中。</p>
<p>(3) static环境，包括static方法和static语句块，在执行时还没有构造对象实例，因此不能在static环境中使用this()和super()</p>
<h3 id="问：Java中的方法重写-Overriding-和方法重载-Overloading-是什么意思？"><a href="#问：Java中的方法重写-Overriding-和方法重载-Overloading-是什么意思？" class="headerlink" title="问：Java中的方法重写(Overriding)和方法重载(Overloading)是什么意思？"></a>问：Java中的方法重写(Overriding)和方法重载(Overloading)是什么意思？</h3><p>方法重写和方法重载都是Java多态性的不同表现(动态绑定 dynamic binding)</p>
<p>(1) 方法重载是一个类中多态性的一种表现，发生在同一个类里面两个或多个方法的方法名相同但是参数列表不同的情况。</p>
<blockquote>
<p>函数名必须相同；</p>
<p>函数参数列表必须不相同，可以是参数个数、参数类型或者参数顺序不同；</p>
<p>函数的返回值类型、修饰符可以相同，也可以不相同；</p>
</blockquote>
<p>(2) 方法重写是父类与子类之间多态性的一种表现，是说子类重新定义了父类的方法；方法的重写满足两同两小一大原则</p>
<blockquote>
<p>方法名相同，参数类型相同</p>
<p>子类返回类型小于等于父类方法返回类型；</p>
<p>子类抛出异常小于等于父类方法抛出异常；</p>
<p>子类访问权限大于等于父类方法访问权限 (public&gt;protected&gt;defualt(默认修饰符)&gt;private)。</p>
</blockquote>
<p>注意：Java不支持运算符重载。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/7993658/44624?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a></p>
<h3 id="问：Java中是否可以覆盖-override-一个private或者是static的方法？"><a href="#问：Java中是否可以覆盖-override-一个private或者是static的方法？" class="headerlink" title="问：Java中是否可以覆盖(override)一个private或者是static的方法？"></a>问：Java中是否可以覆盖(override)一个private或者是static的方法？</h3><p>private修饰的方法不能被覆盖，因为被private修饰的父类方法在子类中是不可见的。</p>
<p>Java中静态方法在形式上可以被重写，即子类中可以重写父类中静态的方法。但是实际上从内存的角度上静态方法不可以被重写，因为<strong>方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的</strong>。static方法跟类的任何实例都不相关，所以概念上不适用。</p>
<h3 id="问：final关键字"><a href="#问：final关键字" class="headerlink" title="问：final关键字"></a>问：final关键字</h3><p>final关键字可以用于修饰类、变量和方法。</p>
<p>(1) final修饰的类不可被继承(因此一个类不能同时被final和abstract修饰)；</p>
<p>(2) final修饰的方法不可被重写；</p>
<p>(3) final修饰的变量的值不可被修改，一旦获得初始值，该变量就不能被重新赋值。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8070641/15311?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a>，<a href="https://www.nowcoder.com/profile/7404313/test/8073294/22481?onlyWrong=0" title="Title" target="_blank" rel="external">例2</a>，<a href="https://www.nowcoder.com/profile/7404313/test/8078128/14994?onlyWrong=0" title="Title" target="_blank" rel="external">例3</a></p>
<p>(4) 形式参数只能用final修饰符，任何其它修饰符都会引起编译错误。但是用这个修饰符也有一定的限制，就是在方法中不能对参数做任何修改。不过在一般情况下，一个方法的形参不用final修饰。只有在特殊情况下：方法内部类，一个方法内的内部类如果使用了这个方法的参数或者局部变量，这个参数或局部变量应该是final。</p>
<p>(5) final修饰的成员变量既可以在定义时显示地初始化，也可以先声明而不初始化，这种成员变量称为blank final，此时可以在构造代码块或构造函数中对其赋初值，否则编译会报错。</p>
<p><a href="" title="Title">例1：</a></p>
<pre><code>class Foo {
    final int i;
    int j;
    public void doSomething() {
        System.out.println(++j + i);  // 编译出错，因为final成员变量在使用前没有赋初值
    }
}
</code></pre><p><a href="https://www.nowcoder.com/questionTerminal/48f183240e8d4ec3aeecc90337a396a0" title="Title" target="_blank" rel="external">例2：</a><br>这一题解释尚不明确，不知道final方法在子类中继承了没有。</p>
<pre><code>public class Car extends Vehicle{
    public static void main(String[] args){
        new Car().run();    //输出：Car
    }
    private final void run(){
        System.out.println(&quot;Car&quot;);
    }
}
class Vehicle{
    private final void run(){
        System.out.println(&quot;Vehicle&quot;);
    }
}
</code></pre><p>(6) 被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8109636/44646?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a></p>
<pre><code>byte b1=1,b2=2,b3,b6,b8;
final byte b4=4,b5=6,b7;
b3=(b1+b2);  /*语句1*/
b6=b4+b5;    /*语句2*/
b8=(b1+b4);  /*语句3*/
b7=(b2+b5);  /*语句4*/
System.out.println(b3+b6);

代码片段中，存在编辑错误的语句是：语句1、语句3和语句4
语句1错误：b3=(b1+b2);自动转为int，所以正确写法为b3=(byte)(b1+b2);或者将b3定义为int；
语句2正确：b6=b4+b5;b4、b5为final类型，不会自动提升，计算结果任然是byte类型，然后结果的类型视左边变量类型而定，即b6可以是任意数值类型；
语句3错误：b8=(b1+b4);虽然b4不会自动提升，但b1仍会自动提升，所以结果需要强转，b8=(byte)(b1+b4);
语句4错误：b7=(b2+b5); 同上。同时注意b7是final修饰，即只可赋值一次，便不可再改变。
</code></pre><h3 id="问：Object类"><a href="#问：Object类" class="headerlink" title="问：Object类"></a>问：Object类</h3><p>Java中Object是所有类的祖先类，Object类中包含如下方法：</p>
<center><br><img src="/2017/05/28/Java/Object-Methods.png" width="90%">图 1<br></center>

<h3 id="问：equals-方法和-的区别"><a href="#问：equals-方法和-的区别" class="headerlink" title="问：equals()方法和==的区别"></a>问：equals()方法和==的区别</h3><ul>
<li><p>==运算符：对于基本数据类型变量比较的是两个变量的值是否相等；对于引用型变量表示的是两个变量指向的对象在堆中存储的地址是否相同，即栈中的内容是否相同</p>
</li>
<li><p>equals()方法：继承自Object类，默认调用==进行比较。判断两个对象是否相等需要覆盖equals()方法和hashcaode()方法</p>
</li>
</ul>
<h3 id="问：finalize-方法什么时候被调用？析构函数-finalization-的目的是什么？"><a href="#问：finalize-方法什么时候被调用？析构函数-finalization-的目的是什么？" class="headerlink" title="问：finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？"></a>问：finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？</h3><p>finalize()是Object类的一个方法，垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法。</p>
<p>但是很不幸的是，在Java中，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说filalize()可能永远不被执行，显然指望它做收尾工作是靠不住的。 那么finalize()究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。</p>
<h3 id="问：clone，没遇到过，暂时存放"><a href="#问：clone，没遇到过，暂时存放" class="headerlink" title="问：clone，没遇到过，暂时存放"></a>问：clone，没遇到过，暂时存放</h3><p>42、写clone()方法时，通常都有一行代码，是什么？<br>Clone有缺省行为，super.clone();他负责产生正确大小的空间，并逐位复制。</p>
<h3 id="问：多态的实现方式"><a href="#问：多态的实现方式" class="headerlink" title="问：多态的实现方式"></a>问：多态的实现方式</h3><p>(1) 静态的多态：方法重载</p>
<p>(2) 动态的多态：子类覆盖父类的方法，将子类的实例赋值给父类的引用，此时调用的是子类的方法；实现接口的实例赋值给接口的引用，此时调用的实现类的方法。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8049404/14992?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a>判断对错</p>
<pre><code>在java的多态调用中，new的是哪一个类就是调用的哪个类的方法。

错误    
</code></pre><h3 id="问：抽象类和接口的区别"><a href="#问：抽象类和接口的区别" class="headerlink" title="问：抽象类和接口的区别"></a>问：抽象类和接口的区别</h3><p>Java提供和支持创建抽象类和接口。</p>
<p>含有abstract修饰符的class即为抽象类，abstract类不能创建类的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。  </p>
<p>接口(interface)可以说成是抽象类的一种特例</p>
<p>它们的不同点在于：</p>
<p>从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p>
<p>(1) 抽象类和接口都不可以被实例化</p>
<p><strong>(2)</strong> 抽象类中可以包含普通成员变量、静态成员变量；而接口中没有普通成员变量、只有常量，接口中声明的成员变量默认为public static final类型，且只能是public static final类型；</p>
<p><strong>(3)</strong> 抽象类中可以同时包含抽象方法和非抽象方法，也可以没有抽象方法，但如果一个类中有一个抽象方法，那么当前类一定是抽象类；而接口中只有方法的声明、没有方法体，即接口中的所有方法必须都是抽象的，不能有非抽象的普通方法(<strong>Java8中接口可以有非抽象的default方法</strong>)</p>
<p>(4) 抽象类中的抽象方法，需要由子类实现，如果子类不实现所有抽象方法，则子类也需要定义为抽象类；接口中定义的方法都需要由实现类来实现，如果实现类不能实现接口中的所有方法，则实现类需要定义为抽象类</p>
<p><strong>(5)</strong> 抽象类中可以有构造方法，其作用是初始化抽象类的成员；接口中不能有构造方法</p>
<p><strong>(6)</strong> 抽象类中的成员方法的访问类型可以为public、protected和private，抽象方法必须为public或protected；而接口中的成员方法的访问类型默认为public abstract类型，且只能是public abstract</p>
<p>(7) 抽象类中可以包含静态方法；而接口中不能包含静态方法(<strong>Java8开始接口可以有静态方法</strong>) </p>
<p>(8) 抽象类可以implements接口；接口可以继承接口，并且接口可以实现多继承(一个接口可以继承多个接口)</p>
<p><strong>(9)</strong> 抽象类只能被单一extends(一个类只能继承一个类)；接口却可以被多重implements(一个类可以实现多个接口)</p>
<p>(10) 类可以不实现抽象类和接口中声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的</p>
<p>(11) 抽象方法既不能是static的，也不能是native的，还不能是synchronized的</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/7906972/15179?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a>，<a href="https://www.nowcoder.com/profile/7404313/test/8073294/14303?onlyWrong=0" title="Title" target="_blank" rel="external">例2</a>，<a href="https://www.nowcoder.com/profile/7404313/test/8100292/15000?onlyWrong=0" title="Title" target="_blank" rel="external">例3</a>，<a href="https://www.nowcoder.com/profile/7404313/test/8078128/36678?onlyWrong=0" title="Title" target="_blank" rel="external">例4</a></p>
<h3 id="问：instanceof关键字"><a href="#问：instanceof关键字" class="headerlink" title="问：instanceof关键字"></a>问：instanceof关键字</h3><p>instanceof前一个参数通常是一个引用类型变量，后一个操作数通常是一个类（也可以是一个接口）。它用于判断前面的变量引用的对象是否是后面的类(也可以是一个接口)或者其子类的实例。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/7964595/3035?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a></p>
<pre><code>public static void main(String args[]) {
    List  Listlist1 = new ArrayList();
    Listlist1.add(0);
    List Listlist2 = Listlist1;
    System.out.println(Listlist1.get(0) instanceof Integer);
    System.out.println(Listlist2.get(0) instanceof Integer);
}

上面代码将输出：true true
Collection类型的集合（ArrayList,LinkedList）只能装入对象类型的数据
该题中需要装入0，是一个基本类型，但是JDK5以后提供了自动装箱与自动拆箱，所以int类型自动装箱变为了Integer类型。
List没有使用泛型，因此使用get(0)取出的元素的编译类型是Object型的，但运行时类型是Integer，所以打印true，这里体现了多态的应用。
而Listlist1把引用赋给了Listlist2，说明两个指向同一个对象，因此第二个打印的也是true。
</code></pre><h3 id="问：内部类"><a href="#问：内部类" class="headerlink" title="问：内部类"></a>问：内部类</h3><p><strong>内部类分类</strong>，来自例2中评论部分BlueFish的总结。</p>
<p>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，<br>对于内部类都没有影响。</p>
<p>使用内部类最大的优点就在于它能够非常好的解决多重继承的问题,使用内部类还能够为我们带来如下特性:</p>
<ul>
<li>内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立；</li>
<li>在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类；</li>
<li>创建内部类对象的时刻并不依赖于外围类对象的创建；</li>
<li>内部类并没有令人迷惑的”is-a”关系，他就是一个独立的实体；</li>
<li>内部类提供了更好的封装，除了该外围类，其他类都不能访问。</li>
</ul>
<p>(1) 成员内部类</p>
<pre><code>public class Outer{
    private String name=&quot;Outer&quot;;
    private int age=99;

    public static void main(String[] args){
        Outer outer=new Outer();
        Inner inner=outer.new Inner();
        inner.show();
    }

    private class Inner{
        private String name=&quot;Inner&quot;;
        private final int num=10;
        public void show(){
            System.out.println(Outer.this.name);
            System.out.println(this.name);
            System.out.println(age);
        }
    }
}
</code></pre><ul>
<li>Inner类定义在Outer类的内部(相当于Outer类的一个成员变量的位置处)，Inner类可以使用任意访问控制符，如public、protected、private等；</li>
<li>Inner 类中定义的show()方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问Outer类中的私有属性age；</li>
<li>定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去new一个内部类对象，即：<strong>内部类 对象名=外部类对象.new 内部类()</strong>;</li>
<li>编译上面的程序后，会发现产生了两个.class文件: Outer.class和Outer$Inner.class</li>
<li>成员内部类中不能存在任何static的变量和方法，但可以定义常量:<ul>
<li>因为非静态内部类的存在是依赖于外部类的实例的，而静态变量和方法是不依赖于对象的，仅与类相关。而在加载静态域时，根本没有外部类实例，所在在非静态内部类中不能定义静态变量或方法，编译不通过;非静态内部类的作用域是实例级别</li>
<li>常量是在编译器时确定的，放到所谓的常量池了，因此可以定义常量。</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ul>
<li>外部类是不能直接使用内部类的成员和方法的，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法；</li>
<li>如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用this关键字，如:Outer.this.name</li>
</ul>
<p>(2) 静态内部类，static修饰的内部类</p>
<pre><code>public class Outer{
    private static String name=&quot;Outer&quot;;
    private static String tag=&quot;tag&quot;;
    private int age=99;

    public static void main(String[] args){
        Inner inner=new Inner();
        inner.show();
    }

    private static class Inner{
        private String name=&quot;Inner&quot;;
        public void show(){
            System.out.println(Outer.name);
            System.out.println(this.name);
            System.out.println(tag);
            System.out.println(new Outer().age);
        }
    }
}
</code></pre><ul>
<li>静态内部类不能直接访问外部类的非静态成员，但可以通过<strong>new 外部类().成员</strong>的方式访问 </li>
<li>如果外部类的静态成员与内部类的成员名称相同，可通过<strong>类名.静态成员</strong>的方式访问外部类的静态成员；</li>
<li>如果外部类的静态成员与内部类的成员名称不相同，则可通过<strong>成员名</strong>直接调用外部类的静态成员；</li>
<li>创建静态内部类的对象时，不需要外部类的对象，可以直接创建<strong>内部类 对象名=new 内部类()</strong>;</li>
</ul>
<p>(3) 方法内部类，访问仅限于方法内或者该作用域内</p>
<pre><code>public class Outer {
    public static void main(String[] args) {
        Outer outer = new Outer();
        outer.print();
    }

    public void print() {
        final int a = 25;
        class Inner {
            private int c = 2;

            public void show() {
                System.out.println(a);
                System.out.println(c);
            }
        }
        Inner inner = new Inner();
        inner.show();
    }
}
</code></pre><ul>
<li>方法内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的</li>
<li>方法内部类不能修改方法中定义的局部变量(<strong>解释看原评论，原评论这部分，我测试有点问题</strong>，大概原因是内部类访问方法局部变量时会拷贝局部变量，对局部变量修改会造成拷贝的局部变量值与方法中局部变量值不一致，为了保持局部变量值得一致性，可以将被内部类访问的局部变量声明为final)</li>
</ul>
<p>(4) 匿名内部类</p>
<pre><code>public class Outer{
    public static void main(String[] args){
        Outer outer=new Outer();
        InnerClass inner=outer.getInnerClass(2, &quot;inner&quot;);
        System.out.println(inner.getNumber());
    }

    public InnerClass getInnerClass(int num, String str){
        return new InnerClass(){
            int count;
            int number=num+1;

            {
                count=100;
            }

            @Override
            public int getNumber() {
                return number;
            }
        };
    }

    private interface InnerClass{
        int getNumber();
    }
}
</code></pre><ul>
<li>匿名内部类是直接使用 new 来生成一个对象的引用；</li>
<li>对于匿名内部类的使用，它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用；</li>
<li>使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口；</li>
<li>匿名内部类中是不能定义构造函数的，匿名内部类中不能存在任何的静态成员变量和静态方法；</li>
<li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法；</li>
<li><strong>匿名内部类初始化:使用构造代码块!</strong> 利用构造代码块能够达到为匿名内部类创建一个构造器的效果</li>
</ul>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8045843/7673?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a> 重要</p>
<p>非静态内部类是属于对象的，所以初始化时需要先初始化一个外部类实例对象，然后使用此对象调用内部类的构造方法。静态内部类属于类本身，初始化时直接使用外部类调用静态内部类的构造方法即可</p>
<pre><code>public class Test{
    public static void main(String[] args){
        EnclosingOne.InsideOne obj1=new EnclosingOne().new InsideOne(); //非静态内部类
        EnclosingOne.InsideTwo obj2=new EnclosingOne.InsideTwo();       //静态内部类
    }
}
class EnclosingOne {
    //非静态内部类
    public class InsideOne {
    }
    //静态内部类
    public static class InsideTwo{
    }
}
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/8066549/5120?onlyWrong=0" title="Title" target="_blank" rel="external">例2：</a>往OuterClass类的代码段中插入内部类声明，哪一个是错误的？</p>
<pre><code>public class OuterClass{
    private float f=1.0f;
    //插入代码到这里
}

A.    class InnerClass{
        public static float func(){
            return f;
        }
    }
B.    abstract class InnerClass{
        public abstract float func(){}
    }
C.    static class InnerClass{
        protected static float func(){
            return f;
        }
    }
D.    public class InnerClass{
        static float func(){return f;}
    }

答案：ABCD
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/8073294/4332?onlyWrong=0" title="Title" target="_blank" rel="external">例3</a></p>
<h3 id="问Static-Nested-Class和Inner-Class的不同？"><a href="#问Static-Nested-Class和Inner-Class的不同？" class="headerlink" title="问Static Nested Class和Inner Class的不同？"></a>问Static Nested Class和Inner Class的不同？</h3><p>Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化，而通常的内部类需要在外部类实例化后才能实例化。 </p>
<h3 id="问：类加载器"><a href="#问：类加载器" class="headerlink" title="问：类加载器"></a>问：类加载器</h3><p>Java中类的加载是由类加载器完成的，类加载器包括：引导类加载器(BootStrap ClassLoader)、扩展类加载器(Extension ClassLoader)、应用类加载器(Application ClassLoader)和用户自定义类加载器(java.lang.ClassLoader的子类)。</p>
<ul>
<li>Bootstrap ClassLoader：它负责加载放在<java_home\>\jre\lib/目录中的，或者-Xbootclasspath参数所指定路径中的Java核心库(如rt.jar)，是用原生代码来实现的；</java_home\></li>
<li>Extension ClassLoader：它负责加载<java_home\>\jre\lib\ext目录中，或系统变量java.ext.dirs所指定路径中的所有类库；</java_home\></li>
<li>Application ClassLoader：它负责加载Java应用的CLASSPATH所指定的类库。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它是应用最广泛的类加载器。开发者可以直接使用这个类加载器，如果应用程序中没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器；</li>
<li>Custom ClassLoader：应用程序根据自身需要自定义的ClassLoader，是java.lang.ClassLoader的子类，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader。</li>
</ul>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8004321/36456?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a></p>
<h3 id="问：JVM的类加载机制"><a href="#问：JVM的类加载机制" class="headerlink" title="问：JVM的类加载机制"></a>问：JVM的类加载机制</h3><p><a href="http://www.importnew.com/18548.html" title="Title" target="_blank" rel="external">推荐阅读</a></p>
<p>Java类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中准备、验证、解析3个部分统称为连接（Linking）。</p>
<center><br><img src="/2017/05/28/Java/ClassLoad.jpg" width="55%">图 1<br></center>

<p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/7977669/26108?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a></p>
<h3 id="问：Java类加载时的初始化顺序"><a href="#问：Java类加载时的初始化顺序" class="headerlink" title="问：Java类加载时的初始化顺序"></a>问：Java类加载时的初始化顺序</h3><p>(1) 初始化父类中的静态成员变量和静态代码块(按照在程序中出现的顺序初始化)</p>
<p>(2) 初始化子类中的静态成员变量和静态代码块(按照在程序中出现的顺序初始化)</p>
<p>(3) 初始化父类中的普通成员变量和构造代码块(按照在程序中出现的顺序初始化)，然后再执行父类中的构造方法</p>
<p>(4) 初始化子类中的普通成员变量和构造代码块(按照在程序中出现的顺序初始化)，然后再执行子类中的构造方法</p>
<p><a href="" title="Title">例1：</a></p>
<pre><code>class Member {
    Member(String str) {
        System.out.println(str);
    }
}
class A {
    static {
        System.out.println(&quot;父类静态代码块&quot;);
    }
    public A() {
        System.out.println(&quot;父类构造函数&quot;);
    }
    {
        System.out.println(&quot;父类构造代码块&quot;);
    }
    Member member=new Member(&quot;父类成员变量&quot;);
}
class B extends A {
    Member member=new Member(&quot;子类成员变量&quot;);
    static {
        System.out.println(&quot;子类静态代码块&quot;);
    }
    public B() {
        System.out.println(&quot;子类构造函数&quot;);
    }
    {
        System.out.println(&quot;子类构造代码块&quot;);
    }
}
public class Test{
    public static void main(String[] args) {
        new B();
    }
}

//输出：
父类静态代码块
子类静态代码块
父类构造代码块
父类成员变量
父类构造函数
子类成员变量
子类构造代码块
子类构造函数
</code></pre><p><a href="" title="Title">例2：</a></p>
<pre><code>public class B {
    public static B t1 = new B();
    public static B t2 = new B();
    {
        System.out.println(&quot;构造块&quot;);
    }
    static {
        System.out.println(&quot;静态块&quot;);
    }
    public static void main(String[] args) {
        B t = new B();
    }
}

// 输出

构造块
构造块
静态块
构造块
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/7964595/14700?onlyWrong=0" title="Title" target="_blank" rel="external">例3：</a></p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8066549/3212?onlyWrong=0" title="Title" target="_blank" rel="external">例4：</a>下面代码的输出是什么？</p>
<pre><code>public class Base {
    private String baseName = &quot;base&quot;;

    public Base() {
        callName();
    }

    public void callName() {
        System.out.println(baseName);
    }

    static class Sub extends Base {
        private String baseName = &quot;sub&quot;;

        public void callName() {
            System.out.println(baseName);
        }
    }

    public static void main(String[] args) {
        Base b = new Sub();
    }
}

// 输出：null
</code></pre><h3 id="问：JNI-Java-Native-Interface"><a href="#问：JNI-Java-Native-Interface" class="headerlink" title="问：JNI(Java Native Interface)"></a>问：JNI(Java Native Interface)</h3><p>Java的不足除了体现在运行速度上要比传统的C++慢许多之外，Java无法直接访问到操作系统底层（如系统硬件等)，为此Java使用native方法来扩展Java程序的功能。</p>
<p>native是方法修饰符，native方法是由另外一种语言（如C/C++,汇编等）实现的本地方法，因为在外部实现了方法，所以在java代码中，就不需要声明了，有点类似于接口中的抽象方法。其实现步骤为：</p>
<ul>
<li>在Java中声明native()方法，然后编译；</li>
<li>用javah产生一个.h文件；</li>
<li>写一个.cpp文件实现native导出方法，其中需要包含第二步产生的.h文件（注意其中又包含了JDK带的jni.h文件）；</li>
<li>将第三步的.cpp文件编译成动态链接库文件；</li>
<li>在Java中用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问了。</li>
</ul>
<p><a href="https://www.nowcoder.com/profile/7404313/test/7964595/22484?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a>以下声明合法的是：</p>
<pre><code>A. default String s
B. public final static native int w()
C. abstract double d
D. abstract final double hyperbolicCosine()

答案：B
native可以和任何修饰符连用，abstract除外。因为native暗示这个方法时有实现体的，而abstract却显式指明了这个方法没有实现体。
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/7971730/7665?onlyWrong=0" title="Title" target="_blank" rel="external">例2：</a>Which of the following can be applied to constructors?</p>
<pre><code>A. final  B. static  C. synchronized  D. native  E. None of these.

答案：E

native方法和abstract方法都是方法的声明，一个把方法实现移交给子类，另一个移交给本地操作系统。
如果同时出现，就相当于既把实现移交给子类，又把实现移交给本地操作系统，那就会产生混乱。

Java构造方法可以有任何访问的修饰：public，protected，private或者没有修饰。
但是不能有以下非访问性质的修饰：abstract，final，native，static，或者synchronized。
</code></pre><h2 id="四、-异常处理"><a href="#四、-异常处理" class="headerlink" title="四、 异常处理"></a>四、 异常处理</h2><h3 id="问：Java中的两种异常类型是什么？他们有什么区别？"><a href="#问：Java中的两种异常类型是什么？他们有什么区别？" class="headerlink" title="问：Java中的两种异常类型是什么？他们有什么区别？"></a>问：Java中的两种异常类型是什么？他们有什么区别？</h3><p>Throwable包含了错误(Error)和异常(Excetion)两类。</p>
<center><br><img src="/2017/05/28/Java/Exception.JPG" width="50%">图 1<br></center>

<p>(1) Error： 由Java虚拟机生成并抛出，属于JVM底层或者运行时环境的错误，程序无法预测和捕获处理，如OutOfMemoryError，如果出现Error，Java虚拟机会终止执行。</p>
<p>(2) Exception: 用户程序可以捕获的异常情况，Java中有两种异常，分别为运行时异常(RuntimeException, 又叫非检查异常)和非运行时异常(又叫检查异常)。</p>
<ul>
<li><p><strong>运行时异常</strong>：RuntimeException类及其子类，如ArithmeticException、NullPointerException、IndexOutOfBoundsException、ClassCastException、BufferOverflowException、ConcurrentModificationException、IllegalArgumentException、NoSuchElementException、UnsupportedOperationException等，这类异常是在程序运行的时候可能会发生的，Java编译器不去检查它，也就是说，当程序中可能出现这类异常时，即使没有用try…catch语句捕获它，也没有用throws字句声明抛出它，还是会编译通过。所以程序可以捕捉，也可以不捕捉。这些异常一般是由程序的逻辑错误引起的，其产生频繁，处理麻烦，若显示申明或者捕获将会对程序的可读性和运行效率影响很大，建议不要用try…catch…捕获处理，程序应该在开发调试的过程中从逻辑角度去尽量避免，例如：空值处理。</p>
</li>
<li><p><strong>非运行时异常</strong>：运行时异常以外的异常，也是Exception及其子类，这些异常从程序的角度来说是必须经过捕捉检查处理的(要么用 try…catch捕获处理，要么用throws语句声明抛出)，否则不能通过编译。如IOException、SQLException、NoSuchMetodException、ClassNotFoundException、FileNotFoundException等。</p>
</li>
</ul>
<h3 id="问：异常处理语句的语法规则"><a href="#问：异常处理语句的语法规则" class="headerlink" title="问：异常处理语句的语法规则"></a>问：异常处理语句的语法规则</h3><ul>
<li>try是用于检测被包住的语句块是否出现异常，如果有异常，则抛出异常，并执行catch语句</li>
<li>cacth用于捕获从try中抛出的异常并作出处理</li>
<li>finally语句块是不管有没有出现异常都要执行的内容</li>
<li>throw用于抛出异常</li>
<li>throws关键字可以在方法上声明该方法要抛出的异常，然后在方法内部通过throw抛出异常对象</li>
</ul>
<p>(1) try代码块中包含可能产生异常的代码，其后跟一个或多个catch代码块，每个catch代码块用于捕获并处理一种特定类型的异常。</p>
<p>(2) 当try代码块中产生异常时，程序会终止当前的执行流程，Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个catch代码块，然后其他的catch代码块将不会再执行，即一个异常只能被一个catch代码块捕获执行。如果try代码块没有异常产生，所有的catch代码块将跳过不执行。</p>
<p>(3) catch代码块后可以跟finally代码块，无论try代码块中是否抛出异常，finally代码块都会被执行，因此finally代码块为异常处理提供一个统一的出口，使得在控制流程跳转到程序的其他部分之前，能够对程序的状态作统一的管理。通常在finally代码块中可以进行资源的清除工作。</p>
<p>(4) try代码块后基类异常的捕获语句不可以写在子类异常捕获语句的上面。</p>
<p>(5) 在try-catch-finally结构中，可重新抛出异常。 </p>
<p>(6) try-catch-finally结构可嵌套。 </p>
<p>(7) try不必一定有catch，只要catch和finally有一个存在就行，但是catch和finally不可以同时省略</p>
<p>(8) 自定义异常要继承Exception或Exception的子类。</p>
<h3 id="问：异常处理完成以后，Exception对象会发生什么变化？"><a href="#问：异常处理完成以后，Exception对象会发生什么变化？" class="headerlink" title="问：异常处理完成以后，Exception对象会发生什么变化？"></a>问：异常处理完成以后，Exception对象会发生什么变化？</h3><p>Exception对象会在下一个垃圾回收过程中被回收掉。</p>
<h3 id="问：throw和throws有什么区别？"><a href="#问：throw和throws有什么区别？" class="headerlink" title="问：throw和throws有什么区别？"></a>问：throw和throws有什么区别？</h3><ul>
<li><p>throw关键字用来<strong>在方法内部</strong>明确地抛出异常，后面跟的是要抛出的<strong>异常对象</strong>且只能跟一个异常对象；</p>
</li>
<li><p>throws关键字用<strong>在声明方法上</strong>，表示该方法可能要抛出的、该方法不能处理的异常，后面跟的是<strong>异常类名</strong>，可以有多个，用逗号隔开，这样方法的调用者才能够确保处理可能发生的异常。</p>
</li>
</ul>
<h3 id="问：finally"><a href="#问：finally" class="headerlink" title="问：finally"></a>问：finally</h3><p>finally作为异常处理的一部分，只能用在try/catch语句块后，无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。</p>
<p>例1：当程序执行到try{}语句中的return方法时，它将要返回的结果存储到一个临时栈中，然后程序不会立即返回，而是去执行finally{}中的代码，在执行<code>a = 2</code>时，程序仅仅是覆盖了a的值，但不会去更新临时栈中的那个要返回的值。finally{}执行完之后，程序就会将临时栈中的值取出来返回。</p>
<pre><code>public abstract class Test {
    public static void main(String[] args) {
        System.out.println(beforeFinally());  // output: 1
    }

    public static int beforeFinally(){
        int a = 0;
        try{
            a = 1;
            return a;
        }finally{
            a = 2;
        }
    }
}
</code></pre><p>例2：这里finally{}里也有一个return，那么在执行这个return时，就会更新临时栈中的值。同样，在执行完finally之后，程序将临时栈中的值取出来返回，即返回值是2.</p>
<pre><code>public abstract class Test {
    public static void main(String[] args) {
        System.out.println(beforeFinally());  //output: 2
    }

    public static int beforeFinally(){
        int a = 0;
        try{
            a = 1;
            return a;
        }finally{
            a = 2;
            return a;
        }
    }
}
</code></pre><p>例3：try/catch可以捕获并处理异常，异常被捕获后程序可以继续向后执行</p>
<pre><code>public class Test {
    public static void main(String[] args) {
        try {
            int i = 100 / 0;
            System.out.print(i);
        } catch (Exception e) {
            System.out.print(1);
        } finally {
            System.out.print(2);
        }
        System.out.print(3);
    }
}
// output: 123
</code></pre><p>例4：catch语句块里面，打印完1之后，又抛出了一个RuntimeException，程序并没有处理它，而是直接抛出，因此执行完finally语句块之后，程序便不往下执行直接终止了</p>
<pre><code>public class Test {
    public static void main(String[] args) {
        try {
            int i = 100 / 0;
            System.out.print(i);
        } catch (Exception e) {
            System.out.print(1);
            throw new RuntimeException();
        } finally {
            System.out.print(2);
        }
        System.out.print(3);
    }
}
// output: 12
</code></pre><p>例5：catch语句块里面，打印完1之后，程序先执行完finally语句块，然后return。</p>
<pre><code>public class Test {
    public static void main(String[] args) {
        try {
            int i = 100 / 0;
            System.out.print(i);
        } catch (Exception e) {
            System.out.print(1);
            return;
        } finally {
            System.out.print(2);
        }
        System.out.print(3);
    }
}
// output: 12
</code></pre><h3 id="问：final关键字、finally代码块和finalize-方法有什么区别？"><a href="#问：final关键字、finally代码块和finalize-方法有什么区别？" class="headerlink" title="问：final关键字、finally代码块和finalize()方法有什么区别？"></a>问：final关键字、finally代码块和finalize()方法有什么区别？</h3><ul>
<li><p>final关键字用于声明变量、方法和类，分别表示变量的值不可被修改、方法不可被重写、类不可被继承。</p>
</li>
<li><p>finally作为异常处理的一部分，只能用在try/catch语句块后，无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。</p>
</li>
<li><p>finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由垃圾收集器来调用的。可以覆盖此方法在垃圾收集时的进行其他资源回收，例如关闭文件等。</p>
</li>
</ul>
<h2 id="五、-数组"><a href="#五、-数组" class="headerlink" title="五、 数组"></a>五、 数组</h2><h2 id="六、-常用类"><a href="#六、-常用类" class="headerlink" title="六、 常用类"></a>六、 常用类</h2><h3 id="问：String、StringBuffer和StringBuilder"><a href="#问：String、StringBuffer和StringBuilder" class="headerlink" title="问：String、StringBuffer和StringBuilder"></a>问：String、StringBuffer和StringBuilder</h3><p>(1) String：不可变的字符序列</p>
<ul>
<li><p>String类不是基本数据类型，是引用数据类型</p>
</li>
<li><p>String是被final修饰的类，因此一旦一个String对象被创建并初始化后，包含在这个对象里的字符序列是不可改变的，直到这个对象被销毁，即本身的内容不可改变、长度不可改变；</p>
</li>
<li><p>String类不可以被继承；</p>
</li>
<li><p>String变量作为参数时相当于基本数据类型的值传递</p>
</li>
<li><p>对String对象的任何改变都不影响到原对象，每次操作都会生成新的String对象，然后将引用指向新的String对象，因此不推荐频繁改变String内容，会增加内存压力。为了提高效率节省空间，我们应该用StringBuffer类</p>
</li>
<li><p>当多个字符串联合时会先转为StringBuffer，再联合，最后生成String对象，速度较慢。</p>
</li>
</ul>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8004321/15331?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a>Java中的字符串都是常量，字符串一旦被初始化，就不可以被改变，因为是常量，存放在方法区中的常量池中，可以实现共享。</p>
<pre><code>// 双引号引起的数据都是字符串对象，存放在常量池中。s1指向的内存中只有一个对象，在常量池中。 
String s1=&quot;abc&quot;;

// 在内存中生成两个对象，&quot;abc&quot;存放在常量池中，new String()存放在堆内存中。s2指向的内存中有两个对象，分别在常量池中和堆内存中。
String s2=new String(&quot;abc&quot;);

/*&quot;abc&quot;是字符串常量，被存在堆区的常量池中，当定义String s3=&quot;abc&quot;时，不会马上创建字符串&quot;abc&quot;对象，而是会先查找常量池中是否存在相同常量，
如果有，则s3指向同一内存空间，否则创建新的字符串对象。*/
String s3=&quot;abc&quot;;

System.out.println(s1==s2); //false
System.out.println(s1==s3); //true

//String类重写了Object类的equals()方法，使其由比较引用变为了比较引用所指向的字符串内容是否一样。
System.out.println(s1.equals(s2)); //true
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/7964595/36520?onlyWrong=0" title="Title" target="_blank" rel="external">例2</a>，<a href="https://www.nowcoder.com/profile/7404313/test/8073294/22470?onlyWrong=0" title="Title" target="_blank" rel="external">例3</a>，<a href="https://www.nowcoder.com/profile/7404313/test/8088719/14980?onlyWrong=0" title="Title" target="_blank" rel="external">例4</a>，<a href="https://www.nowcoder.com/profile/7404313/test/8073294/3731?onlyWrong=0" title="Title" target="_blank" rel="external">例5：</a>编译器优化</p>
<p>(2) StringBuffer：线程安全的可变字符序列</p>
<ul>
<li>对StringBuffer对象进行操作都是对其本身的字符序列进行操作，而不是生成新的对象。因此StringBuffer对象内容可变、长度可变，可以将多个字符串值直接联合，效率高</li>
</ul>
<p><a href="https://www.nowcoder.com/questionTerminal/f5f375fc6f1f466488daddbc2d224e4d" title="Title" target="_blank" rel="external">例1</a></p>
<pre><code>定义有StringBuffer s1=new StringBuffer(10);s1.append(&quot;1234&quot;)则s1.length()和s1.capacity()分别是：4和10
</code></pre><p>(3) StringBuilder：非线程安全的可变字符序列</p>
<h3 id="问：数组有没有length-方法-String有没有length-方法？"><a href="#问：数组有没有length-方法-String有没有length-方法？" class="headerlink" title="问：数组有没有length()方法? String有没有length()方法？"></a>问：数组有没有length()方法? String有没有length()方法？</h3><p>数组没有length()方法，但有length属性；String有length()方法。</p>
<h3 id="问：String的replaceAll-方法"><a href="#问：String的replaceAll-方法" class="headerlink" title="问：String的replaceAll()方法"></a>问：String的replaceAll()方法</h3><p><a href="https://www.nowcoder.com/profile/7404313/test/8073294/3033?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a>易错的题目</p>
<pre><code>public static void main (String[] args) { 
    String classFile = &quot;com.jd.&quot;. replaceAll(&quot;.&quot;, &quot;/&quot;) + &quot;MyClass.class&quot;;
    System.out.println(classFile);
}

输出为：/////////MyClass.class
replaceAll方法的第一个参数是一个正则表达式，而&quot;.&quot;在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成&quot;/&quot;。
如果想替换的只是&quot;.&quot;的话，正则表达式那里就要写成&quot;\\.&quot;或者是&quot;[.]&quot;。前者将&quot;.&quot;转义为&quot;.&quot;这个具体字符，后者则匹配&quot;[]&quot;中的任意字符。
</code></pre><h3 id="问：String的编码转换"><a href="#问：String的编码转换" class="headerlink" title="问：String的编码转换"></a>问：String的编码转换</h3><p>编码转换，实现将GB2312编码的字符串转换为ISO-8859-1编码的字符串：</p>
<pre><code>String a=new String(&quot;中&quot;.getBytes(&quot;gb2312&quot;), &quot;iso-8859-1&quot;);
</code></pre><p>编码转换，实现将GBK编码字节流转换为UTF-8编码字节流：</p>
<pre><code>byte[] src, dst;
dst=new String (src, &quot;GBK&quot;).getbytes(&quot;UTF-8&quot;);
</code></pre><h3 id="问：Math类"><a href="#问：Math类" class="headerlink" title="问：Math类"></a>问：Math类</h3><p>(1) Math.floor(a) 求小于或等于a的最大整数，返回double类型。</p>
<pre><code>// 如果参数值总是等于某个整数，那么结果与该参数相同
Math.floor(1)=1.0
// 如果参数是NaN、无穷、正0、负0，那么结果与参数相同
Math.floor(Double.NaN)=Double.NaN
Math.floor(Double.POSITIVE_INFINITY)=Double.POSITIVE_INFINITY
Math.floor(Double.NEGATIVE_INFINITY)=Double.NEGATIVE_INFINITY
Math.floor(0.0)=0.0
Math.floor(-0.0)=-0.0
</code></pre><p>(2) Math.ceil(a) 求大于或等于a的最小整数，返回double类型。</p>
<pre><code>// 如果参数值总是等于某个整数，那么结果与该参数相同
Math.ceil(1)=1.0
// 如果参数是NaN、无穷、正0、负0，那么结果与参数相同
Math.ceil(Double.NaN)=Double.NaN
Math.ceil(Double.POSITIVE_INFINITY)=Double.POSITIVE_INFINITY
Math.ceil(Double.NEGATIVE_INFINITY)=Double.NEGATIVE_INFINITY
Math.ceil(0.0)=0.0
Math.ceil(-0.0)=-0.0
//如果参数小于0但大于-1.0，那么结果为-0.0(重要)
Math.ceil(-0.5)=-0.0 
</code></pre><p>(3) Math.round(a)=(long)floor(a+0.5d)；将原来的数字加上0.5后再向下取整，返回long类型，注意向下取整是指小于或等于它的最大整数。</p>
<pre><code>Math.round(6.4)=(long)floor(6.4+0.5d)=(long)floor(6.9)=6
Math.round(6.9)=(long)floor(6.9+0.5d)=(long)floor(7.4)=7
Math.round(6.5)=(long)floor(6.5+0.5d)=(long)floor(7.0)=7

Math.round(-6.4)=(long)floor(-6.4+0.5d)=(long)floor(-5.9)=-6
Math.round(-6.9)=(long)floor(-6.9+0.5d)=(long)floor(-6.4)=-7
Math.round(-6.5)=(long)floor(-6.5+0.5d)=(long)floor(-6.0)=-6

// 了解
Math.round(NaN)=0
Math.round(Math.round(Double.NEGATIVE_INFINITY或&lt;=Long.MIN_VALUE))=Long.MIN_VALUE
Math.round(Math.round(Double.POSITIVE_INFINITY或&gt;=Long.MAX_VALUE))=Long.MAX_VALUE
</code></pre><h3 id="问：枚举类型"><a href="#问：枚举类型" class="headerlink" title="问：枚举类型"></a>问：枚举类型</h3><p>Java中创建枚举类型要使用enum关键字，所有的枚举值都默认为static，在初始化时会对所有的枚举值对象调用一次构造函数进行初始化。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8016183/7688?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a></p>
<pre><code>enum AccountType{
    SAVING, FIXED, CURRENT;
    private AccountType(){
        System.out.println(“It is a account type”);
    }
}
class EnumOne{
    public static void main(String[]args){
        System.out.println(AccountType.FIXED);
    }
}

程序输出如下：
It is a account type
It is a account type
It is a account type
FIXED
</code></pre><h3 id="问：基本数据类型的包装类"><a href="#问：基本数据类型的包装类" class="headerlink" title="问：基本数据类型的包装类"></a>问：基本数据类型的包装类</h3><p>Java语言是一个面向对象的语言，但Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，即包装类。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/7993658/13311?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a></p>
<pre><code>class Two{
    Byte x;
}
class PassO{
    public static void main(String[] args){
        PassO p=new PassO();
        p.start();
    }
    void start(){
        Two t=new Two();
        System.out.print(t.x+””);
        Two t2=fix(t);
        System.out.print(t.x+” ” +t2.x);
    }
    Two fix(Two tt){
        tt.x=42;
        return tt;
    }
}

上面代码的输出为：null 42 42
基本数据类型的包装类型，属于引用类型。如果包装类成员变量没有显示初始化，那么Java默认初始化为null。
</code></pre><h3 id="问：如何将数值型字符串转换为对应类型的数字？"><a href="#问：如何将数值型字符串转换为对应类型的数字？" class="headerlink" title="问：如何将数值型字符串转换为对应类型的数字？"></a>问：如何将数值型字符串转换为对应类型的数字？</h3><p>例1：</p>
<pre><code>Integer.parseInt(&quot;1234&quot;);
Double.parseDouble(&quot;123.2&quot;);
</code></pre><h3 id="问：日期类"><a href="#问：日期类" class="headerlink" title="问：日期类"></a>问：日期类</h3><p>例1： 使用Java编程，打印昨天的当前时刻</p>
<pre><code>public class YesterdayCurrent{
    public static void main(String[] args){
        Calendar cal = Calendar.getInstance();
        cal.add(Calendar.DAY_OF_MONTH, -1);//从当前日期减去一天
        System.out.println(cal.getTime());
    }
} 
</code></pre><p>例2： 如何获取当前时间对应的年月日时分秒?</p>
<pre><code>public class CurrentTime{
    public static void main(String[] args){
        Calendar c=Calendar.getInstance();
        System.out.print(c.get(Calendar.YEAR)+&quot;年&quot;+(c.get(Calendar.MONTH)+1)+&quot;月&quot;+c.get(Calendar.DAY_OF_MONTH)+&quot;日, &quot;;
        System.out.println(c.get(Calendar.HOUR_OF_DAY)+&quot;:&quot;+c.get(Calendar.MINUTE)+&quot;:&quot;+c.get(Calendar.SECOND));
    }
}
</code></pre><p>或</p>
<pre><code>public class CurrentTime{
    public static void main(String[] args){
        Date date=new Date();
        System.out.println(date);
    }
}
</code></pre><p>例3： 如何取得从1970年到现在的毫秒数</p>
<pre><code>public static void main(String[] args){
    System.out.println(System.currentTimeMillis());
}
</code></pre><p>例4： 如何格式化日期？SimpleDateFormat</p>
<pre><code>public static void main(String[] args){
    SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);
    Date date=new Date();
    String dateStr=sdf.format(date);//把日期按指定格式转化为字符串
    System.out.println(dateStr);
}
</code></pre><h2 id="七、-容器"><a href="#七、-容器" class="headerlink" title="七、 容器"></a>七、 容器</h2><h3 id="问：Java的集合类框架"><a href="#问：Java的集合类框架" class="headerlink" title="问：Java的集合类框架"></a>问：Java的集合类框架</h3><p>Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和操作(增、删、改、查)。有的集合类允许重复的键，有些不允许。</p>
<p>Java集合类有两大接口：Collection和Map，一个是元素集合，另一个是键值对集合且键不能重复。</p>
<center><br><img src="/2017/05/28/Java/CollectionFramework1.png" width="90%">图 1<br></center>

<center><br><img src="/2017/05/28/Java/CollectionFramework2.png" width="80%">图 2<br></center>

<ul>
<li>List和Set接口继承了Collection接口。List是有序元素集合(即每个元素都可以按index访问)，元素可以重复；Set是无序元素集合(即每个元素都不可以按index访问)，元素不可以重复。ArrayList和LinkedList实现了List接口，HashSet和TreeSet实现了Set接口，这几个都比较常用；</li>
<li>HashMap和HashTable实现了Map接口。HashMap不是线程安全的，HashTable是线程安全的，但是HashMap性能更好；</li>
<li>ArrayList和Vector都以数组的方式存储，增、删慢，查、改快；ArrayList:线程不安全，速度快；Vector:线程安全，速度慢；LikedList: 以单链表的方式存储，操作慢</li>
</ul>
<p>注意：</p>
<ul>
<li><p>Arrays.asList()将一个数组转化为一个List对象，这个方法会返回一个ArrayList类型的对象，这个ArrayList类并非java.util.ArrayList类，而是Arrays类的静态内部类！对这个对象进行添加删除更新操作，会报UnsupportedOperationException异常。</p>
</li>
<li><p>ConcurrentHashMap使用segment来分段和管理锁，而不是用synchronized</p>
</li>
</ul>
<h3 id="问：java语言中的几种数组复制方法效率比较"><a href="#问：java语言中的几种数组复制方法效率比较" class="headerlink" title="问：java语言中的几种数组复制方法效率比较"></a>问：java语言中的几种数组复制方法效率比较</h3><p>System.arraycopy &gt; clone &gt; Arrays.copyOf &gt; for循环</p>
<h3 id="问：Java集合框架中线程安全的类"><a href="#问：Java集合框架中线程安全的类" class="headerlink" title="问：Java集合框架中线程安全的类"></a>问：Java集合框架中线程安全的类</h3><p>Vector、Stack(它继承了Vector)、Hashtable、Properties、Enumeration、(非集合类的StringBuffer)</p>
<h3 id="问：ArrayList和LinkedList有什么区别？"><a href="#问：ArrayList和LinkedList有什么区别？" class="headerlink" title="问：ArrayList和LinkedList有什么区别？"></a>问：ArrayList和LinkedList有什么区别？</h3><p>ArrayList和LinkedList都实现了List接口，他们有以下的不同点：</p>
<p>(1) ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以链表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。</p>
<p>(2) 相对于ArrayList，LinkedList的插入、添加、删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。</p>
<p>(3) LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</p>
<h3 id="问：数组-Array-和列表-ArrayList-的区别？什么时候应该使用Array而不是ArrayList？"><a href="#问：数组-Array-和列表-ArrayList-的区别？什么时候应该使用Array而不是ArrayList？" class="headerlink" title="问：数组(Array)和列表(ArrayList)的区别？什么时候应该使用Array而不是ArrayList？"></a>问：数组(Array)和列表(ArrayList)的区别？什么时候应该使用Array而不是ArrayList？</h3><p>(1) Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。(但是需要注意的是：Array数组中存放的一定是同种类型的元素；ArrayList就不一定了，因为ArrayList可以存储Object。)</p>
<p>(2) Array大小是固定的，ArrayList的大小是动态变化的。</p>
<p>(3) ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。</p>
<p>对于基本类型数据，ArrayList使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>
<h3 id="问：Vector和ArrayList的主要区别"><a href="#问：Vector和ArrayList的主要区别" class="headerlink" title="问：Vector和ArrayList的主要区别"></a>问：Vector和ArrayList的主要区别</h3><p>(1) Vector是同步的，而ArrayList不是同步的。即Vector是线程安全的，而ArrayList是线程不安全的。</p>
<p>(2) 在元素增加，容量需要增长时，Vector容量默认增长为原来一倍，而ArrayList增长原来的50%，这样,ArrayList就有利于节约内存空间。 </p>
<p>(3) 如果涉及到堆栈、队列等操作，应该考虑用Vector；如果需要快速随机访问元素，应该使用ArrayList。</p>
<h3 id="问：ArrayList容量"><a href="#问：ArrayList容量" class="headerlink" title="问：ArrayList容量"></a>问：ArrayList容量</h3><p>ArrayList的构造函数总共有三个</p>
<ul>
<li><p>ArrayList()构造一个初始容量为 10 的空列表，动态增长时，容量增长到当前容量的1.5倍</p>
</li>
<li><p>ArrayList(Collection&lt;? extends E&gt; c)<br>构造一个包含指定collection的元素的列表，这些元素是按照该collection的迭代器返回它们的顺序排列的。</p>
</li>
<li><p>ArrayList(int initialCapacity)构造一个具有指定初始容量的空列表。</p>
</li>
</ul>
<h3 id="问：什么是Java优先级队列-Priority-Queue-？"><a href="#问：什么是Java优先级队列-Priority-Queue-？" class="headerlink" title="问：什么是Java优先级队列(Priority Queue)？"></a>问：什么是Java优先级队列(Priority Queue)？</h3><p>PriorityQueue是一个基于堆排序的无界队列，此队列按照在构造时所指定的顺序对元素排序，既可以根据元素的自然顺序来指定排序，也可以给它提供一个负责给元素排序的比较器来指定，这取决于使用哪种构造方法。</p>
<p>PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。</p>
<p>最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。</p>
<h3 id="问：什么是迭代器-Iterator-？"><a href="#问：什么是迭代器-Iterator-？" class="headerlink" title="问：什么是迭代器(Iterator)？"></a>问：什么是迭代器(Iterator)？</h3><p>Iterator接口提供了很多对集合中元素进行迭代的方法，每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的remove(Object Obj)删除，可以通过迭代器的remove()方法删除。</p>
<h3 id="问：Enumeration接口和Iterator接口的区别有哪些？"><a href="#问：Enumeration接口和Iterator接口的区别有哪些？" class="headerlink" title="问：Enumeration接口和Iterator接口的区别有哪些？"></a>问：Enumeration接口和Iterator接口的区别有哪些？</h3><p>(1) Enumeration速度是Iterator的2倍，同时占用更少的内存。</p>
<p>(2) 但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。</p>
<p>(3) 同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/7971730/15549?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a>list是一个ArrayList的对象，为了能够在Iterator遍历的过程中正确并安全的删除一个list中保存的对象，//todo delete处可以可以填写什么代码？</p>
<pre><code>Iterator it = list.iterator();
int index = 0;
while (it.hasNext()){
    Object obj = it.next();
    if (needDelete(obj)){//needDelete返回boolean，决定是否要删除
        //todo delete
    }
    index ++;
}

正确答案：it.remove();
</code></pre><h3 id="问：Iterator和ListIterator的区别是什么？"><a href="#问：Iterator和ListIterator的区别是什么？" class="headerlink" title="问：Iterator和ListIterator的区别是什么？"></a>问：Iterator和ListIterator的区别是什么？</h3><p>(1) Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</p>
<p>(2) Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。</p>
<p>(3) ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p>
<h3 id="问：快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#问：快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="问：快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？"></a>问：快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</h3><p>快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个ConcurrentModification异常。</p>
<p>安全失败：你在迭代的时候会对底层集合做一个拷贝，所以有另一个线程在修改上层集合的时候，访问是不会受影响的，不会抛出ConcurrentModification异常。</p>
<blockquote>
<p>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受原集合上修改的影响。</p>
<p>java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。</p>
<p>快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</p>
</blockquote>
<h3 id="问：HashMap和Hashtable有什么区别？"><a href="#问：HashMap和Hashtable有什么区别？" class="headerlink" title="问：HashMap和Hashtable有什么区别？"></a>问：HashMap和Hashtable有什么区别？</h3><p>HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：</p>
<p>(1) HashMap允许键和值是null（但是最多只能有一个键为null，可以有一个或多个键所对应的值都为null。当get()方法返回null值时，既可以表示HashMap中没有该键，又可以表示该键所对应的值为null。因此，<strong>在HashMap中不能由get()方法来判断 HashMap中是否存在某个键，而应该用containsKey()方法来判断</strong>）；而Hashtable不允许键或者值是null。</p>
<p>(2) Hashtable是同步的，而HashMap不是，即HashMap是非线程安全的，HashTable是线程安全的。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。因为线程安全的问题，HashMap效率比HashTable的要高。</p>
<p>(3) HashMap提供了可供应用于迭代键的Iterator，因此，HashMap是快速失败的。Hashtable也使用了Iterator，另一方面，由于历史原因，Hashtable还提供了对键的Enumeration，是安全失败的。</p>
<p>(4) 哈希值的使用不同，HashTable直接使用对象的hashCode，而HashMap重新计算hash值。</p>
<p>(5) Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式不同。HashTable中hash数组默认大小是11，增加的方式是old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/7977669/3213?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a>，<a href="https://www.nowcoder.com/profile/7404313/test/8045843/14454?onlyWrong=0" title="Title" target="_blank" rel="external">例2</a>，看两道题的评论</p>
<p>一般现在不建议用HashTable</p>
<blockquote>
<p>(1) HashTable是遗留类，内部实现很多没优化和冗余。</p>
<p>(2) 即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。</p>
</blockquote>
<h3 id="问：Java中的HashMap的工作原理是什么？"><a href="#问：Java中的HashMap的工作原理是什么？" class="headerlink" title="问：Java中的HashMap的工作原理是什么？"></a>问：Java中的HashMap的工作原理是什么？</h3><p>Java中的HashMap是以键值对(key-value)的形式存储元素的。</p>
<p>HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。<br>当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。</p>
<p>HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。</p>
<p>HashMap中解决哈希冲突的方法是<strong>链地址法</strong>。HashMap的底层结构是一个数组，数组中的每一项是一条链表。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8045843/14935?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a></p>
<h3 id="问：HashSet"><a href="#问：HashSet" class="headerlink" title="问：HashSet"></a>问：HashSet</h3><p><strong>HashSet子类依靠hashCode()和equal()方法来区分重复元素</strong></p>
<p>HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值前，会去判断当前Map中是否含有该key对象，内部是先通过key的hashCode，确定有相同的hashCode之后，再通过equals方法判断是否相同。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8088719/26118?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a></p>
<h3 id="问：HashSet和TreeSet有什么区别？"><a href="#问：HashSet和TreeSet有什么区别？" class="headerlink" title="问：HashSet和TreeSet有什么区别？"></a>问：HashSet和TreeSet有什么区别？</h3><p>HashSet的底层是由哈希表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。</p>
<p>TreeSet的底层是由红黑树来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。</p>
<h3 id="问：Set中的元素不可重复"><a href="#问：Set中的元素不可重复" class="headerlink" title="问：Set中的元素不可重复"></a>问：Set中的元素不可重复</h3><p>Set中的元素是不允许重复的。因此Set再插入或删除元素时，需要对两个元素进行比较。比较时，Set会先调用hashCode方法，判断两个元素是否有相同的hashCode，如果不相同，证明不相等；如果hashcode相同，再调用equals方法，如果equals方法判断返回true，则两个元素是相同的，否则两个元素不相同。</p>
<p>判断Set中是否包含某一个元素是通过contains来判断的。</p>
<h3 id="问：hashCode-和equals-方法的重要性体现在什么地方？"><a href="#问：hashCode-和equals-方法的重要性体现在什么地方？" class="headerlink" title="问：hashCode()和equals()方法的重要性体现在什么地方？"></a>问：hashCode()和equals()方法的重要性体现在什么地方？</h3><p>Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。</p>
<h3 id="问：Comparable和Comparator接口是干什么的？列出它们的区别。"><a href="#问：Comparable和Comparator接口是干什么的？列出它们的区别。" class="headerlink" title="问：Comparable和Comparator接口是干什么的？列出它们的区别。"></a>问：Comparable和Comparator接口是干什么的？列出它们的区别。</h3><p>Java提供了只包含一个compareTo()方法的Comparable接口。</p>
<blockquote>
<p>这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。</p>
</blockquote>
<p>Java提供了包含compare()和equals()两个方法的Comparator接口。</p>
<blockquote>
<p>compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。</p>
<p>equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。</p>
</blockquote>
<p>(1) Comparable和Comparator都是用来实现集合中元素的比较、排序的，只是Comparable是在集合内部定义方法实现排序，Comparator是在集合外部定义方法实现排序，所以，如果想要实现对集合中元素的排序，就需要在集合外定义实现Comparator接口的方法或在集合内实现Comparable接口的方法compareTo()。Comparator位于包java.util下，而Comparable位于包java.lang下。</p>
<p>(2) Comparable是一个对象本身就已经支持自比较所需要实现的接口（如 String、Integer自己就可以完成比较大小操作，已经实现了Comparable接口），自定义的类要在加入list容器中后能够排序，可以实现Comparable接口，在用Collections类的sort方法排序时，如果不指定Comparator，那么就以自然顺序排序，这里的自然顺序就是实现Comparable接口设定的排序方式。 </p>
<p>(3) Comparator是一个专用的比较器，当这个对象不支持自比较或者自比较函数不能满足你的要求时，你可以写一个比较器来完成两个对象之间大小的比较。</p>
<h3 id="问：Collection和Collections"><a href="#问：Collection和Collections" class="headerlink" title="问：Collection和Collections"></a>问：Collection和Collections</h3><p>Collection是java.util下的接口，它是各种集合结构的父接口，其下有set及list</p>
<p>Collections是java.util下的类，它包含有各种有关集合操作的算法(静态方法)</p>
<h3 id="问：Java集合类框架的最佳实践有哪些？"><a href="#问：Java集合类框架的最佳实践有哪些？" class="headerlink" title="问：Java集合类框架的最佳实践有哪些？"></a>问：Java集合类框架的最佳实践有哪些？</h3><p>根据应用的需要正确选择要使用的集合的类型对性能非常重要</p>
<p>(1) 假如元素的大小是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。</p>
<p>(2) 有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。</p>
<p>(3) 为了类型安全、可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。</p>
<p>(4) 使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。</p>
<p>(5) 编程的时候接口优先于实现。</p>
<p>(6) 底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。</p>
<h3 id="问：装箱与拆箱"><a href="#问：装箱与拆箱" class="headerlink" title="问：装箱与拆箱"></a>问：装箱与拆箱</h3><p>自动装箱是Java编译器在基本数据类型和对应的包装类型之间做的一个转化，例如把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。</p>
<h3 id="问：装箱与拆箱中的-和equals"><a href="#问：装箱与拆箱中的-和equals" class="headerlink" title="问：装箱与拆箱中的==和equals()"></a>问：装箱与拆箱中的==和equals()</h3><p><strong>下面的规则基本意思是对的，但语言尚不严格正确</strong></p>
<p>(1) 基本数据类型变量和基本数据类型包装类对象进行”==”运算符的比较，基本数据类型封装类对象将会自动拆箱变为基本数据类型后再进行比较。例如Integer(0)和0比较时，Integer(0)会自动拆箱为int类型再进行比较。</p>
<p>(2) 两个Integer类型变量进行”==”比较，如果这两个对象的值在-128至127且值相等，那么返回true，否则返回false，这跟Integer.valueOf()方法的缓冲对象有关。</p>
<p>(3) </p>
<p>(4) 两个基本数据类型封装类变量进行equals()比较，equals()会首先比较对象的类型，如果类型相同，继续比较值，如果值也相同，返回true，否则返回false。</p>
<p>(5) 基本数据类型封装类对象调用equals()，但是参数是基本数据类型变量，这时候，基本数据类型变量会先进行自动装箱转换为其封装类型对象，再进行4中的比较。</p>
<p>例1：</p>
<pre><code>int a=257;
Integer b1=257; //Integer b1=257会先调用Integer.valueOf()方法将257转化为new Integer(257)对象
Integer b2=57;  //Integer b2=57会先调用Integer.valueOf()方法返回缓存中的57
Integer b3=257;
Integer b4=57;
Integer c=new Integer(257);
Integer d=new Integer(257);
Integer e1=Integer.valueOf(257); //Integer.valueOf()方法将257转化为new Integer(257)对象
Integer e2=Integer.valueOf(57);  //Integer.valueOf()方法返回缓存中的57

// int和Integer(无论new否)比，都为true
System.out.println(a==b1); // true，规则(1)
System.out.println(a==c); // true，规则(1)

// 两个都是非new出来的Integer，如果数在-128到127之间，则是true，否则为false 
System.out.println(b1==b3); // false，规则(2)
System.out.println(b2==b4); // true，规则(2)
System.out.println(b1==e1); // false，规则(3)
System.out.println(b2==e2); // true，规则(3)

// Integer与new Integer比较，结果为false；两个都是new出来的,都为false
System.out.println(b1==c); // false，规则(3)
System.out.println(c==d); // false，规则(3)

//System.out.println(a.equals(b1));  编译出错，基本型不能调用equals()
System.out.println(b1.equals(b3)); // true，规则(4)
System.out.println(c.equals(d)); // true，规则(4)

System.out.println(b1.equals(257.0)); // false，规则(5)，257.0先封装成Double对象再进行比较
</code></pre><p><b></b></p>
<pre><code>public static void main(String[] args){    
    Boolean flag=false;//先调用Boolean.valueOf(boolean b)返回false对应的Boolean对象Boolean.FALSE，然后赋值给flag，flag值为Boolean.FALSE    
    /* 先赋值，遇到if条件表达式自动拆箱     
     * 1. 先调用Boolean.valueOf(boolean b)返回true对应的Boolean对象Boolean.TRUE，然后赋值给flag，flag值为Boolean.TRUE     
     * 2. 调用booleanValue()返回flag值对应的基础数据类型值true     
     * 3. 结果输出true     
     */    
    if (flag=true){        
        System.out.println(&quot;true&quot;);    
    }else{        
        System.out.println(&quot;false&quot;);    
    }
}
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/7964595/25372?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a>，<a href="https://www.nowcoder.com/profile/7404313/test/8073294/3794?onlyWrong=0" title="Title" target="_blank" rel="external">例2</a>，<a href="https://www.nowcoder.com/profile/7404313/test/8049404/15318?onlyWrong=0" title="Title" target="_blank" rel="external">例3</a></p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8049404/16022?onlyWrong=0" title="Title" target="_blank" rel="external">例4：</a>重要的题目</p>
<h3 id="问：为什么集合类没有实现Cloneable和Serializable接口？"><a href="#问：为什么集合类没有实现Cloneable和Serializable接口？" class="headerlink" title="问：为什么集合类没有实现Cloneable和Serializable接口？"></a>问：为什么集合类没有实现Cloneable和Serializable接口？</h3><p>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的，因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</p>
<h3 id="问：泛型"><a href="#问：泛型" class="headerlink" title="问：泛型"></a>问：泛型</h3><p><a href="https://www.nowcoder.com/profile/7404313/test/8066549/7693?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a>重要的题目</p>
<pre><code>class A {}
class B extends A {}
class C extends A {}
class D extends B {}
Which four statements are true?

(A) The type List&lt;A&gt;is assignable to List.
(B) The type List&lt;B&gt;is assignable to List&lt;A&gt;.
(C) The type List&lt;Object&gt;is assignable to List&lt;?&gt;.
(D) The type List&lt;D&gt;is assignable to List&lt;?extends B&gt;.
(E) The type List&lt;?extends A&gt;is assignable to List&lt;A&gt;.
(F) The type List&lt;Object&gt;is assignable to any List reference.
(G) The type List&lt;?extends B&gt;is assignable to List&lt;?extends A&gt;.

正确答案：ACDG
</code></pre><h2 id="八、-流"><a href="#八、-流" class="headerlink" title="八、 流"></a>八、 流</h2><h3 id="问：Java中有几种类型的流？"><a href="#问：Java中有几种类型的流？" class="headerlink" title="问：Java中有几种类型的流？"></a>问：Java中有几种类型的流？</h3><p>Java中有字节流和字符流。字节流继承于InputStream/OutputStream，字符流继承于Reader/Writer。</p>
<p>在java.io包中还有许多其他的流，低层流与调层流，高层流主要是为了提高性能和使用方便。</p>
<center><br><img src="/2017/05/28/Java/IO-Stream.png" width="60%">图 1<br></center>

<h3 id="问：输入输出流的理解"><a href="#问：输入输出流的理解" class="headerlink" title="问：输入输出流的理解"></a>问：输入输出流的理解</h3><p>在Java使用流的机制进行数据的传送，从文件到内存是输入流，从内存到文件是输出流。</p>
<p>流可以分为节点流和处理流，节点流可以从一个特定的数据源(如文件、内存等)读写数据；而处理流则是连接在已存在的节点流或处理流之上，通过对数据的处理为程序提供更强大的读写功能。</p>
<center><br><img src="/2017/05/28/Java/IO1.JPG" width="40%">图 1<br></center>

<center><br><img src="/2017/05/28/Java/IO2.JPG" width="40%">图 2<br></center>

<p>常用的节点流</p>
<center><br><img src="/2017/05/28/Java/IO3.JPG" width="70%">图 1<br></center>

<p>常用的处理流</p>
<center><br><img src="/2017/05/28/Java/IO4.JPG" width="70%">图 2<br></center>

<p>节点流向处理流转换的实例：</p>
<pre><code>FileInputStream(System.in) -&gt; InputSteamReader -&gt; BufferReader
OutputSteam(System.out) -&gt; PrintStream
FileReader -&gt; BufferedReader
FileWriter -&gt; PrintWriter或bufferWriter
</code></pre><h2 id="九、-多线程"><a href="#九、-多线程" class="headerlink" title="九、 多线程"></a>九、 多线程</h2><p>推荐阅读：<a href="http://tengj.top/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="Title" target="_blank" rel="external">嘟嘟独立博客</a></p>
<p>推荐阅读：<a href="http://blog.csdn.net/vking_wang/article/details/9952063" title="Title" target="_blank" rel="external">Java多线程锁机制</a></p>
<h3 id="问：进程和线程的区别是什么？"><a href="#问：进程和线程的区别是什么？" class="headerlink" title="问：进程和线程的区别是什么？"></a>问：进程和线程的区别是什么？</h3><p>进程是资源分配的基本单位，而线程是CPU调度的基本单位。</p>
<p>一个进程可以有多个线程，多个线程共享进程的资源，线程又叫做轻量级进程。</p>
<h3 id="问：线程的几种状态"><a href="#问：线程的几种状态" class="headerlink" title="问：线程的几种状态"></a>问：线程的几种状态</h3><center><br><img src="/2017/05/28/Java/thread-state.png" width="85%"><br></center>

<p><strong>(1) 新建(new)</strong>：新创建了一个线程对象。</p>
<p><strong>(2) 可运行(runnable)</strong>：线程对象创建后，其他线程(比如main线程)调用了该对象的start()方法，该状态的线程便位于可运行线程池中，等待被线程调度选中，获取cpu的使用权。</p>
<p><strong>(3) 运行(running)</strong>：可运行状态(runnable)的线程获得了cpu时间片(timeslice)，执行程序代码。</p>
<p><strong>(4) 阻塞(block)</strong>：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：</p>
<blockquote>
<p>等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。</p>
<p>同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</p>
<p>其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。            </p>
</blockquote>
<p>当sleep()状态超时、 join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</p>
<p><strong>(5) 死亡(dead)</strong>：线程run()、 main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8066549/26053?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a>此题有疑问，感觉下面这句话是不对的。</p>
<pre><code>Java线程调度算法是平台独立的。
</code></pre><h3 id="问：创建线程有几种不同的方式？你喜欢哪一种？为什么？"><a href="#问：创建线程有几种不同的方式？你喜欢哪一种？为什么？" class="headerlink" title="问：创建线程有几种不同的方式？你喜欢哪一种？为什么？"></a>问：创建线程有几种不同的方式？你喜欢哪一种？为什么？</h3><p>(1) 继承Thread类，重写run()方法</p>
<pre><code>public class ThreadTest1 {
    public static void main(String[] args){
        MyThread thread=new MyThread(&quot;T1&quot;);
        thread.start();
        System.out.println(&quot;The main thread is running.&quot;);
    }
}
class MyThread extends Thread{
    private String name;
    public MyThread(String name) {
        this.name = name;
    }
    @Override
    public void run() {
        System.out.println(&quot;The thread &quot;+this.name+&quot; is running.&quot;);
    }
}
</code></pre><p>(2) 实现Runnable接口，重写run()方法</p>
<pre><code>public class ThreadTest2 {
    public static void main(String[] args){
        Thread thread=new Thread(new MyThread2(&quot;T2&quot;));
        thread.start();
        System.out.println(&quot;The main thread is running.&quot;);
    }
}
class MyThread2 implements Runnable{
    private String name;
    public MyThread2(String name) {
        this.name = name;
    }
    @Override
    public void run() {
        System.out.println(&quot;The thread &quot;+this.name+&quot; is running.&quot;);
    }
}
</code></pre><p>(3) 使用ExecutorService、Callable、Future实现有返回结果的多线程</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8078128/25818?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a><br><a href="https://www.nowcoder.com/questionTerminal/fefb0691a35444198c36e8ce0d19c8d9" title="Title" target="_blank" rel="external">例2：</a>注意评论</p>
<p>实现Runnable接口这种方式更受欢迎。在应用设计中线程类已经继承了别的类的情况下，需要多继承，只能实现接口（而Java不支持多继承，却支持实现多个接口），这样就不再需要继承Thread类，避免单继承的局限。同时，线程池也是非常高效的，很容易实现和使用。</p>
<h3 id="问：start-和run"><a href="#问：start-和run" class="headerlink" title="问：start()和run()"></a>问：start()和run()</h3><p>无论是通过继承Thread类还是实现Runnable接口来创建线程，都必须调用start()方法启动线程。线程启动后，线程进入就绪状态，当CPU分配时间给它时，它才开始运行。并不是一调用start()方法线程就立即运行。</p>
<h3 id="问：Java四种线程池的使用"><a href="#问：Java四种线程池的使用" class="headerlink" title="问：Java四种线程池的使用"></a>问：Java四种线程池的使用</h3><p>应用程序可以使用Executor/Callable/Future框架来创建线程池。</p>
<p>(1) ExecutorService java.util.concurrent.Executors.newSingleThreadExecutor()</p>
<p>Creates an Executor that uses a single worker thread operating off an unbounded queue. (Note however that if this single thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks.) Tasks are guaranteed to execute sequentially, and no more than one task will be active at any given time. Unlike the otherwise equivalent newFixedThreadPool(1) the returned executor is guaranteed not to be reconfigurable to use additional threads.</p>
<p>Returns:<br>the newly created single-threaded Executor</p>
<p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>
<p>示例代码：</p>
<pre><code>import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class NewSingleThreadExecutor {
    public static void main(String[] args) {
        ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
        for (int i = 0; i &lt; 10; i++) {
            final int index = i;
            singleThreadExecutor.execute(new Runnable() {
                public void run() {
                    try {
                        System.out.println(index);
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
    }
}

// 顺序执行各个任务，依次输出结果
</code></pre><p>(2) ExecutorService java.util.concurrent.Executors.newFixedThreadPool(int nThreads)</p>
<p>创建一个含有固定数量线程的线程池，可控制最大并发任务数，超出的任务会在队列中等待。</p>
<p>`Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue. At any point, at most nThreads threads will be active processing tasks. If additional tasks are submitted when all threads are active, they will wait in the queue until a thread is available. If any thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks. The threads in the pool will exist until it is explicitly shutdown.</p>
<p>Parameters:<br>nThreads the number of threads in the pool</p>
<p>Returns:<br>the newly created thread pool</p>
<pre><code>import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class NewFixedThreadPool {
    public static void main(String[] args) {
        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
        for (int i = 0; i &lt; 10; i++) {
            final int index = i;
            fixedThreadPool.execute(new Runnable() {
                public void run() {
                    try {
                        System.out.println(index);
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
    }
}

// 因为线程池大小为3，每个线程输出index后sleep 2秒，所以每隔两秒打印3个数字
</code></pre><p>(3) ExecutorService java.util.concurrent.Executors.newCachedThreadPool()</p>
<p>Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available. These pools will typically improve the performance of programs that execute many short-lived asynchronous tasks. Calls to execute will reuse previously constructed threads if available. If no existing thread is available, a new thread will be created and added to the pool. Threads that have not been used for sixty seconds are terminated and removed from the cache. Thus, a pool that remains idle for long enough will not consume any resources. Note that pools with similar properties but different details (for example, timeout parameters) may be created using ThreadPoolExecutor constructors.</p>
<p>Returns:<br>the newly created thread pool</p>
<pre><code>import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolExecutorTest {
    public static void main(String[] args) {
        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; 10; i++) {
            final int index = i;
            try {
                Thread.sleep(index * 1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            cachedThreadPool.execute(new Runnable() {
                public void run() {
                    System.out.println(index);
                }
            });
        }
    }
}
</code></pre><p>(4) ScheduledExecutorService java.util.concurrent.Executors.newScheduledThreadPool(int corePoolSize)</p>
<p>创建一个含有固定数量线程的线程池，支持延时任务或周期性任务的执行。</p>
<p>Creates a thread pool that can schedule commands to run after a given delay, or to execute periodically.</p>
<p>Parameters:<br>corePoolSize the number of threads to keep in the pool, even if they are idle<br>Returns:<br>a newly created scheduled thread pool<br>Throws:<br>IllegalArgumentException - if corePoolSize &lt; 0</p>
<p>执行延时任务的示例代码：</p>
<pre><code>import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class NewScheduledThreadPool1 {
    public static void main(String[] args) {
        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
        scheduledThreadPool.schedule(new Runnable() {
            public void run() {
                System.out.println(&quot;delay 3 seconds&quot;);
            }
        }, 3, TimeUnit.SECONDS);
    }
}

// 表示延迟3秒执行任务
</code></pre><p>执行定期性任务的示例代码：</p>
<pre><code>import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class NewScheduledThreadPool2 {
    public static void main(String[] args) {
        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
        scheduledThreadPool.scheduleAtFixedRate(new Runnable() {
            public void run() {
                System.out.println(&quot;delay 1 seconds, and excute every 3 seconds&quot;);
            }
        }, 1, 3, TimeUnit.SECONDS);
    }
}

// 表示延迟1秒后，每3秒执行一次任务
</code></pre><h3 id="问：同步和异步"><a href="#问：同步和异步" class="headerlink" title="问：同步和异步"></a>问：同步和异步</h3><p>同步：上一段代码没完成，下一段必须等到上一段代码完成后才可以执行。</p>
<p>异步：上一段代码没完成，下一段不必等到上一段代码完成就可以执行。</p>
<h3 id="问：synchronized关键字"><a href="#问：synchronized关键字" class="headerlink" title="问：synchronized关键字"></a>问：synchronized关键字</h3><p>推荐阅读：<a href="http://tengj.top/2016/05/03/threadsynchronized2/" title="Title" target="_blank" rel="external">嘟嘟独立博客</a></p>
<p>在Java中，每一个对象都拥有一个锁标记，也称为监视器。一旦一个方法或一个代码块被synchronized修饰，那么这个部分就放入了监视器的监视区域，确保在同一时刻最多只有一个线程执行该部分代码，线程在获取锁之前不允许执行该部分的代码。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8066549/3206?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a></p>
<pre><code>java实现进程之间的同步执行采用的机制是：监视器
</code></pre><p>当两个并发线程访问同一个对象的synchronized方法或代码块时，两个线程间是互斥的，在同一时刻只能有一个线程得到执行，另一个线程被阻塞，因为在执行synchronized方法或代码块的线程会锁定当前对象，只有在当前线程执行完这些代码并释放该对象的锁时，下一个线程才能锁定并执行该对象的synchronized方法或代码块。</p>
<p>(1) 当一个线程访问对象的一个synchronized方法或代码块时，另一个线程仍然可以访问该对象的非synchronized方法或代码块。(两个线程使用的是同一个对象)</p>
<p>(2) 当一个线程访问对象的一个synchronized方法或代码块时，其他线程对该对象的所有其它synchronized方法或代码块的访问将被阻塞(同上，两个线程使用的是同一个对象)。</p>
<p>例2：</p>
<pre><code>当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?
答：其它线程可以进入该对象的非synchronized方法，不可以进入该对象的synchronized方法。
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/8078128/16017?onlyWrong=0" title="Title" target="_blank" rel="external">例3：</a>看评论</p>
<pre><code>public class HelloSogou{
     public static synchronized void main(String[] a){
        Thread t=new Thread(){
            public void run(){
                Sogou();
            }
         };
         t.run();
         System.out.print(&quot;Hello&quot;);
     }
     static synchronized void Sogou(){
         System.out.print(&quot;Sogou&quot;);
    }
}

上面JAVA程序的输出是：SogouHello
</code></pre><p>(3) 如果父类中的某个方法使用了synchronized关键字，而子类中覆盖了这个方法，默认情况下子类中的这个方法并不是同步的，必须显示的在子类的这个方法中加上synchronized关键字之后该方法才同步。当然，也可以在子类中调用父类中相应的方法，这样虽然子类中的方法并不是同步的，但子类调用了父类中的同步方法，也就相当子类方法也同步了。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/7906972/14929?onlyWrong=0" title="Title" target="_blank" rel="external">例4：</a>判断正误</p>
<pre><code>构造方法不需要同步化。(正确)
一个子类不可以覆盖掉父类的同步方法。(错误)
</code></pre><h3 id="问：同步方法和同步代码块的区别是什么？"><a href="#问：同步方法和同步代码块的区别是什么？" class="headerlink" title="问：同步方法和同步代码块的区别是什么？"></a>问：同步方法和同步代码块的区别是什么？</h3><p>Java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时(增删改查)，将会导致数据的不准确，相互之间产生冲突。因此加入了同步锁，以避免在该线程没有结束前，其他线程操作该资源变量，从而保证了变量的唯一性，准确性。</p>
<p>Java中每个对象都有一把锁，线程可以通过synchronized关键字来获取对象上的锁。</p>
<p><strong>(1) 同步方法(粗粒度锁)：</strong>由synchronized关键字修饰的方法</p>
<p>修饰一般方法:public synchronized void method(){…}，获取的是当前被调用对象的锁<br>修饰静态方法:public static synchronized void method(){…}，获取当前类的字节码对象上的锁 </p>
<p>举例：如果一个线程执行一个对象的非static的synchronized方法，另外一个线程执行这个对象所属类的static的synchronized方法，此时不会发生互斥现象，因为访问static的synchronized方法占用的是类的字节码对象锁，而访问非static的synchronized方法占用的是对象锁，所以不存在互斥现象。</p>
<pre><code>public class SychronizedTest {
    public static void main(String[] args){
        SynObj obj=new SynObj();
        Thread01 thread01=new Thread01(&quot;Thread01&quot;, obj);
        Thread01 thread02=new Thread01(&quot;Thread02&quot;, obj);
        Thread02 thread03=new Thread02(&quot;Thread03&quot;);
        Thread02 thread04=new Thread02(&quot;Thread04&quot;);
        thread01.start();
        thread02.start();
        thread03.start();
        thread04.start();
    }
}

class Thread01 extends Thread{
    private String threadName;
    private SynObj obj;
    public Thread01(String threadName, SynObj obj) {
        this.threadName=threadName;
        this.obj = obj;
    }
    @Override
    public void run() {
        this.obj.run1(this.threadName);
    }
}

class Thread02 extends Thread{
    private String threadName;
    public Thread02(String threadName) {
        this.threadName=threadName;
    }
    @Override
    public void run() {
        SynObj.run2(this.threadName);
    }
}

class SynObj{
    // 同步方法
    public synchronized void run1(String threadName){
        for(int i=0; i&lt;3; i++){
            try {
                Thread.sleep(1000);
                System.out.println(threadName+&quot; run1 i=&quot;+i);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    // 同步static方法
    public static synchronized void run2(String threadName){
        for(int i=0; i&lt;3; i++){
            try {
                Thread.sleep(1000);
                System.out.println(threadName+&quot; run2 i=&quot;+i);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

Thread01和Thread02之间存在互斥关系，Thread03和Thread03之间存在互斥关系，但是Thread01/Thread02和Thread03/Thread04之间不存在互斥关系。
一种可能的输出：
Thread01 run1 i=0
Thread03 run2 i=0
Thread03 run2 i=1
Thread01 run1 i=1
Thread03 run2 i=2
Thread01 run1 i=2
Thread02 run1 i=0
Thread04 run2 i=0
Thread04 run2 i=1
Thread02 run1 i=1
Thread02 run1 i=2
Thread04 run2 i=2
</code></pre><p><strong>(2) 同步代码块(细粒度锁)：</strong>: 由synchronized关键字修饰的语句块，同步代码块可以选择以什么语句块来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法</p>
<blockquote>
<p>synchronized(obj) {…}，同步代码块可以指定获取某个对象上的锁。</p>
</blockquote>
<pre><code>public class SychronizedTest {
    public static void main(String[] args){
        SynObj synObj1=new SynObj();
        SynObj synObj2=new SynObj();
        Obj obj1=new Obj();
        Obj obj2=new Obj();
        Thread01 thread01=new Thread01(&quot;Thread01&quot;, synObj1);
        Thread01 thread02=new Thread01(&quot;Thread02&quot;, synObj1);
        Thread01 thread03=new Thread01(&quot;Thread03&quot;, synObj2);
        Thread02 thread04=new Thread02(&quot;Thread04&quot;, synObj1, obj1);
        Thread02 thread05=new Thread02(&quot;Thread05&quot;, synObj1, obj1);
        Thread02 thread06=new Thread02(&quot;Thread06&quot;, synObj2, obj2);
        thread01.start();
        thread02.start();
        thread03.start();
        thread04.start();
        thread05.start();
        thread06.start();
    }
}

class Thread01 extends Thread{
    private String threadName;
    private SynObj obj;
    public Thread01(String threadName, SynObj obj) {
        this.threadName=threadName;
        this.obj = obj;
    }
    @Override
    public void run() {
        this.obj.run1(this.threadName);
    }
}

class Thread02 extends Thread{
    private String threadName;
    private SynObj synObj;
    private Obj obj;
    public Thread02(String threadName, SynObj synObj, Obj obj) {
        this.threadName=threadName;
        this.synObj=synObj;
        this.obj=obj;
    }
    @Override
    public void run() {
        this.synObj.run2(this.threadName, this.obj);
    }
}

class SynObj{
    public void run1(String threadName){
        // 同步代码块，锁住的是对象本身
        synchronized(this){
            for(int i=0; i&lt;3; i++){
                try {
                    Thread.sleep(1000);
                    System.out.println(threadName+&quot; run1 i=&quot;+i);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    public void run2(String threadName, Obj obj){
        // 同步代码块，锁住的是对象obj
        synchronized(obj){
            for(int i=0; i&lt;3; i++){
                try {
                    Thread.sleep(1000);
                    System.out.println(threadName+&quot; run1 i=&quot;+i);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class Obj{}
</code></pre><p><br></p>
<pre><code>Thread01和Thread02之间存在互斥关系，但是Thread01/Thread02和Thread03之间不存在互斥关系。
注释掉thread04，thread05和thread06的启动代码
//thread04.start();
//thread05.start();
//thread06.start();
一种可能的输出：
Thread01 run1 i=0
Thread03 run1 i=0
Thread01 run1 i=1
Thread03 run1 i=1
Thread01 run1 i=2
Thread03 run1 i=2
Thread02 run1 i=0
Thread02 run1 i=1
Thread02 run1 i=2

Thread04和Thread05之间存在互斥关系，但是Thread04/Thread05和Thread06之间不存在互斥关系。
注释掉thread01，thread02和thread03的启动代码
//thread01.start();
//thread02.start();
//thread03.start();
一种可能的输出：
Thread04 run1 i=0
Thread06 run1 i=0
Thread06 run1 i=1
Thread04 run1 i=1
Thread04 run1 i=2
Thread06 run1 i=2
Thread05 run1 i=0
Thread05 run1 i=1
Thread05 run1 i=2
</code></pre><p>将SynObj的run2方法的被锁对象换成obj.getClass()之后，此时Thread04、Thread05和Thread06之间存在互斥关系。因此Synchronized后面括号括起来的部分为synchronized(className.class)，作用的对象是这个类的所有对象</p>
<pre><code>public void run2(String threadName, Obj obj){
    // 同步代码块，锁住的是对象obj
    synchronized(obj.getClass()){
        for(int i=0; i&lt;3; i++){
            try {
                Thread.sleep(1000);
                System.out.println(threadName+&quot; run1 i=&quot;+i);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

一种可能的输出为：
Thread04 run1 i=0
Thread04 run1 i=1
Thread04 run1 i=2
Thread06 run1 i=0
Thread06 run1 i=1
Thread06 run1 i=2
Thread05 run1 i=0
Thread05 run1 i=1
Thread05 run1 i=2
</code></pre><h3 id="Java支持并发编程的同步机制"><a href="#Java支持并发编程的同步机制" class="headerlink" title="Java支持并发编程的同步机制"></a>Java支持并发编程的同步机制</h3><p><a href="https://www.nowcoder.com/profile/7404313/test/7977669/7696?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a></p>
<pre><code>JDK提供的用于并发编程的同步器有：Semaphore、CyclicBarrier、CountDownLatch
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/8109636/56073?onlyWrong=0" title="Title" target="_blank" rel="external">例2：</a></p>
<pre><code>CyclicBarrier让一组线程等待其他线程；CountDownLatch让一组线程等待某个事件发生
Callable类的call()方法可以返回值和抛出异常
线程调用start()方法后进行就绪状态，等待获取CPU的使用权
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/8103755/55196?onlyWrong=0" title="Title" target="_blank" rel="external">例3：</a></p>
<pre><code>CopyOnWriteArrayList适合于读操作远远大于写操作的场景里，比如缓存。
ReadWriteLock 当写操作时，其他线程无法读取或写入数据，而当读操作时，其它线程无法写入数据，但却可以读取数据。适用于读取远远大于写入的操作。
ConcurrentHashMap是一个线程安全的HashTable，它的主要功能是提供了一组和HashTable功能相同但是线程安全的方法。
ConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，不用对整个ConcurrentHashMap加锁。
</code></pre><h3 id="问：wait、notify、notifyAll"><a href="#问：wait、notify、notifyAll" class="headerlink" title="问：wait、notify、notifyAll"></a>问：wait、notify、notifyAll</h3><ul>
<li>wait()</li>
</ul>
<p>(1) 该方法用来让当前线程进入休眠状态，直到被唤醒或被中断为止。</p>
<p>(2) 在调用wait()之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait()方法。如果调用wait()时，线程没有持有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch结构。</p>
<p>(3) 进入wait()方法后，当前线程释放锁。在从 wait()返回前，线程与其他线程竞争重新获得锁。</p>
<ul>
<li>notify()</li>
</ul>
<p>(1) 该方法也要在同步方法或同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁，如果调用notify()时线程没有持有适当的锁，也会抛出IllegalMonitorStateException。</p>
<p>(2) 该方法用来唤醒那些可能等待该对象的对象锁的其他线程。如果有多个线程等待，则线程调度器任意挑选出其中一个wait()状态的线程来发出通知，并使它等待获取该对象的对象锁（notify后，发出通知的当前线程不会马上释放该对象锁，wait所在的线程并不能马上获取该对象锁，要等到程序退出synchronized代码块后，当前线程才会释放锁，wait所在的线程也才可以获取该对象锁），但不惊动其他同样在等待被该对象notify的线程们。</p>
<p>(3) 当第一个获得了该对象锁的wait线程运行完毕以后，它会释放掉该对象锁，此时如果该对象没有再次使用notify 语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，会继续阻塞在wait状态，直到这个对象发出一个notify或notifyAll。这里需要注意：它们等待的是被notify或notifyAll，而不是锁。这与下面的 notifyAll()方法执行后的情况不同。</p>
<ul>
<li>notifyAll()</li>
</ul>
<p>该方法与 notify ()方法的工作方式相同，重要的一点差异是：<br>notifyAll 使所有原来在该对象上 wait 的线程统统退出 wait 的状态（即全部被唤醒，不再等待notify或notifyAll，但由于此时还没有获取到该对象锁，因此还不能继续往下执行），开始等待获取该对象上的锁，一旦该对象锁被释放（notifyAll线程退出调用了notifyAll的synchronized代码块的时候），他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出synchronized代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。</p>
<p>总结：如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</p>
<p>案例：当前线程调用对象的notify后，当前线程不会马上释放该对象锁，wait所在的线程并不能马上获取该对象锁，要等到程序退出synchronized代码块后，当前线程才会释放锁，wait所在的线程也才可以获取该对象锁。</p>
<pre><code>public static void main(String[]args)throws Exception {
    final Object obj = new Object();
    Thread t1 = new Thread() {
        public void run() {
            synchronized (obj) {
                try {
                    obj.wait();
                    System.out.println(&quot;Thread 1 wake up.&quot;);
                } catch (InterruptedException e) {
                }
            }
        }
    };
    t1.start();
    Thread.sleep(1000);//We assume thread 1 must start up within 1 sec.
    Thread t2 = new Thread() {
        public void run() {
            synchronized (obj) {
                obj.notifyAll();
                System.out.println(&quot;Thread 2 sent notify.&quot;);
            }
        }
    };
    t2.start();
}

output:
Thread 2 sent notify.
Thread 1 wake up
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/8045843/7689?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a>找出代码中错误的地方。</p>
<pre><code>void waitForSignal(){
    Object obj = new Object();
    synchronized(Thread.currentThread()){
        obj.wait();
        obj.notify();
    }
}

第一个错误是wait()方法要以try/catch包覆，或是掷出InterruptedException才行
第二个错误是wait或者notify方法被调用的对象必须与synchronized中的对象一致，否则会有IllegalMonitorStateException
</code></pre><p><a href="https://www.nowcoder.com/profile/7404313/test/8088719/3255?onlyWrong=0" title="Title" target="_blank" rel="external">例2：</a></p>
<pre><code>可用来实现线程间通知和唤醒的方式：
Object.wait/notify/notifyAll
Condition.await/signal/signalAll
</code></pre><h2 id="问：sleep-方法和wait-方法的区别"><a href="#问：sleep-方法和wait-方法的区别" class="headerlink" title="问：sleep()方法和wait()方法的区别"></a>问：sleep()方法和wait()方法的区别</h2><p>sleep()：该方法让线程休眠指定的时间，当这个时间达到之后，线程会再次醒来。</p>
<p>wait()：该方法用来让当前线程进入休眠状态，直到被唤醒或被中断为止。</p>
<p>(1) sleep()是Thread类的方法，wait()是Object类的方法</p>
<p>(2) wait()，notify()和notifyAll()只能在同步方法或同步代码块中使用，而sleep()可以在任何地方使用</p>
<p>(3) 调用sleep()方法后，线程进入睡眠状态，但不会释放对象锁，休眠时间结束后会自动进入就绪状态；调用wait()方法后，线程会释放对象锁，进入此对象的等待池(wait pool)中，直到其他线程调用对象的notify()方法(或notifyAll()方法)时才能唤醒等待池中的线程进入等锁池(lock pool)，如果线程重新获得对象的锁就可以进入就绪状态。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8073294/15267?onlyWrong=0" title="Title" target="_blank" rel="external">例1：</a>sleep()和wait()的对比</p>
<h3 id="问：sleep-方法和yield-方法的区别"><a href="#问：sleep-方法和yield-方法的区别" class="headerlink" title="问：sleep()方法和yield()方法的区别"></a>问：sleep()方法和yield()方法的区别</h3><p>调用线程yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制交出CPU的具体时间，另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。</p>
<p>注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。</p>
<p>sleep()方法和yield()方法的区别:</p>
<p>(1) sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</p>
<p>(2) 线程执行sleep()方法后转入阻塞(blocked)状态，而执行yield()方法后转入就绪(ready)状态；</p>
<p>(3) sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；</p>
<p>(4) sleep()方法比yield()方法(跟操作系统CPU调度相关)具有更好的可移植性。</p>
<h3 id="问：join-方法"><a href="#问：join-方法" class="headerlink" title="问：join()方法"></a>问：join()方法</h3><p>方法join()的作用是让调用join()方法的线程等待被调用线程结束，再继续往下执行。</p>
<h3 id="问：volatile关键字"><a href="#问：volatile关键字" class="headerlink" title="问：volatile关键字"></a>问：volatile关键字</h3><p>推荐阅读：<a href="http://tengj.top/2016/05/06/threadvolatile4/" title="Title" target="_blank" rel="external">嘟嘟独立博客</a></p>
<p>volatile是java中的一个关键字，可以用来修饰被不同线程访问和修改的变量。</p>
<p>出于运行速率的考虑，Java编译器会把经常经常访问的变量放到缓存（严格讲应该是工作内存）中，读取变量则从缓存中读。但是在多线程编程中,内存中的值和缓存中的值可能会出现不一致。volatile用于限定变量只能从内存中读取，保证对所有线程而言，值都是一致的。但是volatile不能保证原子性，也就不能保证线程安全。</p>
<p>一旦一个共享变量(类的成员变量、类的静态成员变量)被volatile修饰之后，那么就具备了两层语义：<br>1）可见性：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。<br>2）禁止进行指令重排序：volatile只提供了保证访问该变量时，每次都是从内存中读取最新值，并不会使用寄存器缓存该值，每次都会从内存中读取。</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8004321/25776?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a>，<a href="https://www.nowcoder.com/profile/7404313/test/8070641/22468?onlyWrong=0" title="Title" target="_blank" rel="external">例2</a></p>
<h3 id="问：ThreadLocal"><a href="#问：ThreadLocal" class="headerlink" title="问：ThreadLocal"></a>问：ThreadLocal</h3><p>ThreadLocal类为每一个线程都维护了自己独有的变量拷贝。在Thread中有一个成员变量ThreadLocals，该变量的类型是ThreadLocalMap,也就是一个Map，它的键是threadLocal，值为就是变量的副本。因此ThreadLocal不是使用在多线程之间共享数据，而是让变量在每个线程中都有独立拷贝，使得不会出现一个线程读取变量时，该变量而被另一个线程修改的现象。</p>
<p>由于每个线程在访问该变量时，读取和修改的，都是自己独有的那一份变量拷贝，不会被其他线程访问，变量被彻底封闭在每个访问的线程中</p>
<p><a href="https://www.nowcoder.com/profile/7404313/test/8049404/7691?onlyWrong=0" title="Title" target="_blank" rel="external">例1</a>，<a href="https://www.nowcoder.com/profile/7404313/test/7977669/14506?onlyWrong=0" title="Title" target="_blank" rel="external">例2：</a>这题A答案似乎是错的</p>
<h4 id="问：什么是死锁-deadlock-？"><a href="#问：什么是死锁-deadlock-？" class="headerlink" title="问：什么是死锁(deadlock)？"></a>问：什么是死锁(deadlock)？</h4><p>两个线程或两个以上线程因争夺资源而都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是若无外力作用，这些线程都陷入了无限的等待中。</p>
<h4 id="问：如何确保N个线程可以访问N个资源同时又不导致死锁？"><a href="#问：如何确保N个线程可以访问N个资源同时又不导致死锁？" class="headerlink" title="问：如何确保N个线程可以访问N个资源同时又不导致死锁？"></a>问：如何确保N个线程可以访问N个资源同时又不导致死锁？</h4><p>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定访问资源的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</p>
<h2 id="十、-网络编程"><a href="#十、-网络编程" class="headerlink" title="十、 网络编程"></a>十、 网络编程</h2><h3 id="问：Java-Socket的几个方法"><a href="#问：Java-Socket的几个方法" class="headerlink" title="问：Java Socket的几个方法"></a>问：Java Socket的几个方法</h3><pre><code>getInetAddress()      Returns the address to which the socket is connected.      
getLocalAddress()     Gets the local address to which the socket is bound.      
getReuseAddress()     Tests if SO_RESUSADDR is enabled.      
getLocalPort()        Returns the remote port number to which this socket is connected.
</code></pre><h3 id="问：序列化"><a href="#问：序列化" class="headerlink" title="问：序列化"></a>问：序列化</h3><p>序列化:将一个对象保存到一个文件，可以通过流的方式在网络上传输；也可以将文件的内容读取，转化为一个对象。</p>
<p>处理对象流的机制：所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。</p>
<p>序列化是为了解决在对对象流进行读写操作时所引发的问题。</p>
<p>序列化的实现：将需要被序列化的类实现java.io.Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要写入的话则用输入流。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="https://hepsilion.github.io/2017/05/28/Java/" data-id="cj39vkjp3004610wrmmszx0k3" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="https://hepsilion.github.io/2017/05/28/Java/#comments" id="sourceId::2017/05/28/Java/" class="article-comment-link cy_cmt_count">评论</a>
    

        </footer>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/blog/2017/05/28/Database/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">上一篇</strong>
            <div class="article-nav-title">
                
                    Database
                
            </div>
        </a>
    
    
        <a href="/blog/2017/05/28/01-XML/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">下一篇</strong>
            <div class="article-nav-title">01-XML</div>
        </a>
    
</nav>


    
</article>


    
    <section id="comments">
    
        
    <div id="SOHUCS" sid="2017/05/28/Java/"></div>

    
    </section>

</section>
            
                <aside id="sidebar">
   <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/blog/',
        CONTENT_URL: '/blog/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/blog/js/insight.js"></script>

</div> 
   
        
    <div class="widget-wrap">
        <h3 class="widget-title"><i class="fa fa-edit"></i>最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/blog/2017/05/28/Docker-Hadoop-Helloworld/" class="thumbnail">
    
    
        <span style="background-image:url(https://wx2.sinaimg.cn/small/e3dde130ly1fft6ucav3vj20zk0iyq5v.jpg)" alt="Docker-Hadoop-Helloworld" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/blog/categories/环境配置/">环境配置</a></p>
                            <p class="item-title"><a href="/blog/2017/05/28/Docker-Hadoop-Helloworld/" class="title">Docker-Hadoop-Helloworld</a></p>
                            <p class="item-date"><time datetime="2017-05-28T14:48:12.000Z" itemprop="datePublished">2017-05-28</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/blog/2017/05/28/C-plus-plus/" class="thumbnail">
    
    
        <span style="background-image:url(https://wx2.sinaimg.cn/small/e3dde130ly1fft6ucav3vj20zk0iyq5v.jpg)" alt="C plus plus" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/blog/categories/C-C/">C/C++</a></p>
                            <p class="item-title"><a href="/blog/2017/05/28/C-plus-plus/" class="title">C plus plus</a></p>
                            <p class="item-date"><time datetime="2017-05-28T11:03:50.000Z" itemprop="datePublished">2017-05-28</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/blog/2017/05/28/Probability-Theory/" class="thumbnail">
    
    
        <span style="background-image:url(https://wx2.sinaimg.cn/small/e3dde130ly1fft6ucav3vj20zk0iyq5v.jpg)" alt="Probability Theory" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/blog/categories/概率论与数理统计/">概率论与数理统计</a></p>
                            <p class="item-title"><a href="/blog/2017/05/28/Probability-Theory/" class="title">Probability Theory</a></p>
                            <p class="item-date"><time datetime="2017-05-28T11:02:06.000Z" itemprop="datePublished">2017-05-28</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/blog/2017/05/28/Security/" class="thumbnail">
    
    
        <span style="background-image:url(https://wx2.sinaimg.cn/small/e3dde130ly1fft6ucav3vj20zk0iyq5v.jpg)" alt="Security" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/blog/categories/信息安全/">信息安全</a></p>
                            <p class="item-title"><a href="/blog/2017/05/28/Security/" class="title">Security</a></p>
                            <p class="item-date"><time datetime="2017-05-28T11:01:20.000Z" itemprop="datePublished">2017-05-28</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/blog/2017/05/28/Software-Testing/" class="thumbnail">
    
    
        <span style="background-image:url(https://wx2.sinaimg.cn/small/e3dde130ly1fft6ucav3vj20zk0iyq5v.jpg)" alt="Software Testing" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/blog/categories/软件测试/">软件测试</a></p>
                            <p class="item-title"><a href="/blog/2017/05/28/Software-Testing/" class="title">Software Testing</a></p>
                            <p class="item-date"><time datetime="2017-05-28T11:00:19.000Z" itemprop="datePublished">2017-05-28</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title"><i class="fa fa-folder"></i>分类</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/C-C/">C/C++</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Java/">Java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Java-Web/">Java Web</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Java基础/">Java基础</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/信息安全/">信息安全</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/并发/">并发</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/操作系统/">操作系统</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/数据库/">数据库</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/数据结构与算法/">数据结构与算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/概率论与数理统计/">概率论与数理统计</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/环境配置/">环境配置</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/算法/">算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/计算机组成原理/">计算机组成原理</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/计算机网络/">计算机网络</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/软件工程/">软件工程</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/软件测试/">软件测试</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title"><i class="fa fa-archive"></i>归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/05/">五月 2017</a><span class="archive-list-count">32</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title"><i class="fa fa-tag"></i>标签</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/C/">C++</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Java/">Java</a><span class="tag-list-count">16</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Linux/">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/SQL/">SQL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Web/">Web</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/docker/">docker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/hadoop/">hadoop</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/信息安全/">信息安全</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/并发/">并发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/操作系统/">操作系统</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/数据库/">数据库</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/数据结构/">数据结构</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/数理统计/">数理统计</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/概率论/">概率论</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/算法/">算法</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/网络/">网络</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/计算机组成原理/">计算机组成原理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/设计模式/">设计模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/软件工程/">软件工程</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/软件测试/">软件测试</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title"><i class="fa fa-link"></i>友链</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://hexo.io" target="_blank">Hexo</a>
                    </li>
                
                    <li>
                        <a href="http://yuren.space/blog" target="_blank">渔人</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2017 Hepsilion<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        
    
    <script id="cy_cmt_num" src="https://changyan.sohu.com/upload/plugins/plugins.list.count.js?clientId=cyt2dNhVw"></script>
    <script charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/changyan.js" ></script>
    <script type="text/javascript">
    window.changyan.api.config({
    appid: 'cyt2dNhVw',
    conf: 'prod_8acceb4b82a359a3e4f200f748824a83'
    });
    </script>




    
        <script src="/blog/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/blog/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/blog/js/main.js"></script>

    </div>
</body>
</html>