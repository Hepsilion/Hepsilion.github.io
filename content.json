{"meta":{"title":"Hepsilion","subtitle":"Hepsilion的博客","description":"Hepsilion的博客","author":"Hepsilion","url":"https://hepsilion.github.io"},"pages":[{"title":"About","date":"2017-10-21T13:19:21.648Z","updated":"2017-10-21T13:19:21.648Z","comments":true,"path":"about/index.html","permalink":"https://hepsilion.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-10-21T13:19:21.664Z","updated":"2017-10-21T13:19:21.664Z","comments":true,"path":"categories/index.html","permalink":"https://hepsilion.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-10-21T13:19:21.664Z","updated":"2017-10-21T13:19:21.664Z","comments":true,"path":"home/index.html","permalink":"https://hepsilion.github.io/home/index.html","excerpt":"","text":"博客说明目前本博客主要记录了我前一段时间在牛客网刷题过程中遇到的一些知识点，包含：我经常出错的、我认为易错的、我经常做到的、我容易忘记的题目，以及为保持内容相对完整性而加入的内容等。部分内容均来自牛客网中题目下方别人的评论，部分内容来自于网络上别人的博客，还有一部分内容来自书籍。 由于本人水平有限，目前该博客中的内容相对简单，未来我希望能够加入一些具有更多价值含量的东西，例如机器学习、深度学习或者比较酷炫的项目说明等。如果朋友你觉得下面的内容都太简单的话，还请多多包涵。 由于时间原因，我只是加之前记录的东西添加在该博客当中，而没有检查所有内容的正确性与完整性。如果有人在看下面这些知识点的过程中，发现存在错误的地方，还请帮忙指正，谢谢。 内容分类 计算机基础 数据结构 操作系统 计算机网络 计算机组成原理 未整理 数据库系统概念 Linux 未整理 软件工程 未整理 软件测试 未整理 信息安全 未整理 并发 未整理 Java Java基础 01-Java概述 02-基础语法 03-面向对象编程 04-异常处理 05-数组 06-常用类 07-集合类 08-流 09-多线程 10-网络编程 11-反射 12-JDBC Java虚拟机 Java内存区域与内存溢出异常 垃圾收集器与内存分配策略 JVM类加载机制 Java并发 Java Web 未整理 01-XML基础 02-Tomcat 03-Servlet 04-JSP Android Android基础 03-Activity 04-数据存储 05-SQLite数据库 06-ContentProvider 07-BroadcastReceiver 08-Service 09-网络编程 算法 未整理 算法 C/C++ 未整理 C/C++ 设计模式 未整理 设计模式 环境配置 01-使用Docker在本地搭建Hadoop分布式集群"},{"title":"Tags","date":"2017-10-21T13:19:21.664Z","updated":"2017-10-21T13:19:21.664Z","comments":true,"path":"tags/index.html","permalink":"https://hepsilion.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"IntelliJ IDEA使用技巧","slug":"IntelliJ-IDEA使用技巧","date":"2018-05-22T08:53:42.000Z","updated":"2018-05-22T08:54:17.101Z","comments":true,"path":"2018/05/22/IntelliJ-IDEA使用技巧/","link":"","permalink":"https://hepsilion.github.io/2018/05/22/IntelliJ-IDEA使用技巧/","excerpt":"","text":"IntelliJ IDEA使用技巧一、高效定位代码 打开搜索框: Ctrl+Shift+A 查看所有快捷键： Ctrl+Shift+A打开搜索框，输入keymap 打开或关闭某个窗口，可以从View-&gt;Tool Window看到对应的命令： Alt+数字 1. 代码跳转项目之间跳转 切换到前一个项目/后一个项目：Ctrl+Alt+左括号/右括号 文件之间跳转 最近打开的文件：Ctrl+E 最近修改的文件：Alt+Shift+C 利用书签跳转可以在搜索命令框搜索bookmark 显示书签： Shift+F11 设置无序书签： F11 设置有序书签： Ctrl+F11，然后设置序号 跳转到各个书签位置： Ctrl+序号，例如 Ctrl+1，Ctrl+3 添加到收藏使用 Alt+2 可以打开收藏视图 收藏类或类中的某个方法：将光标放在类名或方法名上，使用 Alt+Shift+F 收藏类或方法的代码 代码编辑区和文件区跳转 跳转到文件区： Alt+1 跳转到代码编辑区域： Esc 2. 精准搜索 搜索类：Ctrl+N 搜索文件：Ctrl+Shift+N 搜索符号：Ctrl+Shift+Ctrl+N 搜索字符串：Ctrl+Shift+F 二、批处理操作1. 列操作快捷键： 选中某个单词： Ctrl+Shift+左右箭头 跳转到前/后一个单词： Ctrl+左右箭头 将选中字符串全部转换为大写或小写： Ctrl+Shift+U 选中所有匹配的目标： Ctrl+Shift+Alt+J 例1：如何将下面左边内容快速地转换为右边内容 # line1 # line1 100: Aaaa AAAA(100) 200: BbB BBB(200) 300: cC CC(300) # line2 # line2 400: DDeeD DDDDD(400) 500: eE EE(500) # line3 # line3 600: FfFF FFFF(600) 700: Ggg GGG(700) 具体做法： (1) 使用 Ctrl+Shift+左右箭头 选中某个统一的符号，例如 ：，使用Ctrl+Shift+Alt+J选中所有行中统一的符号 (2) 使用Ctrl+Shift+左右箭头选中所有数字并剪切至行尾，添加左右括号，统一删除:和空格 (3) 使用Ctrl+Shift+左右箭头选中每一行中的单词，使用Ctrl+Shift+U转换大小写，剪切至数字前面 2. 代码模板使用Ctrl+Shift+A 搜索到 Live Template，在其中可以添加 Live Template 和 Template Group。 例1：可以定义template为psvm，描述为public static void main，具体内容为： public static void main(String[] args) { $END$ } 设置好应用场景。以后在输代码时，当输入psvm并按回车键，会自动出现上面代码块，并且光标停留在 $END$ 区域。 例2：可以定义template为psc，描述为public String，具体内容为： private String $VAR1$; //$VAR2$ $END$ 设置好应用场景。以后在输代码时，当输入psc并按回车键，会自动出现上面代码块，并且光标会依次停留在 $VAR1$、$END$ 区域。 3. postfix使用Ctrl+Shift+A 搜索到 Postfix Completion，在其中可以查看预设的postfix。 下面是常见的几种postfix： for： 输入数字.for后按回车键，会出现可供选择的postfix，选择其中一个后会自动填充代码 例如输入 100.for ，选择 fori 并按回车键后，会自动填充如下代码： for (int i = 0; i &lt; 100; i++) { } sout： 输入 XXX.sout后按回车键会自动填充代码 例如输入 new Date().sout并按回车键后，会自动填充如下代码： System.out.println(new Date()); return： 输入XXX.r，选择return并按回车，会自动填充代码 例如输入 user.r，选择return并按回车键后，会自动填充如下代码： return user; nn: 输入XXX.nn按回车键会自动填充代码 例如输入 user.nn并按回车键后，会自动填充如下代码： if (user != null) { } 4. alter+enter，自动提示 自动创建函数 list replace 字符串format或build 实现接口 单词拼写 导入包 三、编写高质量的代码1. 重构 重构变量/变量重命名： Shift+F6 如果在编写代码的过程中，想要修改某个变量的变量名以及该变量所有出现位置的名称，可以使用Shift+F6实现全部修改。 重构方法/修改方法签名： Ctrl+F6 如果在修改代码的过程中，想要修改某个被调用方法的方法签名，可以使用Ctrl+F6实现参数的删除、增加或修改。 2. 抽取 抽取局部变量： Ctrl+Alt+V 例1：有如下一段代码，我们想要将字符串”123”抽取出来定义成一个变量，我们可以在某个字符串”123”上使用Ctrl+Alt+V将其定义为变量。 public void fun() { System.out.println(&quot;123&quot;); System.out.println(&quot;123&quot;); System.out.println(&quot;123&quot;); System.out.println(&quot;123&quot;); System.out.println(&quot;123&quot;); } 最终抽取结果如下： public void fun() { String var = &quot;123&quot;; System.out.println(var); System.out.println(var); System.out.println(var); System.out.println(var); System.out.println(var); } 抽取静态变量： Ctrl+Alt+C 抽取成员变量： Ctrl+Alt+F 抽取方法参数： Ctrl+Alt+P 例2：假设有如下一段代码，我们想要将局部变量x抽取为方法参数，我们可以在x上使用Ctrl+Alt+P将其抽取为方法参数 public void fun() { String x = &quot;abc&quot;; System.out.println(x); System.out.println(x); System.out.println(x); System.out.println(x); System.out.println(x); } 最终抽取结果如下： public void fun(String x) { System.out.println(x); System.out.println(x); System.out.println(x); System.out.println(x); System.out.println(x); } 抽取方法： Ctrl+Alt+M 例3：假设有如下一段代码，我们想将其抽取为三个函数调用，我们可以在一个代码块上使用Ctrl+Alt+M将其抽取为一个方法 public void fun(String x) { System.out.println(x); System.out.println(x); System.out.println(x); System.out.println(x); System.out.println(x); } 最终抽取结果如下： public void fun(String x) { fun1(x); fun2(x); fun3(x); } private void fun3(String x) { System.out.println(x); System.out.println(x); } private void fun2(String x) { System.out.println(x); } private void fun1(String x) { System.out.println(x); System.out.println(x); } 四、寻找修改轨迹1. git集成 查看代码记录：annotate 查看所有修改：Ctrl+Alt+Shift+上下箭头 撤销(某一块、某一个文件、某一个项目的)修改：Ctrl+Alt+Z 2. local history当项目不受版本控制时，我们可以通过local history查看代码的修改记录 五、关联一切1. 关联SpringFile -&gt; Project Structure -&gt; Facets -&gt; Add -&gt; Spring -&gt; 将配置文件选中后，将可以让IDEA帮助管理Spring代码 2. 关联数据库View -&gt; Tool Window -&gt; Database -&gt; Add -&gt; Data Source -&gt; 选择具体的数据库，填入相关信息，便可以在IDEA中方便的使用数据库的信息。 六、调试程序七、其他操作 查看类中所有方法和属性： Ctrl+F12 查看Maven依赖结构： Ctrl+Alt+Shift+U 产看类图及继承关系： Ctrl+Alt+Shift+U 查看类继承层次结构：Ctrl+H 查看方法调度层次结构： Ctrl+Alt+H","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://hepsilion.github.io/categories/工具使用/"}],"tags":[],"keywords":[{"name":"工具使用","slug":"工具使用","permalink":"https://hepsilion.github.io/categories/工具使用/"}]},{"title":"新一代构建工具Gradle","slug":"新一代构建工具Gradle","date":"2018-05-22T08:53:28.000Z","updated":"2018-05-22T08:53:28.670Z","comments":true,"path":"2018/05/22/新一代构建工具Gradle/","link":"","permalink":"https://hepsilion.github.io/2018/05/22/新一代构建工具Gradle/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"全面解析Java注解","slug":"全面解析Java注解","date":"2018-05-22T08:51:54.000Z","updated":"2018-05-22T08:53:03.311Z","comments":true,"path":"2018/05/22/全面解析Java注解/","link":"","permalink":"https://hepsilion.github.io/2018/05/22/全面解析Java注解/","excerpt":"","text":"全面解析Java注解一、 注解概述1. JDK自带注解 @Override 告诉编译器该方法覆盖了父类的方法 @Deprecated 表示该方法已经过时 @Suppvisewarnings 表示忽略了”deprecation”警告 2. 常见第三方注解Spring中常见注解：@Autowired， @Service，@Repository Mybatis中常见注解：@InsertProvider，@UpdataProvider，@Options 3. Java注解的分类 按运行机制分类 源码注解：注解只在源码中存在，编译成.class文件就不存在了。 编译时注解：注解在源码和.class文件中都存在，如JDK自带注解。 运行时注解：在运行阶段依然起作用，甚至会影响程序的运行逻辑。 按注解来源分类： JDK自带注解 第三方注解 自定义注解 二、自定义注解1. 定义注解自定义注解的语法要求 使用@interface关键字定义注解，其中成员必须以无参无异常方式声明，同时可以用default为成员指定一个默认值； 自定义注解的成员类型是受限的，合法的类型包括原始类型、String、Class、Annotation和Enumeration； 如果注解只有一个成员，那么成员名必须取名为value()，并且在使用时可以忽略成员名和赋值号(=)； 注解类可以没有成员，没有成员的注解称为标识注解。 元注解说明 @Target： 指定注解的作用域： CONSTRUCTOR，构造方法 FIELD，属性 LOCAL_VARIABLE,局部变量 METHOD，方法 PACKAGE，包 PARAMETER，参数 TYPE 类或接口 @Retention： 指定注解的生命周期 SOURCE，源码级别，编译时丢失 CLASS，编译级别，运行时丢失 RUNTIME，运行级别，可以通过反射获取 @Inherited： 标识注解允许子类继承 @Documented： 指定生成javadoc时会包含注解 例1： 自定义注解的实例：@Target({ElementType.METHOD, ElementType.Type}) @Retention(RetentionPolicy.RUNTIME) @Inherited @Documented public @interface Description { String desc(); String author(); int age() default 18; } 2. 使用自定义注解使用注解的语法： @&lt;注解名&gt;(&lt;成员名1&gt;=&lt;成员值1&gt;, &lt;成员名2&gt;=&lt;成员值2&gt;, …) 例2：使用自定义注解的实例@Description(desc=&quot;I am eyeColor&quot;, author=&quot;Mooc Boy&quot;, age=18) public String eyeColor() { return &quot;red&quot;; } 三、解析注解解析注解：通过反射获取类、函数或成员上的运行时注解信息，从而实现动态控制程序的运行逻辑。 例1：下面通过实例演示解析注解的过程(1) 定义使用自定义注解的父类 @Description(desc = &quot;I am annotation in parent class&quot;, author = &quot;Parent&quot;) public class Parent { @Description(desc = &quot;I am annotation in parent method&quot;, author = &quot;Parent&quot;) public String name() { return &quot;name:parent&quot;; } } (2) 定义使用自定义注解的子类 @Description(desc = &quot;I am annotation in child class&quot;, author = &quot;Child&quot;) public class Child extends Parent { @Description(desc = &quot;I am annotation in child method&quot;, author = &quot;Child&quot;) @Override public String name() { return &quot;name:child&quot;; } } (3) 解析类和方法上的注解 public class Analyzer { public static void main(String[] args) { try { // 类注解解析方式 Class clazz = Class.forName(&quot;Child&quot;); boolean exists = clazz.isAnnotationPresent(Description.class); if(exists) { Description description = (Description) clazz.getAnnotation(Description.class); System.out.println(description.desc()); } // 第一种方法注解解析方式 Method[] methods = clazz.getMethods(); for(Method method : methods) { exists = method.isAnnotationPresent(Description.class); if(exists) { Description description = method.getAnnotation(Description.class); System.out.println(description.desc()); } } // 第二种方法注解解析方法 for(Method method:methods) { Annotation[] annotations = method.getAnnotations(); for(Annotation annotation:annotations) { if(annotation instanceof Description) { Description description = (Description) annotation; System.out.println(description.desc()); } } } } catch (ClassNotFoundException e) { e.printStackTrace(); } } } 解析结果如下： I am annotation in child class I am annotation in child method I am annotation in child method 注意： @Inherited只能实现类上注解的继承，而无法实现接口上注解的继承，即接口的注解无法影响到实现接口的类上面。 父类方法的注解也无法被子类继承。 例2：修改注解如下：@Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.CLASS) @Inherited @Documented public @interface Description { String desc(); String author(); int age() default 18; } 此时解析结果没有输出，说明该注解只作用于编译阶段，运行时注解丢失 例3：修改子类如下public class Child extends Parent { @Override public String name() { return &quot;name:child&quot;; } } 此时解析结果如下，说明父类方法的注解无法被子类方法继承： I am annotation in parent class 例4：修改父类如下@Description(desc = &quot;I am annotation in parent interface&quot;, author = &quot;Parent&quot;) public interface Parent { String name(); } 修改子类如下： public class Child implements Parent { @Override public String name() { return &quot;name:child&quot;; } } 此时解析结果没有输出，说明接口的注解无法影响到实现接口的类。 四、项目实战定义类： public class User { private int id; private String username; private String nickname; private int age; private String city; private String email; private String mobile; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getNickname() { return nickname; } public void setNickname(String nickname) { this.nickname = nickname; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getCity() { return city; } public void setCity(String city) { this.city = city; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getMobile() { return mobile; } public void setMobile(String mobile) { this.mobile = mobile; } } 需求：给定上面展示的实体类及设置了相关属性的对象，实现实体对象对应的SQL查询语句 public static void main(String[] args) { // 查询id为10的用户信息 User user1 = new User(); user1.setId(10); // 查询username为&quot;lucy&quot;的用户信息 User user2 = new User(); user2.setUsername(&quot;lucy&quot;); // 查询email在&quot;liu@sina.com,zh@163.com,777@qq.com&quot;中的用户信息 User user3 = new User(); user3.setEmail(&quot;liu@sina.com,zh@163.com,777@qq.com&quot;); String sql1 = query(user1); String sql2 = query(user2); String sql3 = query(user3); System.out.println(sql1); System.out.println(sql2); System.out.println(sql3); } 实现：通过自定义注解和注解解析实现SQL转化过程 (1) 定义注解Table @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Table { String value(); } (2) 定义注解Column @Target({ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME) public @interface Column { String value(); } (3) 给实体类添加注解 @Table(&quot;user&quot;) public class User { @Column(&quot;id&quot;) private int id; @Column(&quot;username&quot;) private String username; @Column(&quot;nickname&quot;) private String nickname; @Column(&quot;age&quot;) private int age; @Column(&quot;city&quot;) private String city; @Column(&quot;email&quot;) private String email; @Column(&quot;mobile&quot;) private String mobile; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getNickname() { return nickname; } public void setNickname(String nickname) { this.nickname = nickname; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getCity() { return city; } public void setCity(String city) { this.city = city; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getMobile() { return mobile; } public void setMobile(String mobile) { this.mobile = mobile; } } (4) 通过注解解析实现转化过程 private static String query(User user) { StringBuilder sb = new StringBuilder(); Class clazz = user.getClass(); boolean exists = clazz.isAnnotationPresent(Table.class); if(!exists) return null; Table table = (Table) clazz.getAnnotation(Table.class); String tableName = table.value(); sb.append(&quot;select * from &quot;).append(tableName).append(&quot; where 1=1&quot;); Field[] fields = clazz.getDeclaredFields(); for(Field field:fields) { exists = field.isAnnotationPresent(Column.class); if(!exists) continue; Column column = field.getAnnotation(Column.class); String fieldName = field.getName(); String methodName = &quot;get&quot;+fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1); Object fieldValue=null; try { Method method = clazz.getMethod(methodName); fieldValue = method.invoke(user); } catch (Exception e) { e.printStackTrace(); } if(fieldValue==null || (fieldValue instanceof Integer &amp;&amp; (Integer)fieldValue==0)){ continue; } sb.append(&quot; and &quot;).append(fieldName); if(fieldValue instanceof String) { if(((String)fieldValue).contains(&quot;,&quot;)) { String[] values = ((String)fieldValue).split(&quot;,&quot;); sb.append(&quot; in (&quot;); for(String value: values) { sb.append(&quot;&apos;&quot;).append(value).append(&quot;&apos;&quot;).append(&quot;,&quot;); } sb.deleteCharAt(sb.length()-1); sb.append(&quot;)&quot;); }else { sb.append(&quot;=&quot;).append(&quot;&apos;&quot;).append(fieldValue).append(&quot;&apos;&quot;); } }else { sb.append(&quot;=&quot;).append(fieldValue); } } return sb.toString(); } (4) 测试输出结果： select * from user where 1=1 and id=10 select * from user where 1=1 and username=&apos;lucy&apos; select * from user where 1=1 and email in (&apos;liu@sina.com&apos;,&apos;zh@163.com&apos;,&apos;777@qq.com&apos;)","categories":[{"name":"Java其他","slug":"Java其他","permalink":"https://hepsilion.github.io/categories/Java其他/"}],"tags":[{"name":"慕课网","slug":"慕课网","permalink":"https://hepsilion.github.io/tags/慕课网/"}],"keywords":[{"name":"Java其他","slug":"Java其他","permalink":"https://hepsilion.github.io/categories/Java其他/"}]},{"title":"07-文件上传","slug":"SpringMVC-07","date":"2017-10-22T06:55:13.000Z","updated":"2017-10-22T07:14:51.414Z","comments":true,"path":"2017/10/22/SpringMVC-07/","link":"","permalink":"https://hepsilion.github.io/2017/10/22/SpringMVC-07/","excerpt":"","text":"文件上传在Spring MVC中有两种实现上传文件的办法，第一种是Servlet3.0以下的版本通过commons-fileupload与commons-io完成的通用上传，第二种是Servlet3.0以上的版本通过Spring内置标准上传，不需借助第3方组件。通用上传也兼容Servlet3.0以上的版本。 一、Servlet3.0以下版本1. 添加上传依赖包因为需要借助第三方上传组件commons-fileupload与commons-io，所以要修改pom.xml文件添加依赖。 &lt;!--文件上传 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; 2. 新增上传页面upload1.jsp&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;上传文件&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;上传文件&lt;/h2&gt; &lt;form action=&quot;fileSave&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;p&gt; &lt;label for=&quot;files&quot;&gt;文件：&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;files&quot; id=&quot;files&quot; multiple=&quot;multiple&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/p&gt; &lt;p&gt;${message}&lt;/p&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 需要注意的关键点： method的值必为Post； enctype必须为multipart/form-data，该类型的编码格式专门用于二进制数据类型； 上传表单元素必须拥有name属性； 3. 修改配置文件，增加上传配置默认情总下Spring MVC对文件上传的视图内容是不能解析的，需要修改springmvc-servlet.xml配置文件配置一个CommonsMultipartResolver类型的解析器解析上传的内容。 &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot; /&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760000&quot; /&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot; /&gt; &lt;/bean&gt; 其具有的各属性的意义如下： defaultEncoding：默认编码格式 maxUploadSize：上传文件最大限制（字节byte） maxInMemorySize：缓冲区大小 当Spring的前置中心控制器接收到客户端发送的一个多分部请求，定义在上下文中的解析器将被激活并开始处理。解析器将当前的HttpServletRequest包装成一个支持多部分文件上传的MultipartHttpServletRequest对象，在控制器中可以获得上传的文件信息。 CommonsMultipartResolver用于通用的文件上传，支持各种版本的Servlet。 StandardServletMultipartResolver用于Servlet3.0以上的版本上传文件。 4. 增加控制器与Actionpackage org.spring.mvc.controller; import java.io.File; import javax.servlet.http.HttpServletRequest; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.multipart.MultipartFile; @Controller @RequestMapping(&quot;/upload&quot;) public class FileUploadController { @RequestMapping(&quot;/file1&quot;) public String file1(Model model) { return &quot;upload/upload1&quot;; } @RequestMapping(value = &quot;/fileSave&quot;, method = RequestMethod.POST) public String fileSave(Model model, MultipartFile[] files, HttpServletRequest request) throws Exception { for (MultipartFile file : files) { System.out.println(file.getOriginalFilename()); System.out.println(file.getSize()); System.out.println(&quot;--------------------------&quot;); File tempFile = new File(&quot;D:/&quot;, file.getOriginalFilename()); file.transferTo(tempFile); } return &quot;upload/upload1&quot;; } } 注意这里定义的是一个MultipartFile数组，可以接受多个文件上传，如果单文件上传可以修改为MultipartFile类型；另外上传文件的细节在这里并没有花时间处理，比如文件重名的问题，路径问题，关于重名最简单的办法是重新命名为GUID文件名。 5. 测试运行访问路径：http://localhost:8080/spring-mvc/upload/file1，运行结果如图1所示： 图 1 选择三个文件file1.txt，file2.txt，file3.txt，点击提交。 图 2 控制台输出： file1.txt 15 -------------------------- file2.txt 15 -------------------------- file3.txt 15 -------------------------- 图 3 二、Servlet3.0以上版本Servlet3.0以上的版本不再需要第三方组件Commons.io和commons-fileupload，上传的方式与4.1提到基本一样，但配置稍有区别，可以使用@MultipartConfig注解在Servlet上进行配置上传，也可以在web.xml上进行配置。 1. 修改web.xml配置上传参数&lt;!--Servlet3.0以上文件上传配置 --&gt; &lt;multipart-config&gt; &lt;max-file-size&gt;5242880&lt;/max-file-size&gt;&lt;!--上传单个文件的最大限制5MB --&gt; &lt;max-request-size&gt;20971520&lt;/max-request-size&gt;&lt;!--请求的最大限制20MB，一次上传多个文件时一共的大小 --&gt; &lt;file-size-threshold&gt;0&lt;/file-size-threshold&gt;&lt;!--当文件的大小超过临界值时将写入磁盘 --&gt; &lt;/multipart-config&gt; multipart-config的各参数含义如下： file-size-threshold：数字类型，当文件大小超过指定的大小后将写入到硬盘上。默认是0，表示所有大小的文件上传后都会作为一个临时文件写入到硬盘上。 location：指定上传文件存放的目录。当我们指定了location后，我们在调用Part的write(String fileName)方法把文件写入到硬盘的时候可以，文件名称可以不用带路径，但是如果fileName带了绝对路径，那将以fileName所带路径为准把文件写入磁盘，不建议指定。 max-file-size：数值类型，表示单个文件的最大大小。默认为-1，表示不限制。当有单个文件的大小超过了max-file-size指定的值时将抛出IllegalStateException异常。 max-request-size：数值类型，表示一次上传文件的最大大小。默认为-1，表示不限制。当上传时所有文件的大小超过了max-request-size时也将抛出IllegalStateException异常。 2. 修改pom.xml依赖信息删除pom.xml中对文件上传第三方的依赖。 3. 修改springmvc-servlet.xml配置信息将原有的文件上传通用解析器更换为标准解析器： &lt;!--文件上传解析器 --&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.support.StandardServletMultipartResolver&quot;&gt; &lt;/bean&gt; 4. 定义视图在view/up/下定义名称为upload2.jsp文件: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;上传文件 - Servlet3.0&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;上传文件 - Servlet3.0&lt;/h2&gt; &lt;form action=&quot;file3Save&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;p&gt; &lt;label for=&quot;files&quot;&gt;文件：&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;files&quot; id=&quot;files&quot; multiple=&quot;multiple&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/p&gt; &lt;p&gt;${message}&lt;/p&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 5. 定义Action@RequestMapping(&quot;/file2&quot;) public String file2(Model model){ return &quot;upload/upload2&quot;; } @RequestMapping(value=&quot;/file3Save&quot;, method=RequestMethod.POST) public String file3Save(Model model,MultipartFile[] files, HttpServletRequest request) throws Exception{ for (MultipartFile file : files) { System.out.println(file.getOriginalFilename()); System.out.println(file.getSize()); System.out.println(&quot;--------------------------&quot;); File tempFile=new File(file.getOriginalFilename()); file.transferTo(tempFile); } return &quot;upload/upload2&quot;; } 6. 测试运行访问路径：http://localhost:8080/spring-mvc/upload/file2","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hepsilion.github.io/categories/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hepsilion.github.io/tags/SpringMVC/"}],"keywords":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hepsilion.github.io/categories/SpringMVC/"}]},{"title":"06-Spring MVC验证器","slug":"SpringMVC-06","date":"2017-10-22T06:53:40.000Z","updated":"2017-10-22T07:14:43.729Z","comments":true,"path":"2017/10/22/SpringMVC-06/","link":"","permalink":"https://hepsilion.github.io/2017/10/22/SpringMVC-06/","excerpt":"","text":"Spring MVC验证器在展示Spring MVC验证器之前，先在前面项目的基础上，通过一个相对综合的示例串联前面学习过的一些知识点，主要实现产品管理管理功能，包含产品的添加，删除，修改，查询，多删除功能。 一、综合示例1. 新建POJO实体（entity）在包org.spring.mvc.model包中新增产品类型类ProductType： package org.spring.mvc.model; import java.io.Serializable; /** * 产品类型 */ public class ProductType implements Serializable { private static final long serialVersionUID = 2L; // 编号 private int id; // 名称 private String name; public ProductType() { } public ProductType(int id, String name) { super(); this.id = id; this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return &quot;编号：&quot; + this.getId() + &quot;，名称：&quot; + this.getName(); } } 修改产品POJO类Product： package org.spring.mvc.model; import java.io.Serializable; /** * 产品 */ public class Product implements Serializable { private static final long serialVersionUID = 1L; // 编号 private int id; // 名称 private String name; // 价格 private double price; // 产品类型 private ProductType productType; public Product() { productType = new ProductType(); } public Product(String name, double price) { super(); this.name = name; this.price = price; } public Product(int id, String name, double price) { super(); this.id = id; this.name = name; this.price = price; } public Product(int id, String name, double price, ProductType type) { super(); this.id = id; this.name = name; this.price = price; this.productType = type; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } public ProductType getProductType() { return productType; } public void setProductType(ProductType productType) { this.productType = productType; } @Override public String toString() { return &quot;编号(id)：&quot; + this.getId() + &quot;，名称(name)：&quot; + this.getName() + &quot;，价格(price)：&quot; + this.getPrice() + &quot;，类型(productType.Name)：&quot; + this.getProductType().getName(); } } 2. 新建业务层（Service）在包org.spring.mvc.service中创建产品类型服务接口ProductTypeService： package org.spring.mvc.service; import java.util.List; import org.spring.mvc.model.ProductType; /** * 产品类型服务 * */ public interface ProductTypeService { /** * 根据产品类型编号获得产品类型对象 */ public ProductType getProductTypeById(int id); /** * 获得所有的产品类型 */ public List&lt;ProductType&gt; getAllProductTypes(); } 创建产品类型服务接口ProductTypeService的实现类ProductTypeServiceImpl： package org.spring.mvc.service; import java.util.ArrayList; import java.util.List; import org.spring.mvc.model.ProductType; import org.springframework.stereotype.Service; @Service public class ProductTypeServiceImpl implements ProductTypeService { private static List&lt;ProductType&gt; productTypes; static { productTypes = new ArrayList&lt;ProductType&gt;(); productTypes.add(new ProductType(11, &quot;数码电子&quot;)); productTypes.add(new ProductType(21, &quot;鞋帽服饰&quot;)); productTypes.add(new ProductType(31, &quot;图书音像&quot;)); productTypes.add(new ProductType(41, &quot;五金家电&quot;)); productTypes.add(new ProductType(51, &quot;生鲜水果&quot;)); } @Override public ProductType getProductTypeById(int id) { for (ProductType productType : productTypes) { if (productType.getId() == id) { return productType; } } return null; } @Override public List&lt;ProductType&gt; getAllProductTypes() { return productTypes; } } 在包org.spring.mvc.service中创建产品服务接口ProductService： package org.spring.mvc.service; import java.util.List; import org.spring.mvc.model.Product; public interface ProductService { /** * 获得所有的产品 */ List&lt;Product&gt; getAllProducts(); /** * 通过编号获得产品 */ Product getProductById(int id); /** * 通过名称获得产品 */ List&lt;Product&gt; getProductsByName(String productName); /** * 新增产品对象 */ void addProduct(Product enttiy) throws Exception; /** * 更新产品对象 */ public void updateProduct(Product entity) throws Exception; /** * 删除产品对象 */ void deleteProduct(int id); /** * 多删除产品对象 */ void deletesProduct(int[] ids); } 创建产品服务接口ProductService的实现类ProductServiceImpl： package org.spring.mvc.service; import java.util.ArrayList; import java.util.List; import org.spring.mvc.model.Product; import org.springframework.stereotype.Service; @Service public class ProductServiceImpl implements ProductService { private static List&lt;Product&gt; products; static { ProductTypeService productTypeService = new ProductTypeServiceImpl(); products = new ArrayList&lt;Product&gt;(); products.add(new Product(198, &quot;Huwei P8&quot;, 4985.6, productTypeService.getProductTypeById(11))); products.add(new Product(298, &quot;李宁运动鞋&quot;, 498.56, productTypeService.getProductTypeById(21))); products.add(new Product(398, &quot;Spring MVC权威指南&quot;, 49.856,productTypeService.getProductTypeById(31))); products.add(new Product(498, &quot;山东国光苹果&quot;, 4.9856, productTypeService.getProductTypeById(51))); products.add(new Product(598, &quot;8开门超级大冰箱&quot;, 49856.1, productTypeService.getProductTypeById(41))); } /** * 获得所有的产品 */ @Override public List&lt;Product&gt; getAllProducts() { return products; } /** * 通过编号获得产品 */ @Override public Product getProductById(int id) { for (Product product : products) { if (product.getId() == id) { return product; } } return null; } /** * 通过名称获得产品名称 */ @Override public List&lt;Product&gt; getProductsByName(String productName) { if (productName == null || productName.equals(&quot;&quot;)) { return getAllProducts(); } List&lt;Product&gt; result = new ArrayList&lt;Product&gt;(); for (Product product : products) { if (product.getName().contains(productName)) { result.add(product); } } return result; } /** * 新增 * * @throws Exception */ @Override public void addProduct(Product entity) throws Exception { if (entity.getName() == null || entity.getName().equals(&quot;&quot;)) { throw new Exception(&quot;产品名称必须填写&quot;); } if (products.size() &gt; 0) { entity.setId(products.get(products.size() - 1).getId() + 1); } else { entity.setId(1); } products.add(entity); } /** * 更新 */ public void updateProduct(Product entity) throws Exception { if (entity.getPrice() &lt; 0) { throw new Exception(&quot;价格必须大于0&quot;); } Product source = getProductById(entity.getId()); source.setName(entity.getName()); source.setPrice(entity.getPrice()); source.setProductType(entity.getProductType()); } /** * 删除 */ @Override public void deleteProduct(int id) { products.remove(getProductById(id)); } /** * 多删除 */ @Override public void deletesProduct(int[] ids) { for (int id : ids) { deleteProduct(id); } } } 3. 实现展示、查询、删除与多删除功能在org.spring.mvc.controller包中定义一个名为ProductController的控制器 index请求处理方法在路径映射注解@RequestMapping中也并未指定value值是让该action为默认action，所有当我们访问系统时这个index就成了欢迎页。 package org.spring.mvc.controller; import org.spring.mvc.model.Product; import org.spring.mvc.service.ProductService; import org.spring.mvc.service.ProductTypeService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; @Controller @RequestMapping(&quot;/product&quot;) public class ProductController { @Autowired ProductService productService; @Autowired ProductTypeService productTypeService; /** * 展示与搜索 */ @RequestMapping public String index(Model model, String searchKey) { model.addAttribute(&quot;products&quot;, productService.getProductsByName(searchKey)); model.addAttribute(&quot;searchKey&quot;, searchKey); return &quot;product/index&quot;; } /** * 删除，id为路径变量 */ @RequestMapping(&quot;/delete/{id}&quot;) public String delete(@PathVariable int id) { productService.deleteProduct(id); return &quot;redirect:/product&quot;; } /** * 多删除，ids的值为多个id参数组成 */ @RequestMapping(&quot;/deletes&quot;) public String deletes(@RequestParam(&quot;id&quot;) int[] ids) { productService.deletesProduct(ids); return &quot;redirect:/product&quot;; } } 定义所有页面风格用的main.css样式： @CHARSET &quot;UTF-8&quot;; * { margin: 0; padding: 0; font-family: microsoft yahei; font-size: 14px; } body { padding-top: 20px; } .main { width: 90%; margin: 0 auto; border: 1px solid #777; padding: 20px; border-radius: 5px; } .main .title { font-size: 20px; font-weight: normal; border-bottom: 1px solid #ccc; margin-bottom: 15px; padding-bottom: 5px; color: #006ac1; } .main .title span { display: inline-block; font-size: 20px; color: #fff; padding: 0 8px; background: orangered; border-radius: 5px; } a { color: #006ac1; text-decoration: none; } a:hover { color: orangered; } .tab td, .tab, .tab th { border: 1px solid #777; border-collapse: collapse; } .tab td, .tab th { line-height: 26px; height: 26px; padding-left: 5px; } .abtn { display: inline-block; height: 18px; line-height: 18px; background: #006ac1; color: #fff; padding: 0 5px; border-radius: 5px; } .btn { height: 18px; line-height: 18px; background: #006ac1; color: #fff; padding: 0 8px; border: 0; border-radius: 5px; } .abtn:hover, .btn:hover { background: orangered; color: #fff; } p { padding: 5px 0; } fieldset { border: 1px solid #ccc; padding: 5px 10px; } fieldset legend { margin-left: 10px; font-size: 16px; } a.out, input.out { height: 23px; line-height: 23px; } form { margin: 10px 0; } 在view目录下新建目录product，在product目录下新建一个视图index.jsp： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;%@taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;link href=&quot;&lt;c:url value=&quot;/styles/main.css&quot;/&gt;&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;title&gt;产品管理&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;h2 class=&quot;title&quot;&gt; &lt;span&gt;产品管理&lt;/span&gt; &lt;/h2&gt; &lt;form method=&quot;get&quot;&gt; 名称：&lt;input type=&quot;text&quot; name=&quot;searchKey&quot; value=&quot;${searchKey}&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;搜索&quot; class=&quot;btn out&quot; /&gt; &lt;/form&gt; &lt;form action=&quot;product/deletes&quot; method=&quot;post&quot;&gt; &lt;table border=&quot;1&quot; width=&quot;100%&quot; class=&quot;tab&quot;&gt; &lt;tr&gt; &lt;th&gt;&lt;input type=&quot;checkbox&quot; id=&quot;chbAll&quot;&gt;&lt;/th&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;产品名&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;类型&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach var=&quot;product&quot; items=&quot;${products}&quot;&gt; &lt;tr&gt; &lt;th&gt;&lt;input type=&quot;checkbox&quot; name=&quot;id&quot; value=&quot;${product.id}&quot;&gt;&lt;/th&gt; &lt;td&gt;${product.id}&lt;/td&gt; &lt;td&gt;${product.name}&lt;/td&gt; &lt;td&gt;${product.price}&lt;/td&gt; &lt;td&gt;${product.productType.name}&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;product/delete/${product.id}&quot; class=&quot;abtn&quot;&gt;删除&lt;/a&gt; &lt;a href=&quot;product/edit/${product.id}&quot; class=&quot;abtn&quot;&gt;编辑&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;p style=&quot;color: red&quot;&gt;${message}&lt;/p&gt; &lt;p&gt; &lt;a href=&quot;product/add&quot; class=&quot;abtn out&quot;&gt;添加&lt;/a&gt; &lt;input type=&quot;submit&quot; value=&quot;删除选择项&quot; class=&quot;btn out&quot; /&gt; &lt;/p&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;&lt;c:url value=&quot;/scripts/jQuery1.11.3/jquery-1.11.3.min.js&quot;/&gt;&quot;&gt;&lt;/script&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 访问路径：http://localhost:8080/spring-mvc/product，运行结果如图1所示： 图 1 4. 新增产品在ProductController控制器中添加两个Action，一个用于渲染添加页面，另一个用于响应保存功能： /** * 新增，渲染出新增界面 */ @RequestMapping(&quot;/add&quot;) public String add(Model model) { // 与form绑定的模型 model.addAttribute(&quot;product&quot;, new Product()); // 用于生成下拉列表 model.addAttribute(&quot;productTypes&quot;, productTypeService.getAllProductTypes()); return &quot;product/add&quot;; } /** * 新增保存，如果新增成功转回列表页，如果失败回新增页，保持页面数据 */ @RequestMapping(&quot;/addSave&quot;) public String addSave(Model model, Product product) { try { // 根据类型的编号获得类型对象 product.setProductType(productTypeService.getProductTypeById(product.getProductType().getId())); productService.addProduct(product); return &quot;redirect:/product&quot;; } catch (Exception exp) { // 与form绑定的模型 model.addAttribute(&quot;product&quot;, product); // 用于生成下拉列表 model.addAttribute(&quot;productTypes&quot;, productTypeService.getAllProductTypes()); // 错误消息 model.addAttribute(&quot;message&quot;, exp.getMessage()); return &quot;product/add&quot;; } } 在view/product目录下新增视图add.jsp页面： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;%@taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;link href=&quot;&lt;c:url value=&quot;/styles/main.css&quot;/&gt;&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;title&gt;新增产品&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;h2 class=&quot;title&quot;&gt; &lt;span&gt;新增产品&lt;/span&gt; &lt;/h2&gt; &lt;form:form action=&quot;addSave&quot; modelAttribute=&quot;product&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;产品&lt;/legend&gt; &lt;p&gt; &lt;label for=&quot;name&quot;&gt;产品名称：&lt;/label&gt; &lt;form:input path=&quot;name&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;title&quot;&gt;产品类型：&lt;/label&gt; &lt;form:select path=&quot;productType.id&quot; items=&quot;${productTypes}&quot; itemLabel=&quot;name&quot; itemValue=&quot;id&quot;&gt; &lt;/form:select&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;price&quot;&gt;产品价格：&lt;/label&gt; &lt;form:input path=&quot;price&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; value=&quot;保存&quot; class=&quot;btn out&quot;&gt; &lt;/p&gt; &lt;/fieldset&gt; &lt;/form:form&gt; &lt;p style=&quot;color: red&quot;&gt;${message}&lt;/p&gt; &lt;p&gt; &lt;a href=&quot;&lt;c:url value=&quot;/product&quot; /&gt;&quot; class=&quot;abtn out&quot;&gt;返回列表&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 点击添加按钮，运行结果如图2所示： 图 2 5. 编辑产品在ProductController控制器中添加两个Action，一个用于渲染编辑页面，根据要编辑的产品编号获得产品对象，另一个用于响应保存功能。 /** * 编辑，渲染出编辑界面，路径变量id是用户要编辑的产品编号 */ @RequestMapping(&quot;/edit/{id}&quot;) public String edit(Model model, @PathVariable int id) { // 与form绑定的模型 model.addAttribute(&quot;product&quot;, productService.getProductById(id)); // 用于生成下拉列表 model.addAttribute(&quot;productTypes&quot;, productTypeService.getAllProductTypes()); return &quot;product/edit&quot;; } /** * 编辑后保存，如果更新成功转回列表页，如果失败回编辑页，保持页面数据 */ @RequestMapping(&quot;/editSave&quot;) public String editSave(Model model, Product product) { try { // 根据类型的编号获得类型对象 product.setProductType(productTypeService.getProductTypeById(product.getProductType().getId())); productService.updateProduct(product); return &quot;redirect:/product&quot;; } catch (Exception exp) { // 与form绑定的模型 model.addAttribute(&quot;product&quot;, product); // 用于生成下拉列表 model.addAttribute(&quot;productTypes&quot;, productTypeService.getAllProductTypes()); // 错误消息 model.addAttribute(&quot;message&quot;, exp.getMessage()); return &quot;product/edit&quot;; } } 在view/product目录下新增视图edit.jsp页面： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;%@taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;link href=&quot;&lt;c:url value=&quot;/styles/main.css&quot; /&gt;&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;title&gt;编辑产品&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;h2 class=&quot;title&quot;&gt;&lt;span&gt;编辑产品&lt;/span&gt;&lt;/h2&gt; &lt;form:form action=&quot;../editSave&quot; modelAttribute=&quot;product&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;产品&lt;/legend&gt; &lt;p&gt; &lt;label for=&quot;name&quot;&gt;产品名称：&lt;/label&gt; &lt;form:input path=&quot;name&quot;/&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;title&quot;&gt;产品类型：&lt;/label&gt; &lt;form:select path=&quot;productType.id&quot; items=&quot;${productTypes}&quot; itemLabel=&quot;name&quot; itemValue=&quot;id&quot;&gt; &lt;/form:select&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;price&quot;&gt;产品价格：&lt;/label&gt; &lt;form:input path=&quot;price&quot;/&gt; &lt;/p&gt; &lt;p&gt; &lt;form:hidden path=&quot;id&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;保存&quot; class=&quot;btn out&quot;&gt; &lt;/p&gt; &lt;/fieldset&gt; &lt;/form:form&gt; &lt;p style=&quot;color: red&quot;&gt;${message}&lt;/p&gt; &lt;p&gt; &lt;a href=&quot;&lt;c:url value=&quot;/product&quot; /&gt;&quot; class=&quot;abtn out&quot;&gt;返回列表&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 点击编辑按钮，运行结果如图3所示： 图 3 二、Spring MVC验证器Spring MVC不仅是在架构上改变了项目，使代码变得可复用、可维护与可扩展，其实在功能上也加强了不少。验证与文件上传是许多项目中不可缺少的一部分。在项目中验证非常重要，首先是安全性考虑，如防止注入攻击，XSS等；其次还可以确保数据的完整性，如输入的格式，内容，长度，大小等。Spring MVC可以使用验证器Validator与JSR303完成后台验证功能。这里也会介绍方便的前端验证方法。 1. Validator验证器Spring MVC Validator验证器是一个接口，通过实现该接口可以定义对实体对象的验证。该接口如下所示： package org.springframework.validation; /** * Spring MVC内置的验证器接口 */ public interface Validator { /** * 是否可以验证该类型 */ boolean supports(Class&lt;?&gt; clazz); /** * 执行验证 target表示要验证的对象 error表示错误信息 */ void validate(Object target, Errors errors); } (1) 定义验证器package org.spring.mvc.model; import org.springframework.validation.Errors; import org.springframework.validation.ValidationUtils; import org.springframework.validation.Validator; /** * 产品验证器 * */ public class ProductValidator implements Validator { /** * 当前验证器可以验证的类型 */ @Override public boolean supports(Class&lt;?&gt; clazz) { return Product.class.isAssignableFrom(clazz); } /** * 执行校验 */ @Override public void validate(Object target, Errors errors) { // 将要验证的对象转换成Product类型 Product entity = (Product) target; // 如果产品名称为空或为空格，使用工具类 ValidationUtils.rejectIfEmptyOrWhitespace(errors, &quot;name&quot;, &quot;required&quot;, &quot;产品名称必须填写&quot;); // 价格，手动判断 if (entity.getPrice() &lt; 0) { errors.rejectValue(&quot;price&quot;, &quot;product.price.gtZero&quot;, &quot;产品价格必须大于等于0&quot;); } // 产品类型必须选择 if (entity.getProductType().getId() == 0) { errors.rejectValue(&quot;productType.id&quot;, &quot;product.productType.id.required&quot;, &quot;请选择产品类型&quot;); } } } ValidationUtils是一个工具类，中间有一些方可以用于判断内容是否有误。 (2) 执行校验/** * 新增保存，如果新增成功转回列表页，如果失败回新增页，保持页面数据 * * @param model * @param product * @return */ @RequestMapping(&quot;/addSave&quot;) public String addSave(Model model, Product product, BindingResult bindingResult) { // 创建一个产品验证器 ProductValidator validator = new ProductValidator(); // 执行验证，将验证的结果给bindingResult，该类型继承Errors validator.validate(product, bindingResult); // 获得所有的字段错误信息，非必要 for (FieldError fielderror : bindingResult.getFieldErrors()) { System.out.println(fielderror.getField() + &quot;，&quot; + fielderror.getCode() + &quot;，&quot; + fielderror.getDefaultMessage()); } try { // 是否存在错误，如果没有，执行添加 if (!bindingResult.hasErrors()) { // 根据类型的编号获得类型对象 product.setProductType(productTypeService.getProductTypeById(product.getProductType().getId())); productService.addProduct(product); return &quot;redirect:/product2&quot;; } else { // 与form绑定的模型 model.addAttribute(&quot;product&quot;, product); // 用于生成下拉列表 model.addAttribute(&quot;productTypes&quot;, productTypeService.getAllProductTypes()); return &quot;product2/add&quot;; } } catch (Exception exp) { // 与form绑定的模型 model.addAttribute(&quot;product&quot;, product); // 用于生成下拉列表 model.addAttribute(&quot;productTypes&quot;, productTypeService.getAllProductTypes()); // 错误消息 model.addAttribute(&quot;message&quot;, exp.getMessage()); return &quot;product2/add&quot;; } } 注意在参数中增加了一个BindingResult类型的对象，该类型继承自Errors，获得绑定结果，承载错误信息，该对象中有一些方法可以获得完整的错误信息，可以使用hasErrors方法判断是否产生了错误。 (4) 在UI中添加错误标签&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;%@taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;link href=&quot;&lt;c:url value=&quot;/styles/main.css&quot;/&gt;&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;title&gt;新增产品&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;h2 class=&quot;title&quot;&gt;&lt;span&gt;新增产品&lt;/span&gt;&lt;/h2&gt; &lt;form:form action=&quot;addSave&quot; modelAttribute=&quot;product&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;产品&lt;/legend&gt; &lt;p&gt; &lt;label for=&quot;name&quot;&gt;产品名称：&lt;/label&gt; &lt;form:input path=&quot;name&quot;/&gt; &lt;form:errors path=&quot;name&quot; cssClass=&quot;error&quot;&gt;&lt;/form:errors&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;title&quot;&gt;产品类型：&lt;/label&gt; &lt;form:select path=&quot;productType.id&quot;&gt; &lt;form:option value=&quot;0&quot;&gt;--请选择--&lt;/form:option&gt; &lt;form:options items=&quot;${productTypes}&quot; itemLabel=&quot;name&quot; itemValue=&quot;id&quot;/&gt; &lt;/form:select&gt; &lt;form:errors path=&quot;productType.id&quot; cssClass=&quot;error&quot;&gt;&lt;/form:errors&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;price&quot;&gt;产品价格：&lt;/label&gt; &lt;form:input path=&quot;price&quot;/&gt; &lt;form:errors path=&quot;price&quot; cssClass=&quot;error&quot;&gt;&lt;/form:errors&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; value=&quot;保存&quot; class=&quot;btn out&quot;&gt; &lt;/p&gt; &lt;/fieldset&gt; &lt;/form:form&gt; &lt;p style=&quot;color: red&quot;&gt;${message}&lt;/p&gt; &lt;p&gt; &lt;a href=&quot;&lt;c:url value=&quot;/product2&quot; /&gt;&quot; class=&quot;abtn out&quot;&gt;返回列表&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; (5) 测试运行访问路径：http://localhost:8080/spring-mvc/product2，运行结果如图4所示： 图 4 控制台输出： name，required，产品名称必须填写 price，product.price.gtZero，产品价格必须大于等于0 productType.id，product.productType.id.required，请选择产品类型 2. JSR303验证器JSR是Java Specification Requests的缩写，意思是Java规范提案，是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。任何人都可以提交JSR，以向Java平台增添新的API和服务。JSR已成为Java界的一个重要标准。JSR303只是一个标准，是一个数据验证规范，对这个标准的实现有：hibernate-validator，Apache BVal等。这里我们使用hibernate-validator实现校验。 (1) 添加hibernate-validator依赖修改配置pom.xml配置文件，添加依赖。 &lt;!--JSR303 Bean校验--&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.2.2.Final&lt;/version&gt; &lt;/dependency&gt; (2) 注解实体类为Bean的name和price属性设置验证规则： // 名称 @Size(min=1,max=50,message=&quot;名称长度必须介于{2}-{1}之间&quot;) @Pattern(regexp=&quot;^[\\\\w\\\\u4e00-\\\\u9fa5]{0,10}$&quot;,message=&quot;格式错误，必须是字母数字与中文&quot;) private String name; // 价格 @Range(min=0,max=1000000,message=&quot;价格只允许在{2}-{1}之间&quot;) private double price; 常用验证的注解如下所示： 空值检查 @Null 验证对象是否为null @NotNull 验证对象是否不为null, 无法查检长度为0的字符串 @NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格. @NotEmpty 检查约束元素是否为NULL或者是EMPTY. Booelan检查 @AssertTrue 验证 Boolean 对象是否为 true @AssertFalse 验证 Boolean 对象是否为 false 长度检查 @Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内 @Length(min=, max=) Validates that the annotated string is between min and max included. 日期检查 @Past 验证 Date 和 Calendar 对象是否在当前时间之前 @Future 验证 Date 和 Calendar 对象是否在当前时间之后 正则 @Pattern 验证 String 对象是否符合正则表达式的规则 数值检查建议使用在Stirng,Integer类型，不建议使用在int类型上，因为表单值为“”时无法转换为int，但可以转换为String为””,Integer为null @Min 验证 Number 和 String 对象是否大等于指定的值 @Max 验证 Number 和 String 对象是否小等于指定的值 @DecimalMax 被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过BigDecimal定义的最大值的字符串表示.小数存在精度 @DecimalMin 被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过BigDecimal定义的最小值的字符串表示.小数存在精度 @Digits 验证 Number 和 String 的构成是否合法 @Digits(integer=,fraction=) 验证字符串是否是符合指定格式的数字，interger指定整数精度，fraction指定小数精度。 范围 @Range(min=, max=) 检查被注解对象的值是否处于min与max之间，闭区间，包含min与max值 @Range(min=10000,max=50000,message=”必须介于{2}-{1}之间”) 其它注解 @Valid 递归的对关联对象进行校验, 如果关联对象是个集合或者数组,那么对其中的元素进行递归校验,如果是一个map,则对其中的值部分进行校验.(是否进行递归验证)，该注解使用在Action的参数上。 @CreditCardNumber信用卡验证 @Email 验证是否是邮件地址，如果为null,不进行验证，算通过验证。 @ScriptAssert(lang= ,script=, alias=) @URL(protocol=,host=, port=,regexp=, flags=) (3) 注解控制器参数在需要使用Bean验证的参数对象上注解@Valid，触发验证 @RequestMapping(&quot;/addGoodsSave&quot;) public String addSave(Model model, @Valid Product product, BindingResult bindingResult) { try { // 是否存在错误，如果没有，执行添加 if (!bindingResult.hasErrors()) { // 根据类型的编号获得类型对象 product.setProductType(productTypeService.getProductTypeById(product.getProductType().getId())); productService.addProduct(product); return &quot;redirect:/product3&quot;; } else { // 与form绑定的模型 model.addAttribute(&quot;product&quot;, product); // 用于生成下拉列表 model.addAttribute(&quot;productTypes&quot;, productTypeService.getAllProductTypes()); return &quot;product3/addGoods&quot;; } } catch (Exception exp) { // 与form绑定的模型 model.addAttribute(&quot;product&quot;, product); // 用于生成下拉列表 model.addAttribute(&quot;productTypes&quot;, productTypeService.getAllProductTypes()); return &quot;product3/addGoods&quot;; } } (4) 在UI中添加错误标签这里与Spring MVC Validator基本一致，在product3目录下新增一个名为addGoods.jsp的页面 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;%@taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;link href=&quot;&lt;c:url value=&quot;/styles/main.css&quot; /&gt;&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;title&gt;新增产品&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;h2 class=&quot;title&quot;&gt; &lt;span&gt;新增产品&lt;/span&gt; &lt;/h2&gt; &lt;form:form action=&quot;addGoodsSave&quot; modelAttribute=&quot;product&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;产品&lt;/legend&gt; &lt;p&gt; &lt;label for=&quot;name&quot;&gt;产品名称：&lt;/label&gt; &lt;form:input path=&quot;name&quot; /&gt; &lt;form:errors path=&quot;name&quot; cssClass=&quot;error&quot;&gt;&lt;/form:errors&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;title&quot;&gt;产品类型：&lt;/label&gt; &lt;form:select path=&quot;productType.id&quot;&gt; &lt;form:option value=&quot;0&quot;&gt;--请选择--&lt;/form:option&gt; &lt;form:options items=&quot;${productTypes}&quot; itemLabel=&quot;name&quot; itemValue=&quot;id&quot; /&gt; &lt;/form:select&gt; &lt;form:errors path=&quot;productType.id&quot; cssClass=&quot;error&quot;&gt;&lt;/form:errors&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;price&quot;&gt;产品价格：&lt;/label&gt; &lt;form:input path=&quot;price&quot; /&gt; &lt;form:errors path=&quot;price&quot; cssClass=&quot;error&quot;&gt;&lt;/form:errors&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; value=&quot;保存&quot; class=&quot;btn out&quot;&gt; &lt;/p&gt; &lt;/fieldset&gt; &lt;/form:form&gt; &lt;p style=&quot;color: red&quot;&gt;${message}&lt;/p&gt; &lt;p&gt; &lt;a href=&quot;&lt;c:url value=&quot;/product3&quot; /&gt;&quot; class=&quot;abtn out&quot;&gt;返回列表&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; (5) 测试运行访问路径：http://localhost:8080/spring-mvc/product3/addGoodsSave，运行结果如图5所示： 图 5 (6) 小结从上面的示例可以看出这种验证更加方便直观，一次定义反复使用，验证在编辑、更新时同样可以使用；另外验证的具体信息可以存放在配置文件中，如message.properties，这样便于国际化与修改。 3. 使用jQuery扩展插件Validate实现前端校验暂时没看","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hepsilion.github.io/categories/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hepsilion.github.io/tags/SpringMVC/"}],"keywords":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hepsilion.github.io/categories/SpringMVC/"}]},{"title":"05-SpringMVC视图解析器","slug":"SpringMVC-05","date":"2017-10-22T06:51:31.000Z","updated":"2017-10-22T07:14:36.159Z","comments":true,"path":"2017/10/22/SpringMVC-05/","link":"","permalink":"https://hepsilion.github.io/2017/10/22/SpringMVC-05/","excerpt":"","text":"视图解析器多数MVC框架都为Web应用程序提供一种它自己处理视图的办法，Spring MVC 提供视图解析器，它使用ViewResolver进行视图解析，让用户在浏览器中渲染模型。ViewResolver是一种开箱即用的技术，能够解析JSP、Velocity模板、FreeMarker模板和XSLT等多种视图。 Spring处理视图最重要的两个接口是ViewResolver和View。ViewResolver接口在视图名称和真正的视图之间提供映射关系； 而View接口则处理请求将真正的视图呈现给用户。 图 1 一、ViewResolver视图解析器在Spring MVC控制器中，所有的请求处理方法（Action）必须解析出一个逻辑视图名称，无论是显式的（返回String，View或ModelAndView）还是隐式的（基于约定的，如视图名就是方法名）。Spring中由视图解析器处理这个逻辑视图名称，Spring常用的视图解析器有如下几种： 图 2 1. AbstractCachingViewResolver用来缓存视图的抽象视图解析器。通常情况下，视图在使用前就准备好了。继承该解析器就能够使用视图缓存。这是一个抽象类，这种视图解析器会把它曾经解析过的视图缓存起来，然后每次要解析视图的时候先从缓存里面找，如果找到了对应的视图就直接返回，如果没有就创建一个新的视图对象，然后把它放到一个用于缓存的map中，接着再把新建的视图返回。使用这种视图缓存的方式可以把解析视图的性能问题降到最低。 2. XmlViewResolverXML视图解析器。它实现了ViewResolver接口，接受相同DTD定义的XML配置文件作为Spring的XML bean工厂。它继承自AbstractCachingViewResolver抽象类，所以它也是支持视图缓存的。通俗来说就是通过xml指定逻辑名称与真实视图间的关系，示例如下： &lt;bean class=&quot;org.springframework.web.servlet.view.XmlViewResolver&quot;&gt; &lt;property name=&quot;location&quot; value=&quot;/WEB-INF/views.xml&quot;/&gt; &lt;property name=&quot;order&quot; value=&quot;2&quot;/&gt; &lt;/bean&gt; views.xml是逻辑名与真实视图名的映射文件，order是定义多个视图时的优先级，可以这样定义： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd&quot;&gt; &lt;bean id=&quot;index&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceView&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;/index.jsp&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; id就是逻辑名称，在使用时可以在请求处理方法中这样指定： @RequestMapping(&quot;/index&quot;) public String index() { return &quot;index&quot;; } 从配置可以看出最终还是使用InternalResourceView完成了视图解析。 3. ResourceBundleViewResolver它使用了ResourceBundle定义下的bean，实现了ViewResolver接口，指定了绑定包的名称。通常情况下，配置文件会定义在classpath下的properties文件中，默认的文件名字是views.properties。 4. UrlBasedViewResolver它简单实现了ViewResolver接口，不用显式定义，直接影响逻辑视图到URL的映射。它让你不用任何映射就能通过逻辑视图名称访问资源。它是对ViewResolver的一种简单实现，而且继承了AbstractCachingViewResolver，主要就是提供的一种拼接URL的方式来解析视图，它可以让我们通过prefix属性指定一个指定的前缀，通过suffix属性指定一个指定的后缀，然后把返回的逻辑视图名称加上指定的前缀和后缀就是指定的视图URL了。如prefix=/WEB-INF/views/，suffix=.jsp，返回的视图名称viewName=bar/index，则UrlBasedViewResolver解析出来的视图URL就是/WEB-INF/views/bar/index.jsp。redirect:前缀表示重定向，forword:前缀表示转发。使用UrlBasedViewResolver的时候必须指定属性viewClass，表示解析成哪种视图，一般使用较多的就是InternalResourceView，利用它来展现jsp，但是当我们使用JSTL的时候我们必须使用org.springframework.web.servlet.view.JstlView。 5. InternalResourceViewResolver内部视图解析器。它是URLBasedViewResolver的子类，所以URLBasedViewResolver支持的特性它都支持。它在实际应用中使用的最广泛的一个视图解析器。 &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; 在JSP视图技术中，Spring MVC经常会使用UrlBasedViewResolver视图解析器，该解析器会将视图名称翻译成URL并通过RequestDispatcher处理请求后渲染视图。修改springmvc-servlet.xml配置文件，增加如下视图解析器： &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.UrlBasedViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; 6. VelocityViewResolverVelocity视图解析器，UrlBasedViewResolver的子类，VelocityViewResolver会把返回的逻辑视图解析为VelocityView。 7. FreeMarkerViewResolverFreeMarker视图解析器，UrlBasedViewResolver的子类，FreeMarkerViewResolver会把Controller处理方法返回的逻辑视图解析为FreeMarkerView，使用FreeMarkerViewResolver的时候不需要我们指定其viewClass，因为FreeMarkerViewResolver中已经把viewClass为FreeMarkerView了。Spring本身支持了对Freemarker的集成。只需要配置一个针对Freemarker的视图解析器即可。 8. ContentNegotiatingViewResolver内容协商视图解析器，这个视图解析器允许你用同样的内容数据来呈现不同的view，在RESTful服务中可用。 二、链式视图解析器Spring支持同时配置多个视图解析器，也就是链式视图解析器。这样，在某些情况下，就能够重写某些视图。如果我们配置了多个视图解析器，并想要给视图解析器排序的话，设定order属性就可以指定解析器执行的顺序。order的值越高，解析器执行的顺序越晚，当一个ViewResolver在进行视图解析后返回的View对象是null的话就表示该ViewResolver不能解析该视图，这个时候如果还存在其他order值比它大的ViewResolver就会调用剩余的ViewResolver中的order值最小的那个来解析该视图，依此类推。InternalResourceViewResolver这种能解析所有的视图，即永远能返回一个非空View对象的ViewResolver，一定要把它放在ViewResolver链的最后面。 &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt; &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=UTF-8&quot; /&gt; &lt;property name=&quot;order&quot; value=&quot;2&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt; &lt;property name=&quot;cache&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;prefix&quot; value=&quot;&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.html&quot; /&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerView&quot; /&gt; &lt;property name=&quot;exposeSpringMacroHelpers&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;exposeRequestAttributes&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;exposeSessionAttributes&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;requestContextAttribute&quot; value=&quot;rc&quot; /&gt; &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=UTF-8&quot; /&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot; /&gt; &lt;/bean&gt; viewClass指定了视图渲染类，viewNames指定视图名称匹配规则如名称以html开头或结束，contentType支持了页面头部信息匹配规则。 三、FreeMarker与多视图解析示例1. 新增两个视图解析器修改Spring MVC配置文件springmvc-servlet.xml，在beans结点中增加两个视图解析器，一个为内部解析器用于解析jsp与JSTL，另一个为解析FreeMaker格式。修改后的配置文件如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd&quot;&gt; &lt;!-- 自动扫描包，实现支持注解的IOC --&gt; &lt;context:component-scan base-package=&quot;org.spring.mvc&quot; /&gt; &lt;!-- Spring MVC不处理静态资源 --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 支持mvc注解驱动 --&gt; &lt;mvc:annotation-driven enable-matrix-variables=&quot;true&quot; /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;!--指定视图渲染类 --&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt; &lt;!--设置所有视图的内容类型，如果视图本身设置内容类型视图类可以忽略 --&gt; &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=UTF-8&quot; /&gt; &lt;!-- 优先级，越小越前 --&gt; &lt;property name=&quot;order&quot; value=&quot;2&quot; /&gt; &lt;/bean&gt; &lt;!-- FreeMarker视图解析器与属性配置 --&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt; &lt;!--是否启用缓存 --&gt; &lt;property name=&quot;cache&quot; value=&quot;true&quot; /&gt; &lt;!--自动添加到路径中的前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;&quot; /&gt; &lt;!--自动添加到路径中的后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.html&quot; /&gt; &lt;!--指定视图渲染类 --&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerView&quot; /&gt; &lt;!-- 设置是否暴露Spring的macro辅助类库，默认为true --&gt; &lt;property name=&quot;exposeSpringMacroHelpers&quot; value=&quot;true&quot; /&gt; &lt;!-- 是否应将所有request属性添加到与模板合并之前的模型。默认为false。 --&gt; &lt;property name=&quot;exposeRequestAttributes&quot; value=&quot;true&quot; /&gt; &lt;!-- 是否应将所有session属性添加到与模板合并之前的模型。默认为false。 --&gt; &lt;property name=&quot;exposeSessionAttributes&quot; value=&quot;true&quot; /&gt; &lt;!-- 在页面中使用${rc.contextPath}就可获得contextPath --&gt; &lt;property name=&quot;requestContextAttribute&quot; value=&quot;rc&quot; /&gt; &lt;!--设置所有视图的内容类型，如果视图本身设置内容类型视图类可以忽略 --&gt; &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=UTF-8&quot; /&gt; &lt;!-- 优先级，越小越前 --&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置FreeMarker细节 --&gt; &lt;bean id=&quot;freemarkerConfig&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt; &lt;!-- 模板路径 --&gt; &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/htmlviews&quot; /&gt; &lt;property name=&quot;freemarkerSettings&quot;&gt; &lt;props&gt; &lt;!-- 刷新模板的周期，单位为秒 --&gt; &lt;prop key=&quot;template_update_delay&quot;&gt;5&lt;/prop&gt; &lt;!--模板的编码格式 --&gt; &lt;prop key=&quot;defaultEncoding&quot;&gt;UTF-8&lt;/prop&gt; &lt;!--url编码格式 --&gt; &lt;prop key=&quot;url_escaping_charset&quot;&gt;UTF-8&lt;/prop&gt; &lt;!--此属性可以防止模板解析空值时的错误 --&gt; &lt;prop key=&quot;classic_compatible&quot;&gt;true&lt;/prop&gt; &lt;!--该模板所使用的国际化语言环境选项 --&gt; &lt;prop key=&quot;locale&quot;&gt;zh_CN&lt;/prop&gt; &lt;!--布尔值格式 --&gt; &lt;prop key=&quot;boolean_format&quot;&gt;true,false&lt;/prop&gt; &lt;!--日期时间格式 --&gt; &lt;prop key=&quot;datetime_format&quot;&gt;yyyy-MM-dd HH:mm:ss&lt;/prop&gt; &lt;!--时间格式 --&gt; &lt;prop key=&quot;time_format&quot;&gt;HH:mm:ss&lt;/prop&gt; &lt;!--数字格式 --&gt; &lt;prop key=&quot;number_format&quot;&gt;0.######&lt;/prop&gt; &lt;!--自动开启/关闭空白移除，默认为true --&gt; &lt;prop key=&quot;whitespace_stripping&quot;&gt;true&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置映射媒体类型的策略 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;&gt; &lt;property name=&quot;removeSemicolonContent&quot; value=&quot;false&quot; /&gt; &lt;/bean&gt; &lt;bean name=&quot;/controller01&quot; class=&quot;org.spring.mvc.controller.Controller01&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; 需要注意的是视图解析器的order越小，解析优先级越高。在视图解析的过程中，如果order为1的视图解析器不能正确解析视图的话，会将结果交给order为2的视图解析器，这里为2的视图解析器是InternalResourceViewResolver，它总是会生成一个视图的，所以一般InternalResourceViewResolver在放在视图解析链的末尾，万一没有找到对应的视图，它还会生成一个404的view并返回。 2. 修改pom.xml，添加依赖为了使用FreeMarker，需要引用spring-context-support与FreeMarker的jar包。修改后的pom.xml配置文件如下： &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.spring.mvc&lt;/groupId&gt; &lt;artifactId&gt;spring-mvc&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring.version&gt;4.3.0.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--Spring框架核心库 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring MVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Servlet核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--JSP应用程序接口 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jackson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- FreeMarker --&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.23&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 添加依赖成功后的jar包如图3所示： 图 3 3. 定义Controller与Action定义控制器，增加两个请求处理方法jstl与ftl，ftl让第1个解析器解析，jstl让第2个视图解析器解析，第1个视图解析器也是默认的视图解析器。 package org.spring.mvc.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(&quot;/controller11&quot;) public class Controller11 { @RequestMapping(&quot;/jstl&quot;) public String jstl(Model model) { model.addAttribute(&quot;message&quot;, &quot;Hello JSTL View!&quot;); return &quot;controller11/jstl&quot;; } @RequestMapping(&quot;/ftl&quot;) public String ftl(Model model) { model.addAttribute(&quot;users&quot;, new String[]{&quot;tom&quot;,&quot;mark&quot;,&quot;jack&quot;}); model.addAttribute(&quot;message&quot;, &quot;Hello FreeMarker View!&quot;); return &quot;controller11/ftl&quot;; } } 4. 新增目录与视图在WEB-INF/view/controller11目录下新增jsp页面jstl.jsp页面，在WEB-INF/html/controller11目录下新增ftl.html页面。目录结构如下： 图 4 5. 运行结果访问路径：http://localhost:8080/spring-mvc/controller11/jstl，运行结果如图3所示： 图 5 访问路径：http://localhost:8080/spring-mvc/controller11/ftl，运行结果如图6所示： 图 6 6. 小结当访问/controller11/ftl时会找到action ftl方法，该方法返回controller11/ftl字符串，视图解析器中order为1的解析器去controller11目录下找名称为ftl的视图，视图存在，将视图与模型渲染后输出。当访问/controller11/jstl时会找到action jstl访问，该方法返回controller11/jstl字符串，视图解析器中order为1的解析器去controller11目录下找名称为jstl的视图，未能找到，解析失败，转到order为2的视图解析器解析，在目录controller11下找到jstl的文件成功，将视图与模板渲染后输出。 如果想视图解析器更加直接的选择可以使用属性viewNames，如viewNames=”html*”，则会只解析视图名以html开头的视图。","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hepsilion.github.io/categories/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hepsilion.github.io/tags/SpringMVC/"}],"keywords":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hepsilion.github.io/categories/SpringMVC/"}]},{"title":"04-SpringMVC表单标签库","slug":"SpringMVC-04","date":"2017-10-22T06:49:57.000Z","updated":"2017-10-22T07:14:14.078Z","comments":true,"path":"2017/10/22/SpringMVC-04/","link":"","permalink":"https://hepsilion.github.io/2017/10/22/SpringMVC-04/","excerpt":"","text":"Spring MVC 表单标签库一、简介从Spring2.0起就提供了一组全面的自动数据绑定标签来处理表单元素。生成的标签兼容HTML 4.01与XHTML 1.0。表单标签库中包含了可以用在JSP页面中渲染HTML元素的标签。表单标记库包含在spring-webmvc.jar中，库的描述符称为spring-form.tld，为了使用这些标签必须在jsp页面开头处声明这个tablib指令。 &lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt; 以下是标签库中的常用标签： form 渲染表单元素form input 渲染&lt; input type=”text”/&gt;元素 password 渲染&lt; input type=”password”/&gt;元素 hidden 渲染&lt; input type=”hidden”/&gt;元素 textarea 渲染textarea元素 checkbox 渲染一个&lt; input type=”checkbox”/&gt;复选元素 checkboxs 渲染多个&lt; input type=”checkbox”/&gt;元素 radiobutton 渲染一个&lt; input type=”radio”/&gt;单选元素 radiobuttons 渲染多个&lt; input type=”radio”/&gt;元素 select 渲染一个选择元素 option 渲染一个可选元素 options 渲染多个可选元素列表 errors 在span元素中渲染字段错误 二、常用属性 path:要绑定的属性路径，是最重要的属性，当绑定的对象有多个属性时必填，相当于modelAttribute.getXXX() 。 cssClass:定义要应用到被渲染元素的CSS类，类样式。 cssStyle:定义要应用到被渲染元素的CSS样式，行内样式。 htmlEscape:接受true或者false，表示是否应该对被渲染的值进行HTML转义。 cssErrorClass:定义要应用到被渲染input元素的CSS类，如果bound属性中包含错误，则覆盖cssClass属性值。 三、常用标签1. form:form标签与form:input标签这个标签会生成HTML form标签，同时为form内部所包含的标签提供一个绑定路径（binding path)。 它把命令对象（command object)存在PageContext中，这样form内部的标签就可以使用这个对象了。标签库中的其他标签都声明在form标签的内部。 commandName：暴露表单对象的模型属性名称，默认为command，它定义了模型属性的名称，其中包含了一个backing object，其属性将用于填充生成的表单。如果该属性存在，则必须在返回包含该表单的视图的请求处理方法中添加相应的模型属性。 modelAttribute：暴露form backing object的模型属性名称，默认为command commandName与modelAttribute功能基本一样，使用modelAttribute就可以了，因为commandName已被抛弃。 action示例代码： @RequestMapping(&quot;/action49&quot;) public String action49(Model model){ //向模型中添加一个名为product的对象，用于渲染视图 model.addAttribute(&quot;product&quot;, new Product(&quot;Meizu note1&quot;, 999)); return &quot;controller10/action49&quot;; } action49.jsp代码： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;controller10/action49&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form:form modelAttribute=&quot;product&quot;&gt; &lt;p&gt; &lt;label for=&quot;name&quot;&gt;Name:&lt;/label&gt; &lt;form:input path=&quot;name&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;price&quot;&gt;Price:&lt;/label&gt; &lt;form:input path=&quot;price&quot; /&gt; &lt;/p&gt; &lt;/form:form&gt; &lt;/body&gt; &lt;/html&gt; form表单与模型中名称为product的对象进行绑定，form表单元素的path指的就是访问该对象的属性，如果没有该对象或找不到属性名将异常。系统将自动把指定模型中的值与页面进行绑定。 访问路径：http://localhost:8080/spring-mvc/controller10/action49，运行结果如图1所示： 图 1 模型可以为空，不是为null，中间可以没有数据，但非字符类型会取默认值，如价格会变成0.0。 action示例代码： @RequestMapping(&quot;/action50&quot;) public String action50(Model model){ //向模型中添加一个名为product的对象，用于渲染视图 model.addAttribute(&quot;product&quot;, new Product()); return &quot;controller10/action49&quot;; } 访问路径：http://localhost:8080/spring-mvc/controller10/action50，运行结果如图2所示： 图 2 input元素可以设置其它的属性。修改后的表单： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;controller10/action49&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form:form modelAttribute=&quot;product&quot;&gt; &lt;p&gt; &lt;label for=&quot;name&quot;&gt;名称：&lt;/label&gt; &lt;form:input path=&quot;name&quot; cssClass=&quot;textCss&quot; cssStyle=&quot;color:blue&quot; a=&quot;b&quot; htmlEscape=&quot;false&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;price&quot;&gt;价格：&lt;/label&gt; &lt;form:input path=&quot;price&quot; /&gt; &lt;/p&gt; &lt;/form:form&gt; &lt;/body&gt; &lt;/html&gt; 修改后的示例代码： @RequestMapping(&quot;/action51&quot;) public String action51(Model model){ //向模型中添加一个名为product的对象，用于渲染视图 model.addAttribute(&quot;product&quot;, new Product(&quot;Meizu note1&lt;hr/&gt;&quot;, 999)); return &quot;controller10/action51&quot;; } 访问路径：http://localhost:8080/spring-mvc/controller10/action51，运行结果如图3所示： 图 3 2. form:checkbox标签form:checkbox标签将渲染成一个复选框，通过该标签可以获得3种不同类型的值，分别是boolean、数组和基本数据类型。 若绑定的值是java.lang.Boolean类型，当其值为true时，checkbox被标记为选中； 若绑定的值是数组类型或java.util.Collection，当setValue(Object)配置的值出现在绑定的Collection中时，checkbox被标记为选中； 若绑定的值是其他类型，当setValue(Object)配置的值等于其绑定值时，checkbox被标记为选中。 定义一个实体类Person： package org.spring.mvc.model; public class Person { // 婚否 private boolean isMarried; // 爱好 private String[] hobbies; // 学历 private String education; public boolean getIsMarried() { return isMarried; } public void setIsMarried(boolean isMarried) { this.isMarried = isMarried; } public String[] getHobbies() { return hobbies; } public void setHobbies(String[] hobbies) { this.hobbies = hobbies; } public String getEducation() { return education; } public void setEducation(String education) { this.education = education; } } 特别注意的是boolean类型的值生成的get/set方法前是不带get与set的，这样会引起异常，建议手动修改。 action示例代码： @RequestMapping(&quot;/action52&quot;) public String action52(Model model) { Person person = new Person(); person.setIsMarried(true); person.setHobbies(new String[]{&quot;Movie&quot;, &quot;Surfing&quot;}); person.setEducation(&quot;Bachelor&quot;); model.addAttribute(&quot;person&quot;, person); return &quot;controller10/action52&quot;; } @RequestMapping(&quot;/action53&quot;) @ResponseBody public Person action53(HttpServletResponse response, Person person) { return person; } action52.jsp: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;controller10/action52&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form:form modelAttribute=&quot;person&quot; action=&quot;action53&quot;&gt; &lt;p&gt; &lt;label for=&quot;name&quot;&gt;isMarried:&lt;/label&gt; &lt;form:checkbox path=&quot;isMarried&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;name&quot;&gt;Hobbies:&lt;/label&gt; &lt;form:checkbox path=&quot;hobbies&quot; value=&quot;Reading&quot;/&gt;Reading &lt;form:checkbox path=&quot;hobbies&quot; value=&quot;Surfing&quot;/&gt;Surfing &lt;form:checkbox path=&quot;hobbies&quot; value=&quot;Movie&quot;/&gt;Movie &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;name&quot;&gt;hasGraduate:&lt;/label&gt; &lt;form:checkbox path=&quot;education&quot; value=&quot;Bachelor&quot;/&gt;Bachelor &lt;/p&gt; &lt;p&gt; &lt;button&gt;Submit&lt;/button&gt; &lt;/p&gt; &lt;/form:form&gt; &lt;/body&gt; &lt;/html&gt; 访问路径：http://localhost:8080/spring-mvc/controller10/action52，运行结果如图4所示： 图 4 form:checkbox在渲染成input标签里会变成2个表单元素，这样可以确保用户没有选择内容时也会将值带会服务器，默认是没有这样的。 3. form:radiobutton标签form:radiobutton标签生成类型为radio的HTML input标签，也就是常见的单选框。这个标签的典型用法是一次声明多个标签实例，所有的标签都有相同的path属性，但是他们的value属性不同。 action示例代码： @RequestMapping(&quot;/action54&quot;) public String action54(Model model){ Person person = new Person(); person.setEducation(&quot;Bachelor&quot;); model.addAttribute(&quot;person&quot;, person); return &quot;controller10/action54&quot;; } action54.jsp: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;bar/action31&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form:form modelAttribute=&quot;person&quot; action=&quot;action53&quot;&gt; &lt;p&gt; &lt;label for=&quot;name&quot;&gt;Education&lt;/label&gt; &lt;form:radiobutton path=&quot;education&quot; value=&quot;College&quot;/&gt;College &lt;form:radiobutton path=&quot;education&quot; value=&quot;Bachelor&quot;/&gt;Bachelor &lt;form:radiobutton path=&quot;education&quot; value=&quot;Master&quot;/&gt;Master &lt;/p&gt; &lt;p&gt; &lt;button&gt;Submit&lt;/button&gt; &lt;/p&gt; &lt;/form:form&gt; &lt;/body&gt; &lt;/html&gt; 访问路径：http://localhost:8080/spring-mvc/controller10/action54，运行结果如图5所示： 图 5 4. form:password标签form:password标签生成类型为password的HTML input标签，渲染后生成一个密码框。input标签的值和表单支持对象相应属性的值保持一致。该标签与input类似，但有一个特殊的属性showPassword，是否将对象中的值绑定到密码框中，默认为false，也意味着密码框中不会出现默认的掩码。 action示例代码： @RequestMapping(&quot;/action55&quot;) public String action55(Model model){ Person person=new Person(); person.setEducation(&quot;edu&quot;); model.addAttribute(&quot;person&quot;, person); return &quot;controller10/action55&quot;; } action55.jsp: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;bar/action31&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form:form modelAttribute=&quot;person&quot; action=&quot;action53&quot;&gt; &lt;p&gt; &lt;label for=&quot;name&quot;&gt;Education&lt;/label&gt; &lt;form:radiobutton path=&quot;education&quot; value=&quot;College&quot; /&gt;College &lt;form:radiobutton path=&quot;education&quot; value=&quot;Bachelor&quot; /&gt;Bachelor &lt;form:radiobutton path=&quot;education&quot; value=&quot;Master&quot; /&gt;Master &lt;/p&gt; &lt;p&gt; &lt;label&gt;Password:&lt;/label&gt; &lt;form:password path=&quot;education&quot; showPassword=&quot;false&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;button&gt;Submit&lt;/button&gt; &lt;/p&gt; &lt;/form:form&gt; &lt;/body&gt; &lt;/html&gt; 访问路径：http://localhost:8080/spring-mvc/controller10/action55，运行结果如图6所示：其中showPassword值为false 图 6 当showPassword值为true时，运行结果如图7所示： 图 7 5. form:select标签form:select标签生成HTML select标签，就是下拉框，多选框。在生成的HTML代码中，被选中的选项和表单支持对象相应属性的值保持一致。这个标签也支持嵌套的option和options标签。 action示例代码： @RequestMapping(&quot;/action56&quot;) public String action56(Model model){ List&lt;ProductType&gt; productTypes = new ArrayList&lt;ProductType&gt;(); productTypes.add(new ProductType(11, &quot;数码电子&quot;)); productTypes.add(new ProductType(21, &quot;鞋帽服饰&quot;)); productTypes.add(new ProductType(31, &quot;图书音像&quot;)); productTypes.add(new ProductType(41, &quot;五金家电&quot;)); productTypes.add(new ProductType(51, &quot;生鲜水果&quot;)); model.addAttribute(&quot;productTypes&quot;, productTypes); model.addAttribute(&quot;person&quot;, new Person()); return &quot;controller10/action56&quot;; } 在action56中为模型添加了一个属性productTypes，该对象用于绑定到页面的下拉列表框。 action56.jsp: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;bar/action41&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form:form modelAttribute=&quot;person&quot; action=&quot;action42&quot;&gt; &lt;p&gt; &lt;label for=&quot;name&quot;&gt;Product Types: &lt;/label&gt; &lt;form:select size=&quot;3&quot; multiple=&quot;multiple&quot; path=&quot;education&quot; items=&quot;${productTypes}&quot; itemLabel=&quot;name&quot; itemValue=&quot;id&quot;&gt;&lt;/form:select&gt; &lt;/p&gt; &lt;p&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/p&gt; &lt;/form:form&gt; &lt;/body&gt; &lt;/html&gt; size=”3” 表示可见项为3项，默认可见项为1项 multiple=”multiple” 表示允许多选，默认为单选 path=”education” 与表单中指定的modelAttribute对象进行双向绑定 items=”${productTypes}” 绑定到下拉列表的集合对象 itemLabel=”name” 集合中的对象的name属性作为下拉列表option的text属性 itemValue=”id” 集合中的对象的id属性作为下拉列表option的value属性 访问路径：http://localhost:8080/spring-mvc/controller10/action56，运行结果如图8所示： 图 8 6. form:option标签option标签生成HTML option标签，可以用于生成select表单元素中的单项，没有path属性，有label与value属性。 action示例代码： @RequestMapping(&quot;/action57&quot;) public String action57(Model model){ model.addAttribute(&quot;person&quot;, new Person()); return &quot;controller10/action57&quot;; } action57.jsp: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;bar/action51&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form:form modelAttribute=&quot;person&quot; action=&quot;action52&quot;&gt; &lt;p&gt; &lt;label for=&quot;name&quot;&gt;Education: &lt;/label&gt; &lt;form:select path=&quot;education&quot;&gt; &lt;form:option value=&quot;&quot; &gt;--Select--&lt;/form:option&gt; &lt;form:option value=&quot;College&quot;&gt;College&lt;/form:option&gt; &lt;form:option value=&quot;Bachelor&quot;&gt;Bachelor&lt;/form:option&gt; &lt;form:option value=&quot;Master&quot;&gt;Master&lt;/form:option&gt; &lt;/form:select&gt; &lt;/p&gt; &lt;p&gt; &lt;button&gt;Submit&lt;/button&gt; &lt;/p&gt; &lt;/form:form&gt; &lt;/body&gt; &lt;/html&gt; 访问路径：http://localhost:8080/spring-mvc/controller10/action57，运行结果如图9所示： 图 9 7. form:options标签form:options标签生成一系列的HTML option标签，可以用它生成select标签中的子标签。 action示例代码： @RequestMapping(&quot;/action58&quot;) public String action58(Model model){ List&lt;ProductType&gt; productTypes = new ArrayList&lt;ProductType&gt;(); productTypes.add(new ProductType(11, &quot;数码电子&quot;)); productTypes.add(new ProductType(21, &quot;鞋帽服饰&quot;)); productTypes.add(new ProductType(31, &quot;图书音像&quot;)); productTypes.add(new ProductType(41, &quot;五金家电&quot;)); productTypes.add(new ProductType(51, &quot;生鲜水果&quot;)); model.addAttribute(&quot;productTypes&quot;, productTypes); model.addAttribute(&quot;person&quot;, new Person()); return &quot;controller10/action58&quot;; } action58.jsp: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;controller10/action58&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form:form modelAttribute=&quot;person&quot; action=&quot;action62&quot;&gt; &lt;p&gt; &lt;label for=&quot;name&quot;&gt;Product Type: &lt;/label&gt; &lt;form:select path=&quot;education&quot;&gt; &lt;form:option value=&quot;&quot;&gt;--Select--&lt;/form:option&gt; &lt;form:options items=&quot;${productTypes}&quot; itemLabel=&quot;name&quot; itemValue=&quot;id&quot;/&gt; &lt;/form:select&gt; &lt;/p&gt; &lt;p&gt; &lt;button&gt;Submit&lt;/button&gt; &lt;/p&gt; &lt;/form:form&gt; &lt;/body&gt; &lt;/html&gt; 访问路径：http://localhost:8080/spring-mvc/controller10/action58，运行结果如图10所示： 图 10 上面的这个例子同时使用了option标签和options标签。这两个标签生成的HTML代码是相同的，但是第一个option标签允许你在JSP中明确声明这个标签的值只供显示使用，并不绑定到表单支持对象的属性上。 8. form:textarea、form:errors标签form:textarea标签生成HTML textarea标签，就是一个多行文本标签，用法与input非常类似。 form:errors标签用于显示错误信息。 9. form:hidden标签form:hidden标签生成类型为hidden的HTML input标签。在生成的HTML代码中，input标签的值和表单支持对象相应属性的值保持一致。如果你需要声明一个类型为hidden的input标签，但是表单支持对象中没有对应的属性，你只能使用HTML的标签。 action示例代码： @RequestMapping(&quot;/action59&quot;) public String action59(Model model){ Person person=new Person(); person.setEducation(&quot;99&quot;); model.addAttribute(&quot;person&quot;, person); return &quot;controller10/action59&quot;; } action59.jsp: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;controller10/action59&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form:form modelAttribute=&quot;person&quot; action=&quot;action72&quot;&gt; &lt;p&gt; &lt;form:hidden path=&quot;education&quot; /&gt; &lt;input type=&quot;hidden&quot; value=&quot;1&quot; name=&quot;id&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;button&gt;Submit&lt;/button&gt; &lt;/p&gt; &lt;/form:form&gt; &lt;/body&gt; &lt;/html&gt; 访问路径：http://localhost:8080/spring-mvc/controller10/action59。 10. form:radiobuttons标签与form:checkboxs标签form:radiobuttons标签将生成一组单选框，只允许多个中选择1个；form:checkboxs标签生成一组复选列表，允许多选。 action示例代码： @RequestMapping(&quot;/action60&quot;) public String action60(Model model) { List&lt;ProductType&gt; productTypes = new ArrayList&lt;ProductType&gt;(); productTypes.add(new ProductType(11, &quot;数码电子&quot;)); productTypes.add(new ProductType(21, &quot;鞋帽服饰&quot;)); productTypes.add(new ProductType(31, &quot;图书音像&quot;)); productTypes.add(new ProductType(41, &quot;五金家电&quot;)); productTypes.add(new ProductType(51, &quot;生鲜水果&quot;)); model.addAttribute(&quot;productTypes&quot;, productTypes); model.addAttribute(&quot;person&quot;, new Person()); return &quot;controller10/action60&quot;; } action60.jsp: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;controller10/action60&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form:form modelAttribute=&quot;person&quot; action=&quot;action82&quot;&gt; &lt;p&gt; &lt;label for=&quot;name&quot;&gt;Product Type: &lt;/label&gt; &lt;form:radiobuttons path=&quot;education&quot; items=&quot;${productTypes}&quot; itemLabel=&quot;name&quot; itemValue=&quot;id&quot; delimiter=&quot;,&quot; element=&quot;a&quot;/&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;name&quot;&gt;Product Type: &lt;/label&gt; &lt;form:checkboxes path=&quot;education&quot; items=&quot;${productTypes}&quot; itemLabel=&quot;name&quot; itemValue=&quot;id&quot; delimiter=&quot;-&quot;/&gt; &lt;/p&gt; &lt;p&gt; &lt;button&gt;Submit&lt;/button&gt; &lt;/p&gt; &lt;/form:form&gt; &lt;/body&gt; &lt;/html&gt; 属性delimiter=”,”，表示生成的单项间使用”,”号分隔，默认为空。 属性element=”a”，表示生成的单项容器，默认为span。 访问路径：http://localhost:8080/spring-mvc/controller10/action60，运行结果如图11所示： 图 11","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hepsilion.github.io/categories/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hepsilion.github.io/tags/SpringMVC/"}],"keywords":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hepsilion.github.io/categories/SpringMVC/"}]},{"title":"03-请求处理方法Action详解","slug":"SpringMVC-03","date":"2017-10-22T06:47:25.000Z","updated":"2017-10-22T07:14:05.097Z","comments":true,"path":"2017/10/22/SpringMVC-03/","link":"","permalink":"https://hepsilion.github.io/2017/10/22/SpringMVC-03/","excerpt":"","text":"SpringMVC 请求处理方法Action详解在Spring MVC的每个控制器中可以定义多个请求处理方法，我们把这种请求处理方法称为Action，每个请求处理方法可以有多个不同类型的参数和一个某种类型的返回结果。 一、Action参数1. 自动参数映射(1) 基本数据类型或包装类型方法的参数可以是任意基本数据类型或包装类型。当方法的参数名与http请求的参数名相同时，参数会进行自动映射；但如果请求的参数中没有对应名称与类型的数据，则会产生异常。 示例代码：基本数据类型 @RequestMapping(&quot;/action19&quot;) public String action19(Model model, int id, String name) { model.addAttribute(&quot;message&quot;, &quot;name=&quot; + name + &quot;,id=&quot; + id); return &quot;index&quot;; } 访问路径：http://localhost:8080/spring-mvc/controller08/action19?id=1234&amp;name=kevin，运行结果如图1所示： 图 1 示例代码：包装类型 @RequestMapping(&quot;/action20&quot;) public String action20(Model model, Integer id, Double price) { model.addAttribute(&quot;message&quot;, &quot;price=&quot; + price + &quot;,id=&quot; + id); return &quot;index&quot;; } 访问路径：http://localhost:8080/spring-mvc/controller08/action20?id=1234&amp;price=20.0，运行结果如图2所示： 图 2 (2) 自定义数据类型除了基本数据类型和其对应的包装类型，我们也可以自定义数据类型，如一个自定义的POJO对象，Spring MVC会通过反射把请求中的参数设置到对象的属性中并进行类型转换。 自定义数据类型Product： package org.spring.mvc.model; import java.io.Serializable; public class Product implements Serializable { private static final long serialVersionUID = 1L; private int id; private String name; private double price; public Product() { } public Product(String name, double price) { super(); this.name = name; this.price = price; } public Product(int id, String name, double price) { super(); this.id = id; this.name = name; this.price = price; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } @Override public String toString() { return &quot;编号(id)：&quot; + this.getId() + &quot;，名称(name)：&quot; + this.getName() + &quot;，价格(price)：&quot; + this.getPrice(); } } 示例代码：自定义数据类型 @RequestMapping(&quot;/action21&quot;) public String action21(Model model, Product product) { model.addAttribute(&quot;message&quot;, product); return &quot;index&quot;; } 访问路径：http://localhost:8080/spring-mvc/controller08/action21?id=1234&amp;name=meat&amp;price=20.0，运行结果如图3所示： 图 3 示例中使用的是请求URL中的参数，其实也可以是客户端提交的任意参数，特别是表单中的数据。 (3) 复杂数据类型复杂数据类型指的是一个自定义类型中还包含另外一个对象类型 自定义数据类型User，其中包含Product成员： package org.spring.mvc.model; public class User { private String username; private Product product; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Product getProduct() { return product; } public void setProduct(Product product) { this.product = product; } } 示例代码：复杂数据类型 @RequestMapping(&quot;/action22&quot;) public String action22(Model model, User user) { model.addAttribute(&quot;message&quot;, user.getUsername() + &quot;,&quot; + user.getProduct().getName()); return &quot;index&quot;; } 访问路径：http://localhost:8080/spring-mvc/controller08/action22?username=tom&amp;product.name=rice，运行结果如图4所示： 图 4 使用表单提交数据，创建表单action22.jsp： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;action22&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=&quot;post&quot; action=&quot;action02&quot;&gt; username:&lt;input name=&quot;username&quot; /&gt;&lt;br/&gt; pdctname:&lt;input name=&quot;product.name&quot; /&gt;&lt;br/&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 访问路径：http://localhost:8080/spring-mvc/action22.jsp，运行结果如图5所示： 图 5 提交之后，运行结果如图6所示： 图 6 (4) List集合类型不能直接在action的参数中指定List类型。 定义一个数据类型ProductList，其中包含一个List成员： public class ProductList { private List&lt;Product&gt; items; public List&lt;Product&gt; getItems() { return items; } public void setItems(List&lt;Product&gt; items) { this.items = items; } } 示例代码：List集合类型 @RequestMapping(&quot;/action23&quot;) public String action23(Model model, ProductList products) { model.addAttribute(&quot;message&quot;, products.getItems().get(0) + &quot;&lt;br/&gt;&quot; + products.getItems().get(1)); return &quot;index&quot;; } 在URL中模拟表单数据，访问路径：http://localhost:8080/spring-mvc/controller08/action23?items[0].name=phone&amp;items[1].name=book，运行结果如图7所示： 图 7 这里同样可以使用一个表单向服务器提交数据。 (5) Map集合类型Map与List的实现方式基本一样。 定义一个数据类型ProductMap，其中包含一个Map成员： public class ProductMap { private Map&lt;String, Product&gt; items; public Map&lt;String, Product&gt; getItems() { return items; } public void setItems(Map&lt;String, Product&gt; items) { this.items = items; } } 示例代码：Map集合类型 @RequestMapping(&quot;/action24&quot;) public String action24(Model model, ProductMap map) { model.addAttribute(&quot;message&quot;, map.getItems().get(&quot;p1&quot;) + &quot;&lt;br/&gt;&quot; + map.getItems().get(&quot;p2&quot;)); return &quot;index&quot;; } 在URL中模拟表单数据，访问路径：http://localhost:8080/spring-mvc/controller08/action24?items[p1].name=phone&amp;items[p2].name=book，运行结果如图8所示： 图 8 集合类型基本都一样，set也差不多，问题是如果为了获得一个集合需要刻意去包装会很麻烦，可以通过@RequestParam结合@RequestBody等注解完成。 2. @RequestParam参数绑定简单的参数可以使用上一节中讲过的自动参数映射，虽然自动参数映射很方便，但有些细节是不能处理的，如参数是否为必须参数、参数名称没有办法指定、指定参数的默认值。复杂的参数映射可以使用@RequestParam完成，Spring MVC会自动查找请求中的参数，并进行参数绑定和类型转换。 @RequestParam共有4个注解属性： required属性表示是否为必须，默认值为true，如果请求中没有指定的参数会报异常； defaultValue用于设置参数的默认值，如果不指定值则使用默认值，只能是String类型的。 name与value互为别名关系用于指定参数名称。 (1) 基本数据类型示例代码： @RequestMapping(&quot;/action25&quot;) public String action25(Model model, @RequestParam(required = false, defaultValue = &quot;99&quot;) int id) { model.addAttribute(&quot;message&quot;, id); return &quot;index&quot;; } 访问路径：http://localhost:8080/spring-mvc/controller08/action25?id=98，运行结果如图9所示： 图 9 访问路径：http://localhost:8080/spring-mvc/controller08/action25，运行结果如图10所示： 图 10 (2) List与数组直接绑定：基本数据类型在上一节中我们使用自动参数映射是不能直接完成List数组绑定的，结合@RequestParam可以轻松实现。 示例代码： @RequestMapping(&quot;/action26&quot;) public String action26(Model model, @RequestParam(&quot;id&quot;) List&lt;String&gt; ids) { model.addAttribute(&quot;message&quot;, Arrays.deepToString(ids.toArray())); return &quot;index&quot;; } 在URL中模拟表单数据，访问路径：http://localhost:8080/spring-mvc/controller08/action26?id=tom&amp;id=rose，运行结果如图11所示： 图 11 使用表单提交数据，创建表单action26.jsp： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;action22&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;controller08/action26&quot; method=&quot;post&quot;&gt; &lt;p&gt; &lt;label&gt;爱好：&lt;/label&gt; &lt;input type=&quot;checkbox&quot; value=&quot;reading&quot; name=&quot;id&quot; /&gt;阅读 &lt;input type=&quot;checkbox&quot; value=&quot;surfing&quot; name=&quot;id&quot; /&gt;上网 &lt;input type=&quot;checkbox&quot; value=&quot;gaming&quot; name=&quot;id&quot; /&gt;电游 &lt;/p&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 访问路径：http://localhost:8080/spring-mvc/action26.jsp，运行结果如图12所示： 图 12 提交之后，运行结果如图13所示： 图 13 @RequestParam(“id”)表明参数是必须的。因为页面中的表单name的名称为id，所有服务器在收集数据时应该使用id页非ids。 如果name属性和参数名称同名，则name属性可以省去。示例代码： @RequestMapping(&quot;/action27&quot;) public String action27(Model model, @RequestParam(&quot;id&quot;) List&lt;String&gt; id) { model.addAttribute(&quot;message&quot;, Arrays.deepToString(id.toArray())); return &quot;index&quot;; } (3) List与数组直接绑定：自定义数据类型上一小节中我们绑定的集合中存放的是基本数据类型，如果需要直接绑定更加复杂的数据类型则需要使用@RequestBody与@ResponseBody注解。 @RequestBody 将HTTP请求正文转换为适合的HttpMessageConverter对象。 @ResponseBody 将内容或对象作为 HTTP 响应正文返回，并调用适合HttpMessageConverter的Adapter转换对象，写入输出流。 @RequestBody注解修饰的参数默认接收的Content-Type是application/json，因此客户端在发送POST请求时需要设置请求报文头信息，否则Spring MVC在解析集合请求参数时不会自动将参数转换成JSON数据再解析成相应的集合。Spring默认的json协议解析由Jackson完成，要完成这个功能需要修改配置环境。 (a) 修改Spring MVC配置文件，启用mvc注解驱动功能 &lt;mvc:annotation-driven /&gt; (b) 修改pom.xml，添加jackson依赖 &lt;!-- jackson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/dependency&gt; (c) 使用Ajax发送请求时需要设置contentType属性为’application/json;charse=UTF-8’(请求的默认contentType属性并非是application/json，而是application/x-www-form-urlencoded)，服务器将把接收到的参数转换成JSON字符串，如果条件不满足有可能会出现415异常。 前端示例代码：定义一个action28-29.jsp页面，在客户端发送请求时设置contentType为application/json &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;List与数组直接绑定：自定义数据类型&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button type=&quot;button&quot; onclick=&quot;addPdts_click1();&quot;&gt;向服务器发送json&lt;/button&gt; &lt;button type=&quot;button&quot; onclick=&quot;addPdts_click2();&quot;&gt;接收服务器返回的json&lt;/button&gt; &lt;p id=&quot;msg&quot;&gt;&lt;/p&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;&lt;c:url value=&quot;/scripts/jQuery1.11.3/jquery-1.11.3.min.js&quot;/&gt;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var products = new Array(); products.push({ id : 1, name : &quot;iPhone 6 Plus&quot;, price : 4987.5 }); products.push({ id : 2, name : &quot;iPhone 7 Plus&quot;, price : 5987.5 }); products.push({ id : 3, name : &quot;iPhone 8 Plus&quot;, price : 6987.5 }); function addPdts_click1() { $.ajax({ type : &quot;POST&quot;, //请求谓词类型 url : &quot;controller08/action28&quot;, data : JSON.stringify(products), //将products对象转换成json字符串 contentType : &quot;application/json;charset=UTF-8&quot;, //发送信息至服务器时的内容编码类型，默认为application/x-www-form-urlencoded dataType : &quot;text&quot;, //期望服务器返回的数据类型 success : function(result) { $(&quot;#msg&quot;).html(result); } }); } function addPdts_click2() { $.ajax({ type : &quot;POST&quot;, //请求谓词类型 url : &quot;controller08/action29&quot;, data : JSON.stringify(products), //将products对象转换成json字符串 contentType : &quot;application/json;charset=UTF-8&quot;, //发送信息至服务器时的内容编码类型，默认为application/x-www-form-urlencoded dataType : &quot;json&quot;, //期望服务器返回的数据类型 success : function(result) { var str = &quot;&quot;; $.each(result, function(i, obj) { str += &quot;编号：&quot; + obj.id + &quot;,名称：&quot; + obj.name + &quot;,价格：&quot; + obj.price + &quot;&lt;br/&gt;&quot;; }); $(&quot;#msg&quot;).html(str); } }); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 页面中有两个请求方法，第一个方法将一个json集合发送到服务器并映射成一个List集合；第二个方法接收服务器返回的json对象。 接收第一个请求的服务器示例代码: @RequestMapping(&quot;/action28&quot;) public void action28(@RequestBody List&lt;Product&gt; products, HttpServletResponse response) throws IOException { response.setCharacterEncoding(&quot;UTF-8&quot;); System.out.println(Arrays.deepToString(products.toArray())); response.getWriter().write(&quot;添加成功&quot;); } action28的参数List&lt; Product&gt; products是接收从客户端发送到服务器的产品集合，在参数前增加@RequestBody注解的作用是让Spring MVC在接收到客户端请求时选择合适的转换器将参数转换成相应的对象。 接收第二个请求的服务器示例代码: @RequestMapping(&quot;/action29&quot;) @ResponseBody public List&lt;Product&gt; action29(@RequestBody List&lt;Product&gt; products, HttpServletResponse response) throws IOException { products.get(0).setPrice(999.99); return products; } action29的返回值为List，且在方法上有一个注解@ResponseBody，系统会使用jackson将该返回值对象自动序列化成json字符序列。 访问路径：http://localhost:8080/spring-mvc/action28-29.jsp，运行结果如图14所示： 图 14 点击第一个按钮时的如图15所示： 图 15 控制台输出： [编号(id)：1，名称(name)：iPhone 6 Plus，价格(price)：4987.5, 编号(id)：2，名称(name)：iPhone 7 Plus，价格(price)：5987.5, 编号(id)：3，名称(name)：iPhone 8 Plus，价格(price)：6987.5] 点击第二个按钮时的如图16所示： 图 16 3. 重定向与Flash属性如果一个请求处理方法Action的返回结果为”index”字符串，则表示结果转发到index视图。但有时候我们需要重定向，将结果重定向到一个指定的页面或另一个action，则可以在返回的结果前加上一个”redirect:”前缀。 示例代码: @RequestMapping(&quot;/action30&quot;) public String action30(Model model) { model.addAttribute(&quot;message&quot;, &quot;action30Message&quot;); return &quot;redirect:action31&quot;; } @RequestMapping(&quot;/action31&quot;) public String action31(Model model) { model.addAttribute(&quot;message&quot;, &quot;action31Message&quot;); return &quot;index&quot;; } 访问路径：http://localhost:8080/spring-mvc/controller08/action30，运行结果如图17所示： 图 17 在action30中返回的结果为redirect:action31，表示重定向到action31这个请求处理方法，所有重定向都是以当前路径为起点的。action30向model中添加了名称message的数据，因为重定向到action31中会发起两次请求，为了保持action30中的数据，Spring MVC自动将数据重写到了url中。 为了实现重定向时传递复杂数据，可以使用Flash属性。 示例代码： @RequestMapping(&quot;/action32&quot;) public String action32(Model model, RedirectAttributes redirectAttributes) { Product product = new Product(2, &quot;iPhone7 Plus&quot;, 6989.5); redirectAttributes.addFlashAttribute(&quot;product&quot;, product); return &quot;redirect:action33&quot;; } @RequestMapping(&quot;/action33&quot;) public String action33(Model model, Product product) { model.addAttribute(&quot;message&quot;, product); System.out.println(model.containsAttribute(&quot;product&quot;)); // true return &quot;index&quot;; } 当访问action32时，首先创建了一个Product对象，并将该对象添加到了Flash属性中，在重定向后取出该对象。 访问路径：http://localhost:8080/spring-mvc/controller08/action32，运行结果如图18所示： 图 18 此时URL地址已经发生了变化，product对象其实也已经被存入了model中，在action33的视图中可以直接拿到。 4. @ModelAttribute注解@ModelAttribute注解可以应用在方法参数上或方法上，其作用是： 当注解在方法的参数上时，会将被注解的参数对象添加到Model中； 当注解在请求处理方法Action上时，会将该方法变成一个非请求处理的方法，而是让其它Action被调用时先调用该方法。 (1) 注解在参数上当@ModelAttribute注解在参数上时，会将被注解的参数添加到Model中，并自动完成数据绑定。 示例代码： 访问路径：http://localhost:8080/spring-mvc/controller08/action34?id=12&amp;name=apple&amp;price=6000，运行结果如图19所示： 图 19 其实不使用@ModelAttribute也样可以完成参数与对象间的自动映射，但使用注解可以设置更多详细内容，如名称、是否绑定等。 (2) 注解在方法上@ModelAttribute注解还可以用于标注一个非请求处理方法，通俗说就是一个非Action或普通方法。如果一个控制器类有多个请求处理方法，以及一个由@ModelAttribute注解的方法，则在调用其它Action之前会先调用由@ModelAttribute注解的方法。 示例代码： @RequestMapping(&quot;/action35&quot;) public String action35(Model model) { Map&lt;String, Object&gt; map = model.asMap(); for (String key : map.keySet()) { System.out.println(key + &quot;：&quot; + map.get(key)); } return &quot;index&quot;; } @ModelAttribute public String noaction() { System.out.println(&quot;noaction 方法被调用！&quot;); String message = &quot;来自noaction方法的信息&quot;; return message; } 当访问路径：http://localhost:8080/spring-mvc/controller08/action35，控制台会输出： noaction 方法被调用！ string：来自noaction方法的信息 非请求处理方法可以返回void，也可以返回一个任意对象，该对象会被自动添加到每一个要被访问的Action的Model中。从示例中可以看出key为类型名称。 二、Action返回值Spring MVC的action返回值可以为String、void、ModelAndView、Map、Model和其它任意类型。 0. URL问题在/src/main/webapp/WEB-INF/image目录下添加图片3.jpg。 第一次尝试 在/src/main/webapp/WEB-INF/view/controller09目录下添加视图action36.jsp： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;action5的视图&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img alt=&quot;风景&quot; src=&quot;../../image/3.jpg&quot;&gt; &lt;/body&gt; &lt;/html&gt; 目标结构如下： 图 19 定义一个action访问该图片： @RequestMapping(&quot;/action36&quot;) public String action36(Model model) { return &quot;controller09/action36&quot;; } 访问路径：http://localhost:8080/spring-mvc/controller09/action36，运行结果如图21所示： 图 21 访问不到图片的原因是： 此时action36.jsp视图并非以它所在的目录为实际路径，而是以当前action所在的控制器为起始目录的。当前控制器的url为：http://localhost:8080/spring-mvc/controller09/，而图片的src为：../../image/3.jpg，向上2级后变成：http://localhost:8087/image/3.jpg，但是此路径中并没有存放3.jpg这张图片。解决的办法是在视图中使用&quot;绝对&quot;路径； 另外一个问题是我们将静态资源存放到WEB-INF目录下不太合理，该目录是禁止客户端访问的。 修改 修改action36.jsp视图如下： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;action5的视图&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img alt=&quot;风景&quot; src=&quot;../../image/3.jpg&quot;&gt; &lt;img alt=&quot;风景&quot; src=&quot;&lt;c:url value=&quot;/image/3.jpg&quot;&gt;&lt;/c:url&gt;&quot;&gt; &lt;/body&gt; &lt;/html&gt; 修改后目标结构如下： 图 22 访问路径：http://localhost:8080/spring-mvc/controller09/action36，运行结果如图23所示： 图 23 小结：借助标签将路径转换成”绝对路径”；建议在引用外部资源如js、css、图片信息时都使用该标签解析路径。 1. 返回值为String(1) String作为视图名称默认如果action返回String，此时String为视图名称，Spring MVC会去视图解析器设定的目录下查找，查找的规则是：URL= prefix前缀+视图名称+suffix后缀。 在Spring MVC的配置文件中配置视图解析器： &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; 示例代码： @RequestMapping(&quot;/action37&quot;) public String action37(Model model) { model.addAttribute(&quot;message&quot;, &quot;action31&quot;); return &quot;index&quot;; } 返回视图的路径为：/WEB-INF/view/index.jsp (2) String作为内容输出如果方法声明了@ResponseBody注解，将内容或对象作为HTTP响应正文返回，并调用适合HttpMessageConverter的Adapter转换对象，写入输出流，此时的String不再是路径而是内容。 示例代码： @RequestMapping(&quot;/action38&quot;) @ResponseBody public String action38() { return &quot;not &lt;b&gt;path&lt;/b&gt;,but &lt;b&gt;content&lt;/b&gt;&quot;; } 访问路径：http://localhost:8080/spring-mvc/controller09/action38，运行结果如图24所示： 图 24 2. 返回值为voidvoid在普通方法中是没有返回值的意思，但作为请求处理方法的返回值类型并非这样，存在如下两种情况： (1) 方法名默认作为视图名当方法没有返回值时，方法中并未指定视图的名称，则默认视图的名称为方法名，查找的规则为：URL= prefix前缀+控制器路径+方法名称+suffix后缀组成。 示例代码： @RequestMapping(&quot;/action39&quot;) public void action39() { } 返回视图的路径为：/WEB-INF/view/controller09/action39.jsp，controller09是当前控制器映射的路径，action39是方法名。 访问路径：http://localhost:8080/spring-mvc/controller09/action39，运行结果如图25所示： 图 25 上面的action代码等同于 @RequestMapping(&quot;/action39&quot;) public String action39() { return &quot;controller09/action39&quot;; //controller09是控制器的路径 } (2) 直接响应输出结果当方法的返回值为void，但输出流中存在输出内容时，则不会去查找视图，而是将输入流中的内容直接响应到客户端，响应的内容类型是纯文本。 示例代码： @RequestMapping(&quot;/action40&quot;) public void action40(HttpServletResponse response) throws IOException { response.getWriter().write(&quot;&lt;h2&gt;void method&lt;/h2&gt;&quot;); } 访问路径：http://localhost:8080/spring-mvc/controller09/action40，运行结果如图26所示： 图 26 3. 返回值为ModelAndView在旧的Spring MVC中ModelAndView使用频率非常高，它可以同时指定返回的模型与视图名称。ModelAndView有个多构造方法重载，单独设置属性也很方便。 示例代码： @RequestMapping(&quot;/action41&quot;) public ModelAndView action41() { //1. 只指定视图 //return new ModelAndView(&quot;index&quot;); //2. 分别指定视图与模型 Map&lt;String, Object&gt; model=new HashMap&lt;String,Object&gt;(); model.put(&quot;message&quot;, &quot;ModelAndView action41&quot;); return new ModelAndView(&quot;index&quot;, model); //3. 同时指定视图与模型 //return new ModelAndView(&quot;index&quot;, &quot;message&quot;,&quot;action41 ModelAndView &quot;); //4. 分开指定视图与模型 //ModelAndView modelAndView=new ModelAndView(); //指定视图名称 //modelAndView.setViewName(&quot;index&quot;); //添加模型中的对象 //modelAndView.addObject(&quot;message&quot;, &quot;&lt;h2&gt;Hello ModelAndView&lt;/h2&gt;&quot;); //return modelAndView; } 访问路径：http://localhost:8080/spring-mvc/controller09/action41 4. 返回值为Map当返回结果为Map时，相当于只是返回了Model，并未指定具体的视图，返回视图的办法与void是一样的，即URL= prefix前缀+控制器路径+方法名称 +suffix后缀组成。 示例代码： @RequestMapping(&quot;/action42&quot;) public Map&lt;String, Object&gt; action42() { Map&lt;String, Object&gt; model = new HashMap&lt;String, Object&gt;(); model.put(&quot;message&quot;, &quot;Hello Map&quot;); model.put(&quot;other&quot;, &quot;more item&quot;); return model; } 访问路径：http://localhost:8080/spring-mvc/controller09/action42 实际访问的视图路径是：/WEB-INF/view/controller09/action42.jsp，返回给客户端的map相当于模型，在视图中可以取出。 5. 返回值为任意类型(1) 返回值为基本数据类型当返回结果直接为int,double,boolean等基本数据类型时，将会报exception is java.lang.IllegalArgumentException: Unknown return value type异常。 示例代码： @RequestMapping(&quot;/action43&quot;) public int action43() { return 9527; } 如果确实需要直接将基本数据类型返回，则可以使用注解@ReponseBody。 示例代码： @RequestMapping(&quot;/action44&quot;) @ResponseBody public int action44() { return 9527; } 访问路径：http://localhost:8080/spring-mvc/controller09/action44 (2) 返回值为自定义类型当返回值为自定义类型时，Spring会把方法认为是视图名称，与返回值为void类似的办法处理URL，但页面中获得数据比较麻烦。 示例代码： @RequestMapping(&quot;/action45&quot;) public Product action45() { return new Product(1,&quot;iPhone&quot;,1980.5); } 访问路径：http://localhost:8080/spring-mvc/controller09/action45 如果存在action45对应的视图，页面可以正常显示，但无内容。 如果在action上添加@ResponseBody注解，则返回的是Product本身，而非视图，Spring会选择一个合适的方式解析对象，默认是json。 示例代码： @RequestMapping(&quot;/action46&quot;) @ResponseBody public Product action46() { return new Product(1,&quot;iPhone&quot;,1980.5); } 访问路径：http://localhost:8080/spring-mvc/controller09/action46 6. 返回值为Model类型Model接口定义在org.springframework.ui包下，model对象会用于页面渲染，视图路径使用方法名，与void类似。 示例代码： @RequestMapping(&quot;/action47&quot;) public Model action47(Model model) { model.addAttribute(&quot;message&quot;, &quot;返回类型为org.springframework.ui.Model&quot;); return model; } 访问路径：http://localhost:8080/spring-mvc/controller09/action47 返回的类型还有许多如view等，通过view可指定一个具体的视图，如下载Excel、Pdf文档，其实它们也修改http的头部信息，手动同样可以实现。 示例代码： @RequestMapping(&quot;/action48&quot;) @ResponseBody public String action48(HttpServletResponse response) { response.setHeader(&quot;Content-type&quot;,&quot;application/octet-stream&quot;); response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment; filename=table.xls&quot;); return &quot;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Hello&lt;/td&gt;&lt;td&gt;Excel&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&quot;; } 访问路径：http://localhost:8080/spring-mvc/controller09/action48 7. 小结 使用String作为请求处理方法的返回值类型是比较通用的方法，这样返回的逻辑视图名不会和请求URL绑定，具有很高的灵活性，而模型数据又可以通过Model控制； 使用void、map、Model作为请求处理方法的返回值类型时，这样返回对应的逻辑视图名称真实url为：prefix前缀+控制器路径+方法名+suffix后缀组成； 使用String、ModelAndView返回视图名称可以不受请求的url绑定，ModelAndView可以设置返回的视图名称； 另外在非MVC中使用的许多办法在Action也可以使用。","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hepsilion.github.io/categories/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hepsilion.github.io/tags/SpringMVC/"}],"keywords":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hepsilion.github.io/categories/SpringMVC/"}]},{"title":"02-@RequestMapping详解","slug":"SpringMVC-02","date":"2017-10-22T06:45:29.000Z","updated":"2017-10-22T07:13:55.240Z","comments":true,"path":"2017/10/22/SpringMVC-02/","link":"","permalink":"https://hepsilion.github.io/2017/10/22/SpringMVC-02/","excerpt":"","text":"1. value 属性value属性用来指定请求的实际地址，指定的地址可以是URL模板、正则表达式或路径占位；该属性与path属性互为别名关系，即@RequestMapping(“/foo”)}与@RequestMapping(path=”/foo”)相同；该属性是使用最频繁、最重要的一个属性，当只指定该属性时可以把value略去。 (1) 指定具体路径字符串只注解方法，访问时直接指定方法的路径 @Controller public class Controller03 { /** * @url http://localhost:8080/spring-mvc/action01 * @return */ @RequestMapping(&quot;/action01&quot;) public String action01(){ return &quot;index&quot;; } } 访问路径:http://localhost:8080/spring-mvc/action01 同时注解类与方法，访问时需要先指定类的路径再指定方法的路径 @Controller @RequestMapping(&quot;/controller04&quot;) public class Controller04 { /** * @url http://localhost:8080/spring-mvc/controller04/action02 * @return */ @RequestMapping(&quot;/action02&quot;) public String action02(){ return &quot;index&quot;; } } 访问路径:http://localhost:8080/spring-mvc/controller04/action02 value为空值 第一种情况：注解在方法上时，如果value为空则表示该方法为类下默认的Action。 @Controller @RequestMapping(&quot;/controller05&quot;) public class Controller05 { /** * @url http://localhost:8080/spring-mvc/controller05/action03 * @param model * @return */ @RequestMapping(&quot;/action03&quot;) public String action03(Model model){ //在模型中添加属性message值为action03，渲染页面时使用 model.addAttribute(&quot;message&quot;, &quot;action03&quot;); return &quot;index&quot;; } /** * 该方法为类下默认的Action * @url http://localhost:8080/spring-mvc/controller05 * @param model * @return */ @RequestMapping public String action04(Model model){ //在模型中添加属性message值为action04，渲染页面时使用 model.addAttribute(&quot;message&quot;, &quot;action04&quot;); return &quot;index&quot;; } } 访问action04的路径:http://localhost:8080/spring-mvc/controller05，如果加上action02就会产生错误了。 第二种情况：注解在类上时，当value为空值时，则该类为默认的控制器，可以用于设置项目的起始页。 @Controller @RequestMapping public class Controller06 { /** * @url http://localhost:8080/spring-mvc/action05 * @param model * @return */ @RequestMapping(&quot;/action05&quot;) public String action05(Model model){ //在模型中添加属性message值为action05，渲染页面时使用 model.addAttribute(&quot;message&quot;, &quot;action05&quot;); return &quot;index&quot;; } /** * @url http://localhost:8080/spring-mvc/ * @param model * @return */ @RequestMapping public String action06(Model model){ //在模型中添加属性message值为action06，渲染页面时使用 model.addAttribute(&quot;message&quot;, &quot;action06&quot;); return &quot;index&quot;; } } 访问action06的路径:http://localhost:8080/spring-mvc/，同时省去了控制器名与Action名称，可用于欢迎页。 访问action05的路径:http://localhost:8080/spring-mvc/action05 (2) 路径变量占位，URI模板模式在Spring MVC中可以使用@PathVariable 注释方法参数的值绑定到一个URI模板变量。 @RequestMapping(&quot;/action07/{p1}/{p2}&quot;) public String action07(@PathVariable int p1, @PathVariable int p2, Model model) { model.addAttribute(&quot;message&quot;, p1 + p2); return &quot;index&quot;; } 访问action07的路径:http://localhost:8080/spring-mvc/controller07/action07/1/2，运行结果： 图 1 使用路径变量的好处：使路径变得更加简洁；框架会自动进行类型转换，获得参数更加方便，通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到action，如这里访问是的路径是/action07/1/a，则路径与方法不匹配，而不会是参数转换失败。 (3) 正则表达式模式的URI模板@RequestMapping(value = &quot;/action08/{id:\\\\d{6}}-{name:[a-z]{3}}&quot;) public String action08(@PathVariable int id, @PathVariable String name, Model model) { model.addAttribute(&quot;message&quot;, &quot;id:&quot; + id + &quot; name:&quot; + name); return &quot;index&quot;; } 正则要求id必须为6位的数字，而name必须为3位小写字母。 访问action08的路径:http://localhost:8080/spring-mvc/controller07/action08/123456-abc，访问结果如下： 图 1 (4) 矩阵变量@MatrixVariable/** * @url http://localhost:8080/spring-mvc/controller07/action09/the book color;r=33;g=66 * @param model * @param name * @param r * @param g * @param b * @return */ @RequestMapping(value = &quot;/action09/{name}&quot;) public String action09(Model model, @PathVariable String name, // 路径变量，用于获得路径中的变量name的值 @MatrixVariable String r, @MatrixVariable(required = true) String g, // 参数g是必须的 @MatrixVariable(defaultValue = &quot;99&quot;, required = false) String b) { // 参数b不是必须的，默认值是99 model.addAttribute(&quot;message&quot;, name + &quot; is #&quot; + r + g + b); return &quot;index&quot;; } Spring MVC默认是不允许使用矩阵变量的，需要设置配置文件中的RequestMappingHandlerMapping的属性removeSemicolonContent为false；并且在annotation-driven中增加属性enable-matrix-variables=”true”。修改后的springmvc-servlet.xml文件如下： &lt;!-- 支持mvc注解驱动 --&gt; &lt;mvc:annotation-driven enable-matrix-variables=&quot;true&quot; /&gt; &lt;!-- 配置映射媒体类型的策略 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;&gt; &lt;property name=&quot;removeSemicolonContent&quot; value=&quot;false&quot; /&gt; &lt;/bean&gt; 访问action09的路径:http://localhost:8080/spring-mvc/controller07/action09/the book color;r=33;g=66，访问结果如下： 图 1 (5) Ant风格路径模式@RequestMapping注解也支持ant风格的路径模式，如/myPath/*.do，/owners/*/pets/{petId} /** * Ant风格路径模式 * @url http://localhost:8080/spring-mvc/controller07/action10/ant.do * @param model * @return */ @RequestMapping(value = &quot;/action10/*.do&quot;) public String action10(Model model) { model.addAttribute(&quot;message&quot;, &quot;Ant风格路径模式&quot;); return &quot;index&quot;; } 访问action10的路径:http://localhost:8080/spring-mvc/controller07/action10/ant.do，访问结果如下： 图 1 2. method属性method属性可以指定请求谓词的类型，如GET、POST、HEAD、OPTIONS、PUT、PATCH、DELETE、TRACE等，约束请求范围。 @RequestMapping(value = &quot;/action11&quot;, method = { RequestMethod.POST, RequestMethod.DELETE }) public String action11(Model model) { model.addAttribute(&quot;message&quot;, &quot;请求谓词只能是POST与DELETE&quot;); return &quot;index&quot;; } 访问action11的路径:http://localhost:8080/spring-mvc/controller07/action11。 要访问action11的请求谓词类型必须是POST或者为DELETE，但当我们从浏览器的URL栏中直接请求时，发出的是一个GET请求，则结果显示405，访问结果如下： 图 1 现将请求的谓词类型从POST修改为GET @RequestMapping(value = &quot;/action12&quot;, method = RequestMethod.GET) public String action12(Model model) { model.addAttribute(&quot;message&quot;, &quot;请求谓词只能是GET&quot;); return &quot;index&quot;; } 访问action12的路径:http://localhost:8080/spring-mvc/controller07/action12，访问正常，结果如下所示： 图 1 3. consumes属性consumes属性指定提交的请求的内容类型（Content-Type），如application/json, text/html，约束请求范围。如果用户发送的请求内容类型和consumes属性不匹配，则方法不会响应请求。 @RequestMapping(value = &quot;/action13&quot;, consumes=&quot;text/html&quot;) public String action13(Model model) { model.addAttribute(&quot;message&quot;, &quot;请求的提交内容类型（Content-Type）是text/html&quot;); return &quot;index&quot;; } 访问action13的路径:http://localhost:8080/spring-mvc/controller07/action13。 在action8的注解中约束发送到服务器的请求的Content-Type必须是text/html类型，如果类型不一致则会报错（415），结果如下所示： 图 1 4. produces属性5. params属性params属性可以限制客户端发送到服务器的请求中必须含有特定的参数与值(参数的值为某些特定值或不为某些特定值)。 @RequestMapping(value = &quot;/action15&quot;, params = { &quot;id=215&quot;, &quot;name!=abc&quot; }) public String action15(Model model) { model.addAttribute(&quot;message&quot;, &quot;请求的参数必须包含id=215与name不等于abc&quot;); return &quot;index&quot;; } 访问action15的路径:http://localhost:8080/spring-mvc/controller07/action15?id=215&amp;name=abc，结果如下所示： 图 1 访问action15的路径:http://localhost:8080/spring-mvc/controller07/action15?id=215&amp;name=def，结果如下所示： 图 1 name的值不指定或者使用不等于也是通过的 访问action15的路径:http://localhost:8080/spring-mvc/controller07/action15?id=215&amp;name=def，结果如下所示： 图 1 访问action15的路径:http://localhost:8080/spring-mvc/controller07/action15?id=215&amp;name!=abc，结果如下所示： 图 1 6. headers属性headers属性可以限制客户端发送到服务器的请求头部信息中必须包含某个特定的值或不包含特定的值。 @RequestMapping(value = &quot;/action16&quot;,headers=&quot;Host=localhost:8088&quot;) public String action16(Model model) { model.addAttribute(&quot;message&quot;, &quot;请求头部信息中必须包含Host=localhost:8088&quot;); return &quot;index&quot;; } 访问action16的路径:http://localhost:8080/spring-mvc/controller07/action16，结果如下所示： 图 1 @RequestMapping(value = &quot;/action17&quot;,headers=&quot;Host=localhost:8080&quot;) public String action17(Model model) { model.addAttribute(&quot;message&quot;, &quot;请求头部信息中必须包含Host=localhost:8080&quot;); return &quot;index&quot;; } 访问action17的路径:http://localhost:8080/spring-mvc/controller07/action17，结果如下所示： 图 1 这里同样可以使用!号；可以使用通配符如：Content-Type=”application/*“ 7. name属性为当前映射指定一个名称，不常用，一般不会使用。 8. path属性从Spring 4.2开始引入了@AliasFor注解，可以实现属性的别名，如value本身并没有特定的含义，而path会更加具体，见名知义，通俗说可以认为两者在使用中是一样的,如：@RequestMapping(“/foo”)}与@RequestMapping(path=”/foo”)相同。 示例代码: 访问action18的路径:http://localhost:8080/spring-mvc/controller07/action18，结果如下所示： 图 1 访问action18的路径:http://localhost:8080/spring-mvc/controller07/myaction，结果如下所示： 图 1","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hepsilion.github.io/categories/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hepsilion.github.io/tags/SpringMVC/"}],"keywords":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hepsilion.github.io/categories/SpringMVC/"}]},{"title":"01-SpringMVC入门与环境配置","slug":"SpringMVC-01","date":"2017-10-22T06:41:29.000Z","updated":"2017-10-22T07:13:46.693Z","comments":true,"path":"2017/10/22/SpringMVC-01/","link":"","permalink":"https://hepsilion.github.io/2017/10/22/SpringMVC-01/","excerpt":"本页内容来自：http://www.cnblogs.com/best/p/5653916.html，只是对其中部分内容重新组织，稍加修改。","text":"本页内容来自：http://www.cnblogs.com/best/p/5653916.html，只是对其中部分内容重新组织，稍加修改。 一、MVC概要MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范，用一种将业务逻辑、数据、显示分离的方式组织代码，MVC主要作用是降低了视图与业务逻辑间的双向偶合。MVC不是一种设计模式，而是一种架构模式。当然，不同的MVC之间存在差异。 图 1 在早期的web开发中，通常采用的都是Model1模式。如图2所示，在Model1模式中，项目主要分为两层：视图层和模型层。Model1模式的实现比较简单，适用于快速开发小规模项目。Model1模式中的JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，导致代码的重用性非常低，增加了应用扩展和维护的难度。 图 2 Model2模式消除了Model1模式的缺点。如图3所示，Model2模式把一个项目分成三部分：视图、控制、模型。这样不仅提高了代码的复用率与项目的扩展性，而且大大降低了项目的维护成本。 图 3 常见的服务器端MVC框架有Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF等； 常见前端MVC框架有angularjs、reactjs、backbone等； 由MVC模式还演化出了其他一些模式如：MVP、MVVM。 二、Spring MVC简介三、Spring MVC环境配置：第一个Spring MVC项目1. 使用Maven新建一个Web项目(1) 在Eclipse中新建Maven项目 图 4 (2) 选择”Create a simple project”，创建一个简单项目，不选择模板 图 5 (3) 填写Group Id，Artifact Id，Version和Packaging等信息 图 6 (4) 创建好的Maven项目目录结构如图7所示 图 7 (5) 修改层面信息，选择Dynamic Web Module版本为3.0，Java版本为1.8 图 8 (6) 在/src/main/webapp目录下创建WEB-INF文件夹，如图9所示在其中创建web.xml文件，填入如下内容 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt; &lt;/web-app&gt; 图 9 2. 添加依赖的jar包修改pom.xml文件，添加jar包的依赖，主要有：Spring框架核心库、Spring MVC、JSTL等 &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.spring.mvc&lt;/groupId&gt; &lt;artifactId&gt;spring-mvc&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring.version&gt;4.3.0.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--Spring框架核心库 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring MVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 当依赖添加成功后，项目会加载的jar包如图10所示 图 10 3. 注册中心控制器DispatcherServlet和许多其他MVC框架一样，Spring MVC框架也是请求驱动的，使用一个中心控制器(DispatcherServlet，它继承自HttpServlet)分派请求及提供其他功能。 如图11所示，当前端控制器拦截到用户发送的请求时，会根据请求参数生成代理请求，找到请求对应的实际控制器，由该控制器处理请求：创建数据模型、访问数据库、将模型响应给前端控制器，前端控制器使用模型与视图渲染视图结果，再将结果返回给请求者。 图 11 图 12 修改web.xml文件注册该Servlet，修改后的web.xml文件如下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt; &lt;servlet&gt; &lt;!--名称 --&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- Servlet类 --&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!--SpringMVC配置参数文件的位置 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--默认名称为ServletName-servlet.xml --&gt; &lt;param-value&gt;classpath*:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 4. 添加Spring MVC配置文件在/src/main/resources目录下添加Spring MVC配置文件springmvc-servlet.xml，配置的形式与Spring容器配置基本类似，具体配置信息如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd&quot;&gt; &lt;!-- 自动扫描包，实现支持注解的IOC --&gt; &lt;context:component-scan base-package=&quot;org.spring.mvc&quot; /&gt; &lt;!-- Spring MVC不处理静态资源 --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 支持mvc注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; 为了支持基于注解的IOC，设置了自动扫描包的功能； 在视图解析中，我们把所有的视图都存放在/WEB-INF目录下，因为客户端不能直接访问这个目录，这样可以保证视图安全。在该项目中，我们把视图放在view目录下。 5. 创建HelloWorld控制器在src/main/java源代码目录下创建包org.spring.mvc.controller，在包中创建一个普通的类：HelloWorldController，具体代码如下： package org.spring.mvc.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(&quot;/HelloWorld&quot;) public class HelloWorldController { @RequestMapping(&quot;/helloworld&quot;) public String helloworld(Model model) { model.addAttribute(&quot;message&quot;, &quot;Hello Spring MVC!&quot;); return &quot;helloworld&quot;; } } 使用@Controller注解让Spring IOC容器在初始化时可以自动扫描到该控制器； 使用@RequestMapping注解注册映射请求路径，因为这里的类与方法 (Action) 上都有@RequestMapping，所以访问路径应该是/HelloWorld/helloworld； 方法中声明Model类型的参数是为了让控制器把Action中的数据带到视图中； 方法返回的结果是视图的名称：helloworld。 6. 创建视图在WEB-INF/view目录中创建视图helloworld.jsp，该视图将展示从Action中返回的信息，具体内容如下： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Hello Spring MVC!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;${message}&lt;/h2&gt; &lt;/body&gt; &lt;/html&gt; 需要为jsp添加Servlet核心包 &lt;!-- Servlet核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 7. 测试运行启动Tomcat运行项目，注意查看启动信息，如果有异常应该先解决异常信息。运行成功后的结果如下所示： &lt;img src=”SpringMVC-01/SpringMVC-01-13.png” width=80%”/&gt;图 13 三、控制器定义控制器提供了访问应用程序的行为，解析用户的请求并将其转换为一个模型，通常通过接口定义或注解定义两种方法实现。在Spring MVC中一个控制器可以包含多个Action（动作、方法）。 1. 实现Controller接口定义控制器Controller是一个接口，位于包org.springframework.web.servlet.mvc中，接口中只有一个未实现的方法，如下所示： package org.springframework.web.servlet.mvc; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.web.servlet.ModelAndView; //实现该接口的类获得控制器功能与类型, 解析用户的请求并将其转换为一个模型 public interface Controller { //处理请求且返回一个模型与视图对象 ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception; } (1) 定义一个名为Controller01的类，实现Controller接口，重写handleRequest方法，代码如下： package org.spring.mvc.controller; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.Controller; /* * 定义控制器 */ public class Controller01 implements Controller{ public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { //返回一个模型视图对象，指定路径，指定模型的名称为message，值为一段字符串 return new ModelAndView(&quot;index&quot;, &quot;message&quot;, &quot;Hello，我是通过实现接口定义的一个控制器&quot;); } } (2) 在WEB-INF/view目录下创建一个名为index.jsp的视图，内容如下： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;index&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ${message} &lt;/body&gt; &lt;/html&gt; (3) 修改springmvc-servlet.xml配置文件，增加一个控制器bean的声明，基中name是访问路径，class是自定义的控制器的全名称。具体内容如下： &lt;bean name=&quot;/controller01&quot; class=&quot;org.spring.mvc.controller.Controller01&quot;&gt;&lt;/bean&gt; (4) 运行结果如下： &lt;img src=”SpringMVC-01/SpringMVC-01-14.png” width=80%”/&gt;图 14 (5) 小结 实现Controller接口定义控制器是较老的办法，缺点是：一个控制器中只能有一个Action，如果要多个Action则需要定义多个Controller；定义的方式比较麻烦；Spring 2.5以后采用注解的方式定义解决这引起问题。 2. 使用注解@Controller定义控制器org.springframework.stereotype.Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解），Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类。 (1) 为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描，启用自动组件扫描功能，在beans中增加如下配置： &lt;!-- 自动扫描包，实现支持注解的IOC --&gt; &lt;context:component-scan base-package=&quot;org.spring.mvc&quot; /&gt; base-package属性用于指定扫描的基础包，可以缩小扫描的范围。 (2) 定义为一个控制器类，类的具体实现如下： package org.spring.mvc.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; /** * 定义控制器 * * Controller02类的实例是一个控制器，会自动添加到Spring上下文中 */ @Controller public class Controller02 { //映射访问路径 @RequestMapping(&quot;controller02&quot;) public String index(Model model){ //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(&quot;message&quot;, &quot;Hello，我是通过注解定义的一个控制器&quot;); //返回视图位置 return &quot;index&quot;; } } (3) 运行结果如下： &lt;img src=”SpringMVC-01/SpringMVC-01-15.png” width=80%”/&gt;图 15 (4) 小结 从代码与运行结果可以看出Controller01与Controller02同时都指定了一个视图index.jsp，但是页面的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hepsilion.github.io/categories/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hepsilion.github.io/tags/SpringMVC/"}],"keywords":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hepsilion.github.io/categories/SpringMVC/"}]},{"title":"16-JVM类加载机制","slug":"16-JVM类加载机制","date":"2017-08-19T02:46:17.000Z","updated":"2017-10-21T13:19:21.382Z","comments":true,"path":"2017/08/19/16-JVM类加载机制/","link":"","permalink":"https://hepsilion.github.io/2017/08/19/16-JVM类加载机制/","excerpt":"","text":"一、概述类的加载是指将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并向Java程序员提供了访问方法区内的数据结构的接口。 wps5F9E.tmp 类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误 二、类的生命周期类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载这七个阶段，其中验证、准备和解析三个阶段统称为连接，这7个阶段的发生顺序如图1所示。 图 1：类的生命周期 图1中，加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。注意这里写的是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用、激活另一个阶段。 三、类加载的时机四、类加载的过程Java虚拟机中类加载的全过程包括：加载、验证、准备、解析和初始化五个阶段。 1. 加载：查找并加载类的二进制数据加载是”类加载过程”的第一个阶段。在加载阶段，虚拟机需要完成以下三件事情： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区中的运行时数据结构。 在内存中生成一个代表这个类的java.lang.Class对象，作为对方法区中这个类的各种数据的访问入口。 相对于类加载的其他阶段而言，一个非数组类的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段既可以使用系统提供的类加载器来完成，也可以由用户自定义的类加载器来完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式 (即重写一个类加载器的loadClass()方法)。 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区中，然后在内存中实例化一个java.lang.Class类的对象(并没有明确规定是在Java堆中，对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面)，这个对象将作为程序访问方法区中的这些类型数据的外部接口。 加载阶段与连接阶段的部分内容(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。 2. 连接(1) 验证：确保被加载的类的正确性验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。从整体上看，验证阶段大致会完成4个阶段的检验动作： 文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。例如：是否以魔数0xCAFEBABE开头、主次版本号是否在当前虚拟机处理范围之内、常量池中的常量是否有不被支持的类型等。 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。例如：这个类是否有父类(除了java.lang.Object之外，所有的类都应当有父类)、这个类的父类是否继承了不允许被继承的类(被final修饰的类)等。 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。 对于虚拟机的类加载机制来说，验证阶段是非常重要的，但不是必须的阶段(因为对程序运行期没有影响)。如果所运行的全部代码(包括自己编写的及第三方包中的代码)都已经经过反复使用与验证，那么在实施阶段可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 (2) 准备：为类的静态变量分配内存，并将其初始化为默认值准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。 对于该阶段有以下几点需要注意： 这时候进行内存分配的仅包括类变量(被static修饰的变量)，而不包括实例变量，实例变量将会在对象实例化时随着对象一块分配在Java堆中。 这里所说的初始值通常情况下是数据类型的零值(如0、0L、null、false等)，而不是Java代码中被显式地赋予的值。假设一个类变量的定义为：public static int value = 123；那么变量value在准备阶段过后的初始值为0，而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是在程序编译后，存放于类构造器()方法之中的，所以把value赋值为123的动作将在初始化阶段才会执行。 上面提到的在通常情况下初始值是零值，但也会有一些特殊情况：如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那在准备阶段变量value就会被初始化为ConstValue属性所指定的值。假设上面的类变量value被定义为：public static final int value = 123；编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。 (3) 解析：把类中的符号引用转换为直接引用解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。 符号引用是以一组符号来描述所引用的目标，可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。 直接引用可以是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 3. 初始化类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码(或者说字节码)。 初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式： 声明类变量是指定初始值 使用静态代码块为类变量指定初始值 JVM初始化步骤 假如这个类还没有被加载和连接，则程序先加载并连接该类 假如该类的直接父类还没有被初始化，则先初始化其直接父类 假如类中有初始化语句，则系统依次执行这些初始化语句 类初始化时机虚拟机规范严格规定了有且只有5种情况必须立即对类进行初始化(而加载、验证、准备自然需要在此之前开始)： 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段(被final修饰、已在编译期把结果放入常量池的静态字段除外)的时候、以及调用一个类的静态方法的时候。 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 五、类加载器六、相关问题问：Java类加载时的初始化顺序(1) 初始化父类中的静态成员变量和静态代码块(按照在程序中出现的顺序初始化) (2) 初始化子类中的静态成员变量和静态代码块(按照在程序中出现的顺序初始化) (3) 初始化父类中的普通成员变量和构造代码块(按照在程序中出现的顺序初始化)，然后再执行父类中的构造方法 (4) 初始化子类中的普通成员变量和构造代码块(按照在程序中出现的顺序初始化)，然后再执行子类中的构造方法 例1： class Member { Member(String str) { System.out.println(str); } } class A { static { System.out.println(&quot;父类静态代码块&quot;); } public A() { System.out.println(&quot;父类构造函数&quot;); } { System.out.println(&quot;父类构造代码块&quot;); } Member member=new Member(&quot;父类成员变量&quot;); } class B extends A { Member member=new Member(&quot;子类成员变量&quot;); static { System.out.println(&quot;子类静态代码块&quot;); } public B() { System.out.println(&quot;子类构造函数&quot;); } { System.out.println(&quot;子类构造代码块&quot;); } } public class Test{ public static void main(String[] args) { new B(); } } //输出： 父类静态代码块 子类静态代码块 父类构造代码块 父类成员变量 父类构造函数 子类成员变量 子类构造代码块 子类构造函数 例2：下面代码的输出是什么？(易错) public class B { public static B t1 = new B(); public static B t2 = new B(); { System.out.println(&quot;构造块&quot;); } static { System.out.println(&quot;静态块&quot;); } public static void main(String[] args) { B t = new B(); } } // 输出 构造块 构造块 静态块 构造块 例3：下面代码的输出是什么？(易错) public class Base { private String baseName = &quot;base&quot;; public Base() { callName(); } public void callName() { System.out.println(baseName); } static class Sub extends Base { private String baseName = &quot;sub&quot;; public void callName() { System.out.println(baseName); } } public static void main(String[] args) { Base b = new Sub(); } } // 输出：null 实例化子类对象时会先调用父类构造方法，由于父类构造方法调用了callName()方法并且子类重写了此方法，因此父类构造方法将调用子类的callName()方法将输出子类成员变量baseName的值。 但是由于子类的成员变量在父类构造方法调用完才会赋初值，因此调用callName()方法时，baseName值为null，所以输出结果为null。","categories":[{"name":"Java高级","slug":"Java高级","permalink":"https://hepsilion.github.io/categories/Java高级/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java高级","slug":"Java高级","permalink":"https://hepsilion.github.io/categories/Java高级/"}]},{"title":"15-垃圾收集器与内存分配策略","slug":"15-垃圾收集器与内存分配策略","date":"2017-08-19T02:45:58.000Z","updated":"2017-10-21T13:19:21.335Z","comments":true,"path":"2017/08/19/15-垃圾收集器与内存分配策略/","link":"","permalink":"https://hepsilion.github.io/2017/08/19/15-垃圾收集器与内存分配策略/","excerpt":"","text":"一、概述垃圾收集(Garbage Collection，GC)和内存动态分配技术诞生于1960年MIT的Lisp语言，经过半个多世纪，目前已经相当成熟了。 在Java内存运行时区域的各个部分中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭；栈中的栈帧随着方法的进入和退出做入栈和出栈操作，每一个栈帧中分配多少内存基本上是在类结构确定下来就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是Java堆和方法区的内存回收。 二、对象存活判断1. 引用计数算法(Reference Counting)每个对象有一个引用计数属性，新增一个引用时计数值加1，引用释放时计数值减1，计数值为0的对象可以被回收。 这种方法的实现简单，判定效率也很高，但是无法解决对象之间相互循环引用的问题。 2. 可达性分析算法(Reachability Analysis)以一系列的称为”GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。 在Java语言中，可作为GC Roots的对象包括下面几种： 虚拟机栈(栈帧中的本地变量表)中引用的对象。 方法区中类静态属性实体引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI(即一般说的Native方法)引用的对象。 三、垃圾收集算法1. 标记-清除算法最基础的收集算法是”标记-清除”(Mark-Sweep)算法，如同它的名字一样，算法分为”标记”和”清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。标记-清除算法的执行过程如图1所示。 图 1：”标记-清除”算法示意图 2. 复制算法为了解决效率问题，一种称为”复制”(Copying)的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，持续复制生存期的对象则导致效率降低。复制算法的执行过程如图2所示。 图 2：”复制”算法示意图 现在的商业虚拟机都采用这种收集算法来回收新生代，研究表明，新生代中的对象98%是”朝生夕死”的，所以并不需要按照1：1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例为8：1，也就是每次新生代中可用内存空间为整个新生代容量的90%(80%+10%)，只有10%的内存会被浪费。当然98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存(这里指老年代)进行分配担保。如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。 例1：以下哪些jvm的垃圾回收方式采用的是复制算法回收? A. 新生代串行收集器 B. 老年代串行收集器 C. 并行收集器 D. 新生代并行回收收集器 E. 老年代并行回收收集器 F. cms收集器 答案：A D 3. 标记-整理算法复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。 根据老年代的特点，有人提出了另外一种”标记-整理”(Mark-Compact)算法，标记过程仍然与”标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。标记-整理算法的执行过程如图3所示。 图 3：”标记-整理”算法示意图 4. 分代收集算法GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。 当前商业虚拟机的垃圾收集都采用”分代收集”(Generational Collection)算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用”标记-清理”或者”标记-整理”算法来进行回收。 四、垃圾收集器如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。这里讨论的收集器基于JDK 1.7 Update 14之后的HotSpot虚拟机(在这个版本中正式地提供了商用的G1收集器，之前G1仍处于试验状态)，这个虚拟机包含的所有虚拟机如图4所示。 图 4：HotSpot虚拟机的垃圾收集器 图4展示了7中作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表明它是属于新生代收集器还是老年代收集器。 1. Serial收集器Serial收集器是最基本、发展历史最悠久的收集器，它是一个单线程的收集器，它的”单线程”的意义不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。Serial/Serial Old收集器的运行过程如图5所示。 工作线程会因内存回收而导致停顿(Stop The World) 与其他单线程的收集器相比，简单而高效：对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得更高的单线程收集效率。 图 5：Serial/Serial Old收集器运行示意图 2. ParNew收集器ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数(例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等)、收集算法、Stop the World、对象分配规则、回收策略等都与Serial收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。ParNew收集器的运行过程如图6所示。 图 6：Serial/Serial Old收集器运行示意图 ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU环境中都不能百分之百地保证可以超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对于GC时系统资源的有效利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。 3. Parallel Scavenge收集器Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。 Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)。 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而吞吐量则可以高效地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 4. Serial Old 收集器Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。 这个收集器的主要意义在于给CLient模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK1.5以及以前的版本中与Paralle Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备方案，在并发收集发生Concurrent Mode Failure时使用。 5. Parallel Old 收集器Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和”标记-整理”算法。这个收集器是在JDK 1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old收集器外别无选择。由于老年代Serial Old收集器在服务端应用性能上的拖累，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件条件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合给力。 直至Parallel Old收集器出现后，”吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。Parallel Old收集器的工作过程如图7所示。 图 7：Parallel Scavenge/Parallel Old收集器运行示意图 6. CMS收集器CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。 从名字（包含”Mark Sweep”）上就可以看出，CMS收集器是基于”标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括： 初始标记(CMS initial mark) 并发标记(CMS concurrent mark) 重新标记(CMS remark) 并发清除(CMS concurrent sweep) 其中初始标记、重新标记这两个步骤仍然需要”Stop The World”。初始标记仅仅标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 由于在耗时最长的并发标记和并发清除过程中，收集器线程可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。从图8可以清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间。 图 8：Concurrent Mark Sweep收集器运行示意图 优点：并发收集、低停顿 缺点： CMS收集器对CPU资源非常敏感 CMS收集器无法处理浮动垃圾，可能出现”Concurrent Mode Failure”失败而导致另一次Full GC的产生。 CMS收集器是一款基于”标记-清除”算法实现的收集器，收集结束时会有大量空间碎片产生。 7. G1收集器G1(Barbage-First)收集器是当今收集器技术发展的最前沿成果之一，它是一款面向服务端应用的垃圾收集器。HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与其他GC收集器相比，G1具备以下特点： 并行和并发：G1能够充分利用多CPU、多核环境下的硬件优势，使用多个CPU(CPU或CPU核心)来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。 分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。 空间整合：与CMS的”标记-清理”算法不同，G1从整体上来看是基于”标记-整理”算法实现的收集器，从局部(两个Region之间)上来看是基于”复制”算法实现的。但无论如何，这两种算法都意味着G1在运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续空间而提前触发下一次GC。 可预测停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java(RTSJ)的垃圾收集器的特征了。 在G1之前的其他垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域(Region)，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分(不需要连续)Region的集合。 G1收集器的运作大致可以划分为以下几个步骤： 初始标记(Initial Mark)：初始标记阶段仅仅是标记一下GC Roots能直接关联到的对象，并且修改TAMS(Next Top at Mark Start)的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。 并发标记(Concurrent Marking)：并发标记阶段是从GC Roots开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。 最终标记(Final Marking)：最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Rememebered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并发执行。 筛选回收(Live Data Counting and Evacuation)：筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来指定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。 图 9：G1收集器运行示意图 五、内存分配与回收策略Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决两个问题：给对象分配内存以及回收分配对象的内存。 对象的内存分配，从大方向讲，就是在堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中雨内存相关的参数的设置。 下面是几条最普遍的内存分配规则： 1. 对象优先分配在Eden区大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机执行一次Minor GC。 2. 大对象直接进入老年代所谓大对象是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。大对象对虚拟机的内存分配来说是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前出发垃圾收集以获取足够的连续空间来安置他们。 虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。 3. 长期存活的对象进入老年代既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机为每个对象定义了一个年龄计数器，如果对象在Eden出生并经过第1次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1.对象在Survivor区中每熬过一次Minor GC，年龄就增加1，当它的年龄增加到一定程序(默认为15岁)，就将被晋升到老年代。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。 4. 动态判断对象的年龄为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象必须达到MaxTenuringThreshold才能晋升老年代，如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。 5. 空间分配担保在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么回继续检查老年最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。 六、相关问题问：Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)? 需要整理使答案更简洁JVM的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在JVM启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。 堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。 虚拟机中的堆内存共划分为三个代：年轻代（Young Generation）、年老代（Old Generation）和持久代（Permanent Generation）。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。 Java的垃圾收集机制主要针对新生代和老年代的内存进行回收，不同的垃圾收集算法针对不同的区域。所以Java的垃圾收集算法使用的是分代回收。一般java的对象首先进入新生代的Eden区域，当进行GC的时候会回收新生代的区域，新生代一般采用复制收集算法，将活着的对象复制到survivor区域中，如果survivor区域装在不下，就查看老年代是否有足够的空间装下新生代中的对象，如果能装下就装下，否则老年代就执行FULL GC回收自己，老年代还是装不下，就会抛出OutOfMemory的异常。 (1) 年轻代:所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。Minor GC是针对新生代的回收。 年轻代分三个区:一个Eden区，两个Survivor区(一般而言)。 大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区(两个中的一个)，当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。 (2) 年老代:在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。Major GC/Full GC是针对年老代的回收。 (3) 持久代:用于存放静态文件，如类、方法、final常量、static变量等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=进行设置。 例1：JVM中垃圾回收分为scanvenge gc和full GC，其中full GC触发的条件可能有哪些？ 答案：老年代满、持久代满、System.gc() 问：Java中垃圾回收(GC)有什么目的？什么时候进行垃圾回收？GC是垃圾收集的意思(Gabage Collection)，内存处理是编程人员容易出现问题的地方，忘记或者错误地内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的。Java语言没有提供显示地释放已分配内存的操作方法。 垃圾回收器通常是作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。 垃圾回收的目的是识别并回收堆内存中不再使用的对象所占的内存，释放资源。而栈区的内存是随着线程结束而释放的。 对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。 触发主GC(Garbage Collector，垃圾回收)的条件： (1) 当应用程序空闲时，即没有应用线程在运行时，GC会被调用。 (2) Java堆内存不足时，GC会被调用。 问：System.gc()和Runtime.gc()会做什么事情？Java提供了垃圾回收机制来帮助我们不定时的回收堆中不再使用的对象。当JVM启动时，除了启动我们的主线程外，还会启动垃圾回收线程，它运行优先非常低，会在JVM空闲时，自动回收我们不再使用的对象，释放内存空间。 程序员不能强制执行垃圾回收，可以用这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM，即垃圾回收的具体时间和顺序是无法预知的。 问：如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？不会立即释放对象占用的内存，如果对象的引用被置为null，只是断开了当前线程栈帧中对该对象的引用关系，在下一个垃圾回收周期中，这个对象将是可被回收的。 问：串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？吞吐量收集器使用并行版本的新生代垃圾收集器，它适合于吞吐量要求较高的场合，用于中等规模和大规模数据的应用程序。 串行收集器整个扫描和复制过程均采用单线程的方式，相对于吞吐量GC来说简单；适合于单CPU、客户端级别。串行对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。 问：在Java中，对象什么时候可以被垃圾回收？当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。 问：JVM的永久代中会发生垃圾回收么？(没看懂)垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。 请参考下Java8：从永久代到元数据区(注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区) 问：引用的分类来源1：Java 如何有效地避免OOM：善于利用软引用和弱引用 来源2：Java强引用、 软引用、 弱引用、虚引用 JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及（reachable）状态，程序才能使用它。从JDK 1.2版本开始，把对象的引用分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。 (1) 强引用(StrongReference)强引用是使用最普遍的引用。如果一个对象具有强引用，那么垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。 public class Main { public static void main(String[] args) { new Main().fun1(); } public void fun1() { Object object = new Object(); Object[] objArr = new Object[1000]; } } 当运行至Object[] objArr = new Object[1000];这句时，如果内存不足，JVM会抛出OOM错误也不会回收object指向的对象。不过要注意的是，当fun1运行完之后，object和objArr都已经不存在了，所以它们指向的对象都会被JVM回收。 如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样JVM就可以在合适的时间回收该对象了。 (2) 软引用(SoftReference)软引用是用来描述一些有用但并不是必需的对象，在Java中用java.lang.ref.SoftReference类来表示。对于软引用关联着的对象，当内存空间足够时，垃圾回收器不会回收它；而只有在内存不足的时候JVM才会回收该对象。只要垃圾回收器没有回收它，该对象就可以被程序使用。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现内存敏感的缓存：比如网页缓存、图片缓存等。 软引用可以和一个引用队列(ReferenceQueue)联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。 import java.lang.ref.SoftReference; public class Main { public static void main(String[] args) { SoftReference&lt;String&gt; sr = new SoftReference&lt;String&gt;(new String(&quot;hello&quot;));//当某个对象需要设置为软引用时，只需要给该对象放到软引用对象中即可 System.out.println(sr.get()); } } (3) 弱引用(WeakReference)弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。弱引用与软引用的区别在于：弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 弱引用可以和一个引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 import java.lang.ref.WeakReference; public class Main { public static void main(String[] args) { WeakReference&lt;String&gt; sr = new WeakReference&lt;String&gt;(new String(&quot;hello&quot;)); System.out.println(sr.get()); System.gc();//通知JVM的gc进行垃圾回收 System.out.println(sr.get()); } } 输出： hello null 这说明只要JVM进行垃圾回收，被弱引用关联的对象必定会被回收掉。 不过要注意的是，这里所说的被弱引用关联的对象是指只有弱引用与之关联，如果存在强引用同时与之关联，则进行垃圾回收时也不会回收该对象（软引用也是如此）。 (4) 虚引用(PhantomReference)“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 import java.lang.ref.PhantomReference; import java.lang.ref.ReferenceQueue; public class Main { public static void main(String[] args) { ReferenceQueue&lt;String&gt; queue = new ReferenceQueue&lt;String&gt;(); PhantomReference&lt;String&gt; pr = new PhantomReference&lt;String&gt;(new String(&quot;hello&quot;), queue); System.out.println(pr.get()); } } 输出： null 问：如何利用软引用和弱引用解决OOM问题来源：Android开发优化之——使用软引用和弱引用 在应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量应用软引用和弱引用技术。 假设我们的应用会用到大量的默认图片，比如应用中有默认的头像，默认游戏图标等等，这些图片很多地方会用到。如果每次都去读取图片，由于读取文件需要硬件操作，速度较慢，会导致性能较低。所以我们考虑将图片缓存起来，需要的时候直接从内存中读取。但是，由于图片占用内存空间比较大，缓存很多图片需要很多的内存，就可能比较容易发生OutOfMemory异常。这时，我们可以考虑使用软引用技术来避免这个问题发生。 private Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;(); //保存Bitmap的软引用到HashMap public void addBitmapToCache(String path) { // 强引用的Bitmap对象 Bitmap bitmap = BitmapFactory.decodeFile(path); // 软引用的Bitmap对象 SoftReference&lt;Bitmap&gt; softBitmap = new SoftReference&lt;Bitmap&gt;(bitmap); // 添加该对象到Map中使其缓存 imageCache.put(path, softBitmap); } public Bitmap getBitmapByPath(String path) { // 从缓存中取软引用的Bitmap对象 SoftReference&lt;Bitmap&gt; softBitmap = imageCache.get(path); // 判断是否存在软引用 if (softBitmap == null) { return null; } // 取出Bitmap对象，如果由于内存不足Bitmap被回收，将取得空 Bitmap bitmap = softBitmap.get(); return bitmap; } 使用软引用以后，在OutOfMemory异常发生之前，这些缓存的图片资源的内存空间可以被释放掉的，从而避免内存达到上限，避免Crash发生。 需要注意的是，在垃圾回收器对这个Java对象回收前，SoftReference类所提供的get方法会返回Java对象的强引用，一旦垃圾线程回收该Java对象之后，get方法将返回null。所以在获取软引用对象的代码中，一定要判断是否为null，以免出现NullPointerException异常导致应用崩溃。 问：可能发生OOM和SOF的情况及解决方法(1) OOMOOM：OutOfMemoryError，即内存溢出，是指程序在申请内存时，没有足够的空间供其使用，出现了Out Of Memory，也就是要求分配的内存超出了系统上限，系统不能满足其需求，于是产生溢出。 内存溢出分为上溢和下溢，比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。 有时候内存泄露会导致内存溢出，所谓内存泄露（memory leak），是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光，举个例子，就是说系统的篮子（内存）是有限的，而你申请了一个篮子，拿到之后没有归还（忘记还了或是丢了），于是造成一次内存泄漏。在你需要用篮子的时候，又去申请，如此反复，最终系统的篮子无法满足你的需求，最终会由内存泄漏造成内存溢出。 遇到的OOM： （1）Java Heap 溢出 Java堆用于存储对象实例，我们只要不断的创建对象，而又没有及时回收这些对象（即内存泄漏），就会在对象数量达到最大堆容量限制后产生内存溢出异常。 （2）方法区溢出 方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。异常信息：java.lang.OutOfMemoryError:PermGen space方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。在经常动态生成大量Class的应用中，要特别注意这点。 (2) SOFSOF：StackOverflow（堆栈溢出） 当应用程序递归太深而发生堆栈溢出时，抛出该错误。因为栈一般默认为1-2m，一旦出现死循环或者是大量的递归调用，在不断的压栈过程中，造成栈容量超过1m而导致溢出。 栈溢出的原因： （1）递归调用 （2）大量循环或死循环 （3）全局变量是否过多 （4）数组、List、Map数据过大 OOM在Android开发中出现比较多，例如：加载的图片太多或图片过大、分配特大的数组、内存相应资源过多没有来不及释放等。 解决方法： （1）在内存引用上做处理 软引用是主要用于内存敏感的高速缓存。在jvm报告内存不足之前会清除所有的软引用，这样以来gc就有可能收集软可及的对象，可能解决内存吃紧问题，避免内存溢出。什么时候会被收集取决于gc的算法和gc运行时可用内存的大小。 （2）对图片做边界压缩，配合软引用使用 （3）显示的调用GC来回收内存，如： if(bitmapObject.isRecycled()==false) //如果没有回收 bitmapObject.recycle(); （4）优化Dalvik虚拟机的堆内存分配 》增强程序堆内存的处理效率 //在程序onCreate时就可以调用 即可 privatefinalstaticfloat TARGET_HEAP_UTILIZATION = 0.75f; VMRuntime.getRuntime().setTargetHeapUtilization(TARGET_HEAP_UTILIZATION); 》设置堆内存的大小 privatefinalstaticintCWJ_HEAP_SIZE = 6* 1024* 1024; //设置最小heap内存为6MB大小 VMRuntime.getRuntime().setMinimumHeapSize(CWJ_HEAP_SIZE); （5）用LruCache 和 AsyncTask&lt;&gt;解决 从cache中去取Bitmap，如果取到Bitmap，就直接把这个Bitmap设置到ImageView上面。 如果缓存中不存在，那么启动一个task去加载（可能从文件来，也可能从网络）。","categories":[{"name":"Java高级","slug":"Java高级","permalink":"https://hepsilion.github.io/categories/Java高级/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java高级","slug":"Java高级","permalink":"https://hepsilion.github.io/categories/Java高级/"}]},{"title":"14-Java内存区域","slug":"14-Java内存区域与内存溢出异常","date":"2017-08-19T02:45:14.000Z","updated":"2017-10-21T13:19:21.320Z","comments":true,"path":"2017/08/19/14-Java内存区域与内存溢出异常/","link":"","permalink":"https://hepsilion.github.io/2017/08/19/14-Java内存区域与内存溢出异常/","excerpt":"","text":"JVM内存结构主要有三大块：堆内存、方法区和栈。 堆内存是JVM中最大的一块内存结构，由年轻代和老年代组成，而年轻代内存又被分成三部分：Eden空间、From Survivor空间、To Survivor空间，默认情况下年轻代按照8:1:1的比例来分配； 方法区存储类信息、常量和静态变量等数据，是线程共享的区域。为与Java堆区分，方法区还有一个别名：Non-Heap(非堆)； 栈又分为java虚拟机栈和本地方法栈，主要用于方法的执行。 图 1：JVM内存结构布局 一、运行时数据区域Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途，以及创建和销毁的时间。有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范(Java SE 7版)》的规定，Java虚拟机所管理的内存将会包含以下几个运行时数据区域：程序计数器、Java虚拟机栈，本地方法栈、Java堆和方法区，如图1所示。 程序计数器、Java虚拟机栈和本地方法栈是运行时数据区中线程私有的内存区域； Java堆和方法区是所有线程共享的内存区域。 图 2：Java虚拟机运行时数据区 1. 程序计数器程序计数器(Program Counter Register)是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里(仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现)，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器(对于多核处理器来说是一个内核)只会执行一个线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，各个线程之间的计数器互不影响，独立存储，我们称这类内存区域为”线程私有“的内存。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空(Undefined)。程序计数器是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 2. Java虚拟机栈与程序计数器一样，Java虚拟机栈(JVM Stacks)也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧(Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)。其中64位长度的long和double类型的数据会占用2个局部变量空间(Slot)，其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展(当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈)，当扩展到无法申请到足够的内存时就会抛出OutOfMemoryError异常。 3. 本地方法栈本地方法栈(Native Method Stacks)与虚拟机栈所发挥的作用是非常相似的，也是线程私有的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它，甚至有的虚拟机(譬如Sun HotSpot虚拟机)直接把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 4. Java堆对于大多数应用来说，Java堆(Heap)是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做”GC堆”。从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer，TLAB)。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存或者更快分配内存。 根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms控制)。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 5. 方法区方法区(Method Area)与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap(非堆)，目的应该是与Java堆区分开来。 对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为”永久代”(Permanent Generation)，本质上两者并不等价，因为仅仅是HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，省区专门为方法区编写内存管理的代码。对于其他虚拟机来说是不存在永久代概念的。 Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样”永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收”成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。 根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 例1 6. 运行时常量池运行时常量池(Runtime Constant Pool)是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量表，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池中存放。程序中的字面值如直接书写的100、”hello”和常量都是放在常量池中。 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 例1： String str = new String(&quot;hello&quot;); 上面的语句中变量str放在栈上，用new创建出来的String对象放在堆上，而”hello”这个字面量是放在方法区中的。 7. 直接内存直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。 在JDK 1.4中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 显然，直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是受主机总内存(包括RAM以及SWAP区或者分页文件)大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制)，从而导致动态扩展时出现OutOfMemoryError异常。 二、内存溢出异常三、相关问题问：堆和栈的区别Java的内存分为两类，一类是栈内存，一类是堆内存。 栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。栈内存由操作系统来分配，只要栈剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用new创建的对象都放在堆里，所以，它不会随方法的结束而消失。堆内存由程序员自己来申请分配。 例1： class A { private String a = &quot;aa&quot;; public boolean methodB() { String b = &quot;bb&quot;; final String c = &quot;cc&quot;; } } 上述Java代码中的变量a、b、c分别在内存的：堆区、栈区、栈区 问：运行时数据区域控制参数图 2：JVM内存结构布局 图2展示了如何通过参数来控制各区域的内存大小，其中各控制参数解释如下： Xms设置堆的最小空间大小。 Xmx设置堆的最大空间大小。 XX:NewSize设置新生代最小空间大小。 XX:MaxNewSize设置新生代最大空间大小。 XX:PermSize设置永久代最小空间大小。 XX:MaxPermSize设置永久代最大空间大小。 Xss设置每个线程的堆栈大小。 Xmn:设置堆的年轻代空间大小 XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值 没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。 老年代空间大小=堆空间大小-年轻代大空间大小 例1： 当-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3时，其最小内存值和Survivor区总大小分别是() -Xms初始堆大小即最小内存值，即最小内存值为10240m JVM一般根据对象的生存周期将堆内存分为若干不同的区域，一般情况将新生代分为Eden，两块Survivor； 由-XXSurvivorRatio=3可知Eden:Survivor=3，年轻带总大小为5120m，那么Survivor区总大小为2048m 问：内存泄漏内存泄露(Memory Leak)是指一个不再被使用的对象或者变量还在内存中占有存储空间。在C/C++语言中，内存泄露出现在开发人员忘记释放已分配的内存就会造成内存泄露。在java语言中引入垃圾回收机制，有GC负责进行回收不再使用的对象，释放内存。但是还是会存在内存泄露的问题。 检查Java中的内存泄露，一定要让程序将各种分支都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。 Java中内存泄露的情况： 长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致它不能被回收，这就是java中内存泄露的发生场景。通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，但是这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是java中可能出现内存泄露的情况。例如，在缓存系统中，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用。再例如hibernate的Session(一级缓存)中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭(close)或清空(flush)一级缓存就可能导致内存泄露。 (1) 在堆中申请的空间没有释放； (2) 对象已不再被使用(注意：这里的不再被使用是指对程序来说没有用处，如数据库连接使用后没有关，但是还是存在着引用)，但是仍然在内存中保留着。 GC机制的引入只能解决第一种情况，对于第2种情况无法保证不再使用的对象会被释放。Java语言中的内存泄露主要指第2种情况。 内存泄露的主要场景： (1) 静态集合类。如HashMap和Vector。这些容器是静态的，生命周期和程序的生命周期一致，那么在容器中对象的生命周期也和其一样，对象在程序结束之前将不能被释放，从而会造成内存泄露。 (2) 各种连接。如数据库连接，网络连接，IO连接，不再使用时如果连接不释放容易造成内存泄露。 (3) 监听器。释放对象时往往没有相应的删除监听器，可能会导致内存泄露。 例1：内存泄露举例 class Stack { private Object[] elements = new Object[10]; private int size = 0; public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if (size == 0) throw new EmptyStackException(); return elements[--size]; } private void ensureCapacity() { if (elements.length == size) { Object[] oldElements = elements; elements = new Object[2 * elements.length + 1]; System.arraycopy(oldElements, 0, elements, 0, size); } } } 这个类主要特点就是清空堆栈中的某个元素，并不是彻底把它从数组中拿掉，而是把存储的总数减少。 假如堆栈放了10个元素，然后全部弹出来，虽然堆栈是空的，没有我们要的东西，但是这是个对象是无法回收的，这种情况符合内存泄露的两个条件：无用且无法回收。 正确的做法：在弹出某个元素时，将那个元素所在的位置的值设置为null，让它从数组中消失。 例2：内存泄露举例 public class Test { public static Stack&lt;Object&gt; s= new Stack&lt;Object&gt;(); static{ s.push(new Object()); s.pop(); //这里有一个对象发生内存泄露 s.push(new Object()); //上面的对象可以被回收了，等于是自愈了 } } 因为s是static的，会一直存在直到程序退出，因此其中存储的对象在程序结束之前都不会被释放，存在内存泄漏。 但是我们也可以看到它有自愈功能，例如：如果你的Stack最多有100个对象，那么最多也就只有100个对象无法被回收，Stack内部持有100个引用，最坏的情况就是他们都是无用的。 但是如果我们一旦放新的对象进去，那么对之前对象的引用就会自然消失！ 例3：内存泄露举例 当一个对象被存储进HashSet集合中后，就不能再修改这个对象中的参与计算哈希值的那些字段了。 否则，修改后的对象的哈希值与最初存储进HashSet集合中时的哈希值就不同了。 在这种情况下，即使在contains()方法使用该对象的当前引用作为参数去HashSet集合中检索对象，也将返回找不到对象的结果， 这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露。 内存溢出（OOM）是指程序在申请内存时没有足够的内存供使用，进而导致程序崩溃。内存泄露（Memory Leak）最终会导致内存溢出。 例4：下面哪种情况会导致持久区jvm堆内存溢出？ A. 循环上万次的字符串处理 B. 在一段代码内申请上百M甚至上G的内存 C. 使用CGLib技术直接操作字节码运行，生成大量的动态类 D. 不断创建对象 答案：C 推荐阅读：动手探究Java内存泄露问题 问：OOM和SOFhttp://blog.csdn.net/shakespeare001/article/details/51274685","categories":[{"name":"Java高级","slug":"Java高级","permalink":"https://hepsilion.github.io/categories/Java高级/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java高级","slug":"Java高级","permalink":"https://hepsilion.github.io/categories/Java高级/"}]},{"title":"IT校招全国统一模拟笔试(秋招备战专场二模)编程题","slug":"IT校招全国统一模拟笔试-秋招备战专场二模-编程题","date":"2017-07-23T13:11:16.000Z","updated":"2017-10-21T13:19:21.444Z","comments":true,"path":"2017/07/23/IT校招全国统一模拟笔试-秋招备战专场二模-编程题/","link":"","permalink":"https://hepsilion.github.io/2017/07/23/IT校招全国统一模拟笔试-秋招备战专场二模-编程题/","excerpt":"","text":"随机的机器人有一条无限长的纸带,分割成一系列的格子,最开始所有格子初始是白色。现在在一个格子上放上一个萌萌的机器人(放上的这个格子也会被染红),机器人一旦走到某个格子上,就会把这个格子涂成红色。现在给出一个整数n,机器人现在会在纸带上走n步。每一步,机器人都会向左或者向右走一个格子,两种情况概率相等。机器人做出的所有随机选择都是独立的。现在需要计算出最后纸带上红色格子的期望值。 输入描述：输入包括一个整数n(0 ≤ n ≤ 500)，即机器人行走的步数。 输出描述：输出一个实数，表示红色格子的期望个数，保留一位小数。 示例1 输入: 4 输出: 3.4 import java.text.DecimalFormat; import java.util.*; public class Main{ public static void main(String[] args){ Scanner scanner=new Scanner(System.in); int n=scanner.nextInt(); double[][][] dp=new double[2][n+3][n+3]; dp[0][1][0]=1; for(int i=1; i&lt;=n; i++){ int cur=i%2, prev=1-cur; for(int j=1; j&lt;=i+1; j++){ for(int k=0; k&lt;j; k++){ dp[cur][j][k]=0; } } for(int j=1; j&lt;=i; j++){ for(int k=0; k&lt;j; k++){ //left if(k==0) dp[cur][j+1][k]+=dp[prev][j][k]/2; else dp[cur][j][k-1]+=dp[prev][j][k]/2; //right if(k==j-1) dp[cur][j+1][k+1]+=dp[prev][j][k]/2; else dp[cur][j][k+1]+=dp[prev][j][k]/2; } } } double ans=0; for(int j=1; j&lt;=n+1; j++){ for(int k=0; k&lt;j; k++){ ans+=j*dp[n%2][j][k]; } } DecimalFormat df=new DecimalFormat(&quot;0.0&quot;); System.out.println(df.format(ans)); } }","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://hepsilion.github.io/categories/动态规划/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://hepsilion.github.io/tags/算法/"}],"keywords":[{"name":"动态规划","slug":"动态规划","permalink":"https://hepsilion.github.io/categories/动态规划/"}]},{"title":"MapReduce","slug":"MapReduce","date":"2017-06-06T14:06:35.000Z","updated":"2017-10-21T13:19:21.460Z","comments":true,"path":"2017/06/06/MapReduce/","link":"","permalink":"https://hepsilion.github.io/2017/06/06/MapReduce/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Docker-Hadoop-Helloworld","slug":"Docker-Hadoop-Helloworld","date":"2017-05-28T14:48:12.000Z","updated":"2017-10-21T13:19:21.429Z","comments":true,"path":"2017/05/28/Docker-Hadoop-Helloworld/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/Docker-Hadoop-Helloworld/","excerpt":"使用Docker在本地搭建Hadoop分布式集群本文档参考http://tashan10.com/yong-dockerda-jian-hadoopwei-fen-bu-shi-ji-qun/。","text":"使用Docker在本地搭建Hadoop分布式集群本文档参考http://tashan10.com/yong-dockerda-jian-hadoopwei-fen-bu-shi-ji-qun/。 一、 Docker安装二、构建含有Java运行环境的ubuntu镜像1. 下载ubuntu镜像使用如下命令从Docker仓库中获取ubuntu的最新镜像。 SimontekiMacBook-Pro:~ liu$ docker pull ubuntu 镜像下载完成后，使用命令docker images可以查看本地所有镜像。 SimontekiMacBook-Pro:~ liu$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest f49eec89601e 4 weeks ago 129 MB SimontekiMacBook-Pro:~ liu$ 2. 启动容器下面，我们以ubuntu镜像作为基准镜像，构建包含Java运行环境的ubuntu镜像。 先使用如下命令启动一个容器： SimontekiMacBook-Pro:~ liu$ docker run -ti ubuntu root@52573ef1de5d:/# 可以看到容器几乎瞬间就启动起来了，比虚拟机不知快了多少倍！ 3. Java安装依次执行下面命令安装Java root@52573ef1de5d:/# apt-get update root@52573ef1de5d:/# apt-get install software-properties-common python-software-properties root@52573ef1de5d:/# add-apt-repository ppa:webupd8team/java root@52573ef1de5d:/# apt-get update root@52573ef1de5d:/# apt-get install oracle-java7-installer root@52573ef1de5d:/# java -version 注意：这里安装的Java7(JDK1.7)，如需其他版本请自行修改apt-get install oracle-java7-installer命令，例如命令apt-get install oracle-java6-installer将安装JDK1.6 4. 保存镜像复本现在可以将装好Java的容器保存为一个镜像副本，将来需要的时候可以在此复本基础上构建其他镜像。 先退出上面启动的容器，将上面的容器保存为镜像ubuntu:java，然后使用docker images命令，发现ubuntu:java已保存为本地镜像。 root@52573ef1de5d:/# exit exit SimontekiMacBook-Pro:~ liu$ docker commit -m &quot;java install&quot; 52573ef1de5d ubuntu:java sha256:21716d1532e71a207cd80bcea8579e646a73d6e688ec0984562c92cdbc6296f4 SimontekiMacBook-Pro:~ liu$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu java 21716d1532e7 About a minute ago 791 MB ubuntu latest f49eec89601e 4 weeks ago 129 MB SimontekiMacBook-Pro:~ liu$ 上面命令中52573ef1de5d为之前启动的容器的ID, ubuntu:java是为复本镜像的标识，ubuntu为仓库名，java是Tag。 如何获取容器ID： 在使用到容器的ID却不知道时，可以使用下面两个方法找到容器的ID： 启动容器后，命令行中用户名@后面的那一串字符时当前启动的容器的ID，因此上面启动的容器的ID为52573ef1de5d。这个方法只在容器启动并且没有指定hostname时才能用。 使用docker ps列出所有正在运行的容器，在命令结果中查看对应容器的ID。 三、 构建含有Hadoop运行环境的ubuntu镜像下面，我们以包含Java运行环境的ubuntu镜像作为基准镜像，构建包含Hadoop运行环境的ubuntu镜像。 1. 启动容器使用刚刚已经安装了Java的容器镜像启动一个容器： SimontekiMacBook-Pro:~ liu$ docker run -ti ubuntu:java root@aac699216bce:/# 装有Java的ubuntu容器启动成功了，现在我们开始安装Hadoop。 这里，我们直接使用wget下载安装文件。 2. 安装wget使用如下命令安装wget。 root@aac699216bce:/# apt-get install -y wget 3. 下载并解压安装Hadoop文件使用如下命令下载并解压安装Hadoop。 root@aac699216bce:/# cd ~ root@aac699216bce:~# mkdir software root@aac699216bce:~# cd software root@aac699216bce:~/software# mkdir apache root@aac699216bce:~/software# cd apache/ root@aac699216bce:~/software/apache# mkdir hadoop root@aac699216bce:~/software/apache# cd hadoop/ root@aac699216bce:~/software/apache/hadoop# wget http://mirrors.sonic.net/apache/hadoop/common/hadoop-2.6.0/hadoop-2.6.0.tar.gz root@aac699216bce:~/software/apache/hadoop# tar zxvf hadoop-2.6.0.tar.gz 注意：这里我们安装的Hadoop版本是2.6.0 4. 配置环境变量由于我们使用apt-get安装java，不知道java装在什么地方，使用如下命令查看Java安装目录 root@aac699216bce:~/software/apache/hadoop# update-alternatives --config java There is only one alternative in link group java (providing /usr/bin/java): /usr/lib/jvm/java-7-oracle/jre/bin/java Nothing to configure. root@aac699216bce:~/software/apache/hadoop# 修改~/.bashrc文件，在文件末尾加入下面配置信息： export JAVA_HOME=/usr/lib/jvm/java-7-oracle export HADOOP_HOME=/root/software/apache/hadoop/hadoop-2.6.0 export HADOOP_CONFIG_HOME=$HADOOP_HOME/etc/hadoop export PATH=$PATH:$HADOOP_HOME/bin export PATH=$PATH:$HADOOP_HOME/sbin 5. 配置Hadoop下面，我们开始修改Hadoop的配置文件：core-site.xml、hdfs-site.xml、mapred-site.xml和hadoop-env.sh。 (1) 创建目录开始配置之前，执行下面命令，创建三个目录 root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0# mkdir tmp root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0# cd tmp/ root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0/tmp# pwd /root/software/apache/hadoop/hadoop-2.6.0/tmp root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0/tmp# cd .. root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0# mkdir namenode root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0# cd namenode/ root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0/namenode# pwd /root/software/apache/hadoop/hadoop-2.6.0/namenode root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0/namenode# cd .. root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0# mkdir datanode root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0# cd datanode/ root@aac699216bce:~/software/apache/hadoop/hadoop-2.6.0/datanode# pwd /root/software/apache/hadoop/hadoop-2.6.0/datanode tmp：作为Hadoop的临时目录 namenode：作为NameNode的存放目录 datanode：作为DataNode的存放目录 (2) core-site.xml配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt; &lt;!--Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file. --&gt; &lt;!-- Put site-specific property overrides in this file. --&gt; &lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/root/soft/apache/hadoop/hadoop-2.6.0/tmp&lt;/value&gt; &lt;description&gt;A base for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://master:9000&lt;/value&gt; &lt;final&gt;true&lt;/final&gt; &lt;description&gt; The name of the default file system. A URI whose scheme and authority determine the FileSystem implementation. The uri&apos;s scheme determines the config property (fs.SCHEME.impl) naming the FileSystem implementation class. The uri&apos;s authority is used to determine the host, port, etc. for a filesystem. &lt;/description&gt; &lt;/property&gt; &lt;/configuration&gt; 注意： hadoop.tmp.dir配置项值即为此前命令中创建的tmp目录路径。 fs.default.name配置为hdfs://master:9000，指向的是Master节点的主机（后续做集群配置时，需要配置这个节点，先写在这里） (3) hdfs-site.xml配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt; &lt;!-- Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file. --&gt; &lt;!-- Put site-specific property overrides in this file. --&gt; &lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;2&lt;/value&gt; &lt;final&gt;true&lt;/final&gt; &lt;description&gt;Default block replication. The actual number of replications can be specified when the file is created. The default is used if replication is not specified in create time. &lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;/root/software/apache/hadoop/hadoop-2.6.0/namenode&lt;/value&gt; &lt;final&gt;true&lt;/final&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;/root/software/apache/hadoop/hadoop-2.6.0/datanode&lt;/value&gt; &lt;final&gt;true&lt;/final&gt; &lt;/property&gt; &lt;/configuration&gt; 注意： 我们后续搭建集群环境时，将配置一个master节点和两个slave节点，所以dfs.replication配置为2。 dfs.namenode.name.dir和dfs.datanode.data.dir分别配置为之前创建的NameNode和DataNode的目录路径。 (4) mapred-site.xml配置 创建mapred-site.xml文件 cp mapred-site.xml.template mapred-site.xml 配置mapref-site.xml文件 &lt;?xml version=&quot;1.0&quot;?&gt; &lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt; &lt;!-- Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file. --&gt; &lt;!-- Put site-specific property overrides in this file. --&gt; &lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapred.job.tracker&lt;/name&gt; &lt;value&gt;master:9001&lt;/value&gt; &lt;description&gt;The host and port that the MapReduce job tracker runs at. If &quot;local&quot;, then jobs are run in-process as a single map and reduce task. &lt;/description&gt; &lt;/property&gt; &lt;/configuration&gt; 这里只有一个配置项mapred.job.tracker，我们指向master节点机器。 (5) 修改hadoop-env.sh配置修改如下配置： # The java implementation to use. export JAVA_HOME=/usr/lib/jvm/java-7-oracle 6. 安装SSH搭建集群环境，自然少不了使用SSH，这可以实现无密码访问，访问集群机器的时候很方便。 root@aac699216bce:~# apt-get install ssh 7. 生成访问密钥root@aac699216bce:~# cd ~/ root@aac699216bce:~# ssh-keygen -t rsa -P &apos;&apos; -f ~/.ssh/id_dsa Generating public/private rsa key pair. Created directory &apos;/root/.ssh&apos;. Your identification has been saved in /root/.ssh/id_dsa. Your public key has been saved in /root/.ssh/id_dsa.pub. The key fingerprint is: SHA256:SO6qH6zwvNUKDqVWDYcexe7OQBJ3Jy5vd/mZlF6FiWM root@aac699216bce The key&apos;s randomart image is: +---[RSA 2048]----+ | .. | | . .o+ . | | o++.+ . o | | ..o== . E o . | | +o+.o S o o . | | o.o * . o o . | |+.. O + . + + | |.* + * = | | B++ | +----[SHA256]-----+ root@aac699216bce:~# cd .ssh root@aac699216bce:~/.ssh# cat id_dsa.pub &gt;&gt; authorized_keys 注意： 这里思路是直接将密钥生成后写入镜像，免得在每个容器里面再单独生成一次，还要相互拷贝公钥，比较麻烦。当然这只是学习使用，实际操作时，应该不会这么搞，因为这样所有容器的密钥都是一样的！！ 8. 保存镜像我们将安装好Hadoop的镜像保存为一个镜像副本ubuntu:hadoop，然后使用docker images命令，发现ubuntu:hadoop已保存为本地镜像。 root@aac699216bce:~# exit exit SimontekiMacBook-Pro:~ liu$ docker commit -m &quot;hadoop install&quot; aac699216bce ubuntu:hadoop sha256:b6c13157056ff28c5b8703991bd1c4ba993bc7a3fae17547bff82eedae571529 SimontekiMacBook-Pro:~ liu$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu hadoop b6c13157056f 18 seconds ago 1.35 GB ubuntu java 21716d1532e7 About an hour ago 791 MB ubuntu latest f49eec89601e 4 weeks ago 129 MB 四、 搭建Hadoop分布式集群按照hadoop集群的基本要求，集群中至少需要有3个结点，其中一个为master结点，主要是用于运行hadoop集群中的namenode、secondorynamenode和jobtracker(新版本名字变了)任务；另外两个结点均为slave结点，其中一个节点作为冗余节点。 1. 启动容器打开三个命令行，每个命令行各启动一个容器，其中一个容器作为master节点，另外两个容器作为slave节点。 ####(1)启动master容器 SimontekiMacBook-Pro:~ liu$ docker run -ti -d -p 50070:50070 -h master ubuntu:hadoop d13443e6f6e3575beee69e9cc51f0569067dc0b96fb24a756578aa610ce3310c 这里使用镜像创建容器时，将容器的50070端口映射为本地的50070端口，便于后面可以直接在本地浏览器访问集群的状态。 使用docker ps查看启动的master容器对应的ID，然后使用下面命令进入master容器。 SimontekiMacBook-Pro:~ liu$ docker attach d13443e6f6e3 root@master:/# (2)启动slave1容器SimontekiMacBook-Pro:~ liu$ docker run -ti -h slave1 ubuntu:hadoop Missing privilege separation directory: /var/run/sshd root@slave1:/# (3)启动slave2容器SimontekiMacBook-Pro:~ liu$ docker run -ti -h slave2 ubuntu:hadoop Missing privilege separation directory: /var/run/sshd root@slave2:/# 2. 配置hosts(1)查看各节点ip由于在不同的网络环境下，容器获取的ip可能不一样，例如本机三个容器获取的ip分别如下： master: 172.17.0.2 slave1: 172.17.0.3 slave2: 172.17.0.4 (2)修改各节点的hosts文件根据(1)中查看得到的各节点ip配置hosts文件 172.17.0.2 master 172.17.0.3 slave1 172.17.0.4 slave2 (3)配置slaves下面配置哪些节点是slave。 较老版本的Hadoop中有一个masters文件和一个slaves文件，但新版本中只有slaves文件了。 在master节点容器中执行如下命令打开slaves配置文件： root@master:~/software/apache/hadoop/hadoop-2.6.0/etc/hadoop# vim slaves 将所有slave节点的hostname写入该文件： slave1 slave2 3. 启动Hadoop(1)启动SSH服务在每个节点上之下下面命令，启动SSH服务，实现无密码访问。 master节点 root@master:~/software/apache/hadoop/hadoop-2.6.0/etc/hadoop# /etc/init.d/ssh start * Starting OpenBSD Secure Shell server sshd [ OK ] root@master:~/software/apache/hadoop/hadoop-2.6.0/etc/hadoop# slave1节点 root@slave1:~# /etc/init.d/ssh start * Starting OpenBSD Secure Shell server sshd [ OK ] root@slave1:~# slave2节点 root@slave2:~# /etc/init.d/ssh start * Starting OpenBSD Secure Shell server sshd [ OK ] root@slave2:~# (2)格式化 namenoderoot@master:~/software/apache/hadoop/hadoop-2.6.0/bin# ./hadoop namenode -format (3)启动hadoop在master节点上执行start-all.sh命令，启动Hadoop root@master:~/software/apache/hadoop/hadoop-2.6.0/sbin# ./start-all.sh This script is Deprecated. Instead use start-dfs.sh and start-yarn.sh Starting namenodes on [master] master: starting namenode, logging to /root/software/apache/hadoop/hadoop-2.6.0/logs/hadoop-root-namenode-master.out slave2: starting datanode, logging to /root/software/apache/hadoop/hadoop-2.6.0/logs/hadoop-root-datanode-slave2.out slave1: starting datanode, logging to /root/software/apache/hadoop/hadoop-2.6.0/logs/hadoop-root-datanode-slave1.out Starting secondary namenodes [0.0.0.0] 0.0.0.0: starting secondarynamenode, logging to /root/software/apache/hadoop/hadoop-2.6.0/logs/hadoop-root-secondarynamenode-master.out starting yarn daemons starting resourcemanager, logging to /root/software/apache/hadoop/hadoop-2.6.0/logs/yarn--resourcemanager-master.out slave1: starting nodemanager, logging to /root/software/apache/hadoop/hadoop-2.6.0/logs/yarn-root-nodemanager-slave1.out slave2: starting nodemanager, logging to /root/software/apache/hadoop/hadoop-2.6.0/logs/yarn-root-nodemanager-slave2.out root@master:~/software/apache/hadoop/hadoop-2.6.0/sbin# 如果看到如下信息，则说明启动成功了。 在个节点上执行jps命令，结果如下： master节点 root@master:~/software/apache/hadoop/hadoop-2.6.0/sbin# jps 2149 Jps 1887 ResourceManager 1560 NameNode 1736 SecondaryNameNode root@master:~/software/apache/hadoop/hadoop-2.6.0/sbin# slave1节点 root@slave1:~# jps 352 DataNode 454 NodeManager 569 Jps slave2节点 root@slave2:~# jps 252 DataNode 354 NodeManager 469 Jps 下面，我们在master节点上通过命令hdfs dfsadmin -report查看DataNode是否正常启动 root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# ./hdfs dfsadmin -report Configured Capacity: 134743154688 (125.49 GB) Present Capacity: 117625421824 (109.55 GB) DFS Remaining: 117625372672 (109.55 GB) DFS Used: 49152 (48 KB) DFS Used%: 0.00% Under replicated blocks: 0 Blocks with corrupt replicas: 0 Missing blocks: 0 ------------------------------------------------- Live datanodes (2): Name: 172.17.0.4:50010 (slave2) Hostname: slave2 Decommission Status : Normal Configured Capacity: 67371577344 (62.74 GB) DFS Used: 24576 (24 KB) Non DFS Used: 8558866432 (7.97 GB) DFS Remaining: 58812686336 (54.77 GB) DFS Used%: 0.00% DFS Remaining%: 87.30% Configured Cache Capacity: 0 (0 B) Cache Used: 0 (0 B) Cache Remaining: 0 (0 B) Cache Used%: 100.00% Cache Remaining%: 0.00% Xceivers: 1 Last contact: Wed Feb 22 12:58:22 UTC 2017 Name: 172.17.0.3:50010 (slave1) Hostname: slave1 Decommission Status : Normal Configured Capacity: 67371577344 (62.74 GB) DFS Used: 24576 (24 KB) Non DFS Used: 8558866432 (7.97 GB) DFS Remaining: 58812686336 (54.77 GB) DFS Used%: 0.00% DFS Remaining%: 87.30% Configured Cache Capacity: 0 (0 B) Cache Used: 0 (0 B) Cache Remaining: 0 (0 B) Cache Used%: 100.00% Cache Remaining%: 0.00% Xceivers: 1 Last contact: Wed Feb 22 12:58:22 UTC 2017 root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# 还可以通过Web页面http://127.0.0.1:50070/看到查看DataNode和NameNode的状态。 4. WordCount实例(1) 创建本地单词文件words.txtroot@master:~/software/apache/hadoop/hadoop-2.6.0/bin# touch words.txt root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# 在words.txt文件中写入单词。 （2）将单词文件words.txt上传到到hdfs上root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# ./hdfs dfs -ls / root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# ./hdfs dfs -put words.txt / root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# ./hdfs dfs -ls / Found 1 items -rw-r--r-- 2 root supergroup 1763 2017-02-22 14:42 /words.txt root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# (3) 执行wordcount程序root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# ./hadoop jar ../share/ hadoop/mapreduce/hadoop-mapreduce-examples-2.6.0.jar wordcount /words.txt /out (4) 查看结果root@master:~/software/apache/hadoop/hadoop-2.6.0/bin# ./hdfs dfs -text /out/part-r-00000","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://hepsilion.github.io/categories/环境配置/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hepsilion.github.io/tags/docker/"},{"name":"hadoop","slug":"hadoop","permalink":"https://hepsilion.github.io/tags/hadoop/"}],"keywords":[{"name":"环境配置","slug":"环境配置","permalink":"https://hepsilion.github.io/categories/环境配置/"}]},{"title":"C plus plus","slug":"C-plus-plus","date":"2017-05-28T11:03:50.000Z","updated":"2017-10-21T13:19:21.398Z","comments":true,"path":"2017/05/28/C-plus-plus/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/C-plus-plus/","excerpt":"C++","text":"C++ 一、概述二、基础语法整型一般我们把short称为短整型，把int称为整型，把long称为长整型，把long long称为超长整型。以unsigned开头的那些整数类型统称为无符号整型。例如：我们称unsigned short为无符号短整型，以此类推。 问：https://www.nowcoder.com/profile/7404313/test/8046125/55536?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8046125/23331?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8078490/15721?onlyWrong=0 问：求一个整数二进制表示中1的个数int fun(int x){ int countx = 0; while(x){ countx++; x = x &amp; (x – 1); } return countx; ｝ 问：forkhttps://www.nowcoder.com/profile/7404313/test/7993780/1023?onlyWrong=0 问：各种数据类型的大小(单位Bytes) 32位系统 64位系统 char 1 1 short 2 2 int 4 4 指针 4 8 long 4 8 float 4 4 double 8 8 long long 8 问：一道题目的分析(y^(x^y)&amp;-(x","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://hepsilion.github.io/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://hepsilion.github.io/tags/C/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://hepsilion.github.io/categories/C-C/"}]},{"title":"Probability Theory","slug":"Probability-Theory","date":"2017-05-28T11:02:06.000Z","updated":"2017-10-21T13:19:21.476Z","comments":true,"path":"2017/05/28/Probability-Theory/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/Probability-Theory/","excerpt":"概率论与数理统计","text":"概率论与数理统计 问：全概率和后验概率案例： https://www.nowcoder.com/profile/7404313/test/7971904/14885?onlyWrong=0","categories":[{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://hepsilion.github.io/categories/概率论与数理统计/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"https://hepsilion.github.io/tags/概率论/"},{"name":"数理统计","slug":"数理统计","permalink":"https://hepsilion.github.io/tags/数理统计/"}],"keywords":[{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://hepsilion.github.io/categories/概率论与数理统计/"}]},{"title":"信息安全总结","slug":"信息安全","date":"2017-05-28T11:01:20.000Z","updated":"2017-10-21T13:19:21.476Z","comments":true,"path":"2017/05/28/信息安全/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/信息安全/","excerpt":"信息安全","text":"信息安全 问：计算机病毒计算机病毒实质上是一种特殊的计算机程序，一般具有寄生性、破坏性、传染性、潜伏性和隐蔽性 问：加密算法是双向的，摘要算法是单向的摘要算法是单向的，即明文可以通过摘要算法生成摘要结果，但反之则不能通过摘要结果还原成明文，所以不可逆；加密算法是双向的，即可以从明文通过加密算法生成密文，反之也可以通过解密算法将密文还原成明文，所以可逆。 对称加密算法 DES 3DES AES：高级加密标准，是下一代的加密算法标准，速度快，安全级别高。 AES的区块长度固定为128比特，密钥长度则可以是128、192或256比特。 Blowfish：BlowFish算法用来加密64Bit长度的字符串，它使用两个盒，一个是unsigned long pbox[18]，一个是unsigned long sbox[4*256]。 Twofish IDEA RC6 CAST5 Serpent 攻击DES最有效方法是密钥穷举攻击，因为它使用56位密钥过短，已经被高级加密标准如AES所替代 非对称加密算法 DHA(差异哈希算法) RSA：TLS/SSL协议中RSA的公钥长度一般为1024或2048位，它的安全性依赖于大数分解。 EIGamal DSA：数字签名算法，是一种标准的DSS(数字签名标准)。 ECC 信息摘要算法 MD5 SHA1 SHA512 CRC-32 问：RSAhttps://www.nowcoder.com/profile/7404313/test/8122789/46253?onlyWrong=0 问：MD5摘要算法，不是加密算法MD5即Message-Digest Algorithm 5(信息-摘要算法5)，用于确保信息传输完整一致，是计算机广泛使用的杂凑算法之一(又译摘要算法、哈希算法)，主流编程语言普遍已有MD5实现。将数据(如汉字)运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。 MD5算法具有以下特点： 压缩性：任意长度的数据，算出的MD5值长度都是固定的。 容易计算：从原数据计算出MD5值很容易。 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。 弱抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据(即伪造数据)是非常困难的。 强抗碰撞：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。 MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式(就是把一个任意长度的字节串变换成一定长的十六进制数字串)。除了MD5以外，其中比较有名的还有SHA-1、RIPEMD以及Haval等。 注意：由于MD5是单向不可逆的，所以不可以解密，不能用来对文本进行加密，只能用来签名，校验数据的完整性 问：HttpsHTTP协议通常承载于TCP协议之上，有时也承载于TLS(安全传输层协议)或SSL(安全套接层协议Secure Sockets Layer)协议层之上，这个时候，就成了我们常说的HTTPS。 问：常见的攻击方法 Vulnerability scan，缺陷/弱点扫描 SQL Injection，SQL注入攻击 Drive-by downloading Brute force，暴力破解 问：实现防火墙的主流技术(1) 包过滤技术 包过滤是最早使用的一种防火墙技术，包过滤技术工作的地方就是各种基于TCP/IP协议的数据报文进出的通道，它把这两层作为数据监控的对象，对每个数据包的头部、协议、地址、端口、类型等信息进行分析，并与预先设定好的防火墙过滤规则(Filtering Rule)进行核对，一旦发现某个包的某个或多个部分与过滤规则匹配并且条件为”阻止”的时候，这个包就会被丢弃。 (2) 应用代理技术 由于包过滤技术无法提供完善的数据保护措施，而且一些特殊的报文攻击仅仅使用过滤的方法并不能消除危害(如SYN攻击、ICMP洪水等)，因此人们需要一种更全面的防火墙保护技术，在这样的需求背景下，采用”应用代理”(Application Proxy)技术的防火墙诞生了。一个完整的代理设备包含一个服务端和客户端，服务端接收来自用户的请求，调用自身的客户端模拟一个基于用户请求的连接到目标服务器，再把目标服务器返回的数据转发给用户，完成一次代理工作过程。应用级网关和代理服务器技术都是是应用代理技术实现防火墙。 (3) 状态检测技术 这种防火墙技术通过一种被称为”状态监视”的模块，在不影响网络安全正常工作的前提下采用抽取相关数据的方法对网络通信的各个层次实行监测，并根据各种过滤规则作出安全决策。 问：能加强家用路由器的网络安全的措施 将wifi加密方式从wep改为wpa2 关闭wan管理端口 关闭upnp 配置MAC地址绑定 升级路由器固件 问：交换机攻击交换机攻击主要有以下5种类型： vlan跳跃攻击 生成树攻击 mac表洪水攻击 arp攻击 vtp攻击 问：DNS欺骗的方式hosts文件篡改， 本机DNS服务器IP地址篡改，DNS通讯包篡改 https://www.nowcoder.com/profile/7404313/test/8122845/15110?onlyWrong=0","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"信息安全","slug":"信息安全","permalink":"https://hepsilion.github.io/tags/信息安全/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"软件测试总结","slug":"软件测试","date":"2017-05-28T11:00:19.000Z","updated":"2017-10-21T13:19:21.648Z","comments":true,"path":"2017/05/28/软件测试/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/软件测试/","excerpt":"软件测试","text":"软件测试 软件测试软件测试的对象包括源程序、目标程序、数据及相关文档 单元测试(Unit Testing)单元测试(unit testing)，是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如C语言中单元指一个函数，Java里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。 单元测试能发现约80%的软件缺陷。 测试用例测试用例(Test Case)是为测试设计的数据，由测试输入数据和与之对应的预期输出结果两部分组成 https://www.nowcoder.com/profile/7404313/test/8133610/55464?onlyWrong=0 瀑布模型中的软件测试按照瀑布模型的阶段划分，软件测试可以分为单元测试，集成测试，系统测试。 系统测试：压力测试，功能测试，安全测试，性能测试 集成测试：接口测试 内测和公测内侧是开发人员与用户、测试人员一起进行的，而公测是仅有用户参与的 黑盒测试黑盒测试是对软件已经实现的功能是否满足需求进行测试和验证，黑盒测试完全不考虑程序内部的逻辑结构和内部特性，只根据程序的需求和功能规格说明，检查程序的功能是否符合它的功能说明 白盒测试https://www.nowcoder.com/profile/7404313/test/8133610/55176?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133610/26144?onlyWrong=0 软件测试的步骤单元测试、集成测试、确认测试和系统测试 https://www.nowcoder.com/profile/7404313/test/8133610/3137?onlyWrong=0 alpha测试与beta测试的区别https://www.nowcoder.com/profile/7404313/test/8133610/14374?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133610/4480?onlyWrong=0 软件验收测试的合格通过准则https://www.nowcoder.com/profile/7404313/test/8133610/56351?onlyWrong=0 负载测试，容量测试和强度测试https://www.nowcoder.com/profile/7404313/test/8133610/14375?onlyWrong=0 ###集成测试的过程 https://www.nowcoder.com/profile/7404313/test/8133610/14368?onlyWrong=0 测试设计员的职责测试设计人员主要负责设计测试用例以及设计测试过程。 测试工具https://www.nowcoder.com/profile/7404313/test/8133610/14488?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133610/14491?onlyWrong=0","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://hepsilion.github.io/tags/软件工程/"},{"name":"软件测试","slug":"软件测试","permalink":"https://hepsilion.github.io/tags/软件测试/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"Concurrency","slug":"Concurrency","date":"2017-05-28T10:59:30.000Z","updated":"2017-10-21T13:19:21.429Z","comments":true,"path":"2017/05/28/Concurrency/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/Concurrency/","excerpt":"并发","text":"并发 问：并发与并行两个线程并发执行以下代码，假设a是全局变量，初始为1，那么执行完下列语句后的输出可能为：3 2，2 3，3 3和2 2 void foo(){ ++a; printf(&quot;%d &quot;,a); } 解释还不是特别清楚 https://www.nowcoder.com/profile/7404313/test/8115789/3939?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8120272/3356 https://www.nowcoder.com/profile/7404313/test/8120272/4607?onlyWrong=0 问：进程同步为禁止两个进程同时进入临界区，同步机制应该遵循一下基本准则： 空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。 忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待。 有限等待：对要求访问临界资源的进程，应保证能在有限的时间内进入临界区。 让权等待：当进程不能进入自己的临界区时，应立即释放处理机，防止进程忙等待。 问：死锁死锁产生的原因 系统资源的竞争，资源出现循环等待 https://www.nowcoder.com/profile/7404313/test/8067759/14356?onlyWrong=0 死锁产生的必要条件 互斥条件：一个资源在一段时间内仅为一个进程所占有，此时若有其他进程请求该资源，则请求进程只能等待。 不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放。 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不妨。 循环等待条件：存在一种资源的进程循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。即存在一个处于等待状态的进程集合{P1, P2, …, Pn}，其中Pi等待的资源被P(i+1)占有，Pn等待的资源被P0占有。 死锁的处理策略 (1) 死锁预防：破坏产生死锁的四个必要条件中的一个或几个，防止发生死锁。 (2) 死锁避免：死锁避免同样属于事先预防的策略，但并不是事先采取某种限制措施破坏死锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。 银行家算法是最著名的死锁避免算法。 (3) 死锁检测 问：共享内存共享内存是进程间通信的一种方式。尽管每个进程都有自己的内存地址，但是不同的进程可以同时将同一个内存页面映射到自己的地址空间中，所有进程都可以访问共享内存中的地址，从而达到共享内存的目的。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。共享内存并未提供同步机制，也就是说，在第一个进程结束对共享内存的写操作之前，并无自动机制可以阻止第二个进程开始对它进行读取。所以我们通常需要使用像信号量这样的同步机制来限制对共享内存的访问。 其他问：无锁化编程https://www.nowcoder.com/profile/7404313/test/8120272/4043?onlyWrong=0","categories":[{"name":"并发","slug":"并发","permalink":"https://hepsilion.github.io/categories/并发/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://hepsilion.github.io/tags/并发/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"https://hepsilion.github.io/categories/并发/"}]},{"title":"Design Pattern","slug":"Design-Pattern","date":"2017-05-28T10:58:37.000Z","updated":"2017-10-21T13:19:21.429Z","comments":true,"path":"2017/05/28/Design-Pattern/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/Design-Pattern/","excerpt":"设计模式","text":"设计模式 问：设计模式分类设计模式主要分三个类型：创建型、结构型和行为型。 创建型模式：社会化的分工越来越细，自然在软件设计方面也是如此，因此对象的创建和对象的使用分开也就成为了必然趋势。因为对象的创建会消耗掉系统的很多资源，所以单独对对象的创建进行研究，从而能够高效地创建对象就是创建型模式要探讨的问题。这里有6个具体的创建型模式可供研究，它们分别是：抽象工厂模式、工厂方法模式、建造者模式、原型模式、单例模式。 (0) 简单工厂模式 https://www.nowcoder.com/profile/7404313/test/8133214/25215?onlyWrong=0 (1) 抽象工厂模式(Abstract Factory)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。 (2) 工厂方法模式(Factory Method)：定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类。 (3) 建造模式(Builder)：将一个复杂对象的构建与他的表示相分离，使得同样的构建过程可以创建不同的表示。 (4) 原型模式(Prototype)：用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象。 (5) 单例模式(Singleton)：保证一个类只有一个实例，并提供一个访问它的全局访问点 结构型模式：在解决了对象的创建问题之后，对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点，因为如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等。对象结构的设计很容易体现出设计人员水平的高低，这里有7个具体的结构型模式可供研究，它们分别是：外观模式、适配器模式、代理模式、装饰器模式、桥接模式、组合模式、享元模式。 (6) 外观模式(Facade)：为子系统中的一组接口提供一致的界面，fa?ade提供了一高层接口，这个接口使得子系统更容易使用。 (7) 适配器模式(Adapter)：将一类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作那些类可以一起工作。 (8) 代理模式(Proxy)：为其他对象提供一种代理以控制对这个对象的访问 (9) 装饰器模式(Decorator)：动态地给一个对象增加一些额外的职责，就增加的功能来说，Decorator模式相比生成子类更加灵活。 (10) 桥接模式(Bridge)：将抽象部分与它的实现部分相分离，使他们可以独立的变化。 (11) 组合模式(Composite)：将对象组合成树形结构以表示部分整体的关系，Composite使得用户对单个对象和组合对象的使用具有一致性。 (12) 享元模式(Flyweight) 行为型模式：在对象的结构和对象的创建问题都解决了之后，就剩下对象的行为问题了，如果对象的行为设计的好，那么对象的行为就会更清晰，它们之间的协作效率就会提高，这里有11个具体的行为型模式可供研究，它们分别是：模板方法模式、观察者模式、状态模式、策略模式、责任链模式、命令模式、访问者模式、中介者模式、备忘录模式、迭代器模式、解释器模式。 (13) 模板方法模式(Template Method)：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可以重定义该算法得某些特定步骤。 (14) 观察者模式(Observer)：定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新。 (15) 状态模式(State)：允许对象在其内部状态改变时改变他的行为。对象看起来似乎改变了他的类。 (16) 策略模式(Strategy)：定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们的客户。 (17) 责任链模式(Chain of Responsibility)：使多个对象都有机会处理请求，从而避免请求的送发者和接收者之间的耦合关系 (18) 命令模式(Command)：将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。 (19) 访问者模式(Visitor)：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作。 (20) 中介者模式(Mediator)：用一个中介对象封装一些列的对象交互。 (21) 备忘录模式(Memento)：在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 (22) 迭代器模式(Iterator)：提供一个方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示。 (23) 解释器模式(Interpreter)：给定一个语言，定义他的文法的一个表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 工厂方法模式https://www.nowcoder.com/profile/7404313/test/8133214/1466?onlyWrong=0 装饰器模式https://www.nowcoder.com/profile/7404313/test/8130955/50973?onlyWrong=0 策略模式https://www.nowcoder.com/profile/7404313/test/8133296/3006?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8114731/1063?onlyWrong=0 观察者模式https://www.nowcoder.com/profile/7404313/test/8114731/4716?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8129910/15064?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8129910/25593?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8129910/25465?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8130955/3006?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/55299?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/1063?onlyWrong=0","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://hepsilion.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://hepsilion.github.io/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"https://hepsilion.github.io/categories/设计模式/"}]},{"title":"软件工程总结","slug":"软件工程","date":"2017-05-28T10:57:43.000Z","updated":"2017-10-21T13:19:21.633Z","comments":true,"path":"2017/05/28/软件工程/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/软件工程/","excerpt":"软件工程","text":"软件工程 本文档总结软件工程的一些知识，侧重于了解。 问：计算机软件计算机软件指的是计算机系统中与硬件相互依赖的另一部分，包括程序、数据和有关的文档。 问：软件危机的主要原因缺乏好的开发方法和手段；软件本身特点；开发效率低。 软件生命周期软件生命周期分为3个阶段：软件定义阶段、软件开发阶段 (1) 软件定义阶段，任务是确定软件开发工作必须完成的目标，确定工程的可行性； (2) 软件开发阶段，任务是具体完成设计和实现定义阶段所定义的软件，通常包括总体设计、详细设计、编码和测试； (3) 软件维护阶段，任务是使软件在运行中持久地满足用户的需要。 https://www.nowcoder.com/profile/7404313/test/8130955/3131?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8130955/55220?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8130955/57997?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/58141?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/57880?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/57923?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/58000?onlyWrong=0 结构化方法软件需求分析工具结构化分析的常用工具有数据流图、数据字典、判定树和判定表 https://www.nowcoder.com/profile/7404313/test/8133296/3129?onlyWrong=0 问：软件设计的主要任务https://www.nowcoder.com/profile/7404313/test/8133296/3133 软件设计，包括软件的结构设计、数据设计、接口设计和过程设计。 结构设计 ：定义软件系统各主要部件之间的关系； 数据设计 ：将模型转换成数据结构的定义； 接口设计 ：软件内部，软件和操作系统间及软件和人之间如何通信； 过程设计 ：系统结构部件转换成软件的过程描述。 面向过程的系统采用的集成策略对面向过程的系统采用的集成策略有自顶向下(也就是先整体再局部)和自底向上(也就是先局部再整体)两种 问：软件工程的三要素方法(开发方法)、工具(支持方法的工具)、过程(管理过程)。 问：软件需求分析阶段的主要工作需求分析是软件生命周期的一个重要阶段，它的基本任务是准确地回答”系统必须做什么”这个问题，它的主要工作分为4个方面，分别为需求获取、需求分析、编写需求规格说明书及需求评审。 需求获取是通过和用户的接触初步确定系统的功能； 需求分析的任务是确定系统必须完成哪些工作，也就是对目标系统提出完整、准确、清晰、具体的要求； 在需求分析阶段结束以前，系统分析员应该写出需求规格说明书； 需求评审是根据需求规格说明书来严格审查和验证需求分析的结果。 问：软件需求规格说明软件需求规格说明应重点描述软件的目标，包括软件的功能需求、性能需求、外部接口、属性及约束条件等。 功能需求是软件需求规格说明，给出软件要执行什么功能的详尽描述。 性能需求是指定量的描述软件系统应满足的具体性能需求，即各种软件功能的速度、响应时间、恢复时间。 外部接口指软件如何与人、系统的硬件及其他硬件和其他软件进行交互。 属性是指与软件有关的质量属性，如正确性、可用性、可靠性、安全性、可维护性等。 约束条件包括影响软件实现的各种设计约束，如使用的标准、编程语言、数据库完整性方针、资源限制、运行环境等方面的要求。 https://www.nowcoder.com/profile/7404313/test/8129910/58186?onlyWrong=0 问：软件需求规格说明书的作用软件需求规格说明书的编制是为了使用户和软件开发者双方对该软件的初始规定有一个共同的理解，使之成为整个开发工作的基础。软件需求规格说明书包含硬件、功能、性能、输入输出、接口界面、警示信息、保密安全、数据与数据库、文档和法规的要求。 软件规格说明书是开发软件的方向，程序员要根椐需求规格说明书去开发软件，作用在于便于用户、开发人员进行理解和交流，反映出用户问题的结构，可以作为软件开发工作的基础和依据，并作为确认测试和验收的依据。但不包括软件设计的依据。 https://www.nowcoder.com/profile/7404313/test/8114731/3132 https://www.nowcoder.com/profile/7404313/test/8133214/3132?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133296/58071?onlyWrong=0 软件设计软件设计是软件工程的重要阶段，是一个把软件需求转换为软件表示的过程。软件设计的基本目标是用比较抽象概括的方式确定目标系统如何完成预定的任务，即解决软件“怎么做”的问题。 面向数据流的设计方法在面向数据流的设计方法中，一般把数据流图中的数据划分变换流和事务流。 (1) 交换流：信息沿输入通路进入系统，同时由外部形式变换为内部形式，进入系统的信息通过变换中心，经加工处理以后再沿输出通路变换成外部形式离开软件系统。 (2) 事务流：沿传入路径进入系统，由外部形式变换为内部形式后到达事务中心，事务中心根据数据项计值结果从若干动作路径中选定一条执行。有这样形状的成为事务流。 关联、聚合和组合https://www.nowcoder.com/profile/7404313/test/8130955/15073?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8130955/15866?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/55300?onlyWrong=0 问：软件开发模型https://www.nowcoder.com/profile/7404313/test/8114731/56412?onlyWrong=0 快速原型法https://www.nowcoder.com/profile/7404313/test/8129910/4441#summary https://www.nowcoder.com/profile/7404313/test/8133214/4441?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/2232?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133296/4436?onlyWrong=0 问：瀑布模型瀑布模型，提供一种结构化的、自顶向下的软件开发方法，是所有软件生命周期模型的基础。 https://www.nowcoder.com/profile/7404313/test/8129910/4443?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8130955/4442?onlyWrong=0 问：演化模型演化模型，针对实现不能完整定义需求的软件项目，利用迭代的思想，使软件逐步开发、逐步完善的机制，产品需求分解成多组，分批循环开发。 问：螺旋模型螺旋模型，遵从瀑布模型，迭代和风险驱动的开发过程，将瀑布模型的多个阶段转化到多个迭代过程中，适合大型系统的开发。过程：需求、架构、设计、开发、测试。 https://www.nowcoder.com/profile/7404313/test/8130955/4444?onlyWrong=0 螺旋模型是一种演化软件开发过程模型，它兼顾了快速原型的迭代特征以及瀑布模型的系统化与严格监控。螺旋模型最大的特点在于引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。同时，在每个迭代阶段构建原型是螺旋模型用以减小风险的途径。螺旋模型更适合大型的昂贵的系统级的软件应用。 问：喷泉模型喷泉模型，主要用于面向对象软件技术开发项目，特点是各项活动之间没有明显界限。过程为：分析、设计、实现、确认、维护和演化。 问：软件设计中模块划分应遵循的准则 高内聚低偶合：指功能集中模块化，低耦合只模块之间相互影响尽量小，改动一个模块不影响另一个模块或者尽可能减少影响 模块大小规模适当 模块的依赖关系适当等 https://www.nowcoder.com/profile/7404313/test/8129910/57922?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8130955/22264?onlyWrong=0 E-R模型向关系模型的转换的规则https://www.nowcoder.com/profile/7404313/test/8133214/4462?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8133214/57907?onlyWrong=0 代码评审代码评审也称代码复查，是指通过阅读代码来检查源代码与编码标准的符合性以及代码质量的活动。 问：结构化程序设计的原则自顶向下、逐步求精、模块化、限制使用goto语句 维护性的特性https://www.nowcoder.com/profile/7404313/test/8129910/2231?onlyWrong=0 软件实施活动的进入准则需求工件已经被基线化，详细设计工件已经被基线化，构架工件已经被基线化 问：在数据流图中，用标有名字的箭头表示数据流。在程序流程图中，用标有名字的箭头表示控制流。 问：模型驱动开发技术过程建模 数据建模 对象建模。 工厂模式是比较常用的设计模式，它遵循了设计原则中的开放-封闭原则。https://www.nowcoder.com/profile/7404313/test/8129910/55299 其他系统软件中主要包括操作系统，语言处理程序和实用程序。 层次模型、网状模型和关系模型不知道考什么 https://www.nowcoder.com/profile/7404313/test/8129910/2277?onlyWrong=0 B/S架构软件与C/S架构软件的区别C/S又称Client/Server或客户/服务器模式。服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix或 SQL Server。客户端需要安装专用的客户端软件。 B/S是Brower/Server的缩写，客户机上只要安装一个浏览器（Browser），如Netscape Navigator或Internet Explorer，服务器安装Oracle、Sybase、Informix或 SQL Server等数据库。浏览器通过Web Server 同数据库进行数据交互。 https://www.nowcoder.com/profile/7404313/test/8129910/15285?onlyWrong=0 面向对象的五大原则https://www.nowcoder.com/profile/7404313/test/8066549/14362?onlyWrong=0 MVChttps://www.nowcoder.com/profile/7404313/test/8130955/45212?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8130955/1331?onlyWrong=0 名词辨析：CAD、CAI、CAM、CASE CAD(Computer Aided Design)：计算机辅助设计，指利用计算机及其图形设备帮助设计人员进行设计工作。 CAI(Computer Aided Instruction)：计算机辅助教学，是在计算机辅助下进行的各种教学活动，以对话方式与学生讨论教学内容、安排教学进程、进行教学训练的方法与技术。 CAM(Computer Aided Manufacturing)：计算机辅助制造 ，是将计算机应用于制造生产过程的过程或系统。 CASE(Computer Aided Software Engineering):计算机辅助软件工程，用来辅助软件开发、运行、维护、管理、支持等过程中的活动的软件称为软件开发工具。 在面向对象方法中，对象有如下一些基本特点：标识唯一性、分类性、多态性、封装性、模块独立性好。DAO模式DAO的本质是提供数据访问接口 https://www.nowcoder.com/profile/7404313/test/8129910/15008?onlyWrong=0 值对象模式https://www.nowcoder.com/profile/7404313/test/8133214/15007?onlyWrong=0 可维护性https://www.nowcoder.com/profile/7404313/test/8130955/2231?onlyWrong=0 游戏软件和通用软件https://www.nowcoder.com/profile/7404313/test/8130955/14553?onlyWrong=0 模型驱动开发技术过程建模、数据建模、对象建模。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://hepsilion.github.io/tags/软件工程/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"Linux总结","slug":"Linux","date":"2017-05-28T10:56:37.000Z","updated":"2017-10-21T13:19:21.444Z","comments":true,"path":"2017/05/28/Linux/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/Linux/","excerpt":"Linux","text":"Linux 一、 进程管理问：Linux进程间的通信方式Linux进程间通信方式有：消息队列，命名管道，信号量，共享内存，套接字等，临界区不能用于Linux中的进程间通信。 https://www.nowcoder.com/profile/7404313/test/8067759/1034?onlyWrong=0 问：终止一个前台进程可能用到的命令和操作终止一个前台进程用Ctrl+C； 暂停一个前台进程用Ctrl+Z； 终止一个后台进程： 使用kill命令； 或使用fg命令将后台进程变为前台进程，然后Ctrl+C。 问：ps问：jobs显示系统进程 二、 存储管理问：freefree是系统自带的、常用的监控工具，用于显示已使用物理内存和交换空间，相对于top命令，free可以更简洁的查看内存的使用情况。 三、 文件管理 Linux中，在所有目录下都会有存在两个目录：”.”和”..”，分别代表此层和上层目录的意思。 目录与文件相关操作 1. cdcd是Change Directory的缩写，这是用来变换工作目录的指令。 语法是：cd [目标目录]，如：cd /home cd指令可让用户在不同的目录间切换，但该用户必须拥有足够权限进入目标目录。 2. pwdpwd是Print Working Directory的缩写，是显示当前所在目录的指令。 3. mkdir(建立新目录)在默认情况下，你所需要的目录要一层一层建立才行。例如:假如你要建立一个目录为:/home/bird/testing/test，那么首先必须要有/home，然后要有/home/bird，再有/home/bird/testing，最后才可以建立/home/bird/testing/test这个目录。 不过，加上-p这个选项就可以直接完成功能:mkdir -p /home/bird/testing/test。使用上述命令，系统会自动帮你将各个目录依次建立起来。 4. rmdir如果要将刚刚建立的test删掉，使用:rmdir test。但是目录需要一层一层删除，而且被删除的目录里面必定不能存在其他的目录或文件，也就是说只能删除空目录。 如果需要删除非空目录，可以使用:rm -r test 5. ls(文件与目录的查看)ls最常用的选项是”-l”。 6. cp要复制文件或目录，可以使用cp。如将当前目录下的aaa文件复制到/tmp下，并更名为bbb:cp ./aaa /tmp/bbb 复制目录时需要使用”-r”选项，如复制/etc/这个目录下的所有内容到/tmp下：cp -r /etc/ /tmp 7. rm执行rm指令可删除文件或目录，如欲删除目录必须加上参数”-r”，否则默认仅会删除文件。 8. mvmv命令移动或更名现有的文件或目录。 如何更改一个目录的名称，例如由/home/test变为/tome/test2？ 命令如下:mv /home/test /home/test2 例1: Linux的非root用户，在自己的目录中，解决不可以删除非空目录dirs的方法是() A. rm dir dirs B. rm -r dins C. my dirs /dev/null D. destroy dirs 解答:B。C需要root权限，且只能对文件进行操作，而不能对目录进行操作。 文本文件内容查看 如果我们要查阅一个文件内容时，该如何是好呢？这里有相当多命令可以使用，最常使用的显示文件内容的命令可以说是cat, more及less了。 1. cat由第一行开始查看文件。cat是Concatenate(连续)的简写，主要的功能是将一个文件的内容连续输出在屏幕上。如显示当前目录下的aaa的内容:cat ./aaa 2. tac从最后一行开始显示，可以看出。cat与tac是倒置的。cat是由第一行到最后一行连续显示在屏幕上，而tac则是由最后一行到第一行反向在屏幕上显示出来。 3. nl显示文件内容的时候，一起显示文件行号。 4. more一页一页显示文件内容。前面提到的n1, cat, tac等，都是一次性将数据显示到屏幕上面，若是文件行数很多，前面的内容就会看不到，这时就需要使用more与less来一页一页查看文件内容。命令如下:more ./aaa 5. lessless与more类似，但是比more更好的是，它可以向前翻页。命令如下:less ./aaa 6. headhead命令查看文本文件时，只显示头几行。用法如下:head -n number 文件名 上述用法表示只显示文件的前number行。另外一n选项后而的参数如果接的是负数，代表列出前而的所有行数，但不包括后面number行。举例来说，/etc/man.config共有141行，则下述的指令:head -n -100 /etc/man.config就会列出前面41行，后面100行不会打印出来了。 7. tailtail命令查看文本文件时，只显示尾几行。tail的用法跟head很相似：tail -n number 文件名 当number前面有”+”号时，与head -n -xx有异曲同工之妙。如:tail -n +100 /etc/man.config代表该文件从100行以后都会被列出来，同样，在man.config共有141行，因此第100-141行就会被列出来，前面的99行都不会被显示出来。 8. touchtouch这个指令最常被使用的情况是建立一个空的文件。 若aaa不存在，则:touch aaa，将会新建一个名为”aaa”的文件。 9. grepgrep是分析一行信息，若当中有我们所需要的信息，就将该行显示出来。 grep常用在管道中。例如将文件aaa中包含”root”的行的内容显示出来的命令如cat aaa grep &quot;root&quot;或grep &quot;root&quot; aaa 当使用”grep -E”表示后面跟着的内容是延伸型正则表达式，等价于”egrep”。 例1: 在Linux系统中，为找到文件try_grep中含有以a字母为行开头的内容，可以使用()命令。 A. grep -E #$ try_grep B. grep -E #a try_grep C. grep -E ^$ try_grep D. grep -E ^a try_grep 答案：D。 ^M表示以M开头的行，^表示开始的意思；M$表示以M结尾的行，$表示结束的意思。 查看系统信息 1. df列出文件系统的整体磁盘使用量。 2. ps将某个时间点的程序运行情况显示出来。 3. top(动态观察程序的变化)top可以持续侦测程序运作的状态。 问：Linux文件目录/bin 二进制执行文件，也就是命令文件 /etc 下存放的是配置文件 /dev 存放是时外部设备文件，硬盘，usb等 /lib 存放的是库文件 问：常用文件介绍 /etc/resolv.conf DNS解析的设置文件 /etc/dhcpd.conf DHCP的设置文件 /etc/gateways 网络路由的设置文件(建立动态路由需要用到) /etc/mail.rc 邮件服务的设置文件 /etc/hosts hosts文件是Linux系统上一个负责ip地址与域名快速解析的文件，以ascii格式保存在/etc/目录下。hosts文件包含了ip地址与主机名之间的映射，还包括主机的别名。在没有域名解析服务器的情况下，系统上的所有网络程序都通过查询该文件来解析对应于某个主机名的ip地址，否则就需要使用dns服务程序来解决。通过可以将常用的域名和ip地址映射加入到hosts文件中，实现快速方便的访问。 /etc/hostname 主机名设置文件 /etc/fstab 系统分区的配置文件，开机后系统会自动挂载文件中指定的设备 https://www.nowcoder.com/profile/7404313/test/8343455/22114?onlyWrong=0 /proc/interrupts 显示使用的中断 /proc/ioports 当前使用的I/O端口 /proc/kcore 系统物理内存映像。与物理内存大小完全一样，但不实际占用这么多的内存。 /proc/kmsg 内核输出的消息，也被送到syslog https://www.nowcoder.com/profile/7404313/test/8148327/26137?onlyWrong=0 问：文件复制(1) cp命令：cp命令用于复制文件或目录。 将文件file1复制成文件file2命令如下：cp file1 file2 (2) cat命令 ：cat命令是linux下的一个文本输出命令，通常是用于观看某个文件的内容的。 一次显示整个文件命令如下： cat filename : linux中的数据流重导向：输出导向，覆盖导向的文件内容。 &lt; : linux中的数据流重导向：输入导向，理解为原本由键盘输入改为文本输入 (3) dd命令 : 作用是用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。 参数：if 输入文件(或设备名称) of 输出文件(或设备名称) 将文件file1拷贝到文件file2中命令如下： dd if=file1 of=file2 (4) | ：管道命令操作符，处理经由前面一个指令传出的正确输出信息，然后，传递给下一个命令，作为标准的输入 例1： 将文件file1复制为file2可以使用的命令： cp file1 file2 cat file1 &gt;file2 cat &lt; file1 &gt;file2 dd if=file1 of=file2 cat file1 | cat &gt;file2 问：Linux文件权限 Linux文件权限的长度为10位，分成四段：文件类型(1位) + 拥有者权限(3位) + 所属组权限(3位) + 其他用户权限(3位) 问：chmod 修改文件权限chmod [who] [+|-|=][mode] 文件名 (1) [who]的取值可以为u，g，o和a， u 表示”用户(user)”，即文件拥有者； g 表示”同组(group)用户”，即与文件拥有者有相同组ID的所有用户； o 表示”其他(others)用户”； a 表示”所有(all)用户”，它是系统默认值。 (2) [+|-|=] + 添加某个权限； 取消某个权限； = 赋予给定权限并取消其他所有权限（如果有的话）。 (3) [mode] 当使用+或-时，权限从0到7的一个八进制数，例如7为4+2+1的组合，代表可读可写可执行权限；5为4+1的组合，代表可读可执行，等； 当使用=时，权限为从0到7的3个八进制数，按(u)、(g)、(o)顺序组织，分别对应文件拥有着、同组用户和其他用户的权限。 例1： 文件file的访问权限为rw-r--r--，现要增加所有用户的执行权限和同组用户的写权限，其命令可以为：chmod a+x,g+w file 或 chmod 764 file 注意为多种用户设置权限时，中间以”,”隔开，不可以加空格。如chmod a+x, g+w file为错误形式，逗号后面存在空格。 例2： 现在file文件的权限改为只有拥有着拥有执行权限的命令可以为：chmod u+x,g-x,o-x file 或 chmod 100 file 例3： 在unix系统下执行chmod 753 file之后，该文件sample的访问权限为：拥有者可读写执行，同组用户可读可执行，其他用户可写可执行 问：umaskumask [-p] [-S] [mode] umask可用来指定在建立文件时预设的权限掩码。对于每一类用户(文件属主、同组用户、其他用户)在umask值mode中都存在一个相应的数字。 对于文件来说，这一数字的最大值是6。系统不允许你在创建一个文本文件时就赋予它执行权限，必须在创建后用chmod命令增加这一权限； 目录则允许设置执行权限，这样针对目录来说，umask中各个数字最大可以为7。 例1： 如果系统的umask设置为244，创建一个新文件后，它的权限为：-r---w--w- 创建时，文件权限默认为666，目录权限默认777，减去umask的位就是结果权限。因此该文件权限为666-244=422，即为-r---w--w- 例2： 设umask为002, 则新建立的文件的权限是：-rw-rw-r-- 问：tar 压缩和解压缩tar [必选项+可选项] 文件或者目录 必选项： -c 创建压缩包； -x 解开压缩包； -t 列出包中的内容； -r 增加文件到指定包中； -u 更新包中的文件 可选项： -j 创建或解开压缩包包时使用bzip2进行压缩或解压缩； -z 创建或解开压缩包包时使用gzip进行压缩或解压缩； -Z 创建或解开压缩包包时使用compress进行压缩或解压； -f 后面跟指定的压缩包文件名； -v 显示创建压缩包/解开压缩包的过程； -C 指定解开压缩包的路径 例1： 在linux中如何使用tar命令将文件aaa打包为bak.tar：tar -cf bak.tar aaa 例2： tar命令用于解压的参数是: -x 问：tar，gzip，compress，uncompresstar是操作.tar的命令 gzip是压缩.gz压缩包的命令 compress：压缩.Z文件 uncompress：解压缩.Z文件 例1： 一个文件名字为rr.Z，可以用来解压缩的命令是:uncompress 问：查看文件内容cat，less，more都可以查看文件内容 less命令除了可以按空格键向下显示文件外，还可以用上下键来卷动文件 cat是将文件中的内容全部输出，如果内容过多，鼠标光标自动移到最后一行 more只能用enter键往下翻 问：cut从行当中截取所需要的内容进行显示 https://www.nowcoder.com/profile/7404313/test/8343455/22098?onlyWrong=0 问：硬链接和软链接推荐阅读 https://www.nowcoder.com/profile/7404313/test/8114836/36414?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8343455/44623?onlyWrong=0 四、 网络管理问：ping 测试连通性ping命令用来测试主机之间网络的连通性，底层是ICMP协议。 主机发出ICMP报文后，若主机与目的主机之间的网络连通正常，则目的主机会返回响应报文。 我们经常会说”ping一下某机器，看是不是开着”、不能打开网页时会说”你先ping网关地址192.168.1.1试试”。它通过发送ICMP ECHO_REQUEST数据包到网络主机，并显示响应情况，这样我们就可以根据它输出的信息来确定目标主机是否可访问(但这不是绝对的)。有些服务器为了防止通过ping探测到，通过防火墙设置了禁止ping或者在内核参数中禁止ping，这样就不能通过ping确定该主机是否还处于开启状态。 问：traceroute 路径跟踪traceroute是常用的路由查看命令，用来追踪数据包到达网络上某个主机在时经过的路径 问：route 查看路由表route命令用来显示目前本机路由表的内容，并且还可以针对路由表中的记录进行相应的添加、删除或修改等操作。 (1) route print 本命令用于显示路由表中的当前项目，由于用IP地址配置了网卡，因此所有的这些项目都是自动添加的。 (2) route add 本命令可以将新路由项目添加到路由表。 (3) route change 使用本命令可以修改数据的传输路由，不过，你不能使用本命令来改变数据的目的地。 (4) route delete 使用本命令可以从路由表中删除路由。 例1： 局域网的网络地址192.168.1.0/24，局域网络连接其它网络的网关地址是192.168.1.1。 主机192.168.1.20访问172.16.1.0/24网络时，其路由设置正确的是：route add –net 172.16.1.0 gw 192.168.1.1 netmask 255.255.255.0 metric 1 路由信息是由{目的主机所在的网络地址，下一跳地址，子网掩码}组成，-net 后面跟的是目的网络，下一跳的地址就是局域网中连接外网的网关地址 问：ifconfigifconfig命令用来查看活动的网卡信息 问：telnettelnet命令通常用来进行远程登录。telnet程序是基于TELNET协议的远程登录客户端程序。Telnet协议是TCP/IP协议族中的一员，是Internet远程登录服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。 问：netstatnetstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。 netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。 如果你的计算机有时候接收到的数据报导致出错数据或故障，你不必感到奇怪，TCP/IP可以容许这些类型的错误，并能够自动重发数据报。但如果累计的出错情况数目占到所接收的IP数据报相当大的百分比，或者它的数目正迅速增加，那么你就应该使用 netstat查一查为什么会出现这些情况了。 问：tcpdumphttps://www.nowcoder.com/profile/7404313/test/8322129/14462?onlyWrong=0 五、 用户管理六、 系统管理问：uptimeuptime命令主要用于获取主机运行时间和查询linux系统负载等信息 问：top问：sar问：Linux关机命令 halt init 0 poweroff shutdown -h 时间 (例如，shutdown -h now) 问：Linux重启命令 reboot init 6 shutdown -r 时间 七、 内核管理八、 帮助文档问：man 查看Linux命令手册例1： 命令man 5 passwd的作用：显示password文件的格式描述 九、 其他问：查看相关信息 cat /proc/meminfo 查看物理内存的信息 问：常用命令介绍 grep netstat netstat命令用来查看本机的传输层连接状态，如TCP、UDP连接，端口等信息 tcpdump tcpdump是简单可靠网络监控的实用工具 top top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况 fg 将一个后台进程调至前台继续运行 bg 将一个在后台暂停的进程唤醒，继续执行 ctrl+z 可以将一个正在前台执行的进程放到后台，并且暂停，表示进程被挂起 dpkg “dpkg”是”Debian Packager”的简写，是为”Debian”专门开发的套件管理系统，方便软件的安装、更新及移除。所有源自”Debian”的”Linux “发行版都使用”dpkg”，例如”Ubuntu”、”Knoppix”等。示例：dpkg -i avg71flm_r28-1_i386.deb df df命令用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 https://www.nowcoder.com/profile/7404313/test/8078490/55441?onlyWrong=0 问：grep和findfind是根据文件名进行查找，grep是对文件的内容进行搜索 https://www.nowcoder.com/profile/7404313/test/8114836/14452?onlyWrong=0 问：sedhttps://www.nowcoder.com/profile/7404313/test/8114836/14510?onlyWrong=0 问：init命令是进程和作业管理命令，init命令是Linux下的进程初始化工具，init进程是所有Linux进程的父进程，它的进程号为1。init命令是 Linux操作系统中不可缺少的程序之一，init进程是Linux内核引导运行的，是系统中的第一个进程。 问：mount查看磁盘挂载状态 问：mkdirhttps://www.nowcoder.com/profile/7404313/test/8114836/23226?onlyWrong=0 问：usermodhttps://www.nowcoder.com/profile/7404313/test/8114836/22122?onlyWrong=0 问：crontab，定时任务通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本，该命令前五个域是指定命令被执行的时间，最后一个域是要被执行的命令，每个域之间使用空格或者制表符分隔。 格式如下： minute hour day-of-month month-of-year day-of-week command 这些项都不能为空，必须填入。如果用户不需要指定其中的几项，那么可以使用*代替。因为*是统配符，可以代替任何字符，所以就可以认为是任何时间，也就是该项被忽略了。 第1列表示分钟(1～59)，每分钟用*或者*/1表示 第2列表示小时(1～23，0表示0点) 第3列表示日期(1～31) 第4列表示月份(1～12) 第5列标识号星期(0～6，0表示星期天) 第6列要运行的命令 例如：*/5 * * * * exam，表示每5分钟运行一次任务exam。 问：Linux下的输入/输出重定向在Linux中，每个打开的文件被赋予一个文件描述符(file descriptor)，包括标准输入(stdin)，标准输出(stdout)和标准错误输出(stderr)，分别由0，1，2描述。 command &amp;&gt; file 表示将标准输出(stdout)和标准错误输出(stderr)重定向至指定的文件file中 command &gt; file 2&gt;&amp;1，是由两部分组成。首先command&gt;file表示将标准输出(stdout)重定向到文件file中。接下来的2&gt;&amp;1表示将标准错误输出(stderr)输出到文件描述符1指定的位置，即标准输出(stdout)的位置，由于标准输出已经冲定向到文件file中，所以标准错误输出也会重定向到文件file中。 https://www.nowcoder.com/profile/7404313/test/8343455/15827?onlyWrong=0 问：Shell命令https://www.nowcoder.com/profile/7404313/test/8114836/14919?onlyWrong=0 问：Linux内存划分https://www.nowcoder.com/profile/7404313/test/8114836/25177?onlyWrong=0 问：Nginxhttps://www.nowcoder.com/profile/7404313/test/8114836/26093?onlyWrong=0 问：forkhttps://www.nowcoder.com/profile/7404313/test/8114836/14836?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8343455/26090?onlyWrong=0 grep统计一个文件中&quot;牛客&quot;出现的行数: grep &quot;牛客&quot; 文件名 | wc -l https://www.nowcoder.com/profile/7404313/test/8148327/22524?onlyWrong=0 findhttps://www.nowcoder.com/profile/7404313/test/8148327/25705?onlyWrong=0 孤儿进程、僵尸进程https://www.nowcoder.com/profile/7404313/test/8148327/14857?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8148327/25761?onlyWrong=0 管道通信https://www.nowcoder.com/profile/7404313/test/8322129/36306?onlyWrong=0 ### makefile https://www.nowcoder.com/profile/7404313/test/8322129/15416?onlyWrong=0 Linux X Window System (X11)Linux X Window System中X是一个开放的协议规范，当前版本为11，俗称X11。X Window System由客户端和服务端组成，服务端X Server负责图形显示，而客户端库X Client根据系统设置的DISPLAY环境变量，将图形显示请求发送给相应的X Server。 https://www.nowcoder.com/profile/7404313/test/8343455/26052?onlyWrong=0","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://hepsilion.github.io/tags/操作系统/"},{"name":"Linux","slug":"Linux","permalink":"https://hepsilion.github.io/tags/Linux/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"Advanced Algorithms","slug":"Advanced-Algorithms","date":"2017-05-28T10:55:45.000Z","updated":"2017-10-21T13:19:21.398Z","comments":true,"path":"2017/05/28/Advanced-Algorithms/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/Advanced-Algorithms/","excerpt":"算法","text":"算法 一、分治法二、贪心算法三、动态规划四、回溯法五、分支限界法六、问题复杂性问：P、NP、NPChttps://www.nowcoder.com/profile/7404313/test/8073440/14496?onlyWrong=0","categories":[{"name":"算法","slug":"算法","permalink":"https://hepsilion.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://hepsilion.github.io/tags/算法/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://hepsilion.github.io/categories/算法/"}]},{"title":"计算机组成原理总结","slug":"计算机组成原理","date":"2017-05-28T10:54:33.000Z","updated":"2017-10-21T13:19:21.601Z","comments":true,"path":"2017/05/28/计算机组成原理/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/计算机组成原理/","excerpt":"计算机组成原理","text":"计算机组成原理 原码、反码和补码https://www.nowcoder.com/profile/7404313/test/7956107/927?onlyWrong=0 问：在定点二进制运算器中，减法运算一般通过补码运算的二进制加法器来实现https://www.nowcoder.com/profile/7404313/test/7994191/1735?onlyWrong=0 问：https://www.nowcoder.com/profile/7404313/test/8073949/15746?onlyWrong=0 问：IEEE754单精度浮点格式案例： float型数据通常用IEEE754单精度浮点数格式表示。若编译器将float型变量x分配在一个32位浮点寄存器FR1中，且x=-8.25，则FR1的内容是()。 1、十进制转二进制 小数点之前的部分除以2取余倒序，小数点之后的部分乘以2取整正序 例：8.25的二进制表示，整数部分：8=1000；小数部分：0.25=01，8.25=1000.01 规格化：8.25=1.00001*2^3 2、浮点数保存的字节格式如下： 地址 +0 +1 +2 +3 内容 SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM S表示符号位(正为0，负为1)；E表示阶码，M表示尾数 阶码=阶数+127；尾数还原=MMM MMMM MMMM MMMM MMMM MMMM(规格化时，最高位为1，默认隐藏，只取小数点后部分) 对于-8.25，S=1，阶码=3+127=130=1000 0010，尾数=00001 所以-8.25的字节格式如下 地址 +0 +1 +2 +3 内容 1100 0001 0000 0100 0000 0000 0000 0000 C1 04 00 00 来源：https://www.nowcoder.com/profile/7404313/test/7941145/52554?onlyWrong=0 问：大端和小端https://www.nowcoder.com/profile/7404313/test/8144521/36423?onlyWrong=0","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://hepsilion.github.io/tags/计算机组成原理/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"04-JSP","slug":"04-JSP","date":"2017-05-28T10:52:12.000Z","updated":"2017-10-21T13:19:21.086Z","comments":true,"path":"2017/05/28/04-JSP/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/04-JSP/","excerpt":"JSP","text":"JSP https://www.nowcoder.com/profile/7404313/test/8073294/15276?onlyWrong=0","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://hepsilion.github.io/categories/Java-Web/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"},{"name":"Web","slug":"Web","permalink":"https://hepsilion.github.io/tags/Web/"}],"keywords":[{"name":"Java Web","slug":"Java-Web","permalink":"https://hepsilion.github.io/categories/Java-Web/"}]},{"title":"03-Servlet","slug":"03-Servlet","date":"2017-05-28T10:51:29.000Z","updated":"2017-10-21T13:19:21.070Z","comments":true,"path":"2017/05/28/03-Servlet/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/03-Servlet/","excerpt":"Servlet","text":"Servlet https://www.nowcoder.com/profile/7404313/test/8073294/15043?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8073294/7699?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8078128/15047?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/8113740/15258?onlyWrong=0 https://my.oschina.net/dtkking/blog/89443 问：Servlet初始化https://www.nowcoder.com/profile/7404313/test/8103755/26091?onlyWrong=0","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://hepsilion.github.io/categories/Java-Web/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"},{"name":"Web","slug":"Web","permalink":"https://hepsilion.github.io/tags/Web/"}],"keywords":[{"name":"Java Web","slug":"Java-Web","permalink":"https://hepsilion.github.io/categories/Java-Web/"}]},{"title":"02-HTTP协议","slug":"02-HTTP协议","date":"2017-05-28T10:51:09.000Z","updated":"2017-10-21T13:19:21.006Z","comments":true,"path":"2017/05/28/02-HTTP协议/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/02-HTTP协议/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"01-XML","slug":"01-XML","date":"2017-05-28T10:50:01.000Z","updated":"2017-10-21T13:19:21.006Z","comments":true,"path":"2017/05/28/01-XML/","link":"","permalink":"https://hepsilion.github.io/2017/05/28/01-XML/","excerpt":"XML解析","text":"XML解析 https://www.nowcoder.com/profile/7404313/test/8114731/25962?onlyWrong=0","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://hepsilion.github.io/categories/Java-Web/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"},{"name":"Web","slug":"Web","permalink":"https://hepsilion.github.io/tags/Web/"}],"keywords":[{"name":"Java Web","slug":"Java-Web","permalink":"https://hepsilion.github.io/categories/Java-Web/"}]},{"title":"如何使用Markdown","slug":"如何使用Markdown","date":"2017-05-27T14:07:46.000Z","updated":"2017-10-21T13:19:21.476Z","comments":true,"path":"2017/05/27/如何使用Markdown/","link":"","permalink":"https://hepsilion.github.io/2017/05/27/如何使用Markdown/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"数据库系统概念","slug":"数据库系统概念","date":"2017-03-18T10:45:37.000Z","updated":"2017-10-21T13:19:21.538Z","comments":true,"path":"2017/03/18/数据库系统概念/","link":"","permalink":"https://hepsilion.github.io/2017/03/18/数据库系统概念/","excerpt":"数据库系统概念","text":"数据库系统概念 问：数据库管理系统的特点数据库管理系统将具有一定结构的数据组成一个集合，它主要具有以下几个特点: (1) 数据的结构化：数据库中的数据并不是杂乱无章、毫不相干的，它们具有一定的组织结构，属于同一集合的数据具有相似的特征。 (2) 数据的共享性：在一个单位的各个部门之间，存在着大量的重复信息。使用数据库的目的就是要统一管理这些信息，减少冗余度，使各个部门共同享有相同的数据。 (3) 数据的独立性：数据的独立性是指数据记录和数据管理软件之间的独立。数据及其结构应具有独立性，而不应该去改变应用程序。 (4) 数据的完整性：数据的完整性是指保证数据库中数据的正确性。可能造成数据不正确的原因很多，数据库管理系统通过对数据性质进行检查而管理它们。 (5) 数据的灵活性：数据库管理系统不是把数据简单堆积，它在记录数据信息的基础上具有很多的管理功能，如输入、输出、查询、编辑修改等。 (6) 数据的安全性：根据用户的职责，不同级别的人对数据库具有不同的权限，数据库管理系统应该确保数据的安全性。 问：数据模型数据库是长期存储在计算机内有组织的大量的共享的数据集合。它可以供各种用户共享，具有最小冗余度和较高的数据独立性。数据库系统的核心和基础是数据模型。数据模型是对现实世界数据特征的抽象，是用来描述数据、组织数据和对数据进行操作的。根据模型应用目的的不同，数据模型可以分为两类，第一类是概念模型，第二类是逻辑模型和物理模型。 概念模型，也称信息模型，它是按用户的观点来对数据和信息建模，主要用于数据库设计。 第二类中的逻辑模型主要包括层次模型、网状模型、关系模型、面向对象模型和对象关系模型等。 第二类中的物理模型是对数据最底层的抽象，它描述数据在系统内部的表示方法和存取方法，在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的。 一般来说，数据模型是严格定义的一组概念的集合。这些概念精确地描述了系统的静态特征、动态特征和完整性约束条件。因此数据模型一般由数据结构、数据操作和完整性约束三部分组成。 数据结构:存储在数据库中对象类型的集合，作用是描述数据库组成对象以及对象之间的联系。 数据操作:指对数据库中各种对象实例允许执行的操作的集合，包括操作及其相关的操作规则。 数据完整性约束条件:指在给定的数据模型中，数据及其联系所遵守的一组通用的完整性规则，它能保证数据的正确性和一致性。 问：关系数据模型关系模型是目前最重要的一种数据模型。关系数据库系统采用关系模型作为数据的组织方式，在这些系统中，关系模型中数据的逻辑结构是一张二维表，或者说关系的数据结构就是一张表。 关系数据模型的数据操作主要包含查询、抽入、删除和更新数据。 关系模型的完整性约束包含:实体完整性、参照完整性和用户自定义的完整性。 问：关系数据库和非关系型数据库(1) 关系型数据库 MS SQL Server、IBM DB2、Oracle、MySQL、Microsoft Access和PostgreSQL。 (2) 非关系型数据库 (NoSQL) 键值(Key-Value)存储数据库 这一类数据库主要会使用到一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。Key/value模型对于IT系统来说的优势在于简单、易部署。但是如果DBA只对部分值进行查询或更新的时候，Key/value就显得效率低下了。 常见的键值存储数据库：Tokyo Cabinet/Tyrant，Redis，Voldemort，Oracle BDB.，Google BigTable，Amazon DynamoDB。 列存储数据库 这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。 常见的列存储数据库：Cassandra，HBase，Riak。 文档型数据库 文档型数据库的灵感是来自于LotusNotes办公软件的，而且它同第一种键值存储相类似。该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高。 常见的文档型数据库：CouchDB, MongoDb。国内也有文档型数据库SequoiaDB，已经开源。 图(Graph)数据库 图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。许多NoSQL数据库都有REST式的数据接口或者查询API。 常见的图数据库：Neo4J，InfoGrid，Infinite Graph。 NoSQL数据库在以下的这几种情况下比较适用： 数据模型比较简单； 需要灵活性更强的IT系统； 对数据库性能要求较高； 不需要高度的数据一致性； 对于给定key，比较容易映射复杂值的环境。 问：ER模型ER模型的基本元素是：实体、联系和属性 (1) 实体：是一个数据对象，指应用中可以区别的客观存在的事物。 (ER模型中的实体往往是指实体集)实体集：指同一类实体构成的实体集合，用矩形表示表示，矩形内注明实体名。 (2) 联系：表示一个或多个实体之间的关联关系。联系用菱形框表示，菱形框内注明联系名，并用无向边将与其相关的实体连接起来，同时在无向边旁标上联系的类型。 联系可分为以下3种类型：1对多联系，1对1联系和多对多联系 1对1联系(1:1)： 例如，一个部门有一个经理，而每个经理只在一个部门任职，则部门与经理的联系是一对一的。 一对多联系(1:N): 例如，某校教师与课程之间存在一对多的联系”教”，即每位教师可以教多门课程，但是每门课程只能由一位教师来教。 多对多联系(M:N): 例如，学生与课程间的联系(“学”)是多对多的，即一个学生可以学多门课程，而每门课程可以有多个学生来学。 (3) 属性：实体的某一特性称为属性，属性用椭圆形框表示，加下划线的属性为主属性。 例1：教学管理的一个可能设计的ER图 教学管理的一个可能设计的ER图 问：主键与外键若关系(二维表)中的某一属性组的值能唯一标识一个元组，则称该属性组为候选码。若个表中有多个候选码，则可选定其中一个为主键。 候选码的各个属性称为主属性。不包含在任何候选码中的属性称为非主属性或非码属性。 如果关系模式R1中的某属性集不是R1的主键，并且该属性集是另一个关系R2的主键，则该属性集是关系模式R1的外键。由此可见，外键表示了两个关系(表)之间的联系。以另一个关系的外键作主键的表被称为主表(R2)，具有此外键的表被称为主表的从表(R1)，外键又称为外关键字。 问：完整性约束主键的设置是为了强制表的实体完整性，外键的设置是为了强制表之间的参照完整性。 (1) 关系模型的实体完整性约束 若属性(指一个或一组属性)A是基本关系R的主属性，则A不能取空值。由此约束可得一直接结论:主键不能为空。 (2) 关系模型的参照完整性约束 若属性(或属性组)F是某基本关系R1的外键，且它与基本关系R2的主键相对应，则对于R1中，每个F上的值或为空值或者等于R1中的主键值。 (3) 关系模型的用户自定义完整性约束 例1：下列哪种完整性约束中，将每一条记录定义为表中的惟一实体，即不能重复 A. 域完整性 B. 引用完整性 C. 实体完整性 D. 其他 答案： C。 问：关系代数介绍关系代数的一篇文章 关系代数是关系数据库系统查询语言的理论基础，包括：并、交、差、乘、选择、投影、联接、除、自然联接等操作。 例1： 设有关系模式R(a,b,c,d,)，与关系代数表达式σ3&lt;&apos;4&apos;(R)等价的SQL语句为：select * from R where c&lt;&apos;4&apos;; 例2 问：常见的SQL语句SQL语句功能极强，包括数据定义(create、 drop和alter)、数据操纵(insert，update和delete)、数据查询(select)、数据控制(grant和revoke)。 例1：ANSI SQL语句的分类 (1) 数据定义 创建表：SQL语言使用create table语句定义表，其基本格式如下: create table &lt;表名&gt;( &lt;列名&gt; &lt;数据类型&gt; [列级完整性约束条件] [, &lt;列名&gt; &lt;数据类型&gt; [列级完整性约束条件]] ... [, &lt;表级完整性约束条件&gt;]); 例1：建立一个”学生信息”表Student: create table Student( Sno char(9) primary key, Sname char(20) unique, Ssex char(2), Sage smallint, Sdept char(20) ); 修改表：随着应用环境和应用需求的变化，有时需要修改已建立好的表，SQL语言用alter table语句修改表，其一般格式为: ALTER TABLE &lt;表名&gt; [ADD &lt;新列名&gt; &lt;数据类型&gt; [完整性约束]] [DROP &lt;完整性约束名&gt;] [MODIFY COLUMN &lt;列名&gt; &lt;数据类型&gt;] 其中，&lt;表名&gt;是要修改的表，ADD子句用于增加新列和新的完整性约束条件，DROP子句用于删除指定的完整性约束，MODIFY COLUMM子句用于修改原有的列定义，包括修改列名和数据类型。 例2：向Student表增加”入学时间”列，其数据类型为日期类型。 alter table Student add Sentrance date; 上述代码不论Student表中原来是否已有数据，新增加的列一律为空值。 例3：删除Student表中”年龄”列 alter table Student drop column Sage; 删除列可以省略column 例4：要求将年龄的数据类型由字符型(假设原来的数据类型是字符型)改为整数。 alter table Student modify column Sage int; 例5：增加Student表Sname必须取唯一值的约束条件。 alter table Student add unique(Sname); 删除表：当某个表不再需要时，可以使用drop table语句删除它。其一般格式为: DROP TABLE &lt;表名&gt; [RESTRICT | CASCADE]; 若选择RESTRICT，则该表的删除是有限制条件的:欲删除的表不能被其他表的约束所引用(如check，foreign key等约束)，不能有视图，不能有触发器，不能有存储过程或函数等。如果存在这些依赖该表的对象，则此表不能被删除。 若选择CASCADE，则该表的删除没有限制条件。在删除该表的同时，相关的依赖对象，例如视图，都将被一起删除。 例6：删除Student表 drop table Student cascade; (2) 数据操纵 数据操纵操作有3种：向表中添加若干行数据、修改表中的数据和删除表中的若干行数据。 插入元组：插入元组的INSERT语句的格式为: INSERT INTO table (fieldl, field2 ...) VALUES(valuel, value2..); 其功能是将新元组插入到指定表中，其中新元组的field1的值为value1, field2的值为value2…。 如果INTO语句中没有指定任何属性列名，则新插入的元组必须在每个属性列上均有值。 例1：将一个新学生元组(学号:201009014，姓名:Wang，性别:女， 所在系:MA，年龄:21)插入到Student表中 insert into Student(Sno, Sname, Ssex, Sdept, Sage) values (&apos;201009014&apos;, &apos;Wang&apos;, &apos;F&apos;, &apos;MA&apos;, 21); 修改数据：修改数据又称为更新操作，其语句的一般格式为: UPDATE table SET fieldl=valuel, field2=value2 WHERE 范围 其功能是修改指定表中满足WHERE子句条件的元组。其中SET子句给出的value值用于取代相应的属性列值。如果省略WHERE子句，则表示要修改表中的所有元组。 例2：将学生201009013的年龄改为22岁 update Student set Sage=22 where Sno=&apos;201009013&apos;; 删除数据：删除语句的一般格式为: DELETE FROM tabIe WHERE范围; DELETE语句的功能是从指定表中删除满足WHERE子句条件的所有元组。如果省略WHERE子句，表示删除表中全部元组，但表仍存在。 删除表中的所有行(truncate和delete的区别，这里尚未整理) truncate table TABLE_NAME; (不可恢复) 例3：删除学号为201009020的学生记录 delete from Student where Sno=&apos;201009020&apos;; (3) 数据查询 数据库查询是数据库的核心操作。SQL提供了select语句进行数据库的查询，其一般格式为: SELECT [ALL | DISTINCT] &lt;目标列表达式&gt; [，&lt;目标列表达式&gt;] ... FROM &lt;表名或视图名&gt; [,&lt;表名或视图名&gt;] ... [WHERE &lt;条件表达式&gt;] [GROUP BY &lt;列名1&gt; [HAVING &lt;条件表达式&gt;]] [ORDER BY &lt;列名2&gt; [ASC | DESC]]; 整个SELECT语句解析顺序：FROM-&gt;WHERE-&gt;GROUP BY-&gt;HAVING-&gt;SELECT-&gt;ORDER BY 整个SELECT语句的含义 根据WHERE子句的条件表达式，从FROM子句指定的表或视图中找出满足条件的元组，再按SELECT子句中的目标列表达式，选出元组中的属性值形成结果表。 如果有GROUP BY子句，则将结果按&lt;列名1&gt;的值进行分组，该属性值相等的元组为一个组。通常会在每组中使用聚集函数。如果GROUP BY子句带HAVING子句，则只有满足指定条件的组才会被输出。 如果有ORDER BY子句，则结果表还要按&lt;列名2&gt;的值的升序或降序排序。 选择表中的若干列 例1：在表Student中查询名为Wang的学生信息 select * from Student where Sname=&apos;Wang&apos;; 例2：在表Student中，查询名字中有ang的学生信息 select * from Student where Sname like &apos;%ang%&apos;; 上述%是通配符，代表任意长度(可为0)的字符串。例如a%b表示以a开头，以b结尾的任意长度的字符串。除此之外，_(下画线)代表任意单词字符。 例3：在表Student中查询年龄在20-22岁(包括20岁与22岁)之间的学生的信息 select * from Student where Sage between 20 and 22; 与BETWEEN...AND...相对的谓词是NOT BETWEEN...AND... 例4：在表Student中查询计算机系(CS)、信息系(MA)和和物理系(PH)学生的姓名和性别 select Sname, Ssex from Student where Sdept in (&apos;CS&apos;, &apos;MA&apos;, &apos;PH&apos;); 与IN相对的谓词是NOT IN，用于查找属性值不属于指定集合的元组。 例5：在表Student中查询没有年龄信息的学生 select * from Student where Sage is null; 注意这里的&quot;is&quot;不能被等号代替。 order by子句 用户可以用order by子句对查询的结果按照一个或多个属性列的升序(ASC)或降序(DESC)排列，默认值为升序。 例6：在表Student中，按学生的年龄值升序检索出全部学生的信息 select * from Student order by Sage; 在表Student中先按专业升序排序，然后同一专业的学生再按年龄降序排序，并输出全部学生信息 select * from Student order by Sdept, Sage desc; limit子句 limit主要是用于查询之后显示返回的前几条或者中间某几条数据。 SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset; LIMIT子句可以被用于强制SELECT语句返回指定的记录数。 LIMIT接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是0(而不是1)。 例7：从Student表中检索出第3到第7条记录，共5条记录 select * from Student limit 2, 5; 例8：从Student表中检索出前2条记录 select * from Student limit 2; 换句话说，LIMIT n等价于LIMIT 0, N 聚集函数 SQL语句中的常用聚集函数有以下几种：count，sum，avg，max，min。用法如下： 总数： select count(*) as totalcount from table; 求和： select sum(field) as sumvalue from table; 平均： select avg(field) as avgvalue from table; 最大： select max(field) as maxvalue from table; 最小： select min(field) as minvalue from table; GROUP BY子句 GROUP BY子句根据一个或多个属性的值来对元组进行分组，值相等的为一组。 对查询结果分组的目的是为了细化聚集函数的作用对象，分组后聚集函数将作用于每一个组，即每一组都有一个函数值。 例9：查询Student表中具有相同年龄的每个组的人数 select Sage, count(*) from Student group by Sage; 如果分组后还要求按一定的条件对这些组进行筛选，最终只输出满足指定条件的组，则使用HAVING短语指定筛选条件。通常，HAVING子句只用在GROUP BY子句的SQL语句中，用来选取符合指定条件的分组。 例10：查询Student表中每种年龄的人数大于1的年龄与人数信息 select Sage, count(*) from Student group by Sage having count(*) &gt; 1; 连接查询 前面的查询都是针对一个表进行的。若一个查询同时涉及两个以上的表，则称之为连接查询。 例11：若有表Student(学生信息表)、SC(选课表)，要求查询每个学生及其选修课程的情况: select Student.*, SC.* from Student, SC where Student.Sno=SC.Sno; 在以上的连接操作中，只有满足条件的元组才能作为结果输出。 若表Student中某些学生没有选课，则在SC表中没有相应的元组，造成最终结果中舍弃掉了这些学生的信息。 上述连接称为自然连接、内连接。有时想以Student表为主体列出每个学生的基本情况及其选课情况。若某个学生没有选课，依然将其保存到结果中(在SC表的属性上填空值)，这时就需要使用外连接。 select Student.*，SC.* from Student left join SC on (Student.Sno=SC.Sno); 以上是左外连接，左外连接列出左边表(本例为Student表)中的所有元组，右外连接列出右表关系中所有的元组。 例12 例13：一道综合题 设有学生信息表s(sno, sname)，其属性分别表示学号，姓名；课程信息表c(cno, cname)，其属性分别表示课程号、课程名称;选课信息表sc(sno, cno, grade)，其属性分别表示学号、课程号和成绩。 1) 问选修课程”db”的学生学号 select sc.sno from sc, c where sc.cno=c.cno and c.cname=&apos;db&apos;; 2) 平均成绩最高的学生学号 select sno, avg(grade) as g from sc group by sno order by g desc limit 1; 3) 每科大于90分的人数 select cno, count(sno) from sc where grade&gt;90 group by cno; 4) 列出既学过”math”，又学过”english”的所有学生学号、姓名 select s.sno, s.sname from s, (select sc.sno from sc, c where sc.cno=c.cno and c.cname in(&apos;math&apos;, &apos;english&apos;) group by sno having count (distince c.cno)=2) x where s.sno=x.sno; 5) 列出有两门以上(含两门)不及格课程(成绩小于60)的学生学号、姓名及其平均成绩 select s.sno, s.sname，avg(sc.grade) as avggrade from s, sc, (select sno from sc where grade&lt;60 group by sno having count (distince cno)&gt;=2) x where s.sno=x.sno and sc.sno=x.sno group by s.sno; 6) 列出”math”课程成绩比”english”课程成绩高的所有学生的姓名 select s.sname, from s, (select sno, grade from sc where cno in (select cno from c where cname=&apos;math&apos;)) A, (select sno, grade from se where cno in (select cno from c where cname=’english&apos;)) B where s.sno=A.sno and s.sno=B.sno and A.grade&gt;B.grade; (4) 数据控制 授予权限 grant [权限] on [table] to &apos;username&apos;@&apos;localhost&apos;; 例1：使用sql语句中为用户zhangsan分配数据库userdb表userinfo的查询和插入数据权限 grant select,insert on userdb.userinfo to&apos;zhangsan&apos;@&apos;localhost&apos; 问：视图视图是从一个或几个表(或视图)导出的表。它与表不同，是一个虚表。数据库中只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的表中。所以表中的数据发生变化时，从视图中查询出的数据也就随之发生改变了。从这个意义上讲，视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化。 例1：在学生表Student的基础上，创建一个计算机系学生的视图 create view cs_student as select sno, sname from Student where Sdept=&apos;CS&apos;; 视图一经定义，就可以和基本表一样被查询、被删除。 例2：若要求进行修改和插入操作时，仍需保证该视图中只有计算机系的学生: create view cs_student as select sno, sname from Student where Sdept=&apos;CS&apos; with check option; 例3：删除视图的语句为: drop view cs_student; 例4 问：SQL约束 NOT NULL：控制字段的内容不能为空(NULL)。 UNIQUE：控制字段的内容不能重复，一个表允许有多个Unique约束。 PRIMARY KEY：控制字段的内容不能重复，即它在一个表中只允许出现一个。 FOREIGN KEY：FOREIGN KEY约束用于预防破坏表之间连接的动作，FOREIGN KEY约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。 CHECK：用于控制字段的值范围。 DEFAULT：用于设置新记录的默认值。 问：SQL的匹配模式(1) %表示匹配0个或多个字符 select * from user where name LIKE &apos;%三%&apos;; 将会把name为&quot;张三&quot;、&quot;三脚猫&quot;、&quot;唐三藏&quot;等等有&quot;三&quot;的全找出来。 %三：表示左匹配； 三%：表示右匹配； %三%：表示模糊查询。 (2) _表示匹配单个任意字符 select * from user where name LIKE &apos;_三_&apos;； 只找出&quot;唐三藏&quot;这样name为三个字且中间一个字是&quot;三&quot;的； select * from user where name LIKE &apos;三__&apos;； 只找出&quot;三脚猫&quot;这样name为三个字且第一个字是&quot;三&quot;的 (3) [ ]表示匹配括号内所列字符中的任意一个 select * from user where name LIKE &apos;[张李王]三&apos;; 将找出&quot;张三&quot;、&quot;李三&quot;、&quot;王三&quot;(而不是&quot;张李王三&quot;)； 如[]内有一系列字符（01234、abcde之类的)，则可略写为&quot;0-4&quot;、&quot;a-e&quot;。 select * from user where name LIKE &apos;老[1-9]&apos;； 将找出&quot;老1&quot;、&quot;老2&quot;、……、&quot;老9&quot;； 如要找&quot;-&quot;字符，请将其放在首位：&apos;张三[-1-9]&apos;； (4) [^ ]表示匹配不在括号所列字符内的单个任意字符 select * from user where name LIKE &apos;[^张李王]三&apos;; 将找出不姓&quot;张&quot;、&quot;李&quot;、&quot;王&quot;的&quot;赵三&quot;、&quot;孙三&quot;等 select * from user where name LIKE &apos;老[^1-4]&apos;; 将排除&quot;老1&quot;到&quot;老4&quot;，寻找&quot;老5&quot;、&quot;老6&quot;、&quot;老9&quot;、…… 问：查看Mysql表结构的命令 desc 表名; show columns from 表名; describe 表名; show create table 表名; use information_schema select * from columns where table_name=’表名’; 问：union操作符SQL union语法： select COLUMN_NAME(S) from TABLE_NAME1 union select COLUMN_NAME(S) from TABLE_NAME2; union操作符用于合并两个或多个select语句的结果集。请注意，union内部的select语句必须拥有相同数量的列，列也必须拥有相似的数据类型。同时，每条select语句中的列的顺序必须相同。默认地，union操作符会剔除重复的结果。如果要允许重复的值，请使用union all。 问：从表TABLE_NAME中提取前10条记录Sql server: select TOP N * from table_name. MySQL: select * from table_name limit 0,10; Oracle: select * from table_name where rownum＜=10 问：MySQL中的”空值”和”NULL”例1 问：索引索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。 为表设置索引是要付出代价的:一是增加了数据库的存储空间；二是在插入和修改数据时要花费较多的时间维护索引。 例1：创建索引和删除索引 (1) 在表Student(学生信息表)上按Sno(学号)降序建唯一索引Stusno create unique index Stusno ON Student(Sno desc); (2) 删除Student表的索引Stusno alter table Student drop index Stusno; 注意:以上代码在MySQL数据库上调试通过，下文代码也都是在MySQL上运行的。 例2：数据库中索引的作川是什么？什么情况下适合建立索引以及什么情况下不适合建立索引？(2011·浙商银行) 解答:创建索引可以大大提高系统的性能。 (1) 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 (2) 可以大大加快数据的检索速度，这也是创建索引的最主要原因。 (3) 可以加速表和表之间的连接，特别是在实现数据的参照完整性方面特别有意义。 (4) 在使用分组(group by)和排序(order by)子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 (5) 通过使用索引，可以在查询的过程中，使用查询优化器，提高系统的性能。 那么索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？这是因为增加索引也有许多不利的方面。 (1) 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 (2) 索引需要占用物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 (3) 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。 一般来说，应该在这些列上创建索引: (1) 在经常需要搜索的列上创建索引，可以加快搜索的速度; (2) 在作为主键的列上创建索引，强制该列的唯一性和组织表中数据的排列结构; (3) 在经常用在连接的列上创建索引，这些列主要是一些外键，可以加快连接的速度; (4) 在经常需要根据范围进行搜索的列上创建索引，囚为索引已经排序，其指定的范围是连续的; (5) 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间: (6) 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 同样，对于有些列不应该创建索引。一般来说，不应该创建索引的这些列具有下列特点: (1) 对于那些在查询中很少使用的列不应该创建索引。这是因为，既然这些列很少使用到，因此有无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度，增大了空间需求。 (2) 对于那些只有很少数据值的列也不应该创建索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占据了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 (3) 对于那些定义为text和bit等数据类型的列不应该创建索引。这是因为，这些列的数据量要么相当大，要么取值很少，不利于使用索引。 (4) 当修改操作远远大于检索操作时，不应该创建索引。这是因为，修改性能和检索性能是互相相矛盾的。当增加索引时，会提高检索的性能，但是会降低修改的性能。当减少索引时，会提高修改的性能，降低检索的性能。因此，当修改操作远远多于检索操作时，不应该创建索引。 问：范式理论 待完善(1) 第一范式(1NF) 定义：如果关系模式R的每个关系r的属性都是不可分的数据项，那么就称R是第一范式的模式。 简单的说，每一个属性都是原子项，不可分割。 1NF是关系模式应具备的最起码的条件，如果数据库设计不能满足第一范式，就不称为关系型数据库。关系数据库设计研究的关系规范化是在1NF之上进行的。 例如(学生信息表)： 学生编号 姓名 性别 联系方式 20080901 张三 男 email:zs@126.com,phone:88886666 20080902 李四 女 email:ls@126.com,phone:66668888 以上的表就不符合第一范式：联系方式字段可以再分，所以变更为正确的模式是： 学生编号 姓名 性别 电子邮件 电话 20080901 张三 男 zs@126.com 88886666 20080902 李四 女 ls@126.com 66668888 (2) 第二范式(2NF) 定义：如果关系模式R是1NF，且每个非主键属性完全函数依赖于候选键，那么就称R是第二范式。 简单的说，第二范式要满足以下的条件：首先要满足第一范式，其次每个非主键属性要完全函数依赖于候选键，或者是主键。也就是说，每个非主属性是由整个主键函数决定的，而不能由主键的一部分来决定。 例如(学生选课表): 学生 课程 教师 教师职称 教材 教室 上课时间 李四 Spring 张老师 java讲师 《Spring深入浅出》 301 08:00 张三 Struts 杨老师 java讲师 《Struts in Action》 302 13:30 这里通过(学生，课程)可以确定教师、教师职称、教材、教室和上课时间，所以可以把(学生，课程)作为主键。但是，教材并不完全依赖于(学生，课程)，只拿出课程就可以确定教材，因为一个课程一定指定了某个教材。这就叫不完全依赖，或者部分依赖。出现这种情况，就不满足第二范式。 修改后，选课表： 学生 课程 教师 教师职称 教室 上课时间 李四 Spring 张老师 java讲师 301 08:00 张三 Struts 杨老师 java讲师 302 13:30 课程表： 课程 教材 Spring 《Spring深入浅出》 Struts 《Struts in Action》 所以，第二范式可以说是消除部分依赖。第二范式可以减少插入异常，删除异常和修改异常。 (3) 第三范式(3NF) 满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。 例1，例2，例3，例4 问：数据库事务的四大特性：数据库事务是指作为单个逻辑工作单元执行的一系列操作，这些操作要么全做要么全不做，是一个不可分割的工作单位。 数据库事务的四大特性是：原子性、一致性、独立性和持久性，简称ACID。 (1) 原子性(Atomicity) 事务的原子性指的是，事务中包含的程序作为数据库的逻辑工作单位，它所做的对数据修改操作要么全部执行，要么完全不执行。这种特性称为原子性。 例如银行取款事务分为2个步骤(1)存折减款(2)提取现金。不可能存折减款，却没有提取现金。2个步骤必须同时完成或者都不完成。 (2) 一致性(Consistency) 事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。这种特性称为事务的一致性。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。 例如完整性约束a+b=10，一个事务改变了a，那么b也应随之改变。 (3) 独立性(Isolation) 分离性指并发的事务是相互隔离的。即一个事务内部的操作及正在操作的数据必须封锁起来，不被其它企图进行修改的事务看到。假如并发交叉执行的事务没有任何控制，操纵相同的共享对象的多个并发事务的执行可能引起异常情况。 (4) 持久性(Durability) 持久性意味着当系统或介质发生故障时，确保已提交事务的更新不能丢失。即一旦一个事务提交，DBMS保证它对数据库中数据的改变应该是永久性的，即对已提交事务的更新能恢复。持久性通过数据库备份和恢复来保证。 例1： DBMS中实现事务持久性的子系统是：恢复管理子系统。 问：数据库事务隔离级别讲解”数据库事务隔离级别”的一篇文章 数据库事务的隔离级别有4个，由数据库系统实现，从低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。 问：数据库恢复的基础是利用转储的冗余数据。这些转储的冗余数据包括：日志文件，数据库后备副本","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://hepsilion.github.io/tags/数据库/"},{"name":"SQL","slug":"SQL","permalink":"https://hepsilion.github.io/tags/SQL/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"计算机网络","slug":"计算机网络","date":"2017-03-17T10:42:51.000Z","updated":"2017-10-23T06:25:53.214Z","comments":true,"path":"2017/03/17/计算机网络/","link":"","permalink":"https://hepsilion.github.io/2017/03/17/计算机网络/","excerpt":"计算机网络","text":"计算机网络 一、 计算机网络体系结构问：OSI参考模型国际标准化组织(ISO)提出的网络体系结构模型，称为开放系统互联参考模型(OSI/RM)，通常简称为OSI参考模型。 OSI有七层，自下而上依次为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。每一层的作用如下： 物理层(比特Bit)：负责在连接各个计算机的传输媒介上传输数据比特流，确定与传输媒介的接口相关的一些特性。(通过媒介传输比特，确定机械及电气规范) 数据链路层(帧Frame)：将比特组装成帧和点到点的传递。 网络层(分组或数据包Packet)：负责网际互连及对数据包进行路由选择和存储转发。 传输层(报文或数据段Segment)：提供端到端的可靠报文传递和错误恢复。 会话层(会话协议数据单元SPDU)：建立、管理和终止会话 表示层(表示协议数据单元PPDU)：对数据进行翻译、加密和压缩 应用层(应用协议数据单元APDU)：允许访问OSI环境的手段 数据链路层在概念上常被划分为两个子层:逻辑链路控制子层(LLC)和媒体访问拧制子层(MAC)。数据链路层负责分配MAC地址。MAC地址(或称物理地址)，48比特长，由12个十六进制数字组成，0~23位(前6位十六进制数)是厂商向IETF等机构申请用来标识厂商的代码。24到47位由厂商自行分派，是各个厂商制造的所有网卡的一个唯一编号。因此每一个网卡会有一个全球唯一固定的MAC地址，但可对应多个IP地址。MAC地址的第48位是组播地址标志位。 网络层提供点到点的通信。直接相连的结点之间的通信称为点到点通信。它只提供一台机器到另一台机器之间的通信，不会涉及程序或进程的概念。 传输层是第一个提供端到端的通信，即进程到进程的层次。由于一个主机可同时运行多个进程，因此传输层有复用和分用的功能。 每一层的协议及设备如下： 物理层(中继器，集线器)：RJ45、CLOCK、IEEE802.3 数据链路(网桥，交换机)：PPP、FR、HDLC、VLAN、MAC 网络层(路由器)：IP、ICMP、ARP、RARP、OSPF、IPX、RIP(内部网关协议，基于UDP)、IGRP、IGMP 传输层：TCP、UDP、SPX、SCTP 会话层：NFS、SQL、NETBIOS、RPC 表示层：JPEG、MPEG、ASII 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS、SNMP 例1： RIP协议是基于UDP协议实现的。 例2：网卜完成哪一层的功能？ 答案：网卡工作在物理层和数据链路层的MAC子层 问：TCP/IP参考模型TCP/IP模型从低到高依次为：网络接口层、网际层、运输层、应用层。TCP/IP由于得到广泛应用而成为事实上的国际标准。 网络接口层的功能类似于OSI的物理层和数据链路层。 网际层是TCP/IP体系结构的关键部分。它和OSI网络层在功能上非常相似。网际层将分组发往任何网络，并为之独立地选择合适的路由，但它不保证各个分组有序到达，各个分组的有序交付由高层负责。网际层定义了标准的分组格式和协议，即IP协议。当前采用的IP协议是第4版，即IPv4，它的下一个版本是IPv6。 传输层的功能同样和OSI中的传输层类似，是使发送端和目的端主机上的对等实体可以进行会话。 应用层包含所有的高层协议。如虚拟终端协议(Telnet)、文件传输协议(FTP)、域名解析服务(DNS)、电子邮件协议(SMTP)和超文本传输协议(HTTP)。 传输层主要使用以下两种协议: (1) 传输控制协议(Transmission Control Protocol, TCP)。它是面向连接的，数据传输的单位是报文段，能够提供可靠的交付。 (2) 用户数据报协议(User Datagram Protocol, UDP)。它是无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供”尽最大努力交付”。 例1 TCP/IP模型中，ARP协议属于网络层，在OSI参考模型中，ARP属于数据链路层 问：各种协议的介绍(2) TFTP协议 TFTP协议是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。基于UDP协议实现，端口号为69。 (3) HTTP协议(超文本传输协议) 该协议定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。HTTP是面向事务的应用层协议，它规定了浏览器和服务器之间的请求和响应格式和规则，是万维网上能够可靠地交换文件(包括文本、声音、图像等各种多媒体文件)的重要基础。 (4) NAT协议 网络地址转换属接入广域网(WAN)技术，它通过将私有网络地址(如企业内部Internet)转换为共用地址(如Internet)，从而对外隐藏了内部管理的IP地址。它使得整个私有网络只需要一个全球IP地址就可以与因特网连同。由于私有网络本地IP地址是可以重用的，所以NA大大节省了IP地址的消耗；同时，它隐藏了内部网络结构，从而降低了内部网络收到攻击的风险。 (5) DHCP协议(动态主机配置协议，DHCP是应用层协议，它是基于UDP的) 常用于给主机动态地分配IP地址，提供了即插即用联网机制，这种机制允许一台计算机加入新的网络和获取IP地址而不用手动参与。 问：了解中继器、集线器、网桥、交换机、路由器、网关的概念，并知道各自的用途(1) 中继器 中继器工作在物理层，用来连接两个速率相同且数据链路层协议也相同的网段，连接起来的几个网段仍然是一个局域网。 中继器功能是消除数字信号在基带传输中由于经过一长段电缆而造成的失真和衰减，使信号的波形和强度达到所需的要求，其原理是信号再生。 中继器既不能隔离冲突域，也不能隔离广播域。 (2) 集线器 集线器也工作在物理层，相当于一个多接口的中继器，可以将多个节点连接成一个共享式局域网，但任何时刻只能有一个节点通过公共信道发送数据。 中继器既不能隔离冲突域，也不能隔离广播域。 举例：假设一集线器存在７个端口，共连接了５台计算机，那么该网络环境中存在冲突域的个数为1。 原因：集线器的所有端口是一个冲突域，而交换机的每个端口是一个冲突域 (3) 网桥 两个或多个以太网通过网桥连接起来后，就成为一个覆盖范围更大的以太网，而原来的每个以太网就可称为一个网段。 网桥工作在数据链路层的MAC子层，可以互联不同的物理层、不同的MAC子层以及不同速率的以太网，使以太网各网段成为隔离开的碰撞域。 网桥具有过滤帧以及存储转发帧的功能，可以隔离冲突域，但不能隔离广播域。 (4) 交换机 交换机工作在数据链路层，俗称”二层交换机”，相当于一个多端口的网桥，是交换式局域网的核心设备。除此之外，还有三层交换机、四层交换机，七层交换机，分别工作在OSI第三层、第四层、第七层。 交换机允许端口之间建立多个并发的连接，允许多对计算机同时通信，实现多个节点之间的并发传输。因此，交换机的每个端口节点所占用的带宽不会因为端口节点数目的增加而减少，且整个交换机的总带宽会随着端口节点的增加而增加。 交换机一般以全双工方式工作，有的局域网交换机采用存储转发方式进行转发，有的交换机采用直通交换方式(即在收到帧的同时立即按帧的目的MAC地址决定帧的转发端口，而不必进行先缓存再进行处理)。 利用交换机可以实现虚拟局域网(VLAN)，VLAN可以隔离冲突域，也可以隔离广播域。 (5) 路由器 路由器是一种具有多个输入输出端口的专用计算机，其任务是连接不同的网络(连接异构网络)并完成路由转发。 路由器是网络层设备，它实现了网络模型的下三层，即物理层、数据链路层和网络层。路由器隔离了广播域。 路由器主要完成两个功能：分组转发和路由计算。前者处理通过路由器的数据流，关键操作是转发表查询、转发以及相关的队列管理和任务调度等；后者通过和其他路由器进行基于路由协议的交互，完成路由表的计算。 (6) 网关 在传统TCP/IP术语中，网关(gateway)与路由器(router)没有区别。 在现代网络术语中，网关与路由器的定义不同。网关能在不同协议间移动数据，而路由器是在不同网络间移动数据，相当于传统所说的IP网关。网关是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过网关还原成模拟的电话信号，最后才能在电话机上听到。 二、 物理层三、 数据链路层问：太网卡的工作模式例1：太网卡的工作模式 答案：广播模式、多播传送、直接模式、混杂模式 问：海明码例1：用海明码对长度为8位的数据进行检/纠错时，若能纠正一位错，则校验位数至少为多少？ 答案为4。 假设为k个数据位设置r个校验位，则校验位能表示2^r个状态。 可用其中的一个状态指出&quot;没有发生错误&quot;，用其余的2^r-1个状态指出有错误发生在某一位，包括k个数据位和r个校验位。 因此校验位的位数应满足如下关系:2^r≥k+r+1。 问：交换机攻击交换机攻击主要有以下5种类型 (1) VLAN跳跃攻击(2) 生成树攻击(3) MAC表洪水攻击(4) ARP攻击(5) VTP攻击 问：CSMA/CD例1： CSMA/CD适用于有线网络，而CSMA/CA则广泛应用于无线局域网。 四、 网络层问：IPv4地址分类连接在Internet中的每台主机(或路由器)都分配一个32bit的全球唯一的标识符，即IP地址。IP地址的编码方法有三种:分类的IP地址、子网的划分和CIDR。 传统的IP地址是分类的地址，分为A、B、C、D、E五类。无论哪类IP地址，都由网络号和主机号两部分组成。其中，网络号代表主机所连接到的网络，主机号代表该主机或路由器在网络中的地址。 A类地址(1~126)：网络号占前8位，以0开头，主机号占后24位。 B类地址(128~191)：网络号占前16位，以10开头，主机号占后16位。 C类地址(192~223)：网络号占前24位，以110开头，主机号占后8位。 D类地址(224~239)：以1110开头，保留为多播地址。 E类地址(240~255)：以1111开头，保留为今后使用。 在各类IP地址中，有一些IP地址用于表示特殊用途，不用于作主机IP地址: 主机号全为0表示本网络本身，例如202.98.174.0；主机号全为1表示本网络的广播地址，例如202.98.174.255。 网络号剩余字段全为0的IP地址是保留地址，表示本网络，如00000000+24位主机号 127.X.X.X网络保留做为环路自检地址，该地址表示任意主机本身，目的地址为环路自检地址的IP数据报永远不会出现在网络上。 32位全为1，即255.255.255.255表示整个TCP/IP网络的广播地址;32位全为0，即0.0.0.0表示本网络上的本主机。 问：网络地址转换网络地址转换(NAT)是通过将专用网络地址(如企业内网)转换为公用地址(如互联网Internet，从而对外隐藏了内部管理的IP地址。这样，通过在内部使用非注册的IP地址，并将它们转换为一小部分外部注册的IP地址，从而减少了IP地址注册的费用以及节省了日前越来越缺乏的IPv4地址空间。 此外，划出了部分IP地址为私有IP地址。私有IP地址值用于LAN，不用于WLAN连接。因此私有IP地址不能直接用于Internet，必须通过网关利用NAT把私有IP地址转换为Internet中合法的全球IP地址后才能用于Internet。私有IP地址有效地解决了IP地址不足的问题。私有IP地址网段如下: A类：1个A类网段，即10.0.0.0~10.255.255.255 B类：16个B类网段，即172.16.0.0~172.31.255.255 C类：256个C类网段，即192.168.0.0~192.168.255.255 在因特网中的所有路由器，对目的地址是私有地址的数据报一律不进行转发。使用NAT时，需要在专用网连接到因特网的路由器上安装NAT软件，NAT路由器至少有一个有效的外部全球地址。普通路由器在转发数据报时不改变其源IP地址和目的IP地址，且路由器工作在网络层，而NAT路由器在转发IP数据报时，一定要更换其IP地址(按路由器中的地址转换表转换源IP地址或目的IP地址)。NAT路由器转发数据报时需要查看和转换传输层的端口，其操作没有严格的层次关系。 问：子网划分与子网掩码各类地址的默认子网掩码： A类：255.0.0.0 B类：255.255.0.0 C类：255.255.255.00 使用子网划分时的地址格式: A类网络：8位+子网X位+主机24-X位 B类网络：16位+子网X位+主机16-X位 C类网络：24位+子网X位+主机8-X位 例1：使用子网掩码255.255.255.224可以将C类地址203.67.12.0分成多少个子网。 答案：8个 把子网掩码255.255.255.224转换成二进制：11111111.11111111.11111111.11100000 网络ID=24bits(C类地址)，子网ID=3位，主机ID=5位 所以，子网数位2^3=8个，每个子网的地址数为2^5=32个，每个子网的主机地址数为32-2=30个。 自所以减去2是因为全0和全1的主机号不能使用。 问：无分类编址CIDRCIDR是在使用可变长度子网掩码的基础上提出的一种消除传统A，B，C类网络划分，并且可以在软件的支持下实现超网构造的一种IP地址的网络划分方法。这样可以大幅度提高IP地址空间的利用率，并减小路由表大小，提高路由器的路由转发能力。 CIDR的主要特点如下: (1) 消除了传统的A，B，C类地址以及子网的概念，因而可以更加有效地分配IPv4的地址空间。CIDR使用”网络前缀”概念代替子网络概念。这样IP地址分为两部分:网络前缀、主机号。CIDR使用斜线记法，即IP地址/网络前缀所占比特数。其中，网络前缀所占比特数对应于网络号的部分，等效子网掩码中连续1的部分。 (2) 将网络前缀都相同的连续的IP地址组成”CIDR地址块”。一个CIDR地址块可以包括多个A、B、C类地址，这种地址的聚合称为路由聚合，或称为构成超网。路由聚合使得路由表中的一个表项可以表示很多个原来传统分类地址的路由，有利于减少路由之间的路由选择信息的交换，从而提高网络性能。 例1：CIDR地址块192.168.10.0/20所能包含主机的最大地址范围是多少？ 答案：192.168.0.1~192.168.15.254 CIDR地址由网络前缀和主机号构成。CIDR将网络前缀都相同的连续的IP地址组成&quot;CIDR&quot;地址块。 本题中，网络前缀的长度为20，把IP的第17~24bit写成二进制位00001010，这8bit中的前4bit为前缀，后4bit为主机号。 由于主机号不能为全0或全1，因此地址块所能包含的主机最大范围为192.168.0.1~192.168.15.254。 问：ARP是地址解析协议，简单语言解释一下工作原理。在实际网络的数据链路上传送数据时，最终必须使用硬件地址。所以需要一种方法来完成IP地址到MAC地址的映射，这就需要用到地址解析协议(ARP)。 每个主机(或路由器)都有一个ARP高速缓存，存放本局域网上各主机或路由器的IP地址到MAC地址的映射表，称为ARP表，主机(或路由器)使用ARP协议来动态维护此ARP表。 ARP工作在网络层，其工作原理是(广播发送ARP请求，单播发送ARP响应)： (1) 当主机源欲向本局域网上的某个目的主机发送IP数据报时，就先在其ARP高速缓存中查看有无目的主机的IP地址，如果有，就可以查出其对应的MAC地址，并将此地址写入MAC帧，然后通过局域网将该MAC帧发往此地址；如果没有，就通过使用目的MAC地址为FF-FF-FF-FF-FF-FF的帧来封装并广播ARP请求数据包(该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP地址)，可以使同一个局域网中的所有主机收到ARP请求。 (2) 当本局域网中的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后向源主机发出ARP响应包，该响应包中包含自己的IP地址与MAC地址的映射关系。 (3) 源主机收到ARP响应包后,将目的主机的IP和MAC地址的映射写入ARP表，然后按查询到的MAC地址发送MAC帧。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。 问：描述RARP协议RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。 工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。 问：ICMP协议(因特网控制报文协议，TCP/IP协议族IP层子协议)为了提高IP数据报交付成功的机会，网络层使用ICMP协议来允许主机或路由器报告差错和异常情况。ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去。 问：在局域网内使用ping www.nowcoder.com时，使用了哪些协议？Ping命令工作在应用层，它直接使用网络层的ICMP协议，而没有使用传输层的TCP或UDP协议。 (1) 首先将域名转换为IP地址，用到了应用层的DNS协议，而DNS协议使用了传输层的UDP协议。 (2) ping功能是测试另一台主机是否可达，程序发送一份ICMP回显请求给目标主机，并等待返回ICMP回显应答 (3) 数据在局域网中，根据MAC地址通过数据链路层传输，所以要用到ARP解析服务，获取到目的主机的MAC地址 问：IPv6IPv6由128bit构成，通常使用冒号十六进制记法表示IPv6地址，每个16bit的值用四位十六进制值表示，各值之间用冒号分割，如68E6:8C64:FFFF:FFFF:0:1180:960A:FFFF。该表示方法允许使用零压缩，即一连串连续的零可以为一对冒号所取代，如DE08:0:0:0:0:0:0:B3可以写成DE08::B3。IP地址0:0:0:0:0:0:118.17.23.1可以写成::118.17.23.10。 IPv6所引入的主要变化: 更大的地址空间。IPv6将地址从IPv4的32bit增大到了128bit; 扩展的地址层次结构； 灵活的首部格式； 改进的选项。这一特征加快了分组处理速度； 允许协议继续扩充； 支持即插即用； 支持资源的预分配； 增加了安全性，身份验证和保密验证是IPv6的关键特征； 分片限制为由源点来完成，是端到端的，路由途中的路由器不允许进行分片。 问：TTL例1：当路由器接收的IP报文的TTL值等于1时，采取的策略是什么？ 答案：丢掉该分组 问：广播风暴一个数据帧或包被传输到本地网段上的每个节点就是广播；由于网络拓扑的设计和连接问题，或其他原因导致广播在网段内大量复制，传播数据帧，导致网络性能下降，甚至网络瘫痪，这就是广播风暴。所以需要有能够隔离广播域的设备才可以抑制广播风暴。 五、 传输层问：UDP用户数据报协议(User Datagram Protocol)。UDP是一种无连接协议，因为UDP客户与服务器不必存在长期的关系，例如一个UDP客户创建一个套接字并发送一个数据报给一个服务器，然后立即用同一个套接字发送另一个数据报给另外一个服务器。同样，一个UDP服务器可以使用同一个套接字从若干不同的客户一连串接受多个数据报。 UDP不是可靠的，不能保证最终到达它们的目的地，不保证各个数据报的先后顺序跨越网络保持不变，也不保证每个数据报只到达一次。 UDP既可以使用IPv4，也可以使用IPv6。 问：TCP传输控制协议(Transmission Control Protocol)。 (1) TCP是一种面向连接的协议，提供客户与服务器的连接。 (2) TCP提供可靠性。当使用TCP向另一端发送数据时，它要求对端返回一个确认。如果没有收到确认，TCP自动重传数据并等待更长时间。在数次重传失败后，TCP才放弃。 (3) TCP通过给所发送数据的每一个字节关联一个序列号进行排序。UDP提供不可靠的数据报传送，不提供确认、序列号、超时重传等机制。 (4) TCP提供流量控制，而UDP不提供流量控制。TCP总是告诉对端它能够接收多少字节的数据，这称为通信窗口。该窗口在任何时刻都指出接收缓冲区中的可用空间，从而确保发送端发送的数据不会溢出接收缓冲区。 (5) TCP的连接是全双工的。UDP也可以是全双工的。 TCP既可以使用IPv4，也可以使用IPv6 0 UDP与TCP的主要区别在于UDP不一定提供可靠的数据传输。事实上，该协议不能保证数据准确无误地到达目的地。UDP在许多方面非常有效，如UDP具有对系统资源要求较少、具有较好的实时性、网络开销小的优点。当某个程序的目标是尽快地传输尽可能多的信息时(其中任意给定数据的重要性相对较低)，可使用UDP。 问：TCP和UDP的区别？TCP和UDP的区别： (1) TCP提供面向连接的、可靠的数据流传输；而UDP提供的是面向无连接的、不可靠的数据流传输。 (2) TCP协议保证数据按序发送，按序到达，提供超时重传来保证可靠性；但是UDP不保证按序到达，甚至不保证到达，只是努力交付，即便是按序发送的序列，也不保证按序送到。 (3) TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。 (4) TCP提供面向字节流的服务，UDP提供面向报文的服务。 (5) TCP有流量控制和拥塞控制；UDP没有，网络拥堵不会影响发送端的发送速率 (6) TCP支持一对一的连接；而UDP则可以支持一对一、多对多、一对多的通信。 (7) TCP由于提供面向连接的可靠的传输服务，因此不可避免地增加了许多开销，如确认、流量控制、计时器以及连接管理，这不仅使协议数据单元的头部增加很多，还占用许多处理机资源，因此TCP主要适用于可靠性更重要的场合，如文件传输协议FTP、超文本传输协议HTTP、远程登陆TELNET等；UDP由于在传送数据之前不需要先建立连接，远程主机的传输层收到UDP报文后，不需要给出任何确认，执行速度比较快、实时性较好，因此UDP主要适用于实时性要求高的场合，如小文件传输协议(TFTP)、DNS、SNMP和实时协议(RTP)。 例1 TCP对应的协议和UDP对应的协议 (1) TCP对应的协议： FTP：定义了文件传输协议，使用21端口。https://www.nowcoder.com/profile/7404313/test/8114836/23235?onlyWrong=0 Telnet：一个通过创建虚拟终端提供登陆到远程主机终端的协议，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。 SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。 POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。 HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。HTTP协议所用的是80端口。 (2) UDP对应的协议： DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。 SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。 TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。 问：常见的应用中有哪些是应用TCP协议的，哪些又是应用UDP协议的，为什么它们被如此设计？多播的信息一定要用udp实现，因为tcp只支持一对一通信。 如果一个应用场景中大多是简短的信息，适合用udp实现，因为udp是基于报文段的，它直接对上层应用的数据封装成报文段，然后丢在网络中，如果信息量太大，会在链路层中被分片，影响传输效率。 如果一个应用场景重性能甚于重完整性和安全性，那么适合于udp，比如多媒体应用，缺一两帧不影响用户体验，但是需要流媒体到达的速度快，因此比较适合用udp 如果要求快速响应，那么udp听起来比较合适 如果又要利用udp的快速响应优点，又想可靠传输，那么只能考上层应用自己制定规则了。 常见的使用udp的例子：ICQ,QQ的聊天模块。 以qq为例的一个说明（转载自知乎） 登陆采用TCP协议和HTTP协议，你和好友之间发送消息，主要采用UDP协议，内网传文件采用了P2P技术。总来的说： 1.登陆过程，客户端client 采用TCP协议向服务器server发送信息，HTTP协议下载信息。登陆之后，会有一个TCP连接来保持在线状态。 2.和好友发消息，客户端client采用UDP协议，但是需要通过服务器转发。腾讯为了确保传输消息的可靠，采用上层协议来保证可靠传输。如果消息发送失败，客户端会提示消息发送失败，并可重新发送。 3.如果是在内网里面的两个客户端传文件，QQ采用的是P2P技术，不需要服务器中转。 问：TCP三次握手和四次挥手的全过程 (1) 三次握手 第一次握手(SYN=1，seq=x)：客户端首先向服务器发送一个连接请求报文段，并进入SYN_SEND状态，等待服务器确认。这个报文段不含应用层数据，其首部中的SYN标志位被置为1，另外，客户端会随机选择一个起始序号seq=x。(连接请求报文段不携带数据，但要消耗一个序号) 第二次握手(SYN=1, ACK=1, seq=y, ack=x+1)：服务器收到连接请求报文段，如同意建立连接，就向客户端发回确认，并为该TCP连接分配TCP缓存和变量，此时服务器进入SYN_RECV状态。在确认报文段中，SYN和ACK位都被置为1，确认号字段的值为x+1，并且服务器随机产生起始序号seq=y。确认报文段同样不包含应用层数据。 第三次握手(ACK=1, seq=x+1, ack=y+1)：当客户端收到确认报文段后，还要向服务器给出确认，并且也要给该连接分配缓存和变量，客户端和服务器进入ESTABLISHED状态，完成三次握手。这个报文段的ACK标志位被置1，序号字段为x+1，确认号字段ack=y+1。(该报文段可以携带数据，如果不携带数据则不消耗序号)。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。 例1 四次挥手 与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。 第一次挥手(FIN=1，seq=u)：主动关闭方打算关闭连接，就向被动关闭方发送一个连接释放报文段并停止再发送数据，进入FIN_WAIT1状态，主动关闭TCP连接。该报文段的FIN标志位被置为1，seq=u，它等于前面已传送过的数据的最后一个字节的序号加1(FIN报文段即使不携带数据，也要消耗一个序号)。当发送FIN报文时，发送FIN的一方就不能再发送数据了(当然，在FIN包之前发送出去的数据，如果没有收到对应的确认报文，主动关闭方依然会重发这些数据)，也就是关闭了其中一条数据通路，但此时对方还可以发送数据，主动关闭方还可以接受数据。 第二次挥手(ACK=1，seq=v，ack=u+1)：被动关闭方收到连接释放报文段后即发出确认，并进入CLOSE_WAIT状态，确认号是ack=u+1，而这个报文段自己的序号是v，等于它前面已经传送过的数据最后一个字节的序号加1。此时，从主动关闭方到被动关闭方这个方向的连接就释放了，TCP连接处于半关闭状态，但被动关闭方若发送数据，主动关闭方仍要接收。 第三次挥手(FIN=1，ACK=1，seq=w，ack=u+1)：若被动关闭方已经没有要向主动关闭方发送的数据，就通知TCP释放连接，此时其发出FIN=1的连接释放报文段，进入LAST_ACK状态。 第四次挥手(ACK=1，seq=u+1，ack=w+1)：主动关闭方收到连接释放报文段后，必须发出确认。在确认报文段中，ACK字段被置1，确认号ack=w+1，序号seq=u+1。进入TIME_WAIT状态，至此，完成四次挥手。 此时，TCP连接还没有释放掉，必须经过时间等待计时器设置的时间2MSL后，主动关闭方才进入连接关闭状态。 例1:看评论中的图，例2，例3，例4 问：为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的连接请求后，它可以把ACK和SYN(ACK起应答作用，而SYN起同步作用)放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能未必会马上会关闭SOCKET，也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。 问：TCP的三次握手过程中，为什么会采用三次握手，若采用二次握手可以吗？建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。 采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。 考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，若不采用三次握手，新的连接就建立了，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。 采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。 例1 问：TCP的四次挥手过程中，为什么TIME_WAIT状态需要等待2MSL(最大报文段生存时间)才能返回到CLOSE状态？(1) 保证A发送的最后一个ACK报文段能够成功到达B A发送的最后一个ACK报文段可能会丢失，因而使得处在LAST_ACK状态的B收不到对已发送的FIN和ACK报文段的确认。B会超时重传这个FIN和ACK报文段，而A就能在2MSL时间内收到这个重传的ACK+FIN报文段，接着A重传一次确认。 (2) 防止已失效的连接请求报文段出现在本连接中 A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续时间内所产生的所有报文段都从网络中消失。 问：TCP拥塞控制-慢启动和拥塞避免例1 六、 应用层问：FTP协议问：DNS域名系统，简单描述其工作原理。域名系统DNS(Domain Name System)是因特网使用的命名系统，用来把便于人们记忆的含有特定含义的主机名(如www.baidu.com)转换成便于机器处理的IP地址。DNS系统采用客户/服务器模型，其协议运行在UDP之上，使用53号端口。该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。 工作原理 当客户端需要域名解析时，通过本机的DNS客户端构造一个DNS请求报文，以UDP数据报方式发往本地域名服务器。域名解析有两种方式：递归查询(实际中几乎不使用)和迭代查询。 (1) 递归查询 如果本地主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向根域名服务器继续发出查询请求报文(即替该主机继续查询)，而不是让主机自己进行下一步的查询。在这种情况下，本地域名服务器只需向根域名服务器查询一次，后面的几次查询都是递归地在其他几个域名服务器之间进行的(如图a步骤3-6)。在步骤7中，本地域名服务器从根域名服务器得到了所需的IP地址，最后在步骤8中，本地域名服务器把查询结果告诉主机。 (2) 迭代查询 当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地域名服务器：“你下一次应当向哪个顶级域名服务器进行查询”，然后让本地域名服务器向这个顶级域名服务器进行后续的查询，如图b所示。同样，顶级域名服务器收到查询报文后，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步应当向哪一个域名服务器查询。最后，本地域名服务器知道了所要解析的域名的IP地址，然后把查询结果返回给发起查询的主机。 问：HTTP协议的特点建议阅读：HTTP协议详解 HTTP协议的主要特点可概括如下： 支持客户/服务器模式。 简单快速。客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活。HTTP允许传输任意类型的数据对象，传输的类型由Content-Type加以标记。 无连接。无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态。HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 例1，例2 问：如何理解HTTP协议的”无连接”特点？无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。早期这么做的原因是：服务器需要处理全世界数十万、上百万客户端的网页访问，但每个客户端(即浏览器)与服务器之间数据交换的间歇性较大(即传输具有突发性、瞬时性)，并且网页浏览的联想性、发散性导致两次传送的数据关联性很低，大部分通道实际上会很空闲、无端占用资源。因此HTTP的设计者有意利用这种特点将协议设计为请求时建连接、请求完释放连接，以尽快将资源释放出来服务其他客户端。 随着时间的推移，网页变得越来越复杂，里面可能嵌入了很多图片，这时候每次访问图片都需要建立一次TCP连接就显得很低效。后来，Keep-Alive被提出用来解决效率低的问题。Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开(超过 Keep-Alive 规定的时间，意外断电等情况除外)，当客户端发送另外一个请求时，就使用这条已经建立的连接。市场上的大部分Web服务器，包括iPlanet、IIS和Apache等，都支持HTTP Keep-Alive。 对于提供静态内容的网站来说，这个功能通常很有用。但是，对于负担较重的网站来说，这里存在另外一个问题：虽然为客户保留打开的连接有一定的好处，但它同样影响了性能，因为在处理暂停期间，本来可以释放的资源仍旧被占用。当Web服务器和应用服务器在同一台机器上运行时，Keep-Alive功能对资源利用的影响尤其突出。 问：如何理解HTTP协议的”无状态”特点？HTTP是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive没能改变这个结果。无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送HTTP请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何。 HTTP协议这种特性有优点也有缺点：缺点在于如果后续处理需要前面的信息，则它必须重传，每次请求会传输大量重复的内容信息，也导致每次连接传送的数据量增大。优点在于在服务器不需要先前信息时它的应答就较快；同时也解放了服务器，每一次请求”点到为止”不会造成不必要的连接占用， 然而，当客户端与服务器进行动态交互的Web应用程序出现之后，HTTP无状态的特性严重阻碍了这些应用程序的实现，毕竟交互是需要承前启后的，简单的购物车程序也要知道用户到底在之前选择了什么商品。于是，两种用于保持HTTP连接状态的技术就应运而生了，一个是Cookie，而另一个则是Session。 (1) Cookie Cookie可以保持登录信息到用户下次与服务器的会话，换句话说，下次访问同一网站时，用户会发现不必输入用户名和密码就已经登录了(当然，不排除用户手工删除Cookie)。而还有一些Cookie在用户退出会话的时候就被删除了，这样可以有效保护个人隐私。Cookies 最典型的应用是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进入此网站时保留用户信息以便简化登录手续，这些都是 Cookies 的功用。另一个重要应用场合是“购物车”之类处理。用户可能会在一段时间内在同一家网站的不同页面中选择不同的商品，这些信息都会写入 Cookies，以便在最后付款时提取信息。 (2) Session 与Cookie相对的一个解决方案是Session，它是通过服务器来保持状态的。当客户端访问服务器时，服务器根据需求设置 Session，将会话信息保存在服务器上，同时将标示Session的SessionId传递给客户端浏览器，浏览器将这个SessionId保存在内存中，我们称之为无过期时间的Cookie。浏览器关闭后，这个Cookie就会被清掉，它不会存在于用户的Cookie临时文件。以后浏览器每次请求都会额外加上这个参数值，服务器根据这个SessionId，就能取得客户端的数据信息。如果客户端浏览器意外关闭，服务器保存的Session数据不是立即释放，此时数据还会存在，只要我们知道那个 SessionId，就可以继续通过请求获得此 Session的信息，因为此时后台的 Session还存在，当然我们可以设置一个 Session超时时间，一旦超过规定时间没有客户端请求时，服务器就会清除对应 SessionId 的Session信息。 问：在浏览器中输入www.baidu.com后执行的全部过程事件顺序 (1) 浏览器获取输入的域名www.baidu.com (2) 浏览器向DNS请求解析www.baidu.com对应的IP地址 (3) 域名系统DNS解析出百度服务器的IP地址 (4) 浏览器与该服务器建立TCP连接(默认端口号80)，并向服务器发送HTTP请求，请求百度首页 (6) 服务器通过HTTP响应把首页文件发送给浏览器 (7) TCP连接释放 (8) 浏览器将首页文件进行解析，并将Web页显示给用户。 涉及到的协议 (1) 应用层：HTTP(WWW访问协议)，DNS(域名解析服务) (2) 传输层：TCP(为HTTP提供可靠的数据传输)，UDP(DNS使用UDP传输) (3) 网络层：IP(IP数据数据包传输和路由选择)，ICMP(提供网络传输过程中的差错检测)，ARP(将本机的默认网关IP地址映射成物理MAC地址) 问：常见的http协议状态码网络上的一份总结 http1.1状态吗分为五类，所有状态码的第一个数字代表了响应的五种状态之一。 1xx:消息，这一类型的状态码，代表请求已被接受，需要继续处理。其中100表示客户端应当继续发送请求。 2xx:成功，这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。其中200表示请求已成功，请求所希望的响应头或数据体将随此响应返回。 3xx:重定向。 302 临时重定向，(此时浏览器会产生两次http请求) 4xx:客户端错误。其中400表示:语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求；或者请求参数有误。 400 请求报文存在语法错误 403 禁止访问，资源不可用 404 请求的资源不存在 5xx:服务器错误。 500 服务器内部错误 503 服务器繁忙 问：HTTP请求方法OPTIONS、HEAD、GET、POST、PUT、DELETE、TRACE、CONNECT 七、 常用网络测试工具问：pingping是用来检查网络是否通畅或者网络连接速度的命令。 它所利用的原理是这样的:利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通、时延是多少。ping命令是控制台命令，例如Ping百度的用法如下: ping www:baidu.com 问：tracerttracert是路由跟踪实用程序，用于确定IP数据包访问目标所采取的路径。 tracert命令用IP生存时间(TTL)字段和ICMP错误消息来确定从一个主机到网络上其他主机的路由。其命令格式如下: tracert[-d] [-h maximum_hops] [-j computer_list] [-w timeout] target_name 可以使用tracert命令确定数据包在网络上的停留位置。例如:tracert www:baidu.com则会打印出从当前主机到目的主机所经过的路由地址。 问：telnettelnet在网络测试中十分有用，例如可以用telnet测试80端口的Web服务器是否正常工作。输入: telnet www.hitsz .edu.cn 80 然后服务器响应: Trying 219.223.252.3... Connected to www.hitsz.edu.cn Eseape character is &apos;^]&apos;. 然后输入: GET / HTTP1.1 如果Web服务器正常工作的话，就会返回服务器的响应头，以便你确认服务器的情况。 问：netstatnetstat是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每个网络接口设备的状态信息。 netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。使用格式为: netstat [-a] [-e] [-n] [-o] [-p Protocol] [-r] [-s] [Interval] 一般用netstat -an来显示所有连接的端口并用数字表示。 例1：某校园网用户无法访问外部站点210.102.58.74，管理人员在Windows操作系统下可以使用()命令判断故障发生在校园网内还是校园网外。 A. ping 210.102.58.74 B. tracert 210.102.58.74 C. netstat 210.102.58.74 D. arp 210.102.58.74 答案：B 八、 其他东西问：往返时延和网络延迟往返时延(Round-Trip Time, RTT):表示从发送端发送数据开始，到发送端收到来自接收端的确认(接收端收到数据后便立即发送确认)，总共经历的时延。 网络延迟是数据进入网络到离开网络所花费的总时间。 使用最广泛是的B通路B通路：具有定时的64Kbit/s通路，用于传递广泛的各种用户信息流，不传递ISDN电路交换的信令信息。 D通路：主要用于传递ISDN电路交换的信令信息，也可以传递遥信信息和分组交换数 据。D通路可以有不同的比特率， H通路：H通路有以下几种传输速率： H0通路：384Kbit/s H11通路：1536 Kbit/s H12通路：1920 Kbit/s H通路用于传递各种用户信息流，例如高速传真、电视影像、高质量音频或声音节目、高速数据、分组交换信息等，不传递ISDN电路交换的信令信息。 https://www.nowcoder.com/profile/7404313/test/8046849/14529?onlyWrong=0 https://www.nowcoder.com/profile/7404313/test/7959409/3989?onlyWrong=0","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://hepsilion.github.io/tags/计算机网络/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"操作系统","slug":"操作系统","date":"2017-03-16T10:53:28.000Z","updated":"2017-10-21T13:19:21.491Z","comments":true,"path":"2017/03/16/操作系统/","link":"","permalink":"https://hepsilion.github.io/2017/03/16/操作系统/","excerpt":"操作系统","text":"操作系统 一、 概述二、 进程管理问：进程进程(Process)是计算机中已运行程序的实体。程序本身只是指令的集合，进程才是程序(那些指令)的真正运行。用户下达运行程序的命令后，就会产生进程。同一程序可产生多个进程(一对多关系)，以允许同时有多位用户运行同一程序，却不会相互冲突。进程需要一些资源才能完成工作，如CPU使用时间、存储器、文件以及I/O设备，且为依序逐一进行，也就是任何时间内仅能运行一项进程。 通常进程有如下5种状态，其中前3种是进程的基本状态。 运行状态:进程正在处理器上运行。在单处理器环境下，每一时刻最多只有一个进程处于运行状态。 就绪状态:进程已处于准备运行的状态，即进程获得了除处理器之外的一切所需资源，一旦得到处理器即可运行。 阻塞状态:又称为等待状态，进程正在等待某一事件而暂停运行，如等待某资源为可用(不包括处理器)或等待输入/输出完成。即使处理器空闲，该进程也不能运行。 创建状态:进程正在被创建，尚未转到就绪状态。 结束状态:进程正从系统中消失。可能是进程正常结束或其他原因中断退出运行。 进程的三个基本状态之间是可以相互转换的。具体地说，当一个就绪进程获得处理机时，其状态由就绪变为执行；当一个运行进程被剥夺处理机时，如用完系统分给它的时间片、出现更高优先级别的其他进程，其状态由运行变为就绪；当一个运行进程因某事件受阻时，如所申请的资源被占用、启动I/O传输未完成，其状态由执行变为阻塞；当所等待事件发生时，如得到申请的资源、I/O传输完成，其状态由阻塞变为就绪。 问：进程的特征 并发性：指多个进程实体同存于内存中，且在一段时间内同时运行。并发性是进程的重要特征，同时也成为操作系统的重要特征。 动态性：进程的实质是进程实体的一次执行过程，因此，动态性是进程最基本的特征。 独立性：进程实体是一个独立运行、独立分配资源和独立接受调度的基本单位。 异步性：指进程按各自独立的、不可预知的速度向前推进，或者说实体按异步方式运行。 问：进程与程序的区别 进程是程序及其数据在计算机上的一次运行活动，是一个动态的概念。进程的运行实体是程序、离开程序的进程没有存在的意义。从静态角度看，进程是由程序、数据和进程控制块(PCB)三部分组成的。而程序是一组有序的指令集合，是一种静态的概念。 进程是程序的一次执行过程，它是动态地创建和消亡的，具有一定的生命期，是暂时存在的；而程序则是一组代码的集合，它是永久存在的，可长期保存。 一个进程一可以执行一个或几个程序，一个程序也可以构成多个进程。进程可创建进程，而程序不可能形成新的程序。 进程与程序的组成不同。进程的组成包括程序、数据和进程控制块。 创建新进程时会创建新的地址空间:子进程是父进程的复制品，在fork之后子进程获得父进程的数据空间、堆和栈的复制。而线程使用当前的地址空间。 例1：请问下面的程序一共输出多少个”-“() #include&lt;stdio.h&gt; #include&lt;sys/types.h&gt; #include&lt;unistd.h&gt; int main(void){ int i; for(i=0; i&lt;2; i++){ fork(); printf(&quot;-&quot;); } return 0; } 答案：8个。 程序一开始，产生一个进程P1执行此程序，P1进入程序后，此时i=0，于是进入循环体，fork()产生一个子进程P2，接着P1执行下一条语句输出一个&quot;-&quot;(其实是放入缓冲区，等合适的时候再输出，我们将此&quot;-&quot;记为a)； P2成为一个独立的子进程，继承P1的诸如环境变量、PC等环境，P2也执行下一条语句输出一个&quot;-&quot;(其实是放入缓冲区，等合适的时候再输出，我们将此&quot;-&quot;记为b)，同时P2中此时i=1，继续执行for循环---P2先fork()出一个子进程P3，然后P2再执行下一条语句输出一个&quot;-&quot;(其实是放入缓冲区，等合适的时候再输出，我们将此&quot;-&quot;记为c)。 P3进程为P2的子进程，它会复制其父进程P2的诸如环境变量、PC等环境，它执行下一条语句(输出语句)本应该输出一个&quot;-&quot;，但事实上因为这里P3会继承P2的缓冲区，而P2的缓冲区中有个&apos;-&apos;(P2调用fork产生P3时缓冲区里有b)，所以P3会输出两个&apos;-&apos;。 P1产生子进程P2后，继续下一轮循环，当i=1时，fork()产生另一个它的子进程P4，同时P1执行输出语句输出一个&apos;-&apos;。 P4为P1的一个子进程，它会继承P1的缓冲区，P1缓冲区中已经有一个&apos;-&apos;(P1调用fork产生P4时缓冲区里有a)，所以P4执行输出语句时会输出两个&apos;-&apos;。 上述输出语句本应该都输出一个&apos;-&apos;，有时却输出两个&apos;-&apos;，是因为&quot;printf(&quot;-&quot;)&quot;语句不是立即输出，而是先将输出放入缓冲区。所以，在fork的时候，缓存被复制到了子进程空间，导致子进程的输出缓冲区己经有了一个&apos;-&apos;。 例2：请问下而的程序一共输出多少个”-“()？ #include&lt;stdio.h&gt; #include&lt;sysltypes.h&gt; #include&lt;unistd.h&gt; int main(void){ int i; for(i=0; i&lt;2; i++){ fork(); printf(&quot;-\\n&quot;); } return 0 } 答案：6个 输出&apos;\\n&apos;会刷新缓冲区，故正常输出6个。 问：线程线程，有时被称为轻量级进程(Light weight Process，LWP)，是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针(PC)、寄存器集合和堆栈(stack)组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的资源。 线程共享的进程环境包括:进程代码段、进程的公有数据(如全局变量，利用这些共享的数据，线程很容易的实现相互之间的通信)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。 线程拥有这许多共性的同时，还拥有自己的个性。有了这些个性，线程才能实现并发性。这些个性包括: 线程ID：每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程。 寄存器组的值：由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有线程的寄存器集合的状态进行保存，以便将来该线程在被重新切换时能得以恢复。 线程的堆栈(stack)：堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影啊。在一个进程的线程共享堆区(heap)。 错误返回码 线程的信号屏蔽码 线程的优先级 一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。线程是程序中一个单的顺序控制流程。在单个程序中同时运行多个线程完成不同的工作，称为多线程。 引入线程后，进程的内涵发生了改变，进程只作为除CPU以外系统资源的分配单元，线程则作为处理器的分配单元。在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，将会引起进程的切换。 例1：有关多线程，多进程的描述错误的是()。 A.子进程获得父进程的数据空间，堆和栈的复制品 B.线程可以与同进程的其他线程共享数据，但是它拥有自己的栈空间且拥有独立的执行序列 C.线程执行开销小，但是不利于资源管理和保护 D.进程适合在SMP机器上进行，而线程则可以跨机器迁移 答案：D。 线程不能跨机器迁移。 问：进程与线程的区别(1) 调度:在传统操作系统中，拥有资源和独立调度的基本单位都是进程。引入线程后，线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行的线程切换，则会引起进程切换。 (2) 拥有资源:不论是传统的还是引入线程的操作系统，进程都是拥有资源的基本单位，线程不拥有资源(也有一点必不可少的资源)，但线程可以共享其隶属进程的系统资源。 (3) 并发性:在引入线程的操作系统中，不仅进程可以并发执行，而且同一进程内的多个线程也可以并发执行，从而使操作系统具有更好的并发性，大大提高了系统吞吐量。 (4) 系统开销:创建和撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，因此操作系统所付出的开销远远大于创建或撤销线程的开销。类似地，在进程切换时，涉及当前执行进程CPU环境的保存以及新调度的进程CPU环境的设置；而线程切换时只需保存和设置少量寄存器内容，因此开销很小。另外，由于同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信比较容易实现，甚至无须操作系统的干预。 (5) 地址空间和其他资源(如打开的文件):进程的地址空间之间互相独立，同一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见。 (6) 通信方面:进程间通信需要借助操作系统，而线程间可以直接读/写进程数据段(如全局变量)来进行通信。 举例：若系统中只有用户级线程，则处理机调度单位是进程。 原因：如果系统只有用户态线程，则线程对操作系统是不可见的，操作系统只能调度进程；如果系统中有内核态线程，则操作系统可以按线程进行调度； 例1 问：进程的重要性与进程的销毁顺序进程的重要性依次是：前台进程&gt;可见进程&gt;服务进程&gt;后台进程&gt;空进程。进程销毁的顺序为逆方向。 问：进程控制原语原语是由若干条机器指令所构成，用以完成特定功能的一段程序，为保证其操作的正确性，它应当是原子操作，即原语是一个不可分割的操作。所以，原语在执行的过程中，是不可以被中断的。 操作系统对进程的管理和控制主要是通过控制原语言实现的，包括：进程创建，进程阻塞，唤醒进程和进程终止四个原语。 问：调度的基本准则调度的基本准则包括CPU利用率、系统吞吐量、周转时间、等待时间、响应时间等。 系统吞吐量表示单位时间内CPU完成作业的数量。 周转时间为作业完成时刻减去作业到达的时刻。 等待时间是指进程处于等待处理器状态的时间之和，等待时间越长，用户满意度越低。 响应时间是指从用户提交请求到系统首次产生响应所用的时间。 问：调度算法典型调度算法包括：先来先服务算法(FCFS)，短作业优先算法(SJF)、优先级调度算法、高响应比优先调度算法、时间片轮转算法、多级反馈队列调度算法。 注意： 高响应比优先调度算法中，响应比=(等待时间+服务时间)/服务时间 短作业优先算法的平均等待时间、平均周转时间最少。 一道很好的题目： 问：进程通信与进程同步多个进程可以共享系统中的各种资源，但其中许多资源一次只能被一个进程使用，我们把一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。对临界资源的访问，必须互斥的进行，在每个进程中，访问临界资源的那段代码称为临界区(Critical Section)。 (1) 进程通信与同步有如下一些目的 数据传输:一个进程需要将它的数据发送给另一个进程; 共享数据:多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到; 通知事件:一个进程需要向另一个或一组进程发送消息，通知它(它们)发生了某种事件(如进程终止时要通知父进程)。 资源共享:多个进程之间共享同样的资源。为了做到这一点，需要内核提供锁和同步机制; 进程控制:有些进程希望完全控制另一个进程的执行(如Debug进程)，此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。 (2) 进程间、线程间的通信方式 Linux下进程间通信的方式 管道(Pipe)及有名管道(named pipe):管道可用于具有亲缘关系的进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信; 信号(Signal):信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；Linux除了支持UNIX早期信号语义函数sigal外，还支持语义符合Posix标准的信号函数sigaction； Message(消息队列):消息队列是消息的链表，包括Posix消息队列System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。 共享内存:使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其他通信机制，如信号量结合使用，来达到进程间的同步及互斥。 信号量(semaphore)：主要作为进程间以及同一进程不同线程之间的同步手段。 套接字(Socket)：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由UNIX系统的BSD分支开发出来的，但现在一般可以移植到其他类UNIX系统上:Linux和System V的变种都支持套接字。 Linux线程间通信的方式：互斥量(Mutex)，信号量，条件变量。 Windows进程间通信的方式：管道、共享内存、消息队列、信号量、socket Windows线程间通信的方式：临界区(Critical Section)，互斥量(Mutex)、信号量(Semaphore)和事件(Event)。 例1 (3) 临界区(Critical section)与互斥量(Mutex)的区别 临界区只能用来同步本进程内的线程，而不可用来同步多个进程中的线程；互斥量(Mutex)、信号量(Semaphore)、事件(Event)都可以被跨越进程使用来进行同步数据操作; 临界区是非内核对象，只在用户态进行锁操作，速度快；互斥体是内核对象，在核心态进行锁操作，速度慢。 临界区和互斥体在Windows平台都下可用，Linux下只有互斥量可以使用。 例1： 在win32平台下，Event、Semaphore、Mutex能够实现进程同步，Critical Section无法实现进程同步。 问：死锁(1) 死锁的概念 所谓死锁是指多个进程因竞争资源而造成的一种僵局(相互等待)，若无外力作用，这些进程都将无法向前推进。现实生活中一个简单的例子:交通阻塞，两股相向而行的车流都想通过已被对方占用的道路，结果双方都不能前进。 (2) 死锁的原因 系统资源的竟争 进程推进顺序非法 (3) 死锁产生的必要条件 产生死锁必须同时满足以下四个条件，只要其中任意一个条件不成立，死锁就不会发生。 互斥条件:进程要求对所分配的资源进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。 不剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放。 请求和保持条件:又称为部分分配条件。进程每次申请它所需要的一部分资源，在等待新资源的同时，进程继续占有已分配到的资源。 循环等待条件:存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所清求。即存在一个处于等待状态的进程集合{P1，P2，P3，…，Pn}，其中Pi等待的资源被P(i+1)占有，Pn等待的资源被P0占有。 (4) 死锁处理策略 预防死锁:设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个。 避免死锁:在资源的动态分配过程中，用某种方法防止系统进入不安全状态。银行家算法是著名的死锁避免算法。 死锁的检测及解除:无须采取任何限制性措施，允许进程在运行过程中发生死锁，通过系统的检测机制及时地检测出死锁的发生，然后采取某种措施解除死锁。 死锁的检测可利用资源分配图来描述。 死锁的解除主要方法如下：资源剥夺法、撤销进程法、进程回退法。 问：锁的类型例1 三、 内存管理操作系统对内存的划分和动态分配，就是内存管理的概念。内存管理的功能有: 内存空间的分配与回收，包括内存的管理和共享。 地址转换，把逻辑地址转换成相应的物理地址。 内存空间的扩充，利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存。 存储保护，保证各道作业在各自的存储空间内运行，互不干扰。 问：GB、MB和KB换算1GB=1024MB 1MB=1024KB 问：逻辑地址空间与物理地址空间编译后，每个目标模块都是从0号单元开始编址，称为该目标模块的相对地址(或逻辑地址)。当链接程序将各个模块链接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从0号单元开始编址的逻辑地址空间。 物理地址空间是指内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据都要通过物理地址来存取主存。当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为地址重定位。 问：静态重定位和动态重定位对程序进行重定位的技术按重定位的时机可分为两种：静态重定位和动态重定位。现在一般计算机系统中都采用动态重定位方法。 (1) 静态重定位：是在目标程序装入内存时，由装入程序对目标程序中的指令和数据的地址进行修改，即把程序的逻辑地址都改成实际的地址。对每个程序来说，这种地址变换只是在装入时一次完成，在程序运行期间不再进行重定位。 优点：是无需增加硬件地址转换机构，便于实现程序的静态连接。在早期计算机系统中大多采用这种方案。 缺点： 程序的存储空间只能是连续的一片区域，而且在重定位之后就不能再移动。这不利于内存空间的有效使用。 各个用户进程很难共享内存中的同一程序的副本。 (2) 动态重定位：是在程序执行期间每次访问内存之前进行重定位。这种变换是靠硬件地址变换机构实现的。通常采用一个重定位寄存器，其中放有当前正在执行的程序在内存空间中的起始地址，而地址空间中的代码在装入过程中不发生变化。 优点： 程序占用的内存空间动态可变，不必连续存放在一处。 比较容易实现几个进程对同一程序副本的共享使用。 缺点：是需要附加的硬件支持，增加了机器成本，而且实现存储管理的软件算法比较复杂。 例1：能实现紧凑技术的存储管理方式为？ A. 可变分区管理 B. 分区存储管理 C. 页式存储管理 D. 可重定位存储管理 答案：D 内存分配管理方式内存分配管理方式包括连续分配管理方式与非连续分配管理方式。 连续分配方式，是指为一个用户程序分配一个连续的内存空间。它主要包括单一连续分配、固定分区分配和动态分区分配。 非连续分配管理方式允许一个程序分散地装入到不相邻的内存分区中，根据分区的大小是否固定分为分页存储管理方式和分段存储管理方式。分页存储管理方式中，又根据运行作业时是否要把作业的所有页而都装入内存才能运行分为基本分页存储管理方式和请求分页存储管理方式。 问：动态分区分配(1) 首次适应(First Fit)算法 空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。 该算法优先使用低址部分空闲区，在低址空间造成许多小的空闲区，在高地址空间保留大的空闲区。 (2) 最佳适应(Best Fit)算法 空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。 (3) 最坏适应(Worst Fit)算法，又称为最大适应(Largest Fit)算法 空闲分区按容量递减形成分区链，找到第一个能满足要求的空闲分区，也就是找出最大的分区。 (4) 邻近适应(Next Fit)算法，又称为循环首次适应算法 该算法是首次适应算法的变种，不同之处是分配时从上次查找结束的位置开始继续查找。 该算法能使内存中的空闲区分布得较均匀。 问：基本分页存储管理方式固定分区会产生内部碎片，动态分区会产生外部碎片，这两种技术对内存的利用率都比较低。我们希望内存的使用能尽量避免碎片的产生，这就引入了分页的思想:把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。 分页的方法从形式上看，像分区相等的固定分区技术，分页管理不会产生外部碎片。但它又有本质的不同点:块的大小相对分区要小很多，而且进程也按照块进行划分，进程运行时按块申请主存可用空间并执行。这样，进程只会在为最后一个不完整的块申请一个主存块空间时，才产生主存碎片，所以尽管会产生内部碎片，但是这种碎片相对于进程来说也是很小的，每个进程平均只产生半个块大小的内部碎片(也称页内碎片)。 分页存储的几个基本概念： (1) 页面和页面大小。 进程中的块称为页(Page)，内存中的块称为页框(Page Frame，或页帧)。外存也以同样的单位进行划分，称为块(Block)。进程在执行时需要申请主存空间，就是要为每个页面分配主存中的可用页框，这就产生了页和页框的一一对应。 为方便地址转换，页面大小应是2的整数幂。同时页面大小应该适中，如果页面太小，会使进程的页面数过多，这样页表就过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面换入/换出的效率；页面过大又会使页面内碎片增大，降低内存的利用率。所以页面的大小应该适中，考虑到空间效率和时间效率的权衡。 (2) 地址结构。 分页存储管理的逻辑地址结构如下图所示： 地址结构包含两部分:前一部分为页号P，后一部分为页内偏移量M。地址长度为32位，其中0~11位为页内地址，即每页大小为4KB;12~31位为页号，地址空间最多允许有2^20页。 (3) 页表。 为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般存放在内存中。在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射。 问：基本分段存储管理方式段式管理方式按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段，每段从0开始编址，并分配一段连续的地址空间(段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的)。其逻辑地址由段号S与段内偏移量W两部分组成。 在下图中，段号为16位，段内偏移量为16位，则一个作业最多可有2^16=65536个段，最大段长为64KB。 在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在段式系统中，段号和段内偏移量必须由用户显示提供，在高级程序设计语言中，这个工作由编译程序完成。 问：段页式管理方式页式存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享。如果将这两种存储管理方法结合起来，就形成了段页式存储竹理方式。 在段页式系统中，作业的地址空间首先被分成若干逻辑段，每段都有自己的段号，然后再将每一段分成若干大小固定的页。对内存空间的管理仍然和分页存储管理一样，将其分成若干和页面大小相同的存储块，对内存的分配以存储块为单位。 在段页式系统中，作业的逻辑地址分为三部分:段号、页号和页内偏移量。为了实现地址变换，系统为每个进程建立一张段表，而每个分段有一张页表。段表表项中至少包括段号、页表长度和页表起始地址，页表表项中至少包括页号和块号。此外，系统中还应有一个段表寄存器，指出作业的段表起始地址和段表长度。在进行地址变换时，首先通过段表查到页表起始地址，然后通过页表找到页帧号，最后形成物理地址。 问：虚拟存储器的定义和特征基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。之所以将其称为虚拟存储器，是因为这种存储器实际上并不存在，只足由于系统提供了部分装入、请求调入和置换功能后(对用户完全透明)，给用户的感觉是好像存在一个比实际物理内存人得多的存储器。 虚拟内存的实现有以下三种方式: 请求分页存储管理 请求分段存储管理 请求段页式存储管理 段页式虚拟存储器一方面具有段式虚拟存储器的主要优点。例如，用户程序可以模块化编写，程序段的共享和信息的保护都比较方便，程序可以在执行时再动态链接等。另一方面也具有页式虚拟存储器的主要优点。例如:主存储器的利用率比较高，对辅助存储器的管理比较容易等。 不管哪种方式，都需要有一定的硬件支持。一般需要的硬件支持有以下个方面： 一定容量的内存和外存； 页表机制(或段表机制)，作为主要的数据结构； 中断机构，当用户程序要访问的部分尚未调入内存，则产生中断； 地址变换机构，逻辑地址到物理地址的变换。 例1： 问：请求分页管理方式请求分页系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。 在请求分页系统中，只要求将当前需要的一部分页面装入内存，便可以启动作业运行。在作业执行过程中，当所要访问的页面不在内存时，再通过调页功能将其调入，同时还可以通过置换功能将暂时不用的页面换出到外存上，以便腾出内存空间。为了实现请求分页，系统必须提供一定的硬件支持。除了需要一定容量的内存及外存的计算机系统，还需要有页表机制、缺页中断机构和地址变换机构。 常见的置换算法有一下三种:最佳置换算法(OPT)、先进先出页面置换算法(FIFO)、最近最久未使用置换算法(LRU)。 问：页面置换算法 OPT(Optimal Replacement) FIFO(First in First out) LRU(Least Recently Used)，和使用时间相关，和使用次数（频率）无关 LFU(Least Frequently Used)，和使用次数(频率)相关，和使用时间无关 网络上的一个简要的总结 (1) 最佳置换算法(OPT) 最佳置换算法(Optimal, OPT)所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。 最佳置换算法可以用来评价其他算法。假定系统为某进程分配一了三个物理块，并考虑有以下页面号引用串:7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1，进程运行时，先将7，0，1三个页面依次装入内存。进程要访问页面2时，产生缺页中断，根据最佳置换算法，选择第18次访问才需调入的页面7予以淘汰。然后，访问页面0时，因为已在内存中所以不必产生缺页中断。访问页面3时又会根据最佳置换算法将页面淘汰，以此类推，如下图所示。从图中可以看出采用最佳置换算法时页面置换情况。 (2) 先进先出页面置换算法(FIFO) 优先淘汰最早进入内存的页而，亦即在内存中驻留时间最久的页面。该算法实现简单，只需把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最旱的页面。但该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。 这里仍用上而的实例，采用FIFO算法进行页面置换。进程访问页面2时，把最一早进入内存的页面7换出。然后访问页面3时，再把2，0，1中最先进入内存的页面0换出。由图2_2可以看出，利用FIFO算法时进行了12次页面置换，比最佳置换算法正好多一倍。 (3) 最近最久未使用置换算法(LRU) 选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内末访问过的页面，在最近的将来可能也不会被访问。该算法为每个页而设置个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。 再对上面的实例采用LRU算法进行页面置换，如图2-4所示。进程第一次对页面2访问时，将最近最久未被访问的页而7置换出去。然后访问页而3时，将最近最久未使用的页面1换出。 在上图中，前5次置换的情况与最佳置换算法相同，但两种算法并无必然联系。实际上，LRU算法根据各页以前的情况，是”向前看”的，而最佳置换算法则根据各页以后的使用情况，是”向后看”的。LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类的算法。理沦上可以证明，堆栈类算法不可能出现Belady异常。FIFO算法基于队列实现，不是堆栈类算法。 问：Belady’s AnomalyBelady’s Anomaly，即Belady异常或者Belady现象。 所谓Belady现象是指：在页面置换中，当发生缺页时的置换算法采用FIFO(先进先出)算法时，有时会出现分配的页面数增多但缺页率不减反增的异常现象。只有FIFO算法可能出现Belady异常，而LRU和OPT算法永远不会出现Belady异常。 例如：访问页面序列为：1，2，3，4，1，2，5，1，2，3，4，5。当分配页面数位3时，缺页9次；当分配页面数位4时，缺页10次。 问：抖动在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为抖动，或颠簸。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。 频繁的发生缺页中断，其主要原因是某个进程频繁访问的页面数目高于可用的物理页帧数目。虚拟内存技术可以在内存中保留更多的进程以提高系统效率。但系统必须很”聪明”地管理页面分配方案。在稳定状态，几乎主存的所有空间都被进程块占据，处理机和操作系统可以直接访问到尽可能多的进程。但如果处理不当，处理机的大部分时间都将用于交换块，即请求调入页面的操作，而不是执行进程的指令，这就会大大降低系统效率。 问：工作集工作集(或驻留集)是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。 工作集模型的原理是:让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。如果还有空闲物理块，则可以再调一个进程到内存以增加多道程序数。如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会暂停一个进程，将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象。 正确选择工作集的大小，对一存储器的利用率和系统吞吐量的提高，都将产生重要影响。 问：磁盘磁盘是可共享设备，一段时间内允许多个用户进行交叉访问，同一时刻只能有一个进程访问。 问：磁盘平均存取时间平均存取时间=寻道时间+延迟时间+传输时间 例1 问：RAID阵列RAID 0：无差错控制的带区组 要实现RAID0必须要有两个以上硬盘驱动器，RAID0实现了带区组，数据并不是保存在一个硬盘上，而是分成数据块保存在不同驱动器上。在所有的级别中，RAID 0的速度是最快的。但是RAID 0没有冗余功能的，如果一个磁盘(物理)损坏，则所有的数据都无法使用。 RAID 1：镜象结构 当主硬盘损坏时，镜像硬盘就可以代替主硬盘工作。镜像硬盘相当于一个备份盘，可想而知，这种硬盘模式的安全性是非常高的，RAID 1的数据安全性在所有的RAID级别上来说是最好的。但是其磁盘的利用率却只有50%，是所有RAID级别中最低的。 RAID5：分布式奇偶校验的独立磁盘结构 RAID5最大的好处是在一块盘掉线的情况下，RAID照常工作，相对于RAID0必须每一块盘都正常才可以正常工作的状况容错性能好多了。因此 RAID5是RAID级别中最常见的一个类型。RAID5校验位即P位是通过其它条带数据做异或(xor)求得的。计算公式为 P=D0xorD1xorD2…xorDn，其中p代表校验块，Dn代表相应的数据块，xor是数学运算符号异或。 RAID10：高可靠性与高效磁盘结构 RAID 10是先镜射再分区数据。是将所有硬盘分为两组，视为是RAID 0的最低组合，然后将这两组各自视为RAID 1运作。RAID 10有着不错的读取速度，而且拥有比RAID 0更高的数据保护性。 四、 文件管理硬链接和软链接https://www.nowcoder.com/profile/7404313/test/8129531/15818?onlyWrong=0 五、 输入输出(I/O)管理问：I/O控制方式 程序直接控制方式 中断驱动方式：允许I/O设备主动打断CPU的运行并请求服务，从而解放CPU，使得CPU向I/O控制器发送读命令后可以继续做其他有用的工作。 DMA方式：在中断驱动方式中，I/O设备与内存之间的数据交换必须要经过CPU中的寄存器，所以速度受限，而DMA(直接存储器存取)方式的基本思想是在I/O设备和内存之间开辟直接的数据交换通路，彻底解放CPU。 DMA方式的特点： (1) 基本单位是数据块 (2) 所传送的数据，是从设备直接送入内存的，或者相反。 (3) 仅在传送一个或多个数据块的开始和结束时，才需要CPU干预，整块数据的传送是在DMA控制器的控制下完成的。 通道方式 通道能够完成内存与外设之间数据的传输。 问：独享设备、共享设备和虚拟设备 独享设备：在一个用户作业未完成或退出之前，此设备不能分配给其他作业用。所有字符设备都是独享设备。如输入机、磁带机、打印机等。——很明显：需要装驱动。 共享设备：多个用户作业或多个进程可以”同时”从这些设备上存取信息。软硬盘、光盘等块设备都是共享设备。——无需驱动。 虚拟设备：通过软件技术将独享设备改造成共享设备。例如：通过SPOOLing技术将一台打印机虚拟成多台打印机。——实质还是独享设备，需要驱动。 问：单缓冲和双缓冲https://www.nowcoder.com/profile/7404313/test/8073949/24035?onlyWrong=0 问：I/O子系统的层次结构操作系统的I/O 子系统通常由 4 个层次组成，每一层明确定义了与邻近层次的接口，其合理的层次组织排列顺序是：用户级 I/O 软件、设备无关软件、设备驱动程序、中断处理程序 七、 其他进程间的通信方式 管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。 套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 RPC 内存分配方式有三种： （1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。 （2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 （3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多 相联存储器相联存储器（associative memory),也称为按内容访问存储器（content addressed memory)或简称为TLB(Translation Lookaside Buffer)，它是一种不根据地址而是根据存储内容来进行存取的存储器,可以实现快速地查找块表 大端存储和小端存储https://www.nowcoder.com/profile/7404313/test/7907952/14799?onlyWrong=0 案例1： union X{ int x; char y[4]; }; 在小端序的机器中,如果定义X a; a.x=0x11223344;//16 进制，则a.y[3]=0x11 在union 中所有的数据成员共用一个空间，同一时间只能储存其中一个数据成员，所有的数据成员具有相同的起始地址。 管道管道是指用于连接一个读进程和一个写进程以实现进程之间通信的一种共享文件。向管道提供输入的是发送进程，也称为 写进程，负责向管道输入数据，数据的格式是字符流。接受管道 数据的接受进程为读进程。 12. 零碎的东西孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上 ，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。 因此孤儿进程并不会有什么危害。 链接：https://www.nowcoder.com/questionTerminal/8c8bcba738eb4facbdfdb22f47961bee来源：牛客网 Redhat 9所支持的安装方式有光盘安装 (常规情况) 硬盘安装 (无光驱情况)网络安装-NFS方式 (适合于批量安装大量服务器，和kickstart自动安装一起使用)网络安装-FTP方式 (适合于批量安装大量服务器，和kickstart自动安装一起使网络安装-HTTP方式 (适合于批量安装大量服务器，和kickstart自动安装一起使 问：可重入函数https://www.nowcoder.com/profile/7404313/test/8114731/56534?onlyWrong=0 问：并发https://www.nowcoder.com/profile/7404313/test/8114731/44749?onlyWrong=0","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://hepsilion.github.io/tags/操作系统/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"数据结构","slug":"数据结构","date":"2017-03-15T10:38:35.000Z","updated":"2017-10-21T13:19:21.554Z","comments":true,"path":"2017/03/15/数据结构/","link":"","permalink":"https://hepsilion.github.io/2017/03/15/数据结构/","excerpt":"数据结构","text":"数据结构 一、绪论问：数据项、数据元素、数据对象、数据(了解)(1) 数据元素是数据的基本单位。一个数据元素可由若干个数据项组成，数据项是构成数据元素的不可分割的最小单位。 例如，学生记录就是一个数据元素，它由学号、姓名、性别等数据项组成。 (2) 数据对象是具有相同性质的数据元素的集合，是数据的一个子集。 问：抽象数据类型(了解)一个数学模型以及定义在此模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。通常用(数据对象、数据关系和基本操作)三元组来表示抽象数据类型。 问：数据结构的三要素：逻辑结构、存储结构和数据的运算。问：数据的逻辑结构与存储结构逻辑结构：指是数据元素之间的逻辑关系，通常分为线性结构和非线性结构。 存储结构：也称为物理结构，指数据结构在计算机中的表示，也称为存储结构，通常分为顺序结构，链式结构，索引结构，哈希结构。 问：线性结构与非线性结构线性结构与非线性结构，主要看元素之间的关系，如果是一对一的关系则是线性表，如果不是一对一的关系则是非线性表。 数据结构中线性结构指的是数据元素之间存在着“一对一”的线性关系的数据结构。常用的线性结构有：线性表，栈，队列，双队列，数组，串。 线性结构是一个数据元素的有序（次序）集合。它有四个基本特征： (1) 集合中必存在唯一的一个”第一个元素”； (2) 集合中必存在唯一的一个”最后的元素”； (3) 除最后元素之外，其它数据元素均有唯一的”后继”； (4) 除第一元素之外，其它数据元素均有唯一的”前驱”。 相对应于线性结构，非线性结构的逻辑特征是一个结点元素可能对应多个直接前驱和多个直接后继。如树，广义表，图，多维数组等 问：顺序存储结构和链式存储结构顺序存储结构的主要特点： (1) 结点中只有自身的信息域，没有关联信息域。因此，顺序存储结构的存储密度大、存储空间利用率高。 (2) 通过计算地址直接访问任何数据元素，即可以随机访问。 (3) 插入和删除操作会引起大量元素的移动。 链式存储结构的主要特点是： (1) 结点除自身的信息域外，还有表示关联信息的指针域。因此，链式存储结构的存储密度小、存储空间利用率低。 (2) 在逻辑上相邻的结点在物理上不必相邻，因此，不可以随机存取，只能顺序存取。 (3) 插入和删除操作方便灵活，不必移动结点只需修改结点中的指针域即可。 问：广义表如果广义表LS=(a1, a2, …, an)非空，则a1是LS的表头，其余元素组成的表(a2,a3,..an)是称为LS的表尾，所以非空广义表尾一定是个表。 例1： 已知广义表LS＝((a,b,c),(d,e,f)),运用head和tail函数取出LS中原子e的运算是：head(tail(head(tail(LS)))) tail(LS)＝((d,e,f)) head(tail(LS))=(d,e,f) tail(head(tail(LS)))=(e,f) head(tail(head(tail(LS))))=e 广义表可以是自身的子表。(没理解) 例2： 例3：判断正误。 若一个广义表的表头为空表,则此广义表亦为空表。 错误。 例4：判断正误。 对长度为无穷大的广义表,由于存储空间的限制,不能在计算机中实现. 正确。 问：算法的5个基本特征有穷性、确定性、可行性、输入、输出。 问：主定理图 1 二、线性表问：静态链表用数组描述线性表的链式存储结构，即称为静态链表，它的节点有数据域和指针域，指针是节点的相对地址(数组下标)。 例1： 用数组r存储静态链表，结点的next域指向后继，工作指针j指向链中结点，使j沿链移动的操作为：j=r[j].next 三、栈和队列栈有n个数依次入栈，则出栈序列有Cn种，Cn=C(2n,n)/(n+1)。 例1： 问：顺序存储结构的循环队列假设循环队列的队尾指针是rear，队头是front，其中QueueSize为循环队列的最大长度。 (1) 入队时队尾指针前进1：(rear+1)%QueueSize (2) 出队时队头指针前进1：(front+1)%QueueSize 例1，例2 (3) 队列长度：(rear-front+QueueSize)%QueueSize 例1： 现有一循环队列，其队头指针为front，队尾指针为rear；循环队列长度为N。其队内有效长度为？(假设队头不存放数据) 答案：(rear-front+N)%N (4) 队空和队满的条件 为了区分队空还是堆满的情况，有多种处理方式： 方式1： 牺牲一个单元来区分队空和队满，入队时少用一个队列单元，即约定以”队头指针在队尾指针的下一位置作为队满的标志”。 队满条件为：(rear+1)%QueueSize==front 队空条件为：front==rear 队列长度为：(rear-front++QueueSize)%QueueSize 方式2： 增设表示队列元素个数的数据成员size，此时，队空和队满时都有front==rear。 队满条件为：size==QueueSize 队空条件为：size==0 方式3： 增设tag数据成员以区分队满还是队空 tag表示0的情况下，若因删除导致front==rear，则队空； tag等于1的情况，若因插入导致front==rear则队满 例1： 循环队列的存储空间为Q(1:50)，初始状态为front=rear=50。 经过一系列正常的入队与退队操作后，front=rear=25。此后又插入一个元素，则循环队列中的元素个数为多少？ 答案：1，或50且产生上溢错误 例2： 循环队列的存储空间为Q(1:40)，初始状态为front=rear=40。 经过一系列正常的入队与退队操作后，front=rear=15，此后又退出一个元素，则循环队列中的元素个数为多少？ 答案：39，或0且产生下溢错误 例3： 设循环队列的存储空间为Q(1:35)，初始状态为front=rear=35。现经过一系列入队与退队运算后，front=15，rear=15，则循环队列中的元素个数为多少？ 答案：0或35 例4： 循环队列的存储空间为Q(1:200)，初始状态为front=rear=200。经过一系列正常的入队与退队操作后，front=rear=1 则循环队列中的元素个数为多少？ 答案：0或200 例：个人觉得这一题条件不全 最大容量为n的循环队列,队尾指针是rear,队头是front,则队空的条件是：rear=front 问：算术表达式的中缀表达式、前缀表达式和后缀表达式表达式一般由操作数、运算符组成，例如算术表达式中，通常把运算符放在两个操作数的中间，这称为中缀表达式，如A+B。波兰数学家Jan Lukasiewicz提出了另一种数学表示法，它有两种表示形式：把运算符写在操作数之前，称为波兰表达式或前缀表达式，如+AB；把运算符写在操作数之后，称为逆波兰表达式或后缀表达式，如AB+。 将中缀表达式转换成后缀表达式的算法： 例1：将中缀表达式a+b-a*((c+d)/e-f)+g转化为后缀表达式ab+acd+e/f-*-g+的过程。 图 1 例2：简易方法 中缀表达式：a+b*c-(d+e) (1) 中缀表达式转换为前缀表达式： 第一步：按照运算符的优先级对所有的运算单位加括号，算术表达式变成： ((a+(b*c))-(d+e)) 第二步：把每个运算符号移动到其对应的括号前面，则算术表达式变成了： -( +(a *(bc)) +(de)) 第三部：去掉括号得到前缀表达式： -+a*bc+de (2) 中缀表达式转换为后缀表达式： 第一步：按照运算符的优先级对所有的运算单位加括号，算术表达式变成： ((a+(b*c))-(d+e)) 第二步：把每个运算符号移动到其对应的括号后面，则算术表达式变成了： ((a(bc)* )+ (de)+ )- 第三部：去掉括号得到后缀表达式： abc*+de+- 例3，例4，例5，例6，例7，例8 逆波兰表达式求值算法： 1、循环扫描语法单元的项目。 2、如果扫描的项目是操作数，则将其压入操作数堆栈，并扫描下一个项目。 3、如果扫描的项目是一个二元运算符，则对栈的顶上两个操作数执行该运算。 4、如果扫描的项目是一个一元运算符，则对栈的最顶上操作数执行该运算。 5、将运算结果重新压入堆栈。 6、重复步骤2-5，堆栈中即为结果值。 问：稀疏矩阵的压缩存储方法有：三元组、十字链表四、树与二叉树问：平衡二叉树是平衡二叉排序树问：平衡二叉树的平衡操作图 1 例 问：完全二叉树的几个性质(1) 完全二叉树中，编号为i的结点，其父节点为[i/2]（向下取整）。 (2) 完全二叉树中，编号为i的结点，有如下四个性质（1&lt;=i&lt;=n，n为结点个数） 判断编号为i的结点是叶子结点，还是分支结点：若2*i&lt;=n，则结点i为分支结点，否则为叶子结点。 分支结点的左右孩子情况，以及最大分支结点编号 若n为奇数，则所有分支结点都有左右孩子。 若n为偶数，则编号为[n/2]（向下取整）的结点，只有左孩子，没有右孩子；其余分支结点左右孩子都有。 最大分支结点编号都是[n/2]（向下取整）。 编号为i的结点如果有左孩子，则左孩子编号为2i；如果有右孩子，则右孩子的编号为2i+1 编号为i的结点的父结点编号为[i/2]（向下取整）（根节点除外） 问：二叉树在线索化后,仍不能有效求解的问题例1：王道数据结构2015版118页27题 二叉树在线索化后，仍不能有效求解的问题是(D) A. 先序线索二叉树中求先序后继 B. 中序线索二叉树中求中序后继 C. 中序线索二叉树中求中序前驱 D. 后序线索二叉树中求后序后继 解释：如图所示，节点E的右指针指向右孩子，而在后序序列中E的后继节点为B，在查找E的后继时，后序线索不能起到任何作用，只能按常规方法来查找。 问：红黑树例1 问：森林与二叉树树转换成二叉树的步骤： 森林转换成二叉树的步骤： (1) 先把森林中的每棵树转换成二叉树 (2) 第一颗二叉树不动，从第二颗二叉树开始，依次把后一颗二叉树的根结点作为前一颗二叉树的根结点的右孩子结点，用线连起来。当所有的二叉树连接起来后得到的二叉树就是由森林转换得到的二叉树。 注意： (1) 将森林F转换为对应的二叉树T，F中叶结点的个数等于T中左孩子指针为空的结点个数。 在二叉树中，节点的左指针指向其孩子，节点的右指针指向其兄弟。在一颗二叉树中，如果某个节点的左指针为NULL，就说明这个节点在原来的森林中没有孩子，是叶子节点；如果某个节点的右指针为NULL，就说明这个节点在原来的森林中没有兄弟。 所以森林中的叶子节点=二叉树中左指针为NULL的个数。 问：将森林F转换为对应的二叉树T，F中叶结点的个数等于T中左孩子指针为空的结点个数例1 问：将森林F转换为对应的二叉树T，若F中有n个非终端结点，则T中右指针域为空的结点数为n+1。例1 问：树和森林的遍历与二叉树遍历的对应关系图 1 五、图问：顶点的度有向图中，所有顶点的入度之和等于所有顶点的出度之和 问：连通图与强连通图，连通分量与强连通分量在无向图中，如果从顶点v到顶点w有路径存在，则称v和w连通的。如果图中任意两个顶点之间都连通，则称该图为连通图，否则，称该图为非连通图。无向图的极大连通子图称为连通分量。 在有向图中，如果从顶点v到顶点w和从顶点w到顶点v之间都有路径存在，则称v和w是强连通的。如果图中任意两个顶点之间都是强连通的，则称该图为强连通图。有向图的极大连通子图称为强连通分量。 问：十字链表十字链表(Orthogonal List)是有向图的另一种链式存储结构。该结构可以看成是将有向图的邻接表和逆邻接表结合起来得到的。例子 问：几种算法的时间复杂度(1) Prim算法 例1 在图采用邻接表存储时,求最小生成树的Prim算法的时间复杂度为：O(n+e) (2) Kruskal算法 (3) Dijkstra算法 (4) Floyd算法 (5) 拓扑排序 例1 若初始序列为gbfcdae，那么至少需要()次两两交换，才能使该序列变为abcdefg。 任给一个自由a--g这7个字母组成的排列，最坏的情况下需要至少()次两两交换，才能使序列变为abcdefg。 答案：5 6 本质是图论里的拓扑排序问题，将每个字符现在的位置与其排序后的位置连一条单向边，最小两两交换次数为：字符总数-连接后形成的环数(包括自环) (1) gbfcdae-&gt;abcdefg g b f c d a e a b c d e f g 其中，b为自环，而a-&gt;f-&gt;c-&gt;d-&gt;e-&gt;g-&gt;a为另一个环，所以最小交换次数=7-2=5次 (2) 任意a--g这7个字母组成的排列-&gt;abcdefg 最坏情况下是所有字符形成一个环，如gabcdef需要至少6次交换才能变为abcdefg 问：AOV网和AOE网如果用有向无环图表示一个工程，其定点表示活动，用有向边表示活动Vi必须先于Vj进行的一种关系，则将这种有向图称为表示活动的网络，简称AOV网。 在带权有向图中，以定点表示事件，有向边表示活动，边上的权值表示完成该活动的开销(如完成活动所需要的时间)，则称这种有向图为用边表示活动的网络，简称为AOE网。 问：关键路径在AOE网中，从源点到汇点的所有路径中，具有最大路径长度的路径称为关键路径。 在AOE网中，可以有不止一条的关键路径。 关键路径的计算步骤 问：可以判断出一个有向图是否有环的算法(1) 深度优先遍历 (2) 拓扑排序 六、查找问：折半查找的条件数据有序、顺序存储 (如果数据存储在链式结构的链表中同样可以采用跳表完成二分法查找) 问：分块查找分块查找的平均查找长度为索引查找和块内查找的平均长度之和，设索引查找和块内查找的平均查找长度分别为Li和Ls，则分块查找的平均查找长度为ASL=Li+Ls。 问：B树与B+树的区别(1) B树是一棵多路搜索树。一棵m阶B树或为空树，或为满足如下特性的m叉树： 树中每个节点之多有m棵子树(即最多有m-1个关键字) 若根节点不是叶节点，则至少有两棵子树 除根节点以外的所有非叶节点至少有[m/2]棵子树(即至少含有[m/2]-1个关键字)。([]为(上取整)) 所有非叶节点的关键字为K[1]，K[2]，…，K[n-1]且K[i]&lt;K[i+1]；指向子树的指针为P[1]，P[2]，…，P[M]，其中P[0]指向关键字小于K[1] 的子树，P[n]指向关键字大于K[n]的子树，其它P[i]指向关键字属于(K[i], K[i+1])的子树 所有的叶节点都出现在同一层上，并且不带信息 (2) B+树 (3) B树与B+树的区别 B树只能进行索引查找，B+树既能顺序查找，也能索引查找 问：哈夫曼树最优二叉树是哈夫曼树，而哈夫曼树不一定是完全二叉树。 例1： 解析没看懂 已知三叉树T中6个叶结点的权分别是2，3，4，5，6，7，T的带权(外部)路径长度最小是：46 问：哈希表(1) 构造哈希表时经常使用的哈希函数 直接定址法：取关键字或关键字的某个线性函数值为散列地址，即H(key)=key或H(key)=a·key+b，其中a和b为常数(这种散列函数叫做自身函数) 数字分析法 平方取中法 折叠法 除留余数法 (2) 冲突处理的方法 开哈希表——-链式地址法/拉链法 闭哈希表——-开放地址法：线性探测法、平方探测法、再散列法、伪随机序列法 问：Hash的冲突处理例1，例2，例3，例4 问：KMP算法(1) 先了解使用KMP算法进行字符串匹配的过程 KMP算法的最大特点在于：当一趟匹配过程中出现字符不匹配时，不需回溯主串指针，而是利用已经得到的”部分匹配”结果将模式串向右”滑动”尽可能远的一段距离后，继续进行比较，从而提高匹配效率。 (2) KMP算法代码 #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; void computeNext(string pattern, vector&lt;int&gt;&amp; next){ int len=pattern.size(); next.push_back(0); int matchLength=0; for(int q=1; q&lt;len; q++){ while(matchLength&gt;0 &amp;&amp; pattern[q]!=pattern[matchLength]){ matchLength=next[matchLength-1]; } if(pattern[q]==pattern[matchLength]){ matchLength++; } next.push_back(matchLength); } } int kmp(string str, string pattern){ vector&lt;int&gt; next; computeNext(pattern, next); int m=str.size(); int n=pattern.size(); for(int i=0, matchLength=0; i&lt;m; i++){ while(matchLength&gt;0 &amp;&amp; str[i]!=pattern[matchLength]){ matchLength=next[matchLength-1]; } if(str[i]==pattern[matchLength]){ matchLength++; } if(matchLength==n) return i-n+1; } return -1; } int main(){ string str=&quot;BBC ABCDAB ABCDABCDABDE&quot;; string pattern=&quot;ABCDABD&quot;; cout&lt;&lt;kmp(str, pattern)&lt;&lt;endl; return 0; } (3) next数组求解，本质上在求模式串每一位的最大相同前后缀的长度 来源 void computeNext(string pattern, vector&lt;int&gt;&amp; next){ int len=pattern.size(); next.push_back(0); //模式串P的第一个字符的最大相同前后缀长度为0 int matchLength=0; //当前已经求得的子串的最大相同前后缀长度 for(int q=1; q&lt;len; q++){ //从第二个字符开始，依次计算每一个字符对应的next值 while(matchLength&gt;0 &amp;&amp; pattern[q]!=pattern[matchLength]){//while循环 matchLength=next[matchLength-1]; } if(pattern[q]==pattern[matchLength]){ //如果相等，那么最大相同前后缀长度加1 matchLength++; } next.push_back(matchLength); } } 设有模式串P(代码中表示为pattern)，第一个字符的最大相同前后缀长度为0，即next[0]=0，现在准备求模式串P其他字符位对应的next数组值。 next数组求解最大的难点在于while循环，这里重点解释while循环所做的工作： (1) 假设当前已求得P[0, …, q-1]的最大相同前后缀的长度为k(代码中表示为matchLength)，即next[q-1]=k。 (2) 现在求next[q]，即P[0, …, q]的最大相同前后缀的长度。此时比较模式串P中字符位P[q]和字符位P[k]，如图1所示。 如果P[q]等于P[k]，那么很简单，P[0, …, q]的最大相同前后缀的长度等于P[0, …, q-1]的最大相同前后缀的长度加1，即next[q]=next[q-1]+1，继续求下一个位置的next值。 但如果P[q]不等于P[k]又该怎么办呢？这时我们可以利用已经得到的next[0, …, k-1]，为什么呢？ 原因在于P[k]已经和P[q]失配了，而P[q-k, …, q-1]又与P[0, …, k-1]相同，那么在P[0]···P[k-1]这么长的子串用不了的情况下，我们能不能找到一个同样以P[0]开头、P[k-1]结尾且尽可能长的子串来和P[0, …, q-1]匹配？这样的子串存在吗？当然是存在的，想一想P[0, …, k-1]子串不是有最大相同前后缀吗？next[k-1]不就是P[0, …, k-1]子串的最大相同前后缀的长度嘛！那么我们取这个子串为P[0, …, k-1]的最大前缀不就可以了嘛，即P[0, …, j-1] (j=next[k-1])，然后看它的下一项P[j]能否和P[q]匹配，如图2所示。 注意：在一些笔试题中，经常会让选择正确的next数组值，不同的方法计算出来的next数组可能不一样 这里是其中一种计算方式： 例1：求模式串ababaaababaa的next数组。 i 0 1 2 3 4 5 6 7 8 9 10 11 s a b a b a a a b a b a a next[i]的值等于s[i]之前的子串中最长相同前后缀的长度。next[0]=-1为定值。 next[1]等于s[1]之前的子串&quot;a&quot;中最长相同前后缀的长度，为0，故next[1]=0； next[2]等于s[2]之前的子串&quot;ab&quot;中最长相同前后缀的长度，为0，故next[2]=0； next[3]等于s[3]之前的子串&quot;aba&quot;中最长相同前后缀的长度，s[0]与s[2]为最长相同前后缀，长度为1，故next[3]=1； next[4]等于s[4]之前的子串&quot;abab&quot;中最长相同前后缀的长度，s[01]与s[23]为最长相同前后缀，长度为2，故next[4]=2； next[5]等于s[5]之前的子串&quot;ababa&quot;中最长相同前后缀的长度，s[012]与s[234]为最长相同前后缀，长度为3，故next[5]=3； next[6]等于s[6]之前的子串&quot;ababaa&quot;中最长相同前后缀的长度，s[0]与s[5]为最长相同前后缀，长度为1，故next[6]=1； 类似的，可以求得next[7]、next[8]、next[9]、next[10]、next[11]分别为1和2、3、4、5。 next数组为-1 0 0 1 2 3 1 1 2 3 4 5 如果将这里的所有值加1可以得到另一种next数组，为0 1 1 2 3 4 2 2 3 4 5 6 例2：求模式串xyxyyxxyx的next数组。 采用例1相同的计算方式，得到next数组如下： x y x y y x x y x -1 0 0 1 2 0 1 1 2 0 1 1 2 3 1 2 2 3 例3：字符串S为”abaabaabacacaabaabcc”，模式串为”abaabc”。采用KMP算法进行匹配，第一次出现”失配”(s[i]≠t[j])时，i=j=5，则下次开始匹配时，i和j的值是多少？ 先求的模式串的next数组如下： a b a a b c -1 0 0 1 1 2 0 1 1 2 2 3 依据KMP算法&quot;当失配时，i不变，j回退到next[j-1]的位置并重新比较&quot;，当失配(s[i]≠t[j])时，i=j=5，由上表不难得出next[j]=next[5]=2(位序从0开始)。从而最后结果应为：i=5(i保持不变)，j=next[5-1]=2。 例4：求模式串ababaabab的nextval数组，这里使用了未加1的next数组 先计算前缀next[i]的值如下： s a b a b a a b a b -1 0 0 1 2 3 1 2 3 接下来计算nextval[i]的值，nextval[i]的求解需要比较s中next[i]所在位置的字符是否与s[i]的字符一致: 如果一致则用s[next[i]]的nextval的值作为nextval[i]，如果不一致，则用next[i]做为nextval[i]。 nextval[0]和next[0]的值一样，为-1，即nextval[0]=-1； nextval[1]，比较s[next[1]]和s[1]，next[1]=0，s[0]=a，而s[1]=b，二者不一致，则nextval[1]=next[1]=0； nextval[2]，比较s[next[2]]和s[2]，next[2]=0，s[0]=a，而s[2]=a，二者一致，则nextval[2]=nextval[s[next[2]]]=nextval[s[0]]=-1 (严谨来看这么表述是有问题的，因为nextval[2]表示nextval数组中 第3个数值，而nextval[s[0]]表示的是s[0]对应的字母&apos;a&apos;所对应的nextval值-1，这里nextval[]的用法并不严谨，只是为了表述方便)。 nextval[3]，比较s[next[3]]和s[3]，next[3]=1，s[1]=b，而s[3]=b，二者一致，则nextval[3]=nextval[s[next[3]]]=nextval[s[1]]=0； nextval[4]，比较s[next[4]]和s[4]，next[4]=2，s[2]=a，而s[4]=a，二者一致，则nextval[4]=nextval[s[next[4]]]=nextval[s[2]]=-1； nextval[5]，比较s[next[5]]和s[5]，next[5]=3，s[3]=b，而s[5]=a，二者不一致，则nextval[5]= next[5]=3； 同样的求nextval[6]、nextval[7]、nextval[8]分别为0，-1，0。 这里是nextval的下标从-1开始，如果从1开始，则其余各位均＋1，nextval为0，1，0，1，0，4，1，0，1 问：动态查找表动态查找表的表结构是在查找过程中动态生成的，对于给定key，若表中存在某关键字与key相等则查找成功返回，否则则插入关键字等于key的记录。常见的动态查找表有：二叉排序树、平衡二叉树、B树、B+树。 静态查找表有：有序表、分块有序表、线性链表。 七、排序问：各种内部排序算法性质图 1 备注：这里的冒泡排序是指优化的冒泡排序。 注意： (1) 若记录的初始状态已经按关键码基本有序，则选用直接插入排序或冒泡排序发为宜 (2) 在排序中关键字比较次数同记录初始排列次序无关的算法有：折半插入排序、选择排序、基数排序、 直接插入排序，在完全有序的情况下，每个元素只需要与它左边的元素比较一次就可以确定它的最终位置 快速排序，初始排序会影响划分次数。假设2n+1个数在一趟排序中被分为两部分，各为n个数，则下一趟排序中需要比较的次数为n-1+n-2=2n-2；假设分成的两部分分别有1个数和2n个数，则下一趟排序中需要比较的次数为2n-1。很明显初始排序会影响比较次数。 归并排序，假设在归并的时候，右路有n个元素，右路有n个元素，则一次归并最大比较次数为2n-1，最少比较次数为n，所以与初始排序有关。 (3) 在排序中关键字移动次数同记录初始排列次序无关的算法有： (4) 关键字初始排列顺序对算法的性能无影响的排序算法有：选择排序、(原始的)冒泡排序 例1，例2 (5) 快速排序在被排序的数据基本无序的时候最易发挥其长处，时间复杂度为O(nlogn)；在已经有序或逆序的情况下效率最差，为O(n^2)。 (6) 快速排序是目前基于比较的内部排序中平均时间复杂度最好的排序方法 (7) 希尔排序，也称为递减增量排序算法，是插入排序的一种高速而稳定的改进版本。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可达到线性排序的效率； 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位； (8) 堆排序建堆时间复杂度为O(n)，每次调整时间复杂度为O(h) (9) (假设根节点序号为1)小根堆中最大的数一定在叶子节点上，堆本身是个完全二叉树，完全二叉树的叶子节点的位置大于[n/2] 基于内部排序的最少比较次数 问：快速排序(1) 对n个记录的线性表进行快速排序为减少算法的递归深度，应该在每次分区后，先处理较短的部分解析 (2) 采用递归方式对顺序表进行快速排序，递归次数与每次划分后得到的分区处理顺序无关解析 问：外部排序外排中使用置换选择排序的目的,是为了增加初始归并段的长度解析 问：桶排序问：从n个数里面找最大的一个数理论最少需要比较：n-1次例1： 这道题其实就是一种二叉树结构，1001个员工为叶节点，而比赛次数则是求非叶节点 问：从n个数里面找最大的两个数理论最少需要比较：n+logn-2次解析 没看懂 问：希望用最快的速度从一个无序数组中挑选出其中前m个最大的元素，可以使用堆排序例1，例3，例4 问：在n个数中选出最大的m个数(3&lt;m&lt;n)，时间复杂度最小为O(n)网上的一个解析，例1，例2 例，这一题蛮好 问：在N个乱序数字中查找第k大的数字(未整理，因为还不是特别清楚)例1，例2 问：求n个数中的最大值和最小值，最少的比较次数例1 八、 其他","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://hepsilion.github.io/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"https://hepsilion.github.io/tags/数据结构/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hepsilion.github.io/categories/计算机基础/"}]},{"title":"第九章 网络编程","slug":"09-网络编程","date":"2017-03-09T12:46:32.000Z","updated":"2017-10-21T13:19:21.273Z","comments":true,"path":"2017/03/09/09-网络编程/","link":"","permalink":"https://hepsilion.github.io/2017/03/09/09-网络编程/","excerpt":"Http协议简介 使用Handler进行线程间通信 AsyncTask 使用HttpURLConnection、HttpClient访问网络提交数据 AsyncHttpClient、SmartImageView开源项目的使用 多线程下载文件","text":"Http协议简介 使用Handler进行线程间通信 AsyncTask 使用HttpURLConnection、HttpClient访问网络提交数据 AsyncHttpClient、SmartImageView开源项目的使用 多线程下载文件 Android系统提供了以下几种方式实现网络通信：Socket通信、HTTP通信、URL通信和WebView，其中最常用的是HTTP通信。 一、网络编程入门1. HTTP协议简介HTTP：超文本传输协议，它规定了浏览器和万维网服务器之间互相通信的规则。 当客户端在与服务器端建立连接后，向服务器端发送的请求，被称作HTTP请求。服务器端接收到请求后会做出响应，称为HTTP响应。 2. Handler消息机制原理在使用Android手机下载软件时，通常都能在界面上看到一个下载的进度条，这个进度条用来表示当前软件下载的进度。但是Android4.0以后不能在UI线程中访问网络，子线程也不能更新UI界面。为了根据下载进度实时更新UI界面，就需要用到Handler消息机制来实现线程间的通信。 Handler机制主要包括4个关键对象，分别是Message、Handler、MessageQueue和Looper。 (1) Message Message是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同的线程之间交换数据。 Message的what字段可以用来携带一些整型数据，obj字段可以用来携带一个Object对象。 (2) Handler Handler主要用于发送消息和处理消息。 一般使用Handler对象的sendMessage()方法发送消息，发出的消息经过一系列的辗转处理后，最终会传递到Handler对象的handleMessage()方法中。 (3) MessageQueue MessageQueue主要用来存放通过Handler发送的消息。通过Handler发送的消息会存在Message中等待处理。 每个线程中只会有一个MessageQueue对象。 (4) Looper Looper是每个线程中的MessageQueue的管家。调用Looper的loop()方法后，就会进入一个无限循环中。然后，每当发现MessageQueue中存在一条消息，就会将它取出，并传递到Handler的handleMessage()方法中。 此外，每个线程也只有一个Looper对象。在主线程中创建Handler对象时，系统已经创建了Looper对象，所以不用手动创建Looper对象，而在子线程中的Handler对象，需要调用Looper.loop()方法开启消息循环。 图 9-1 Handler消息机制处理流程如图9-1所示： 在主线程(UI线程)创建一个Handler对象 在子线程中调用Handler的sendMessage()方法发送消息 这个消息会存放在主线程的MessageQueue中，通过Looper对象取出MessageQueue中的消息，最后分发回Handler的handleMessage()方法中进行处理，更新UI。 3. AsyncTask为了方便在子线程中对UI进行操作，Android提供了一些好用的工具类，AsyncTask就是其中之一。利用AsyncTask，可以十分简单地从子线程切换到主线程，它的原理是基于异步消息处理机制实现的。 AsyncTask是一个抽象类，使用它必须创建一个类继承它。在继承AsyncTask时，可以为其执行三个泛型参数，这三个参数的用途如下： Params：在执行AsyncTask时需要传入的参数，用于后台任务中使用。 Progress：后台任务执行时，如果需要在界面上显示当前的进度，则使用该参数作为进度单位。 Result:当任务执行完毕后，如果需要对结果进行返回，则使用该参数作为返回值类型。 下面定义了一个AsyncTask类，它的三个泛型参数分别被指定为Void, Integer, Boolean。第一个参数表示在执行AsyncTask时，不需要传递参数给后台任务；第个参数表示使用整数来作为进度显示单位；第三个参数表示使用布尔值来返回执行结果。 通常在使用AsyncTask时，需要重写它的4个方法： public class MyAsyncTask extends AsyncTask&lt;Void, Integer, Boolean&gt; { // 这个方法在后台任务执行之前调用，一般用于界面上的初始化操作，例如，显示一个进度条对话框 @Override protected void onPreExecute() { super.onPreExecute(); } //这个方法在子线程中运行，用于处理耗时操作，操作一旦完成即可以通过return语句将任务的执行结果返回。 //如果AsyncTask的第三个泛型参数指定的是void，则可以不返回执行结果。 //注意：这个方法不能进行更新UI操作，如果要在该方法中更新UI，可以调用publishProgress()方法来完成。 @Override protected Boolean doInBackground(Void... params) { publishProgress(50); return null; } //如果在doInBackground()方法中调用了publishProgress()方法，这个方法就会很快被调用，方法中携带的参数就是后台任务传递过来的。 //在这个方法中可以对UI进行操作，利用参数values就可以对UI进行相应的更新。 @Override protected void onProgressUpdate(Integer... values) { super.onProgressUpdate(values); } //当doInBackground()方法执行完毕并且通过return语句返回时，这个方法会很快被调用。在doInBackground()中返回的数据会作为参数传递到该方法中。 //此时可以利用返回的参数进行UI操作，例如，提醒某个任务完成了。 @Override protected void onPostExecute(Boolean aBoolean) { super.onPostExecute(aBoolean); } } 最后，我们可以在UI线程中创建AsyncTask实例，并调用它的execute()方法。 new MyAsyncTask().execute(); 以上便士AsyncTask的基本用法，使用AsyncTask可以不使用Handler发送和接收消息，只需要在doInBackground()方法中调用publicProgress()方法，即可实现从子线程切换到UI线程。 二、HttpURLConnection和HttpClient在实际开发中，绝大多数App都需要和服务器进行数据交互，也就是访问网络。 Android客户端访问网络发送HTTP请求的方式一般有两种：HttpURLConnection和HttpClient。 HttpURLConnection是一个标准的Java类，HttpClient是一个开源项目。 1. 使用HttpURLConnection访问网络使用HttpURLConnection，客户端与服务器建立连接并获取服务器返回的数据的过程： try{ //在URL的构造方法中传入要访问资源的路径 URL url=new URL(&quot;https://www.baidu.com/&quot;); HttpURLConnection conn=(HttpURLConnection)url.openConnection(); conn.setRequestMethod(&quot;GET&quot;); //设置请求方式 conn.setConnectionTimeout(5000); //设置超时时间 int code=conn.getResponseCode(); if(code==200){ //请求网络成功后返回码是200 InputStream is=conn.getInputStream(); //获取服务器返回的输入流 //读取流信息，获取服务器返回的数据 conn.disconnect(); //关闭http连接 }else{ //返回码不是200，请求服务器失败 } }catch(Exception e){ } 需要注意的是，在使用HttpURLConnection对象访问网络时，需要设置超时时间。如果没有设置超时时间，在网络异常的情况下，程序会因取不到数据而一直等待，导致程序僵死不往下执行。 案例：Demo0901，网络图片浏览器，演示手机端使用HttpURLConnection和客户端进行通信的过程 2. 使用HttpClient访问网络HttpClient是Apache的一个开源项目，从一开始就被引入到Android的API中。HttpClient可以完成和HttpURLConnection一样的效果，但使用起来更简单。简单来说，HttpClient是HttpURLConnection的增强版。 图9-2是使用HttpClient访问网络时所需要用到的几个常用类的介绍。 图 9-2 使用HttpClient访问网络与HttpURLConnection的过程大致相同，具体步骤如下： 创建HttpClient对象 指定访问网络的方式，创建一个HttpPost对象或者HttpGet对象 如果需要发送请求参数，可调用HttpGet、HttpPost的setParams方法，对于HttpPost对象而言，也可以调用setEntity()方法来设置请求参数 调用HttpClient对象的execute()方法访问网络，并获取HttpResponse对象 调用HttpResponse.getEntity()方法获取HttpEntity对象，该对象包装了服务器的响应内容，即所请求的数据。 使用HttpClient访问服务器并获取返回数据的示例代码： HttpClient client=new DefaultHttpClient(); HttpPost httpPost=new HttpPost(&quot;https://www.baidu.com/&quot;); List&lt;NameValuePair&gt; params=new ArrayList&lt;NameValuePair&gt;(); //创建一个NameValuePair集合，用于添加参数 params.add(new BasicNameValuePair(&quot;username&quot;, &quot;admin&quot;)); UrlEncodedFormEntity entity=new UrlEncodedFormEntity(params, &quot;utf-8&quot;); //给参数设置编码 httpPost.setEntity(entity);//设置参数 HttpResponse httpResponse=client.execute(httpPost); int statusCode=httpResponse.getStatusLine().getStatusCode(); if(statusCode==200){ HttpEntity httpEntity=httpResponse.getEntity();//获取HttpEntity实例 String response=EntityUtils.toString(httpEntity, &quot;utf-8&quot;);//设置编码格式 InputStream content = httpEntity.getContent(); //拿到输入流 } 需要注意的是，使用Post方式设置参数时，需要创建一个NameValuePair的集合来添加参数。在给参数设置编码时，需要与服务器的解码格式保持一致，否则会出现中文乱码的情况。 案例：Demo0902，网络图片浏览器，，演示手机端使用HttpClient和客户端进行通信的过程 3. 数据提交方式HTTP/1.1协议中共定义了8种方法来表明Request-URI指定的资源的不同的操作方式，其中最常用的两种请求方式是GET和POST。 (1) GET方式 GET方式是以实体的方式得到由请求URL所指向的资源信息，它向服务器提交的参数跟在请求URL后面。 使用GET方式访问网络URL的长度是有限制的，HTTP协议规范规定GET方式请求URL的长度不超过4K。但是IE浏览器GET方式请求URL的长度不能超过1K。 示例代码：使用HttpURLConnection GET方式提交数据到服务器： //将用户名和密码拼装在指定资源路径后面，并给用户名和密码进行编码 String path=&quot;http://192.168.1.100:8080/web/LoginServlet?username=&quot; +URLEncoder.encode(&quot;zhangsan&quot;)+&quot;&amp;password=&quot;+URLEncoder.encode(&quot;123&quot;); URL url=new URL(path); HttpURLConnection conn=url.openConnection(); conn.setRequestMethod(&quot;GET&quot;); //设置请求方式 conn.setConnectTimeout(5000); //设置超时时间 int responseCode=conn.getResponseCode(); //获取状态码 if(responseCode==200){//访问成功 InputStream is=conn.getInputStream(); //获取服务器返回的输入流 try{ //读取流里面的信息 }catch(Exception e){ } } (2) POST方式 POST方式在向服务器发出请求时，它向服务器提交的参数跟在请求实体中。 它提交的参数是浏览器通过流的方式直接写给服务器的，用户不能在浏览器中看到向服务器提交的请求参数，因此POST方式比GET方式相对安全。 此外，POST方式对URL的长度没有限制。 示例代码：使用HttpURLConnection POST方式提交数据到服务器： //使用HttpURLConnection String path=&quot;http://192.168.1.100:8080/web/LoginServlet&quot;; //准备数据并给参数进行编码 String data=&quot;username=&quot;+URLEncoder.encode(&quot;zhangsan&quot;)+&quot;&amp;password=&quot;+URLEncoder.encode(&quot;123&quot;); URL url=new URL(path); HttpURLConnection conn=(HttpURLConnection)url.openConnection(); conn.setRequestMethod(&quot;POST&quot;); //设置请求方式 conn.setConnectTimeout(5000); //设置超时时间 //设置请求头-数据提交方式，这里是以form表单方式提交 conn.setRequestProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); //设置请求头-设置提交数据的长度 conn.setRequestProperty(&quot;Content-Length&quot;, data.length()+&quot;&quot;); //post方式，实际上是浏览器把数据写给了服务器 conn.setDoOutput(true); //设置允许向外写数据 OutputStream os=conn.getOutputStream(); os.write(data.getBytes()); //利用输出流往服务器写数据 int code=conn.getResponseCode(); //获取状态码 if(responseCode==200){ //访问成功 InputStream is=conn.getInputStream(); //获取服务器返回的输入流 try{ //读取流里面的信息 }catch(Exception e){ } } 注意：使用HttpURLConnection POST方式提交数据时，是以流的方式直接将参数写到服务器上的，需要设置数据的提交方式和数据的长度。 在实际开发中，手机端和服务器进行交互的过程中，避免不了提交中文到服务器，这时就会出现中文乱码的情况。 无论是GET方式还是POST方式，提交参数时都要给参数进行编码。需要注意的是，编码方式必须与服务器解码方式统一。同样在获取服务器返回的中文数据时，也需要用指定格式进行解码。 案例：Demo0903和Demo0903Server：提交数据到服务器，演示HttpURLConnection/HttpClient分别使用Get方式和Post方式提交数据到服务器 三、开源项目在实际开发中，使用Android自带的API与服务器通信比较麻烦。一些热心的开发者为了节约开发成本、节约开发时间，开发出了一些开源的项目方便大家使用。因此网上出现了各种各样的开源项目。 1. AsyncHttpClient 由于访问网络是一个耗时的操作，放在主线程里面会影响用户体验，因此Google规定Android 4.0以后访问网络的操作都必须放在子线程中。 但是，在Android中，发送、处理HTTP请求十分常见，如果每次和服务器进行交互都需要开启一个子线程，这样是非常麻烦的。为了解决这个问题，一些开发者开发出了一个开源项目：AsyncHttpClient，它是HttpClient的再次包装。 AsyncHttpClient的特点有：发送异步HTTP请求，HTTP请求发生在UI线程之外，内部采用了线程池来处理并发请求。 AsyncHttpClient的常用类： AsyncHttpClient：用来访问网络的类 RequestParams:用来添加参数的类 AsyncHttpResponseHandler：访问网络后的回调接口 使用AsyncHttpClient：创建AsyncHttpClient的实例；设置参数；通过AsyncHttpClient的实例对象访问网络。如果访问成功则会回调AsyncHttpResponseHandler接口中的OnSucess()方法；失败则会回调OnFailure()方法。 使用AsyncHttpClient的GET方式访问网络并提交数据实例代码： //拼接URL，注意将参数编码 String path=&quot;http://192.168.1.100:8080/web/LoginServlet?username=&quot;+URLEncoder.encode(&quot;zhang&quot;)+&quot;&amp;password=&quot;+URLEncoder.encode(&quot;123&quot;); //创建AsyncHttpClient实例 AsyncHttpClient asyncHttpClient = new AsyncHttpClient(); //使用GET方式请求 asyncHttpClient.get(path, new AsyncHttpResponseHandler() { //请求成功 public void onSuccess(String content) { super.onSuccess(content); Toast.makeText(MainActivity.this, &quot;请求成功&quot;+content, Toast.LENGTH_SHORT).show(); } //请求失败 public void onFailure(Throwable error, String content) { super.onFailure(error, content); Toast.makeText(MainActivity.this, &quot;请求失败&quot;+content, Toast.LENGTH_SHORT).show(); } }); 使用AsyncHttpClient的POST方式访问网络并提交数据实例代码： String path=&quot;http://192.168.1.100:8080/web/LoginServlet&quot;; //添加参数 RequestParams params=new RequestParams(); params.put(&quot;username&quot;, &quot;zhang&quot;); params.put(&quot;password&quot;, &quot;123&quot;); //创建AsyncHttpClient实例 AsyncHttpClient asyncHttpClient = new AsyncHttpClient(); //使用GET方式请求 asyncHttpClient.post(&quot;&quot;, new RequestParams(), new AsyncHttpResponseHandler(){ //请求成功 @Override public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) { super.onSuccess(statusCode, headers, responseBody); Toast.makeText(MainActivity.this, &quot;请求成功&quot;+new String(responseBody), Toast.LENGTH_SHORT).show(); } //请求失败 @Override public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) { super.onFailure(statusCode, headers, responseBody, error); Toast.makeText(MainActivity.this, &quot;请求失败&quot;+new String(responseBody), Toast.LENGTH_SHORT).show(); } }); 从上面的实例代码可以看出，使用AsyncHttpClient访问网络并不需要创建子线程，而且不需要切换线程更新UI，使用起来更加方便。 2. SmartImageView 应用市场上的常见软件都加载了大量的网络上的图片。如果使用Android自带的API实现这一功能，首先需要请求网络，然后获取服务器返回的图片信息，转换成输入流，使用BitmapFactory生成Bitmap对象，最后再设置到指定的控件中，这种操作步骤十分麻烦而且耗时。为了，开发者们开发了一个开源项目：SmartImageView。它继承自ImageView，支持根据URL地址加载图片、支持异步加载图片、支持图片缓存等。 使用SmartImageView加载网络图片的实例代码： (1) 在布局文件中添加SmartImageView控件 &lt;com.loopj.android.image.SmartImageView android:id=&quot;@+id/siv_icon&quot; android:layout_width=&quot;80dip&quot; android:layout_height=&quot;60dip&quot; android:layout_alignParentLeft=&quot;true&quot; android:layout_marginBottom=&quot;5dip&quot; android:layout_marginLeft=&quot;5dip&quot; android:layout_marginTop=&quot;5dip&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@drawable/ic_launcher&quot; /&gt; (2) 在Activity中使用SmartImageView控件 SmartImageView siv = (SmartImageView) view.findViewById(R.id.siv_icon); //SmartImageView加载指定路径图片 siv.setImageUrl(newsInfo.getIconPath(), R.drawable.ic_launcher, R.drawable.ic_launcher); 在加载指定图片时，setImageUrl()方法指定了图片的路径，加载中显示的图片以及加载失败时显示的图片。 案例：Demo0904，新闻客户端，演示AsyncHttpClient和SmartImageView的综合使用，该案例使用AsyncHttpClient实现获取服务器的XML文件并将其解析出来捆绑显示到ListView上，然后使用SmartImageView获取网络图片 四、多线程下载下载一个文件时，使用多线程下载速度通常比使用单线程下载速度快。 使用多线程下载资源时，先要获取到服务器资源文件的大小，然后在本地创建一个与服务器资源一样大的文件，接着在客户端开启若干个线程去下载服务器资源。需要注意的是，每个线程必须要下载对应的模块，然后将每个线程下载的模块按顺序组装成资源文件。 图 9-3 图9-3展示了多线程下载的原理：从图中可以看出，每个线程下载的区域就是总大小/线程个数，但不能保证每个文件都可以完全平均分配资源，因此最后一个线程需要下载到文件的末尾。 需要注意的是，使用多线程下载时，需要在请求头中设置Range字段获取到指定位置的数据，例如Range:byte=100-200 案例：Demo0905，多线程下载文件，并将每个线程的下载进度显示在界面上","categories":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://hepsilion.github.io/tags/Android/"}],"keywords":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}]},{"title":"第八章 服务","slug":"08-Service","date":"2017-03-08T12:45:55.000Z","updated":"2017-10-21T13:19:21.210Z","comments":true,"path":"2017/03/08/08-Service/","link":"","permalink":"https://hepsilion.github.io/2017/03/08/08-Service/","excerpt":"服务的生命周期 服务的两种启动方式 本地服务通信 远程服务通信(调用其它应用的服务)","text":"服务的生命周期 服务的两种启动方式 本地服务通信 远程服务通信(调用其它应用的服务) 服务(Service)和Activity一样，是Android中的四大组件之一，不同的是服务没有界面，是一个长期运行在后台的组件，即使启动服务的应用程序被切换掉，服务仍可以在后台正常运行。因此服务经常被用来处理一些耗时的任务，例如进行网络传输或者播放音乐等。 一、服务的创建1. 创建服务 服务的创建方式与创建Activity类似，只需要继承Service类即可。 示例代码： public class MyService extends Service{ @Nullable @Override public IBinder onBind(Intent intent) { return null; } } 2. 在清单文件中配置 由于服务是Android四大组件中的一个，因此需要在Androidmanifest.xml文件中进行注册，否则服务是不生效的。 示例代码： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;learning.android.it.org.demo0801&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!--注册服务--&gt; &lt;service android:name=&quot;.MyService&quot;/&gt; &lt;/application&gt; &lt;/manifest&gt; 二、服务的生命周期与其他组件不同，Service不能自己主动运行，需要调用相应的方法来启动。启动服务的方法有两种，分别是Context.startService()和Context.bindService()。如图8-1所示，使用不同的方法启动服务，服务的生命周期也会不同。 图 8-1 1. startService方式开启服务的生命周期 当其他组件调用startService()方法时，服务会先执行onCreate()方法，接着执行onStartCommand()方法，此时服务处于运行状态，直到自身调用stopSelf()方法或者其他组件调用stopService()方法时服务停止，最终被系统销毁。 这种方式开启的服务会长期在后台运行，并且服务的状态与开启者的状态无关。 2. bindService方式开启服务的生命周期 当其他组件调用bindService()方法时，服务被创建，接着客户端通过Ibinder接口与服务通信。客户端通过unbindService()方法关闭连接，多个客户端能绑定到同一个服务上，并且当它们都解绑时，系统将直接销毁服务(服务不需要被停止)。 这种方法开启的服务与开启者的状态有关，当调用者销毁了，服务也会被销毁。 3. 服务声明周期中的重要方法 onCreate() 服务被创建时执行的方法。 onDestroy() 服务被销毁时执行的方法。 onStartCommand() 客户端通过startService()显式启动服务时执行该方法。 onBind() 客户端通过调用bindService()方法启动服务时执行该方法。 onUnbind() 客户端调用unBindService()方法断开服务绑定时执行该方法。 三、服务的启动方式前面讲过，启动服务有两种方式，分别是通过startService()方法启动服务和bindService()方法启动服务。 1. start方式启动服务 使用Context的startService()和stopService()方法来启动、关闭服务，Intent对象用于指定要启动或关闭的服务。 Intent intent=new Intent(this, MyService.class); startService(intent); //开启服务 stopService(intent); //关闭服务 onCreate()方法只有在服务创建时执行，而onStartCommand()方法则是在每次启动服务时调用。 需要注意的是，如果不调用stopService()或stopSelf()方法，这种方式开启的服务会长期运行在后台，除非用户强制停止服务。 案例：Demo0801，start方式启动服务 2. bind方式启动服务 当程序使用startService()和stopService()启动、关闭服务时，服务与调用者之间基本不存在太多的关联，也无法与访问者进行通信、数据交互等。 如果服务需要与调用者进行方法调用和数据交互时，应该使用bindService()和unbindService()方法启动、关闭服务。 使用bindService()方式启动服务的标准步骤： // 1. 创建MyConn类，用于实现连接服务 private MyService.MyBinder myBinder; private class MyConn implements ServiceConnection{ @Override public void onServiceConnected(ComponentName name, IBinder service) { myBinder= (MyService.MyBinder) service; Log.i(&quot;MainActivity&quot;, &quot;服务成功绑定，内存地址为&quot;+myBinder.toString()); } @Override public void onServiceDisconnected(ComponentName name) { } } MyConn myConn; // 2. 绑定服务 Intent intent=new Intent(this, MyService.class); bindService(intent, myConn, BIND_AUTO_CREATE); // 3. 利用myBinder调用服务中的方法 myBinder.callMethodInService(); // 4. 解绑服务 unbindService(myConn); bindService()方法的完整方法名为public boolean bindService(Intent service, ServiceConnection conn, int flags)，该方法的参数解释如下： Intent对象用于指定要启动的Service ServiceConnection对象用于监听调用者与Service之间的连接状态。 当调用者与Service连接成功时，将回调该对象的public void onServiceConnected(ComponentName name, IBinder service)方法； 当调用者与Service断开连接时，将回调该对象的public void onServiceDisconnected(ComponentName name)方法。 flags指定绑定时是否自动创建Service(如果Service还未创建)。该参数可指定为0即不自动创建，也可指定为BIND_AUTO_CREATE_即自动创建。 注意：ServiceConnection中的onServiceConnected()方法有一个参数IBinder service，这个参数是在服务的onBind()方法中返回的。 public class MyService extends Service{ // 创建服务的代理，调用服务中的方法 class MyBinder extends Binder{ public void callMethodInService(){ methodInService(); } } public void methodInService(){ Log.i(&quot;BindService&quot;, &quot;自定义方法methodInService&quot;); } @Nullable @Override public IBinder onBind(Intent intent) { Log.i(&quot;BindService&quot;, &quot;onBind&quot;); return new MyBinder(); } @Override public boolean onUnbind(Intent intent) { Log.i(&quot;BindService&quot;, &quot;onUnbind&quot;); return super.onUnbind(intent); } @Override public void onCreate() { super.onCreate(); Log.i(&quot;BindService&quot;, &quot;onCreate&quot;); } } 案例：Demo0802，bind方式启动服务 四、服务通信在Android系统中，服务的通信方式有两种：一种是本地服务通信，另一种是远程服务通信。本地服务通信是指应用程序内部的通信，而远程服务通信是指两个应用程序之间的通信。使用这两种方式进行通信时必须满足一个前提，就是服务必须以绑定方式开启。 1. 本地服务通信 在使用服务进行本地通信时，首先需要开发一个Service类，该类会提供一个IBinder onBind(Intent intent)方法，onBind()方法返回的IBinder对象会作为参数传递给ServiceConnection类中onServiceConnected(ComponentName name, IBinder service)方法，这样访问者就可以通过IBinder对象与Service进行通信。 使用Ibinder对象进行本地服务通信： 图 8-2 如图8-2所示，服务在进行通信时实际上使用的就是IBinder对象，在ServiceConnection类中得到IBinder对象，通过该对象就可以获取到服务中定义的方法，执行具体的操作。 案例：Demo0803，音乐播放器，演示如何使用服务进行通信 (1) MediaPlayer 在Android中，播放音频文件一般都是使用MediaPlayer类来实现的。 setAudioStreamType() 指定音频文件的类型必须在prepare()方法之前调用 setDataSource() 设置要播放的音频文件的位置 prepare() 在开始播放之前调用这个方法完成准备工作 start() 开始或继续播放音频 pause() 暂停播放音频 reset() 将MediaPlayer对象重置到刚刚创建的状态 seekTo() 从指定的位置开始播放音频 stop() 停止播放音频，调用该方法后MediaPlayer对象就无法再播放音频 release() 释放掉与MediaPlayer对象相关的资源 isPlaying() 判断当前MediaPlayer是否正在播放音频 getDuration() 获取载入音频文件的时长 getCurrentPosition() 获取当前播放音频文件的位置 (2) SeekBar SeekBar与ProgressBar十分类似，它是通过滑块的位置来表示数值的。SeekBar允许用户拖动滑块改变SeekBar的值，例如手机的音量调节，同时SeekBar还允许用户改变滑块外观。 SeekBar的常用方法属性： 属性 android:thumb 指定一个Drawable对象，该对象将作为自定义滑块 监听器OnSeekBarChangeListener 监听滑块位置的改变 方法setProgress() 用来设置SeekBar的当前值 方法setMax() 设置SeekBar的最大值 2. 远程通信服务 在Android系统中，各个应用程序都运行在自己的进程中，进程之间一般无法直接进行通信，如果想要完成不同进程之间的通信，就需要使用远程服务通信。 远程服务通信是通过AIDL(Android Interface Definition Language)实现的，它是一种接口定义语言，其语法格式简单，与Java中接口定义类似，但存在几点差异： AIDL定义接口的源代码文件必须以.aidl结尾 AIDL接口中用到的数据类型，除了基本数据类型、String、List、Map、CharSequence之外，其他类型全部都需要导入包，即使它们在同一个包中。 开发人员定义的AIDL接口只是定义了进程之间的通信接口，服务端、客户端都需要使用Android SDK安装目录下的platform-tools子目录下的aidl.exe工具为该接口提供实现。 远程服务调用的实例： 应用A (1) 定义AIDL接口 package learning.android.it.org.demo0804; interface IService { void callAlipayService(); } AIDL接口定义的方式与Java接口的定义方式类似，都需要包名、接口名以及自定义的方法。不同的是，AIDL没有类型修饰符，在编写ADIL文件时，不能加上类型修饰符，因为它本身就是公有的，例如写为public interface IService是不正确的，正确的写法应该为interface IService。定义好AIDL接口之后，aidl.exe会为IService自动生成实现类IService.Stub。 (2) 创建Service 接着需要在应用程序中创建Service的子类，该Service的onBind()方法所返回的IBinder对象应该是aidl.exe所生成的IService.Stub的子类对象。 public class AlipayService extends Service { private class MyBinder extends IService.Stub { @Override public void callAlipayService() throws RemoteException { methodInService(); } } private void methodInService() { Log.v(TAG, &quot;开始付费，购买装备&quot;); } @Nullable @Override public IBinder onBind(Intent intent) { Log.v(TAG, &quot;绑定支付宝，准备付费&quot;); return new MyBinder(); } } (3) 注册Service 由于该Service需要被其他应用调用，因此需要在注册服务时设置一个action，当其他应用使用隐式Intent调用该服务时，就可以通过这个action匹配上该服务。 &lt;service android:name=&quot;.AlipayService&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;www.baidu.com&quot; /&gt; &lt;/intent-filter&gt; &lt;/service&gt; 应用B (1) 复制应用A的AIDL接口文件 (2) 绑定Service 现在在另一个应用绑定上面应用的服务。注意在调用bindService()方法绑定服务时，使用的Intent设置的action需要和上面应用中服务注册的action一致。 private MyConn conn; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //这里Action需要与Demo04在清单文件中服务注册的Action要一致 service = new Intent(); service.setAction(&quot;www.baidu.com&quot;); } public void bind(View view) { conn = new MyConn(); bindService(service, conn, BIND_AUTO_CREATE); } private class MyConn implements ServiceConnection { @Override public void onServiceConnected(ComponentName name, IBinder service) { iService = IService.Stub.asInterface(service); } @Override public void onServiceDisconnected(ComponentName name) { } } (3) 调用应用A的服务 最后在应用B中调用第一个应用的服务提供的方法 public void call(View view) { try { if (iService != null) { iService.callAlipayService(); } } catch (RemoteException e) { e.printStackTrace(); } } 注意：在调用本地方法时，在onServiceConnected()方法中是通过强制转换将service转换为MyBinder的；但在远程服务调用中，需要通过IService.Stub.asInterface(service)方法转换。IService就是应用A中定义的AIDL接口，需要将这个接口文件复制到应用B相同目录下。 案例：Demo0804与Demo0805，模拟小游戏Demo0805远程调用支付宝Demo0804，演示如何绑定并使用远程服务 注意：两个应用程序中的ADIL文件所在的包名要一致。","categories":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://hepsilion.github.io/tags/Android/"}],"keywords":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}]},{"title":"第七章 广播接收者","slug":"07-BroadcastReceiver","date":"2017-03-07T12:44:40.000Z","updated":"2017-10-21T13:19:21.195Z","comments":true,"path":"2017/03/07/07-BroadcastReceiver/","link":"","permalink":"https://hepsilion.github.io/2017/03/07/07-BroadcastReceiver/","excerpt":"创建广播接收者 自定义广播 有序广播和无序广播 常用广播接收者(如开机启动、短信接收)的使用","text":"创建广播接收者 自定义广播 有序广播和无序广播 常用广播接收者(如开机启动、短信接收)的使用 在Android系统中，广播(Broadcast)是一种在应用程序之间传递消息的机制，广播接收者(BroadcaseReceiver)是用来接收、过滤并响应广播的一类组件。通过广播接收者可以监听系统中的广播消息，在不同组件之间进行通信。 一、广播接收者入门在Android系统中内置了很多系统级别的广播，例如，手机开机完成后会发送一条广播，电池电量不足时也会发送一条广播等。为了监听这些广播事件，Android提供了一个BroadcastReceiver组件，该组件可以监听来自系统或者应用程序的广播。 当Android系统产生一个广播事件时，可以有多个对应的BroadcastReceiver接收并进行处理。 1. 广播接收者创建与注册要使用广播接收者接收其他应用程序发出的广播，先要在本应用中创建一个广播接收者类继承自BroadcastReceiver类，然后在清单文件中或者代码中进行注册并指定要接收的广播事件，最后重写广播接收者类的onReceive()方法，在方法中进行处理广播事件即可。 注册广播接收者有两种方式，常驻型广播和非常驻型广播。 (1) 创建广播接收者 要对监听到的广播事件进行处理，需要创建一个类继承自BroadcastReceiver，然后重写onReceive()方法。 public class OutCallReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { } } 当监听到有广播发出时，就会调用onReceive()方法，在onReceive()方法中可以对事件进行处理。 (2) 注册常驻型广播接收者 常驻型广播接收者是当应用程序关闭后，如果接收到其他应用程序发出的广播，那么该程序会自动重新启动。常驻型广播接收者需要在清单文件中进行注册。 示例代码 &lt;receiver android:name=&quot;learning.android.it.org.demo0701.OutCallReceiver&quot; &gt; &lt;intent-filter android:priority=&quot;20&quot;&gt; &lt;action android:name=&quot;android.intent.action.NEW_OUTGOING_CALL&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 上述代码是在清单文件中注册的监听系统拨打电话的广播。 android:name=”learning.android.it.org.demo0701.OutCallReceiver”是创建的广播接收者的全路径名； 与定义隐式意图一样，广播接收者也需要注册一个&lt;intent-filter&gt;，在过滤器中指定要接收的广播事件； android:name=”android.intent.action.NEW_OUTGOING_CALL”是系统内部定义的拨打电话的广播事件； android:priority=”20”是该广播的优先级，这个值越大代表接收的优先级越高。 (3) 注册非常驻型广播接收者 非常驻型广播接收者依赖于注册广播的组件的生命周期，例如在Activity中注册广播接收者，当Activity销毁后，广播也随之被移除。这种广播接收者需要在代码中注册。 示例代码 MyBroadcastReceiver receiver=new MyBroadcastReceiver(); // 实例化过滤器并设置要过滤的广播 String action=&quot;android.intent.action.NEW_OUTGOING_CALL&quot;; IntentFilter intentFilter=new IntentFilter(action); // 注册广播接收者 registerReceiver(receiver, intentFilter); 与清单文件中注册一样，代码注册广播接收者同样需要进行过滤，IntentFilter接收的是监听的广播事件，最后用registerReceiver方法进行注册。 与清单文件注册不同的是，代码有注册也有移除，比如在Activity的onCreate()中注册广播接收者，就要在onDestroy()方法中进行解除广播。 unregisterReceiver(receiver); 需要注意的是，常驻型广播接收者在应用程序关闭后，接收到广播会重新自动创建。非常驻型广播接收者则依赖于注册广播组件的生命周期和调用unregisterReceiver()方法手动移除。 (4) 案例：Demo0701，IP拨号器，当拨打长途电话时，广播接收者就会监听到这个广播事件，自动在电话号码前加上几个数字，如17911、17951等。 注意：在Android4.0一下的系统中，当进程不存在时，只要有响应广播发出，进程就会自动创建并接收广播进行处理。Google工程师认为这样不安全，为了保护用户隐私，在Android4.0以上系统中，当在任务管理器界面强行停止进程后，再有广播发出也不会打开进程进行接收了。 二、自定义广播Android系统中自带了很多广播，如果需要监听某个广播，只需要创建对应的广播接收者即可。在实际开发中，当这些系统级广播事件不能满足实际需求时，还可以自定义广播。需要注意的是，自定义广播需要由对应的广播接收者去接收，否则这个广播是无意义的。 案例：Demo0702，电台与收音机 创建广播：创建一个Intent对象，然后通过Intent.setAction()语句指定广播事件，最后通过sendBroadcast(intent)发送广播。 Intent intent = new Intent(); // 定义广播的事件类型 intent.setAction(&quot;www.baidu.com&quot;); // 发送广播 sendBroadcast(intent); 接收广播：和接收系统广播事件一样，创建一个广播接收者类继承自BroadcastReceiver类，然后在清单文件中或者代码中进行注册并指定要接收的广播事件，最后重写广播接收者类的onReceive()方法，在方法中进行处理广播事件即可。需要注意的是，自定义的广播事件与广播接收者在清单文件中注册的事件要一致，否则无法接收广播 &lt;receiver android:name=&quot;learning.android.it.org.demo0702.MyBroadcastReceiver&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;www.baidu.com&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 三、广播的类型在Android系统中，根据广播被接收顺序的不同，可以将其分为有序广播和无序广播。 1. 无序广播 无序广播是一种完全异步被接收的广播，在广播发出去之后，所有监听了这个广播事件的广播接收者都会在同一时刻接收到这个广播，它们之间没有任何先后顺序可言，这种广播的效率会比较高，但同时意味着它是无法被截断的。 图7-1 无序广播的工作流程如图7-1所示，当无序广播发送一条广播消息时，所有的广播接收者都可以接收到，不会被拦截。 2. 有序广播 有序广播是一种同步接收的广播，在广播发出之后，同一时刻只会有一个广播接收者能够接收到这条消息，当这个广播接收者中的逻辑执行完后，广播才会继续传递。所以，此时的广播接收者是有先后顺序的，并且可以被拦截。 图7-2 有序广播的工作流程如图7-2所示，当有序广播发送一条消息后，高优先级的广播接收者先接收到广播，低优先级的广播接收者后接收到广播。 Intent intent = new Intent(); // 定义广播的事件类型 intent.setAction(&quot;www.baidu.com&quot;); // 发送有序广播 //第一个参数是指定的意图，设置要发送的广播事件；第二个参数指定接收者的权限，如果不想让所有的接收到看到，可以显示地指定接收者的权限，目前不关心，可以将其设置为null sendOrderedBroadcast(intent, null); 优先级是在清单文件中注册广播接收者时定义的android:priority=””参数，优先级的范围是-1000~1000之间。如果两个广播接收者的优先级相同，则先注册的组件优先接收到广播。如果两个应用程序监听了同一个广播事件并设置了优先级，则优先级高的应用优先接收到广播。 &lt;receiver android:name=&quot;learning.android.it.org.demo0703.MyBroadcastReceiver02&quot; &gt; &lt;intent-filter android:priority=&quot;1000&quot; &gt; &lt;action android:name=&quot;www.baidu.com&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver android:name=&quot;learning.android.it.org.demo0703.MyBroadcastReceiver01&quot; &gt; &lt;intent-filter android:priority=&quot;1000&quot; &gt; &lt;action android:name=&quot;www.baidu.com&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver android:name=&quot;learning.android.it.org.demo0703.MyBroadcastReceiver03&quot; &gt; &lt;intent-filter android:priority=&quot;600&quot; &gt; &lt;action android:name=&quot;www.baidu.com&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 如果高优先级的广播接收者将广播终止，则后面的广播接收者无法接收到广播。想要拦截一条广播不往下发送，可以使用abortBroadcast()方法。 public class MyBroadcastReceiver02 extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { Log.i(&quot;MyBroadcastReceiver02&quot;, &quot;自定义的广播接收者02,接收到了自定义的广播事件&quot;); Log.i(&quot;MyBroadcastReceiver02&quot;, &quot;自定义的广播接收者02，接收到了广播事件&quot;); abortBroadcast(); // 拦截有序广播，这句代码执行完后，广播事件将会被终止。 Log.i(&quot;MyBroadcastReceiver02&quot;, &quot;我是广播接收者02，广播被我终结了&quot;); } } 在实际开发中，还可能遇到这样的情况，当发出了一个有序广播，然后定义多个广播接收者接收这条广播。这些广播接收者的优先级有高有低，需要其中一个广播接收者无论如何都要接收到广播事件，哪怕它的优先级是最低的或者广播被优先级高的接收者强行终止。这时，就可以用一下sendOrderedBroadcast的重载方法，在第三个参数指定要接收的广播接收者。 MyBroadcastReceiver03 receiver03 = new MyBroadcastReceiver03(); sendOrderedBroadcast(intent, null, receiver03, null, 0, null, null); 案例：Demo0704，拦截有序广播 四、常用的广播接收者案例：Demo0704，短信拦截器，监听短信接收的广播事件（拦截没起作用） &lt;receiver android:name=&quot;learning.android.it.org.demo0704.MessageReceiver&quot; &gt; &lt;intent-filter android:priority=&quot;1000&quot; &gt; &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 设置action为android.provider.Telephony.SMS_RECEIVED，接收短信的广播事件 在Windows系统中，有些软件一开机就自动启动，同样在Android系统中也可以实现这种功能，例如杀毒软件程序，每次手机开机便会自动启动，这种功能就是通过广播接收者监听开机启动的广播事件实现的。 案例：Demo0705，杀毒软件，监听开机启动的广播事件 public class BootReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { Intent i = new Intent(context, MainActivity.class); // 由于Activity都是运行在任务栈中的，当开机启动时，任务栈还未创建成功，所以需要设置flag，显示地指定Activity在新的任务栈中运行 i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(i); } } &lt;receiver android:name=&quot;learning.android.it.org.demo0705.BootReceiver&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 设置action为android.intent.action.BOOT_COMPLETED，接收开机启动的广播事件 需要注意的是，在Android3.0以后出现了一个安全机制，如果用户没有启动过这个程序，那么就算该程序注册了开机启动的广播接收者也无法接收到开机启动的广播事件。","categories":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://hepsilion.github.io/tags/Android/"}],"keywords":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}]},{"title":"第六章 ContentProvider","slug":"06-ContentProvider","date":"2017-03-06T12:43:55.000Z","updated":"2017-10-21T13:19:21.164Z","comments":true,"path":"2017/03/06/06-ContentProvider/","link":"","permalink":"https://hepsilion.github.io/2017/03/06/06-ContentProvider/","excerpt":"了解ContentProvider 使用ContentProvider 使用ContentResolver操作其他应用的数据 使用ContentObserver观察其他应用的数据变化","text":"了解ContentProvider 使用ContentProvider 使用ContentResolver操作其他应用的数据 使用ContentObserver观察其他应用的数据变化 在Android开发中，经常需要访问其他应用程序的数据。例如，使用支付宝转账时需要填写收款人的电话号码，此时就需要获取到系统联系人的信息。为了实现这种跨程序共享数据的功能，Android系统提供了一个组件：ContentProvider。 一、ContentProvider简介ContentProvider是Android系统四大组件之一，用于保存和检索数据，是Android系统中不同应用程序之间共享数据的接口。 在Android系统中，应用程序之间是相互独立的，分别运行在自己的进程中，相互之间没有数据交换。若应用程序之间需要共享数据，就需要用到ContentProvider。 ContentProvider是不同应用程序之间进行数据交换的标准API，它以Uri的形式对外提供数据，允许其他应用操作本应用数据。其他应用则使用ContentResolver，并根据ContentProvider提供的Uri操作指定数据。 ContentProvider的工作原理 图6-1 如图6-1所示，A应用需要使用ContentProvider暴露数据，才能被其他应用操作。B应用必须通过ContentResolver操作A应用暴露出来的数据，而A应用会将操作结果返回给ContentResolver，然后ContentResolver再将操作结果返回给B应用。 二、创建ContentProvider1. 创建ContentProvider(1) 创建ContentProvider，暴露数据的增、删、改、查方法 在创建一个ContentProvider时，首先需要定义一个类继承android.content包下的ContentProvider类。ContentProvider类是一个抽象类，在使用该类时，需要重写它的onCreate()、delete()、getType()、insert()、query()和update()这几个抽象方法。 public class PersonDBProvider extends ContentProvider { //当ContentProvider被创建的时候调用，适合数据的初始化 @Override public boolean onCreate() { helper=new PersonSQLiteOpenHelper(getContext()); return false; } //根据传入的Uri查询指定条件下的数据 @Nullable @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { //匹配查询的Uri路径 if(matcher.match(uri)==QUERY){ SQLiteDatabase db=helper.getReadableDatabase(); Cursor cursor=db.query(&quot;person&quot;, projection, selection, selectionArgs, null, null, sortOrder); return cursor; }else if(matcher.match(uri)==QUERYONE){ long id= ContentUris.parseId(uri);//匹配成功,根据id查询数据 SQLiteDatabase db=helper.getReadableDatabase(); Cursor cursor=db.query(&quot;&quot;, projection, &quot;id=?&quot;, new String[]{id+&quot;&quot;}, null, null, sortOrder); return cursor; }else{ throw new IllegalArgumentException(&quot;路径不匹配，不能执行查询操作&quot;); } } // 用于返回指定Uri代表的数据MIME类型，如.jpg和.txt。 // 如果指定数据的类型属于集合型(多条数据)，getType()方法返回的字符串应该以&quot;vnd.android.cursor.dir/&quot;开头； // 如果属于非集合型(单条数据)，则返回的字符串以&quot;vnd.android.cursor.item/&quot;开头。 @Nullable @Override public String getType(Uri uri) { if(matcher.match(uri)==QUERY){ return &quot;vnd.android.cursor.dir/person&quot;;// 返回查询的结果集 }else if(matcher.match(uri)==QUERYONE){ return &quot;vnd.android.cursor.item/person&quot;; } return null; } //根据传入的Uri插入数据 @Nullable @Override public Uri insert(Uri uri, ContentValues values) { if(matcher.match(uri)==INSERT){ SQLiteDatabase db=helper.getWritableDatabase(); db.insert(&quot;person&quot;, null, values); }else{ throw new IllegalArgumentException(&quot;路径不匹配，不能执行插入操作&quot;); } return null; } //根据传入的Uri删除指定条件下的数据 @Override public int delete(Uri uri, String selection, String[] selectionArgs) { if(matcher.match(uri)==DELETE){ SQLiteDatabase db=helper.getWritableDatabase(); db.delete(&quot;person&quot;, selection, selectionArgs); }else{ throw new IllegalArgumentException(&quot;路径不匹配，不能执行删除操作&quot;); } return 0; } //根据传入的Uri更新指定条件下的数据 @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) { if(matcher.match(uri)==UPDATE){ SQLiteDatabase db=helper.getWritableDatabase(); db.update(&quot;person&quot;, values, selection, selectionArgs); }else{ throw new IllegalArgumentException(&quot;路径不匹配，不能执行修改操作&quot;); } return 0; } } (2) 注册ContentProvider ContentProvider是Android的四大组件之一，因此需要和Activity一样在清单文件中注册。 &lt;provider android:authorities=&quot;learning.android.it.org.demo0601.PersonDBProvider&quot; android:name=&quot;learning.android.it.org.demo0601.PersonDBProvider&quot;/&gt; 注册provider时指定了android:name和android:authorities两个属性。 android:name代表继承于ContentProvider类的全路径名 android:authorities代表了访问本provider的路径，这里的路径必须要唯一。 2. Uri简介在ContentProvider的几个抽象方法中，都有一个参数Uri uri，它代表了数据的操作方法。 Uri是由scheme、authorities、path三部分组成。 图6-2 图6-2是一个Uri的实例。 scheme部分content://是一个标准的前缀，表明这个数据被ContentProvider所控制，它不会被修改。 authorities部分learning.android.it.org.demo0601.PersonDBProvider是在清单文件中指定的android:authorities属性值，该值必须唯一，它代表了当前的ContentProvider。 path部分/query代表资源(或者数据)，当访问者需要操作不同数据时，这部分是动态改变的。 Uri.parse(String str)方法可以将字符串转化为Uri对象。为了解析Uri对象，Android系统提供了一个辅助工具类UriMatcher用于匹配Uri。 public UriMatcher(int code) 创建UriMatcher对象时调用，参数通常使用UriMatcher.NO_MATCH，表示路径不满足时返回-1 public void addURI(String authority, String path, int code) 添加一组匹配规则，authority 即Uri的authority部分，path 即Uri的path部分 public int match(Uri uri) 匹配Uri与addURI方法相对应，匹配成功则返回addURI方法中传入的参数code值 使用UriMatcher匹配Uri的实例代码： 在暴露数据的增、删、改、查方法之前，首先需要添加一组用于请求数据操作的Uri，然后在相应的增删改查方法中匹配Uri，匹配成功才能对数据进行操作。 // 定义一个uri的匹配器，用于匹配uri，如果路径不满足条件，则返回 -1 private static UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH); private static final int INSERT = 1; //添加数据Uri路径匹配成功时返回码 private static final int DELETE = 2; //删除数据Uri路径匹配成功时返回码 private static final int UPDATE = 3; //更改数据Uri路径匹配成功时返回码 private static final int QUERY = 4; //查询数据Uri路径匹配成功时返回码 private static final int QUERYONE = 5; //查询一条数据Uri路径匹配成功时返回码 // 添加一组匹配规则 static{ matcher.addURI(&quot;learning.android.it.org.demo0601.PersonDBProvider&quot;, &quot;insert&quot;, INSERT); matcher.addURI(&quot;learning.android.it.org.demo0601.PersonDBProvider&quot;, &quot;delete&quot;, DELETE); matcher.addURI(&quot;learning.android.it.org.demo0601.PersonDBProvider&quot;, &quot;update&quot;, UPDATE); matcher.addURI(&quot;learning.android.it.org.demo0601.PersonDBProvider&quot;, &quot;query&quot;, QUERY); //这里的&quot;#&quot;号为通配符，凡是符合&quot;query/&quot;，皆返回QUERYONE的返回码 matcher.addURI(&quot;learning.android.it.org.demo0601.PersonDBProvider&quot;, &quot;query/#&quot;, QUERYONE); } 案例：Demo0601，本案例实现了查询应用自己暴露的数据，并将数据捆绑到ListView控件中的功能。 三、访问ContentProvider在Android系统中，ContentResolver充当着一个中介的角色。应用程序使用ContentProvider暴露自己的数据，通过ContentResolver可以对应用程序暴露的数据进行操作。 1. ContentResolver的基本用法由于在使用ContentProvider暴露数据时指定了相应数据的Uri，因此在访问现有ContentProvider时需要指定相应的Uri，然后通过ContentResolver对象来实现数据的操作。 示例代码 //利用ContentResolver对象查询使用ContentProvider暴露的数据 private void getPersons(){ //首先要获取查询的uri String path=&quot;content://learning.android.it.org.demo0601.PersonDBProvider/query&quot;; Uri uri= Uri.parse(path); //获取ContentResolver对象 ContentResolver resolver = getContentResolver(); //利用ContentResolver对象查询数据,得到一个Cursor对象 Cursor cursor=contentResolver.query(uri, null, null, null, null, null); persons=new ArrayList&lt;&gt;(); //如果cursor为空立即结束该方法 if(cursor==null){ return; } while(cursor.moveToNext()){ int id=cursor.getInt(cursor.getColumnIndex(&quot;id&quot;)); String name=cursor.getString(cursor.getColumnIndex(&quot;name&quot;)); String number=cursor.getString(cursor.getColumnIndex(&quot;number&quot;)); Person p=new Person(id, name, number); persons.add(p); } //需要注意的是，使用完Cursor之后，一定要关闭，否则会造成内存泄露 cursor.close(); } 案例：Demo0602，本案例实现了使用ContentResolver操作Android系统短信应用暴露的数据，将系统短信的会话内容备份到本地XML文件的功能。 四、内容观察者的使用前面介绍的是当使用ContentProvider将数据共享出来时，可以使用ContentResolver查询ContentProvider共享出来的数据。 如果应用程序需要实时监听ContentProvider共享的数据是否发生变化，可以使用Android系统提供的ContentObserver来实现。 1. 什么是ContentObserverContentObserver用来观察指定Uri所代表的数据。当ContentObserver观察到指定Uri代表的数据发生变化时，就会触发ContentObserver的onChange()方法，此时，在onChange()方法里使用ContentResolver可以查询到变化的数据。 ContentObserver的工作原理： 图6-3 如图6-3所示，使用ContentObserver观察A应用的数据时，首先要在A应用的ContentProvider中调用ContentResolver的notifyChange()方法。调用了这个方法之后，当数据发生变化时，它就会向”消息中心”发送数据变化的消息。然后C应用观察到”消息中心”有数据变化，就会触发ContentObserver的onChange()方法。 ContentObserver的几个方法： public void Observer(Handler handler) ContentObserver的派生类都需要调用该构造方法。参数可以是主线程Handler(可以更新UI)，也可以是任何Handler对象 public void onChange(boolean selfChange) 当观察到Uri代表的数据发生变化时，会触发该方法 2. 使用ContentObserver如果要使用ContentObserver观察数据变化，就必须在ContentProvider中的delete()、insert()、update()方法中调用ContentResolver的notifyChange()方法。 示例代码： public Uri insert(Uri uri, ContentValues values) { if(matcher.match(uri)==INSERT){ SQLiteDatabase db=helper.getWritableDatabase(); db.insert(&quot;person&quot;, null, values); getContext().getContentResolver().notifyChange(Uri.parse(&quot;learning.android.it.org.demo0601.PersonDBProvider&quot;), null); }else{ throw new IllegalArgumentException(&quot;路径不匹配，不能执行插入操作&quot;); } return null; } 上面代码通过调用ContentResolver的notifyChange()方法将数据变化的消息发送至”消息中心”。notifyChange(Uri uri, ContentObserver observer)方法中的observer参数表示指定具体的观察者接收数据发生变化的消息。如果不指定具体的观察者则传入null即可。 接下来在应用中注册ContentObserver监听数据变化。 示例代码： public class MainActivity extends AppCompatActivity { private TextView mSmsTv; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mSmsTv = (TextView) findViewById(R.id.sms_tv); ContentResolver resolver = getContentResolver(); Uri uri = Uri.parse(&quot;content://sms/&quot;); // 注册内容观察者 resolver.registerContentObserver(uri, true, new MyObserver(new Handler())); } // 自定义的内容观察者 private class MyObserver extends ContentObserver { public MyObserver(Handler handler) { super(handler); } // 当ContentObserver观察到是数据库的内容变化了，调用这个方法 // 观察到消息邮箱里面有一条数据库内容变化的通知. public void onChange(boolean selfChange) { super.onChange(selfChange); Toast.makeText(MainActivity.this, &quot;数据库的内容变化了.&quot;, Toast.LENGTH_SHORT).show(); Uri uri = Uri.parse(&quot;content://sms/&quot;); // 获取ContentResolver对象 ContentResolver resolver = getContentResolver(); // 查询变化的数据 Cursor cursor = resolver.query(uri, new String[] { &quot;address&quot;, &quot;date&quot;, &quot;type&quot;, &quot;body&quot; }, null, null, null); // 因为短信是倒序排列 因此获取最新一条就是第一个 cursor.moveToFirst(); String address = cursor.getString(0); String body = cursor.getString(3); // 更改UI界面 mSmsTv.setText(&quot;短信内容：&quot; + body + &quot;\\n&quot; + &quot;短信地址：&quot; + address); cursor.close(); } } } 案例：Demo0603，本案例实现了接收系统短信并将收到的短信显示在界面上的功能","categories":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://hepsilion.github.io/tags/Android/"}],"keywords":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}]},{"title":"第五章 SQLite数据库","slug":"05-SQLite","date":"2017-03-05T12:43:19.000Z","updated":"2017-10-21T13:19:21.132Z","comments":true,"path":"2017/03/05/05-SQLite/","link":"","permalink":"https://hepsilion.github.io/2017/03/05/05-SQLite/","excerpt":"SQLite数据库的基本操作 使用sqlite3工具操作数据库 使用ListView控件展示数据","text":"SQLite数据库的基本操作 使用sqlite3工具操作数据库 使用ListView控件展示数据 一、SQLite数据库简介SQLite是一个轻量级数据库，占用资源少，遵守ACID事务属性，同时还支持SQL语言、事务处理等功能。 SQLite没有服务器进程，它通过文件保存数据，该文件是跨平台的，可以放在其他平台中使用。 在保存数据时，支持NULL、Integer、Real(浮点型数字)、Text(字符串文本)和Blob(二进制对象)5种数据类型。但实际上SQLite也接收varchar(n)、char(n)、decimal(p, s)等数据类型，只不过在运算或保存时会转换成对应的5种数据类型。因此，可以将各种类型的数据保存到任何字段中，而不用关心字段声明的数据类型。这也是SQLite数据库的最大特点。 二、SQLite数据库的使用1. SQLite操作API为了方便使用SQLite数据库，Android SDK提供了一系列对数据库进行操作的类和接口。 (1) SQLiteOpenHelper类 SQLiteOpenHelper是一个抽象类，该类用于创建数据库和数据库版本更新。该类常用方法如图5-1所示 图 5-1 (2) SQLiteDatabase类 SQLiteDatabase是一个数据库访问类，该类封装了一系列数据库操作的API，可以对数据库进行增、删、改、查操作。该类的常用方法如图5-2所示。 图 5-2 (3) Cursor接口 Cursor是一个游标接口，在数据库操作中作为返回值，相当于结果集ResultSet。该类的常用方法如图5-3所示。 图 5-3 2. SQLite常用操作(1) 创建SQLite数据库 Android系统推荐使用SQLiteOpenHelper的子类创建SQLite数据库，因此需要创建一个类继承自SQLiteOpenHelper，重写onCreate()方法，并在该方法中执行创建数据库的命令。 示例代码 public class PersonSQLiteOpenHelper extends SQLiteOpenHelper{ // 构造方法，用来定义数据库的名称，数据库查询的结果集，数据库的版本 public PersonSQLiteOpenHelper(Context context){ super(context, &quot;person.db&quot;, null, 5); } // 数据库第一次被创建时调用该方法 public void onCreate(){ // 初始化数据库的表结构，执行一条建表的SQL语句 db.execSQL(&quot;create table person (id integer primary key autoincrement, name varchar(20), number varchar(20))&quot;); } // 当数据库的版本号增加时调用，如果数据库的版本号不增加，该方法则不会调用 public void onUpgrade(){ db.execSQL(&quot;alter table person add account varchar(20)&quot;); } } 值得注意的是，创建的数据库被放置在/data/data/packagename/databases目录下。 (2) 增 示例代码：使用SQLiteDatabase对象向person表中插入一条数据 public void add(String name, String number){ // 获取一个可读写的SQLiteDatabase对象 SQLiteDatabase db=helper.getWritableDatabase(); // 创建一个ContentValues对象，将参数以key，value的形式添加进去 ContentValues values=new ContentValues(); values.put(&quot;name&quot;, name); values.put(&quot;number&quot;, number); // 插入一条数据到person表中 long id=db.insert(&quot;person&quot;, null, values); // 关闭数据库 db.close(); return id; } 除了上述介绍的方法之外，还有一个方法可以实现该功能： db.execSQL(&quot;insert into person(name, number) values (?, ?)&quot;, new Object[]{name, number}); 需要注意的是，使用完SQLiteDatabase对象后一定要关闭，否则数据库连接会一直存在，不断消耗内存，并且会报出数据库未关闭异常，当系统内存不足时将获取不到SQLiteDatabase对象。 (3) 删 示例代码：使用SQLiteDatabase对象的delete()方法删除person表中的数据 public int delete(String name){ // 获取一个可读写的SQLiteDatabase对象 SQLiteDatabase db=helper.getWritableDatabase(); // 删除数据 int number=db.delete(&quot;person&quot;, &quot;name=?&quot;, new String[]{name}); // 关闭数据库 db.close(); return number; } (4) 改 示例代码：使用SQLiteDatabase对象的update()方法修改person表中的数据 public int update(String name, String newNumber) { // 获取一个可读写的SQLiteDatabase对象 SQLiteDatabase db=helper.getWritableDatabase(); // 创建一个ContentValues对象，将参数以key，value的形式添加进去 ContentValues values=new ContentValues(); values.put(&quot;number&quot;, newNumber); //执行修改 int number=db.update(&quot;person&quot;, values, &quot;name=?&quot;, new String[]{name}); // 关闭数据库 db.close(); return number; } (5) 查 SQLiteDatabase提供两个用于查询数据的方法，一个是rawQuery()方法，另一个是query()方法。 示例代码：使用SQLiteDatabase对象的query()方法查询person表中的数据 public boolean find(String name){ // 获取一个可读的SQLiteDatabase对象 SQLiteDatabase db=helper.getReadableDatabase(); // 查询数据库的操作 // 参数1：表名； 参数2：查询的列名； 参数3：查询条件； // 参数4：查询参数值； 参数5：分组条件； 参数6：having条件； 参数7：排列方式 Cursor cursor=db.query(&quot;&quot;, null, &quot;&quot;, new String[]{name}, null, null, null); // 是否有下一个值 boolean result=cursor.moveToNext(); // 关闭游标 cursor.close(); // 关闭数据库 db.close(); return result; } 使用SQLiteDatabase对象的rawQuery()方法查询person表中的数据 Cursor cursor=db.rawQuery(&quot;select * from person where name=?&quot;, new String[]{name}); 增、删、改操作都可以用execSQL()方法执行SQL语句，而查询却使用rawQuery()，这是因为查询数据库会返回一个结果集Cursor，而execSQL()方法没有返回值。 需要注意的是，在使用完Cursor对象时，一定要及时关闭，否则会造成内存泄露。 3. SQLite事务操作所谓的事务就是针对数据库的一组操作，它可以由一条或多条SQL语句组成，由于事务的操作具备原子性的特点，如果其中有一条语句无法执行，那么所有的语句都不会执行，也就是说，事务中的语句要么都执行，要么都不执行。 示例代码：使用SQLite的事务来模拟转账功能 首先得到一个SQLiteDatabase对象，然后开启事务执行事务操作，最后关闭事务。 PersonSQLiteOpenHelper helper=new PersonSQLiteOpenHelper(getContext()); // 获取一个可读写的SQLiteDatabase对象 SQLiteDatabase db=helper.getWritableDatabase(); // 开始数据库的事务 db.beginTransaction(); try{ //执行转出操作 db.execSQL(&quot;update person set account=account-100 where name=?&quot;, new Object[]{&quot;zhangsan&quot;}); //执行转入操作 db.execSQL(&quot;update person set account=account+100 where name=?&quot;, new Object[]{&quot;wangwu&quot;}); //标记数据库事物执行成功 db.setTransactionSuccessful(); }catch(Exception e){ Log.i(&quot;事务处理失败&quot;, e.toString()); }finally{ db.endTransaction(); //关闭事务 db.close(); //关闭数据库 } 需要注意的是，事务操作完成后，一定要使用endTransaction()方法关闭事务，当执行到endTransaction()方法时，首先会检查是否有事务执行成功的标记，有则提交数据，无则回滚数据。最后会关闭事务，如果不关闭事务，事务只有到超时才自动结束，会降低数据库并发效率。因此，通常情况下，该方法放在finally中执行。 4. sqlite3工具在Android开发中，使用真机进行测试无法进入data目录(只有获得root权限的手机可以进入data目录)，因此也无法直接操作应用程序下的数据库。为了解决这个问题，SQLite数据库为开发者提供了一个sqlite3.exe工具，通过这个工具可以直接操作数据库。 sqlite3.exe是一个简单的SQLite数据库管理工具，位于Android sdk/tools目录下。由于Android在运行时集成了sqlite3.exe，因此在使用sqlite3.exe工具前必须要开启模拟器或者连接真实设备。 使用该工具时，需要在命令行，一次输入如下命令： adb shell (挂载到Linux的目录空间) cd data/data (进入data/data目录) cd packagename (进入应用程序包目录中) ls (列出当前文件夹下的文件) cd databases (进入databases文件夹) ls -l (列出当前文件夹所有文件的详细格式) sqlite3 person.db (使用sqlite3操作应用程序下的数据库) select * from person; (使用SQL语句查询person表中的信息) 三、ListView在Android开发中，ListView是一个比较常用的控件。它以列表的形式展示具体数据内容，并且能够根据数据的长度自适应屏幕显示。 1. ListView控件的使用 ListView的常见属性如图5-4所示。 图 5-4 使用ListView的示例代码： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/ll_root&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;ListView android:id=&quot;@+id/lv&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;/LinearLayout&gt; 图5-5 图形化界面如图5-5所示，ListView是一个列表视图，由很多Item组成，每一个Item的布局都是一样的。需要注意的是，在布局文件中指定了ListView的id之后，ListView才会在图形化视图中显示出来。同时如果不对ListView进行数据适配，那么就无法在界面上看到布局文件中创建的ListView。 2. 常用数据适配器 在使用ListView时，需要对其进行数据适配。为了实现这个功能，Android系统提供了一系列的适配器(Adapter)对ListView进行数据适配。可以将适配器理解为界面数据绑定，适配器就像显示器，把复杂的数据按人们易于接受的方式来展示。 (1) BaseAdapter 它是一个抽象类，该类拥有4个抽象方法。在Android开发中，开发者在适配数据到ListView时，需要创建一个类继承BaseAdapter并重写这4个抽象方法，Android系统再根据这几个抽象方法对ListView进行数据适配。 public int getCount(); 得到ListView中Item的总数 public Object getItem(int position); 根据position得到某个Item对象 public long getItemId(int position); 根据position得到某个Item对象的id public View getView(int position, View convertView, ViewGroup parent); 得到position位置对应的Item视图 (2) SimpleAdapter SimpleAdapter继承自BaseAdapter，实现了BaseAdapter的4个抽象方法。因此，开发者只需在创建SimpleAdapter实例时，在构造方法中传入相应的参数即可。 SimpleAdapter的构造方法： public SimpleAdapter(Context context, List&lt;? extends Map&lt;String, ?&gt; data, int resource, String[] from, int[] to); 构造方法的参数介绍如下： Context context：Context对象，getView()方法中需要用到Context将布局转换成View对象 List&lt;? extends Map&gt; data：数据集合，SimpleAdapter已经在getCount()放啊中实现了将数据集合大小返回。 int resource：Item布局的资源id String[] from：Map集合里面的key int[] to：Item布局对应的空间id 需要注意的是，SimpleAdapter只能适配Checkable、TextView、ImageView，其中Checkable是一个接口，CheckBox控件就实现了该接口，TextView是显示文本的控件，ImageView是显示图片的空间。如果int[] to所代表的控件不是这三种类型则会报IllegalStateException。 (3) ArrayAdapter ArrayAdapter也是BaseAdapter的子类，与SimpleAdapter类似，开发者只需要在构造方法里面传入相应的参数即可适配数据。 // 需要适配的数据 private String[] names = { &quot;京东商城&quot;, &quot;QQ&quot;, &quot;QQ斗地主&quot;, &quot;新浪微博&quot;, &quot;天猫&quot;, &quot;UC浏览器&quot;, &quot;微信&quot; }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 初始化ListView控件 mListView = (ListView) findViewById(R.id.lv); // ArrayAdapter mListView.setAdapter(new ArrayAdapter&lt;String&gt;(this, R.layout.list_item, R.id.tv_list, names)); } ArrayAdapter通常用于适配TextView控件，例如Android系统中的Setting。 ArrayAdapter的构造方法如下所示：public ArrayAdapter(Context context, int resource, int textViewResourceId, T[] objects); 构造方法的参数介绍如下： Context context：Context对象 int resource：Item布局资源的id int textViewResourceId：Item布局相应的TextView控件的id T[] objects：需要适配的数据数组 案例：Demo0501，Android应用市场，演示如何使用ListView以及如何对其进行数据适配。本案例要实现的是将一个字符数组和一组图片资源绑定到ListView上显示。 案例：Demo0502，商品展示，结合ListView和SQLite来实现在界面上操作数据库。 ListView的几个方法： setOnItemClickListener()方法：该方法用于监听Item的点击事件，在使用该方法时需要传入一个OnItemClickListener的实现类对象，并且需要实现onItemClick方法。当点击ListView的Item时就会触发Item的点击事件然后回调onItemClick()方法。 setSelection()方法：该方法用于设置当前选中的条目。 notifyDataSetChange()方法：当数据适配器中的内容发生变化时会调用该方法，重新执行Adapter的getView()方法。","categories":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://hepsilion.github.io/tags/Android/"}],"keywords":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}]},{"title":"第四章 数据存储","slug":"04-数据存储","date":"2017-03-04T12:42:20.000Z","updated":"2017-10-21T13:19:21.117Z","comments":true,"path":"2017/03/04/04-数据存储/","link":"","permalink":"https://hepsilion.github.io/2017/03/04/04-数据存储/","excerpt":"5种数据存储方式的特点 使用文件存储数据 使用SharedPreferences存储数据 XML文件的序列化与解析","text":"5种数据存储方式的特点 使用文件存储数据 使用SharedPreferences存储数据 XML文件的序列化与解析 大部分应用程序都会涉及到数据存储，Android程序也不例外。Android中的数据存储方式有5种，分别为文件存储、SharedPreferences、SQLite数据库、ContentProvider以及网络存储，每种方式都有其不同的特点。 文件存储：以I/O流形式把数据存入手机内存或者SD卡，可以存储大量数据，如音乐、图片或者视频等。 SharedPreferences：它本质上是一个XML文件，以Map形式存入手机内存中。常用于存储较简单的参数设置，如登录帐号密码的存储、窗口功能状态的存储等，使用起来简单、方便。 SQLite数据库：SQLite是一个轻量级、跨平台的数据库。数据库中所有信息都存储在单一文件中，占用内存小，并且支持基本SQL语法，是项目中经常被采用的一种数据存储方式，通常用于存储用户信息等。 ContentProvider：又称为内容提供者，是Android四大组件之一，以数据库形式存入手机内存，可以共享自己的数据给其他应用使用。相对于其他对外共享数据的方式而言，ContentProvicer统一了数据访问方式，使用起来更规范。 网络存储：把数据存储在服务器上，不存储在本地，使用的时候直接从网络获取，避免了手机端信息丢失以及其他的安全隐患。 需要注意的是，Android中应用程序存储的数据都属于应用私有，如果要将程序的私有数据分享给其他应用程序，可以使用文件存储、SharedPreferences以及ContentProvider，推荐使用ContentProvider。 一、文件存储1. 文件存储简介文件存储是Android中最基本的一种数据存储方式，它与Java中的文件存储类似，都是通过I/O流的形式把数据原封不动地存储到文件中。不同的是，Android中的文件存储分为内部存储和外部存储。 (1) 内部存储 内部存储是指将应用程序中的数据以文件方式存储到设备的内部存储空间中(该文件位于data/data/packagename/files/目录下)。 内存存储方式存储的文件为其所创建的应用程序所私有，如果其他应用程序要操作本应用程序中的文件，需要设置权限。 当创建的应用程序被卸载时，其内部存储文件也随之被删除。 内部存储可以使用Context提供的openFileOutput(String name, int mode)方法和openFileInput(String name)方法分别获取FileOutputStream对象和FileInputStream对象。 openFileOutput() 用于打开应用程序中对应的输出流，将数据存储到指定的文件中； openFileInput() 用于打开应用程序中对应的输入流，用于从文件中读取数据。 其中参数name表示文件名，mode表示文件的操作模式，也就是读写文件的方式，它的取值有4种： MODE_PRIVATE：该文件只能被当前程序读写，默认的操作方式； MODE_APPEND：该文件的内容可以追加，常用的一种方式； MODE_WORLD_READABLE：该文件的内容可以被其他程序读取，安全性低，通常不使用； MODE_WORLD_WRITEABLE: 该文件的内容可以被其他文件程序写入，安全性低，通常不使用。 使用FileOutputStream对象将数据存储到文件中的示例代码： String saveinfo = et_info.getText().toString().trim(); FileOutputStream fos; try { fos = openFileOutput(&quot;data.txt&quot;, Context.MODE_APPEND); fos.write(saveinfo.getBytes()); fos.close(); } catch (Exception e) { e.printStackTrace(); } 使用FileInputStream对象从文件中读取数据的示例代码： String content = &quot;&quot;; try { FileInputStream fis = openFileInput(&quot;data.txt&quot;); byte[] buffer = new byte[fis.available()]; fis.read(buffer); content = new String(buffer); } catch (Exception e) { e.printStackTrace(); } 案例：Demo0401，存储用户信息，用文件存储信息以及从文件中读取信息 (2) 外部存储 外部存储是指将文件存储到一些外围设备上(该文件通常位于mnt/sdcard目录下，不同厂商生产的手机这个路径可能会不同)，例如SD卡或者设备内嵌的存储卡，属于永久性的存储方式。 外部存储的文件可以被其他应用程序所共享，当将外围存储设备连接到计算机时，这些文件可以被浏览、修改和删除，因此这种方式不安全。 由于外围存储设备可能被移除、丢失或者处于其他状态，因此在使用外围设备之前必须使用Environment.getExternalStorageState()方法来确认外围设备是否可用，当外围设备可用并且具有读写权限时，就可以通过FileInputStream、FileOutputStream或者FileReader、FileWriter对象来读写外围设备中的文件。 向外围设备(SD卡)中存储数据的示例代码： String state=Environment.getExternalStorageState(); if(state.equals(Environment.MEDIA_MOUNTED)){ File SDPath=Environment.getExternalStorageDirectory(); File file=new File(SDPath, &quot;data.txt&quot;); String data=&quot;Hello World&quot;; FileOutputStream fos; try{ fos=new FileOutputStream(file); fos.write(data.getBytes()); fos.close(); }catch(Exception e){ e.printStackTrace(); } } 上述代码中，使用了Environment.getExternalStorageDirectory()方法获取SD卡根目录的路径。由于不同手机厂商SD卡的根目录路径可能不一致，用这种方法可以避免把路径写死而找不到SD卡。 从外围设备(SD卡)中读取数据的示例代码： String state=Environment.getExternalStorageState(); if(state.equals(Environment.MEDIA_MOUNTED)){ File SDPath=Environment.getExternalStorageDirectory(); File file=new File(SDPath, &quot;data.txt&quot;); FileInputStream fis; try{ fis=new FileInputStream(file); BufferedReader br=new BufferedReader(new InputStreamReader(fis)); String data=br.readLine(); }catch(Exception e){ e.printStackTrace(); } } 需要注意的是，操作SD卡中数据时，需要在清单文件的节点中配置权限信息，指定应用程序具有读或写SD卡中数据的权限。 &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt; 2. XML序列化与解析文件存储有很多方式，XML就是其中一种。XML存储的数据结构比较清晰，应用比较广泛。 (1) XML序列化 序列化是将对象状态转换为可保持或可传输状态的过程。在序列化对象时，需要使用XmlSerialize序列化器(XmlSerializer类)，它可以将I/O流中传输的对象变得像基本类型数据一样，实现传输的功能，序列化后的对象以XML形式保存。 对象序列化的示例代码： 要将数据序列化，首先要创建与XML文件相对应的序列化器(XmlSerializer)，然后将对象转化为XML。 File file = new File(Environment.getExternalStorageDirectory(), &quot;person.xml&quot;); FileOutputStream os = new FileOutputStream(file); XmlSerializer serializer = Xml.newSerializer(); serializer.setOutput(os, &quot;UTF-8&quot;); // 设置XML文件编码方式 serializer.startDocument(&quot;UTF-8&quot;, true); // 写入XML文件标志，即&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt; serializer.startTag(null, &quot;persons&quot;); int count = 0; for (Person person : userData) { serializer.startTag(null, &quot;person&quot;); serializer.attribute(null, &quot;id&quot;, count + &quot;&quot;); //将Person对象的name属性写入XML文件 serializer.startTag(null, &quot;name&quot;); serializer.text(person.getName()); serializer.endTag(null, &quot;name&quot;); //将Person对象的age属性写入XML文件 serializer.startTag(null, &quot;age&quot;); serializer.text(String.valueOf(person.getAge())); serializer.endTag(null, &quot;age&quot;); //将Person对象的score属性写入XML文件 serializer.startTag(null, &quot;score&quot;); serializer.text(String.valueOf(person.getScore())); serializer.endTag(null, &quot;score&quot;); serializer.endTag(null, &quot;person&quot;); count++; } serializer.endTag(null, &quot;persons&quot;); serializer.endDocument(); serializer.flush(); os.close(); 序列化后的XML文件如下所示： &lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos; standalone=&apos;yes&apos; ?&gt; &lt;persons&gt; &lt;person id=&quot;0&quot;&gt; &lt;name&gt;王0&lt;/name&gt; &lt;age&gt;100&lt;/age&gt; &lt;score&gt;80&lt;/score&gt; &lt;/person&gt; &lt;person id=&quot;1&quot;&gt; &lt;name&gt;王1&lt;/name&gt; &lt;age&gt;99&lt;/age&gt; &lt;score&gt;79&lt;/score&gt; &lt;/person&gt; &lt;person id=&quot;2&quot;&gt; &lt;name&gt;王2&lt;/name&gt; &lt;age&gt;98&lt;/age&gt; &lt;score&gt;78&lt;/score&gt; &lt;/person&gt; &lt;/persons&gt; 在XML文件中，带有&lt;&gt;的是开始标签，serializer.startTag()写入开始标签；带有&lt;/&gt;的是结束标签，用serializer.endTag()写入结束标签。 使用serializer.attribute()向标签写入属性数据；使用serializer.text()向节点写入节点数据。 XML文档的开始和结束分别用serializer.startDocument()和serializer.endDocument()来表示 案例：Demo0402，XML序列化 (2) XML解析 若要操作XML文档，首先需要将XML文档解析出来。通常情况下，解析XML文档有三种方式，分别是SAX解析、DOM解析和PULL解析。 SAX解析 SAX解析会逐行扫描XML文档，当遇到标签时触发解析处理器，采用事件处理的方式解析XML。 它在读取文档的同时即对XML进行处理，不必等到文档加载结束，相对快捷。而且也不需要将整个文档加载进内存，因此不存在占用内存的问题，可以解析超大XML。 但是，SAX解析只能用来读取XML中的数据，无法进行增删改。 DOM解析 DOM(Document Object Mode)解析式一种基于对象的API，它会将XML文件的所有内容以文档树的形式存放在内存中，然后允许使用DOM API遍历XML树、检索所需的数据，这样便能根据树的结构以节点形式对文件进行操作。 使用DOM操作XML的代码看起来是比较直观的，而且在编码方面比SAX解析更加简单。 但是，由于DOM需要将整个XML文件以文档树的形式存放在内存中，消耗内存比较大。因此，较小的XML文件可以采用这种方式解析，但较大的文件不建议采用这种方式解析。 PULL解析 PULL解析器是一个开源的Java项目，既可以用于Android项目，也可以用于JavaEE程序。 Android已经集成了PULL解析器，因此，在Android中最常用的解析方式就是PULL解析。使用PULL解析XML文档，首先要创建XmlPullParser解析器，该解析器提供了很多属性，通过这些属性可以解析出XML文件中的各个节点内容。 XmlPullParser的常用属性： XmlPullParser.START_DOCUMENT：XML文档的开始，如&lt;?xml version=”1.0” encoding=”utf-8”?&gt; XmlPullParser.END_DOCUMENT：XML文档的结束。 XmlPullParser.START_TAG：开始节点，在XML文件中，除了文本之外，带有尖括号&lt;&gt;的都是开始节点，如&lt; weather&gt;。 XmlPullParser.END_TAG：结束节点，带有&lt;/&gt;都是结束节点，如&lt; /weather&gt;。 使用PULL解析器的步骤： 1) 通过调用Xml.newPullParser() 得到一个XmlPullParser对象。 2) 通过parser.getEventType() 获取当前的事件类型。 3) 通过while循环判断当前操作事件类型是否为文档结束，是则跳出while循环。 4) while循环中通过switch语句判断当前事件类型是否为开始标签，是则获取该标签中的内容。 案例：Demo0403，天气预报，演示XML解析 二、SharedPreferencesSharedPreferences是Android平台上一个轻量级的存储类，主要用于存储一些应用程序的配置参数，例如用户名、密码、自定义参数的设置等。 SharedPreferences中存储的数据是以key/value对的形式保存在XML文件中，该文件位于data/data/packagename/shared_prefs文件夹中。 需要注意的是，SharedPreferences中的value值只能是float、int、long、boolean、String、StringSet类型数据。 使用SharedPreferences类存储数据时，首先需要通过context.getSharedPreferences(String name, int mode)获取SharedPreferences的实例对象(在Activity中可以直接使用this代表上下文，如果不是在Activity中则需要传入一个Context对象获取上下文)： SharedPreferences sp=context.getSharedPreferences(String name, int mode); 在该代码中，name表示文件名，mode表示文件的操作模式，该模式有多个值可供选择： MODE_PRIVATE：指定该SharedPreferences中的数据只能被本应用程序读写。 MODE_APPEND：该文件的内容可以追加。 MODE_WORLD_READABLE：指定该SharedPreferences中的数据可以被其他应用程序读。 MODE_WORLD_WRITEABLE：指定该SharedPreferences中的数据可以被其他应用程序写。 如图4-1所示，SharedPreferences提供了一系列方法用于获取应用程序中的数据，但需要注意的是，SharedPreferences对象本身只能获取数据，并不支持数据的存储和修改。 图 4-1 数据的存储和修改需要通过SharedPreferences.Editor对象实现。要想获取Editor实例对象，需要调用SharedPreferences.Editor.edit()方法。 图 4-2 向SharedPreferences对象中存储数据的示例代码： 使用SharedPreferences存储数据时，需要先获取SharedPreferences对象，通过该对象获取到Editor对象，然后通过Editor对象的相关方法(如图4-2所示)存储数据。 SharedPreferences sp=getSharedPreferences(&quot;config&quot;, MODE_PRIVATE); Editor editor=sp.edit(); //获取编辑器 editor.putString(&quot;name&quot;, &quot;value1&quot;); //存入String类型数据 editor.putInt(&quot;age&quot;, 8); //存入int类型数据 editor.commit(); //提交修改 从SharedPreferences对象中获取数据的示例代码： 创建SharedPreferences对象，使用该对象获取相应key的值。 SharedPreferences sp=context.getSharedPreferences(); String data=sp.getString(&quot;name&quot;, &quot;&quot;); 从SharedPreferences对象中删除数据的示例代码： 与存储数据类似，先要获取到Editor对象，然后通过该对象删除数据，最后提交。 SharedPreferences sp=getSharedPreferences(&quot;config&quot;, MODE_PRIVATE); Editor editor=sp.edit(); //获取编辑器 editor.remove(&quot;name&quot;); //删除一条数据 editor.clear(); //删除所有数据 editor.commit(); //提交修改 注意：SharedPreferences使用很简单，但一定要注意以下几点： 存入数据和删除数据时，一定要在最后使用editor.commit()方法提交修改 获取数据的key值与存入数据的key值的数据类型要一致，否则查找不到数据。 保存SharedPreferences的key值时，可以用静态变量保存，以免存储、删除时写错了，如 private static final String key=”key1”; 案例：Demo0404，QQ登陆，演示使用SharedPreferences存储数据","categories":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://hepsilion.github.io/tags/Android/"}],"keywords":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}]},{"title":"第三章 Activity","slug":"03-Activity","date":"2017-03-03T12:40:47.000Z","updated":"2017-10-21T13:19:21.021Z","comments":true,"path":"2017/03/03/03-Activity/","link":"","permalink":"https://hepsilion.github.io/2017/03/03/03-Activity/","excerpt":"Activity的生命周期 Activity的4种启动模式 隐式意图和显式意图的使用 使用Intent传递数据","text":"Activity的生命周期 Activity的4种启动模式 隐式意图和显式意图的使用 使用Intent传递数据 一、Activity入门1. Activity简介Activity是Android应用程序的四大组件之一，它负责管理Android应用程序的用户界面。 一个应用程序一般会包含若干个Activity，每一个Activity组件负责一个用户界面的展现。 Activity是通过调用setContentView()方法来显示指定组件的，setContentView()方法既可以接收View对象为参数，也可以接受布局文件对应的id为参数。 在应用程序中，Activity就像一个界面管理员，用户在界面上的操作是通过Activity管理的。 2. Activity的创建(1) 定义一个类继承自android.app.Activity或者其子类； (2) 在res/layout目录中创建一个xml布局文件，用于创建Activity的布局； (3) 在AndroidManifest.xml文件中注册Activity； &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;!--表示将当前Activity设置为程序最先启动的Activity--&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;!--表示让当前Activity在桌面上创建图标--&gt; &lt;/intent-filter&gt; &lt;/activity&gt; (4) 重写Activity的onCreate()方法，并在该方法中使用setContentView()加载指定的布局文件。 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } 案例：Demo0301，演示Activity的按键按下、按键松开、点击屏幕事件 3. Activity的生命周期Activity的生命周期是指Activity从创建到销毁的过程，Activity的生命周期中存在三种状态：运行状态、暂停状态和停止状态。 运行状态：当Activity在屏幕的最前端时，它是可见的、有焦点的，可以用来处理用户的常见操作，如点击、双击、长按事件等，这种状态称为运行状态。 暂停状态：在某些情况下，Activity对用户来说仍然是可见的，但它不再拥有焦点，即用户对它的操作是没有实际意义的。例如，当最上面的Activity没有完全覆盖屏幕或者是透明的，被覆盖的Activity仍然对用户可见，并且存活(它保留着所有的状态和成员信息并保持与Activity管理器的连接)。但当内存不足时，这个暂停状态的Activity可能会被杀死。 停止状态：当Activity完全不可见时，它就处于停止状态，但仍然保留着当前状态和成员信息。然而这些对用户来说都是不可见的，当系统内存不足时，这个Activity很容易被杀死。 Activity从一种状态转变到另一种状态时会触发一些事件，执行一些回调函数来通知状态的变化： onCreate() 当Activity被创建的时候调用的方法 onStart() 当Activity变成用户可见的时候调用的方法 onResume() 当Activity获取到焦点的时候调用的方法 onPause() 当Activity失去焦点的时候调用的方法 onStop() 当Activity变成用户不可见的时候调用的方法 onDestroy() 当Activity被销毁的时候调用的方法 onRestart() 当Activity重新回到前台，再次可见时调用的方法。 图 3-1 图3-1所示是一个Activity的生命周期模型，当Activity从启动到关闭时，会依次执行： onCreate() -&gt; onStart() -&gt; onResume() -&gt; onPause() -&gt; onStop() -&gt; onDestroy()方法。 当Activity执行到onPause()方法失去焦点时，重新回到前台会执行onResume()方法。 当Activity执行到onStop()方法变成用户不可见时，再次回到前台会执行onRestart()方法、onStart()方法和onResume()方法。 如果进程被杀死，Activity重新回到前台时会重新执行onCreate()方法。 案例：Demo0302，使用两个Activity之间的跳转演示Activity生命周期方法变化的过程 4. 横竖屏切换时的生命周期现实生活中，使用手机时会根据不同情况进行横竖屏切换。默认情况下，当手机横竖屏切换时，Activity会销毁重建。 这种情况对实际开发肯定会有影响，如果不希望在横竖屏切换时Activity被销毁重建，可以在AndroidManifest.xml文件中设置Activity的android:configChanges的属性，这样无论怎样切换Activity都不会销毁重建： android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; 如果希望某一个界面一直处于竖屏或者横屏状态，不随手机的晃动而改变，同样可以在清单文件中通过设置Activity的参数来完成： 竖屏： android:screenOrientation=&quot;portrait&quot; 横屏： android:screenOrientation=&quot;landscape&quot; 二、Activity的启动模式Android采用任务栈的方式来管理Activity的实例。 当启动一个应用时，Android就会为之创建一个任务栈，先启动的Activity压在栈底，后启动的Activity放在栈顶，通过启动模式可以控制Activity在任务栈中的加载情况。 1. Android下的任务栈 在开发Android应用时，经常会涉及一些消耗大量系统内存的情况，例如视频播放、大量图片或者程序中开启多个Activity没有及时关闭等，会导致程序出现错误。为了避免这种问题，Google提供了一套完整的机制让开发人员控制Android中的任务栈。 图 3-2 Android中的任务栈，类似于一个容器，用于管理所有的Activity实例。在存放Activity时，满足”先进后出”的原则。如图3-2所示，先加入任务栈中的Activity会处于容器下面，后加入的处于容器上面，而从任务栈中取出的Activity是从最顶端先取出，最后取出的是最底端的Activity。 2. Activity的4种启动模式 在实际开发中，应根据特定的需求为Activity指定恰当的启动模式。 Android的启动模式有4种，分别是standard、singleTop、singleTask和singleInstance。 在AndroidManifest.xml中，通过&lt; activity&gt;标签的android:launchMode属性可以设置启动模式. (1) standard模式 standard是Activity默认的启动模式，在不指定Activity启动模式的情况下，所有Activity使用的都是standard模式。 在standard模式下，每当启动一个新的Activity，它就会进入任务栈，并处于栈顶的位置，对于使用standard模式的Activity，系统不会判断该Activity在栈中是否存在，每次启动都会创建一个新的实例。 图 3-3 如图3-3所示，在standard启动模式下，Activity01最先进栈，其次是Activity02，最后是Activity03；出栈时，Activity03最先出栈，其次是Activity02，最后是Activity01，满足”先进后出”原则。 (2) singleTop模式 singleTop模式与standard类似，不同的是，当启动的Activity已经位于栈顶时，则直接使用它而不创建新的实例。如果启动的Activity没有位于栈顶时，则创建一个新的实例位于栈顶。 图 3-4 如图3-4所示，当前栈顶的元素是Activity03，如果再次启动的界面还是Activity03，则复用当前栈顶的Activity实例，如果再次启动的界面没有位于栈顶，则会重新创建一个实例。 (3) singleTask模式 如果希望Activity在整个应用程序中只存在一个实例，可以使用singleTask模式。 当Activity的启动模式指定为singleTask，每次启动该Activity时，系统首先会查找栈中是否存在该Activity的实例，如果发现已经存在则直接使用该实例，并将当前Activity之上的所有Activity出栈，如果没有发现则创建一个新的实例。 图 3-5 如图3-5所示，当再次启动Activity02时，并没有创建Activity02的新实例，而是将Activity03实例移除，复用Activity02实例，这就是singleTask模式，让某个Activity在当前栈中只存在一个实例。 (4) singleInstance模式 在程序开发中，如果需要Activity在整个系统中都只有一个实例，这时就需要用到singleInstance模式。不同于上述模式，指定为singleInstance模式的Acitivity会启动一个新的任务栈来管理这个Activity。 singleInstance模式加载Activity时，无论从哪个任务栈中启动该Activity，只会创建一个Activity实例，并且会使用一个全新的任务栈来装载该Activity实例。 采用这种模式启动Activity会分为以下两种情况： 第一种：如果要启动的Activity不存在，系统会先创建一个新的任务栈，再创建该Activity的实例，并把该Activity加入栈顶，如图3-6所示。 第二种：如果要启动的Activity已经存在，无论位于哪个应用程序或者哪个任务栈中，系统都会把该Activity所在的任务栈转到前台，从而使该Activity显示出来。 图 3-6 三、在Activity中使用Intent1. Intent介绍Android系统常使用Intent绑定应用程序组件，并在应用程序之间完成通信功能。 Intent一般用于启动Activity、启动服务、发送广播等，承担了Android应用程序三大核心组件间的通信功能。 图 3-7 图3-7列举了通过Intent来开启不同组件的常用方法。需要注意的是，使用Intent开启Activity和开启Service只有两个方法，而开启BroadcastReceiver有多个方法，这里只列举了三个常用的方法。 2. 显式意图和隐式意图Android中Intent寻找目标组件的方式分为两种，一种是显式意图，另一种是隐式意图。 (1) 显式意图：在通过Intent启动Activity时，明确指定激活组件的名称 第一种方式 //指定目标组件的包名、全路径名 Intent intent=new Intent(); intent.setClassName(&quot;learning.android.it.org.demo0303&quot;, &quot;learning.android.it.org.demo0303.Activity02&quot;); startActivity(intent); 第二种方式 //第一个参数Content要求提供一个启动Activity的上下文，第二个参数Class则是指定要启动的目标Activity Intent intent=new Intent(MainActivity.this, Activity02.class); startActivity(intent); (2) 隐式意图：没有明确指定组件名的Intent成为隐式意图。 Android系统会根据隐式意图中设置的动作(action)、类别(category)、数据(Uri和数据类型)找到最合适的组件 &lt;activity android:name=&quot;.Activity02&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.media.action.IMAGE_CAPTURE&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; //使用隐式意图开启Activity，只有当action和category的内容同时匹配时，Activity才会被开启 Intent intent = new Intent(); intent.setAction(&quot;android.media.action.IMAGE_CAPTURE&quot;); intent.addCategory(&quot;android.intent.category.DEFAULT&quot;); startActivity(intent); 案例：Demo0303，打开系统照相机，演示如果使用隐式意图 显式意图和隐式意图的比较： 显式意图开启组件时，必须要指定组件的名称，一般只在本应用程序切换组件时使用。 隐式意图的功能要比显式意图强大，不仅可以开启本应用的组件，还可以开启其他应用的组件，例如打开系统自带的照相机、浏览器等。 四、Activity中的数据传递1. 数据传递方式在Android开发中，经常要在Activity之间传递数据，这个功能可以通过Intent来实现。 使用Intent传递数据只需调用putExtra()方法将想要传递的数据存在Intent中，当启动了另一个Activity后，再把这些数据从Intent中取出即可。 方法一： // Activity01通过Intent使用putExtra将数据传递到Activity02 String str=&quot;Data from Activity01 to Activity02&quot;; Intent intent=new Intent(this, Activity02.class); intent.putExtra(&quot;data&quot;, data); //第一个参数是key，第二个参数是value startActivity(intent); // Activity02取出Activity01传递过来的数据 Intent intent=getIntent(); String str=intent.getStringExtra(&quot;data&quot;); //通过key获取value 方法二： // Activity01通过Intent使用putExtras将数据传递到Activity02 Bundle bundle=new Bundle(); bundle.putString(&quot;name&quot;, &quot;Linda&quot;); bundle.putInt(&quot;age&quot;, 20); Intent intent=new Intent(this, Activity02.class); intent.putExtras(bundle); startActivity(intent); // Activity02取出Activity01传递过来的数据 Intent intent=getIntent(); Bundle bundle=intent.getExtras(); String name=bundle.getString(&quot;name&quot;); int age=bundle.getInt(&quot;age&quot;); 案例：Demo0304，用户注册，演示Activity中的数据传递 2. 回传数据Android提供了一个startActivityForResult()方法，来实现Activity之间的回传数据。 (1) Activity01使用startActivityForResult(intent, requestCode)启动Activity02 Intent intent=new Intent(this, Activity02.class); startActivityForResult(intent, 1); startActivityForResult()方法接收两个参数，第一个参数是Intent；第二个参数是请求码，用于在Activity02中判断数据的来源。 (2) 在Activity02中使用setResult(resultCode, data)添加要返回的数据，并销毁当前Activity Intent intent=new Intent(); intent.putExtra(&quot;key&quot;, &quot;Hello&quot;); setResult(1, intent); finish(); setResult()方法接收两个参数，第一个参数resultCode结果码，一般使用0或1；第二个参数则是把带有数据的Intent传递回去 (3) 由于Activity01使用startActivityForResult方法启动Activity02，当Activity02销毁并返回时，会回调Activity01中的onActivityResult()方法，因此需要在Activity01中重写onActivityResult(requestCode, resultCode, data)方法获取Activity02返回的数据 protected void onActivityResult(int requestCode, int resultCode, Intent data){ super.onActivityResult(requestCode, resultCode, data); if(resultCode==1){ String value=data.getStringExtra(&quot;key&quot;); } } onActivityResult()方法有三个参数： 第一个参数requestCode表示在启动Activity02时传递的请求码； 第二个参数resultCode表示在返回数据时传入的结果码； 第三个参数data表示携带返回数据的Intent。 注意：在一个Activity中很可能调用startActivityForResult()方法启动多个Activity，每一个Activity返回的数据都会回调到onActivityResult()方法中，因此，首先要做的是通过检查requestCode的值来判断数据来源，确定数据是从Activity02返回的，然后再通过resultCode的值来判断数据处理结果是否成功，最后再把数据从data中取出。 案例：Demo0305，装备选择，演示Activity之间的数据回传 小知识：ProgressBar进度条 ProgressBar通常用于访问网络展示Loading对话框以及下载文件时显示的进度。 它有两种表现形式，一种是水平的，另一种是环形的。它的表现形式是由style属性控制的，ProgressBar的几个常用属性如下所示： style属性：控制ProgressBar的表现形式。 水平进度条的style属性值为”?android:attr/progressBarStyleHorizontal” 环形进度条的style属性值为”?android:attr/progressBarStyleLarge” setMax()方法：设置进度条的最大值 setProgress()方法：设置当前进度 getProgress()方法：获取当前进度","categories":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://hepsilion.github.io/tags/Android/"}],"keywords":[{"name":"Android基础","slug":"Android基础","permalink":"https://hepsilion.github.io/categories/Android基础/"}]},{"title":"12-JDBC","slug":"11-JDBC","date":"2017-02-24T10:27:20.000Z","updated":"2017-10-21T13:19:21.304Z","comments":true,"path":"2017/02/24/11-JDBC/","link":"","permalink":"https://hepsilion.github.io/2017/02/24/11-JDBC/","excerpt":"JDBC","text":"JDBC 问：什么是JDBC？JDBC是一套面向对象的应用程序接口(API)，制定了访问各类关系数据库的统一标准接口，为访问各个数据库厂商的关系数据库提供了标准的实现，它由一组用Java语言编写的类和接口组成。JDBC允许开发者用Java编写访问数据库的应用程序，而不需要关心底层特定数据库的细节。 问：JDBC访问数据库的步骤// 1. 加载JDBC驱动 try { Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); // Class.forName(&quot;com.mysql.jdbc.driver&quot;); //Mysql } catch (ClassNotFoundException e) { e.printStackTrace(); } // 2. 连接Oracle数据库 String url = &quot;jdbc:oracle:thin:@localhost:1521:DataBaseName&quot;; // String url=&quot;jdbc:mysql://localhost:1521/DataBaseName&quot;; // Mysql String username = &quot;admin&quot;; String password = &quot;root&quot;; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { conn = DriverManager.getConnection(url, username, password); // 3. 利用JDBC检索出表中的数据 ps = conn.prepareStatement(&quot;select * from users;&quot;); rs = ps.executeQuery(); while (rs.next()) { rs.getString(1); // 或rs.getString(&quot;name&quot;) } } catch (SQLException e) { e.printStackTrace(); } finally { // 4. 关闭连接 try { if (rs != null) rs.close(); if (ps != null) ps.close(); if (conn != null) conn.close(); } catch (SQLException e) { e.printStackTrace(); } } 问：Class.forName()方法有什么作用？通过反射机制初始化参数指定的类，并且返回此类对应的Class对象。这个方法可以用来载入并注册跟数据库建立连接的驱动。 问：解释下驱动(Driver)在JDBC中的角色。JDBC驱动提供了特定厂商对JDBC API接口类的实现，驱动必须要提供java.sql包下面这些类的实现：Connection, Statement, PreparedStatement,CallableStatement, ResultSet和Driver。 加载驱动的几种方法： (1) 调用Class.forName()方法注册：Class.forName(“com.microsoft.sqlserver.jdbc.SQLServerDriver”); (2) 通过添加jdbc.drivers系统属性注册：System.setProperty(“jdbc.drivers”, “com.mysql.jdbc.Driver”); (3) 通过registerDriver方法注册：DriverManager.registerDriver(new com.mysql.jdbc.Driver()); 问：Statement、PreparedSatement和CallableStatement 问：PreparedStatement比Statement有什么优势？PreparedStatement接口继承自Statement (1) 使用Statement的方式： Statement stmt=conn.createStatement(); ResultSet rs=stmt.executeQuery(&quot;select * from book;&quot;); (2) 使用PreparedStatement的方式： PreparedStatement pstmt=conn.prepareStatement(&quot;select * from book;&quot;); ResultSet rs=pstmt.executeQuery(); (3) PreparedStatement比Statement的对比 PreparedStatement实例包含预编译的SQL语句，可以减少SQL的编译错误，执行速度要快于Statement对象，因此，性能会更好。 PreparedStatements是预编译的，可以避免不良用户直接敲sql语句产生sql注入攻击，安全性更强。 PreparedStatement中的SQL语句是可以带参数的，对于不同的查询参数值，PreparedStatement可以重用。 当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划） 例1，例2 问：什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？CallableStatement接口继承自PreparedStatement CallableStatement用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。如果有输出参数要注册说明是输出参数。非常鼓励使用存储过程，因为它提供了安全性和模块化。 准备一个CallableStatement的方法是：Connection.prepareCall()，实例代码如下： CallableStatement cs=conn.prepareCall(&quot;{call getCustomerName(?,?)}&quot;); cs.setString(1, &quot;1&quot;); cs.registerOutParameter(2, java.sql.Types.VARCHAR); cs.execute(); cs.getString(2); 问：数据库连接池是什么意思？像打开、关闭数据库连接这种和数据库的交互是很费时间的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本非常高。 可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供服务。在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求。 问：ResultSet例1 例2：使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？ 要提升读取数据的性能，可以指定通过结果集(ResultSet)对象的setFetchSize()方法指定每次抓取的记录数(典型的空间换时间策略)； 要提升更新数据的性能，可以使用PreparedStatement语句构建批处理，将若干SQL语句置于一个批处理中执行。 问：事务的ACID 原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败； 一致性(Consistent)：事务结束后系统状态是一致的； 隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态； 持久性(Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。 事务处理的问题在并发数据访问时需要做事务处理。当多个事务访问同一数据时，可能会存在5类问题，包括3类数据读取问题（脏读、不可重复读和幻读）和2类数据更新问题（第1类丢失更新和第2类丢失更新）。 (1) 脏读（Dirty Read）：A事务读取B事务尚未提交的数据并在此基础上操作，而B事务执行回滚，那么A读取到的数据就是脏数据。 (2) 不可重复读（Unrepeatable Read）：事务A重新读取前面读取过的数据，发现该数据已经被另一个已提交的事务B修改过了。 (3) 幻读（Phantom Read）：事务A重新执行一个查询，返回一系列符合查询条件的行，发现其中插入了被事务B提交的行。 (1) 第1类丢失更新：事务A撤销时，把已经提交的事务B的更新数据覆盖了。 (2) 第2类丢失更新：事务A覆盖事务B已经提交的数据，造成事务B所做的操作丢失。 问：JDBC如何做事务处理？Connection提供了事务处理的方法，通过调用setAutoCommit(false)可以设置手动提交事务；当事务完成后用commit()显式提交事务；如果在事务处理过程中发生异常则通过rollback()进行事务回滚。除此之外，从JDBC 3.0中还引入了Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。 conn.setAutoCommit(false) conn.commit(); conn.rollback(); conn.setAutoCommit(true) 问：数据库连接池由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行TCP的三次握手，释放连接需要进行TCP四次握手，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。 池化技术在Java开发中是很常见的，在使用线程时创建线程池的道理与此相同。 基于Java的开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid等。 问：什么是DAO模式DAO(Data Access Object)顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。 问：JDBC能否处理Blob和ClobBlob是指二进制大对象（Binary Large Object），而Clob是指大字符对象（Character Large Objec），因此其中Blob是为存储大的二进制数据而设计的，而Clob是为存储大的文本数据而设计的。JDBC的PreparedStatement和ResultSet都提供了相应的方法来支持Blob和Clob操作。 下面的代码展示了如何使用JDBC操作LOB： 以MySQL数据库为例，创建一个张有三个字段的用户表，包括编号(id)、姓名(name)和照片(photo)，建表语句如下： create table tb_user( id int primary key auto_increment, name varchar(20) unique not null, photo longblob ); 编程向数据库中插入一条记录： public static void main(String[] args) { Connection conn = null; try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;123456&quot;); PreparedStatement ps = conn.prepareStatement(&quot;insert into tb_user values (default, ?, ?)&quot;); ps.setString(1, &quot;骆昊&quot;); try (InputStream in = new FileInputStream(&quot;head.jpg&quot;)) {// Java 7的TWR ps.setBinaryStream(2, in); // 将SQL语句中第二个占位符换成二进制流 System.out.println(ps.executeUpdate() == 1 ? &quot;插入成功&quot; : &quot;插入失败&quot;); } catch (IOException e) { System.out.println(&quot;读取照片失败!&quot;); } } catch (ClassNotFoundException | SQLException e) {// Java 7的多异常捕获 e.printStackTrace(); } finally { try { if (conn != null &amp;&amp; !conn.isClosed()) { conn.close(); conn = null; // 指示垃圾回收器可以回收该对象 } } catch (SQLException e) { e.printStackTrace(); } } } 问：Jdo是什么？(没用过)JDO是Java对象持久化的新的规范，为java data object的简称，也是一个用于存取某种数据仓库中的对象的标准化API。JDO提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如JDBC API的使用）。这些繁琐的例行工作已经转移到JDO产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上。另外，JDO很灵活，因为它可以在任何数据底层上运行。JDBC只是面向关系数据库（RDBMS)JDO更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML以及对象数据库（ODBMS）等等，使得应用可移植性更强。(o/rMapping工具集合处理) 问：在ORACLE大数据量下的分页解决方法。(没用过)create or replace package myPack is type c_type is ref cursor; procedure getPage(v_sql varchar2,pageSize number,pageIndex number,c out c_type); end; create or replace package body myPack is procedure getPage(v_sql varchar2,pageSize number,pageIndex number,c out c_type) is pageTotal int:=0; pageFirstRow int:=0; pageLastRow int:=0; rowTotal int:=0; begin execute immediate &apos;select count(*) from (&apos;||v_sql||&apos;)&apos; into rowTotal; pageTotal:=ceil(rowTotal/pageSize); if(pageIndex&lt;1) then raise_application_error(-20001,&apos;页数不能小于1&apos;); end if; if(pageIndex&gt;pageTotal) then raise_application_error(-20001,&apos;页数太大，不能读取&apos;); end if; pageFirstRow:=(pageIndex-1)*pageIndex+1; pageLastRow:=pageFirstRow+pageSize; open c for &apos; select * from &apos;||v_sql||&apos; where rownum&lt;&apos;|| pageLastRow||&apos;minus select * from &apos;||v_sql ||&apos; where rownum&lt;&apos;||pageFirstRow; end; end;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"11-反射","slug":"13-反射","date":"2017-02-23T10:26:12.000Z","updated":"2018-05-08T08:34:52.035Z","comments":true,"path":"2017/02/23/13-反射/","link":"","permalink":"https://hepsilion.github.io/2017/02/23/13-反射/","excerpt":"反射","text":"反射 问：ClassloaderJava中类的加载是由ClassLoader和它的子类来实现的，它负责在运行时查找和装入类文件中的类。 ClassLoader是一个重要的Java运行时系统组件，它主要包括：引导类加载器(BootStrap ClassLoader)、扩展类加载器(Extension ClassLoader)、应用类加载器(Application ClassLoader)和用户自定义类加载器(java.lang.ClassLoader的子类)。 Bootstrap ClassLoader：它负责加载放在\\jre\\lib/目录中的，或者-Xbootclasspath参数所指定路径中的Java核心库(如rt.jar)，是用原生代码来实现的； Extension ClassLoader：它负责加载\\jre\\lib\\ext目录中，或系统变量java.ext.dirs所指定路径中的所有类库； Application ClassLoader：它负责加载Java应用的CLASSPATH所指定的类库。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它是应用最广泛的类加载器。开发者可以直接使用这个类加载器，如果应用程序中没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器； Custom ClassLoader：应用程序根据自身需要自定义的ClassLoader，是java.lang.ClassLoader的子类，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader。 例1，例2 例3：能不能自己写个类，也叫java.lang.String？ 可以，但在应用的时候，需要用自己的类加载器去加载，否则，系统的类加载器永远只是去加载rt.jar包中的那个java.lang.String。 由于在tomcat的web应用程序中，都是由webapp自己的类加载器先自己加载WEB-INF/classess目录中的类，然后才委托上级的类加载器加载。 如果我们在tomcat的web应用程序中写一个java.lang.String，这时候Servlet程序加载的就是我们自己写的java.lang.String， 但是这么干就会出很多潜在的问题，原来所有用了java.lang.String类的都将出现问题。 问：JVM的类加载机制 (还不怎么懂，暂时保留)推荐阅读 Java类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中准备、验证、解析3个部分统称为连接（Linking）。 图 1 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定） 例1 问：动态语言问：Class对象 (Class Type，类类型)Java虚拟机有一个运行时数据区，这个数据区又被分为方法区、堆区、栈区等，其中方法区的主要作用是存储被JVM加载的类信息、常量、静态变量等。当JVM加载某个类的时候，需要类加载器定位相应的class文件，然后将其读入到JVM中，紧接着JVM提取class中的类型信息，将这些信息存储到方法区中。 在Java的世界里，一切皆对象。从某种意义上说，在Java中有两种对象：实例对象和Class对象。实例对象就是我们平常定义的一个类的实例，例如定义一个类Person，然后使用new Person()定义Person类的一个实例对象；而Class对象是没办法用new关键字得到的，每当加载一个新的类的时候，JVM都会在Java堆中创建一个对应于该类的Class对象，该对象就代表该类，通过该Class对象我们就可以访问该类的基本信息。 获取Class对象一般有三种方式 (1) 通过类对象的getClass()方法获取 public class test { public static void main(String[] args) { Dog dog = new Dog(); Class clazz = dog.getClass(); } } (2) 通过类的.class静态属性获取 public class test { public static void main(String[] args) { Class clazz = Dog.class; } } 通过这种方式时，只会加载Dog类，并不会触发Dog类构造器的初始化。 基本的数据类型如int、double、void等都有Class对象； (3) 使用Class.forName(String className)动态加载类，className需要是类的全限定名(最常用) public class ClassTest { public static void main(String[] args) { try { Class clazz = Class.forName(&quot;packageName.Dog&quot;); } catch (ClassNotFoundException e) {} } } 问：反射机制所谓的反射是Java语言在运行时拥有一项自观的能力，反射使您的程序代码能够得到装载到JVM中的类的内部信息，允许您执行程序时才得到所需类的内部信息，而不是在编写代码的时候就必须要知道所需类的内部信息。这样，在程序运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够访问它的任意一个属性和方法；这种动态获取信息以及动态调用对象的方法的功能称为Java语言的反射机制。 问：反射机制的基本使用请看文章 Java反射机制的实现要借助于4个类：Class，Constructor，Field，Method；其中Class代表的是类的Class对象，Constructor是代表类构造方法的对象，Field是代表类属性的对象，Method是代表类方法的对象，通过这四个对象我们可以粗略的看到一个类的各个组成部分。其中最核心的就是Class对象，它是实现反射的基础。 1. 反射机制的作用 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法； 在运行时调用任意一个对象的方法； 生成动态代理 Spring、Struts、Hibernate等框架都是通过类的反射进行开发的。 例1 2. 应用反射的基本步骤: (1) 获得你想操作的类的Class对象； (2) 调用Class对象中的方法获取你想要的信息集合，如调用getDeclaredFields()方法得到类的所有属性； (3) 处理第2步中得到的信息，然后进行你想做的实际操作。 3. Class对象的常用方法 - 获取类的信息 (1) 获得类的名称 String getName() String getSimpleName() (2) 获得类的构造方法 Constructor getConstructor(Class[] parameterTypes) Constructor[] getConstructors() Constructor getDeclaredConstructor(Class[] parameterTypes) Constructor[] getDeclaredConstructors() (3) 获得类的字段信息 Field getField(String name) Field[] getFields() Field getDeclaredField(String name) Field[] getDeclaredFields() (4) 获得类的方法信息 Method getMethod(String name, Class[] parameterTypes) Method[] getMethods() Method getDeclaredMethod(String name, Class[] parameterTypes) Method[] getDeclaredMethods() 注意： (1) getFields()与getDeclaredFields()区别 getFields() 只能返回类中所有的公有属性，包括从父类继承的公有属性； getDeclaredFields() 返回类中声明的所有属性，包括public/private/protect/default属性，不包括从父类继承的属性 (2) getMethods()与getDeclaredMethods()区别 getMethods() 只能返回类中所有的公有方法，包括从父类继承的公有方法； getDeclaredFields() 返回类中声明的所有方法，包括public/private/protect/default方法，不包括从父类继承的方法 (3) getConstructors()与getDeclaredConstructors()区别 getConstructors() 只能返回类中所有的公有构造方法 getDeclaredConstructors() 返回类中声明的所有构造方法，包括public/private/protect/default构造方法 例1 例2：获取类的信息 import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; /** * 打印类的信息，包括类的成员函数、成员变量、构造函数 * java.lang.Method中封装了类的成员函数信息 * java.lang.reflect.Field中封装了类的成员变量的信息 * java.lang.Constructor中封装了类的构造函数的信息 * * @param obj 要获取类的信息，首先要获取类的类类型。传递的是哪个子类的对象obj，clazz就是该子类的类类型 */ public class ReflectUtil { /** * 获取类的成员函数信息 * @param obj */ public static void printClassMethodMessage(Object obj) { Class clazz = obj.getClass(); System.out.println(&quot;类的名称是: &quot; + clazz.getName()); Method[] methods = clazz.getMethods(); // clazz.getDeclaredMethods() for (int i = 0; i &lt; methods.length; i++) { Class returnType = methods[i].getReturnType(); // 得到方法的返回值类型的类类型 System.out.print(returnType.getName() + &quot; &quot;); System.out.print(methods[i].getName() + &quot;(&quot;); Class[] paramTypes = methods[i].getParameterTypes(); // 获取参数类型---&gt;得到的是参数列表的类型的类类型 for (Class c : paramTypes) { System.out.print(c.getName() + &quot;,&quot;); } System.out.println(&quot;)&quot;); } } public static void main(String[] args) { ReflectUtil.printClassMethodMessage(new Integer(1)); } /** * 获取成员变量的信息 * @param obj */ public static void printFieldMessage(Object obj) { Class clazz = obj.getClass(); Field[] fields = clazz.getDeclaredFields(); // clazz.getFields() for (Field field : fields) { Class fieldType = field.getType(); // 得到成员变量的类型的类类型 String typeName = fieldType.getName(); String fieldName = field.getName(); System.out.println(typeName + &quot; &quot; + fieldName); } } /** * 打印对象的构造函数的信息 * @param obj */ public static void printConstructorMessage(Object obj) { Class clazz = obj.getClass(); Constructor[] constructors = clazz.getDeclaredConstructors(); // clazz.getConstructors() for (Constructor constructor : constructors) { System.out.print(constructor.getName() + &quot;(&quot;); Class[] paramTypes = constructor.getParameterTypes(); // 获取构造函数的参数列表---&gt;得到的是参数列表的类类型 for (Class class1 : paramTypes) { System.out.print(class1.getName() + &quot;,&quot;); } System.out.println(&quot;)&quot;); } } } 4. 方法反射的应用 (1) 步骤 根据方法的名称和方法的参数列表获取某个方法 调用method.invoke(对象，参数列表)执行方法 (2) 举例 import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /** * 方法的反射操作：使用Method对象进行方法调用 */ public class MethodReflect { public static void main(String[] args) { A a = new A(); Class clazz = a.getClass(); try { /** * 调用print()方法: a.print(); */ Method m1 = clazz.getMethod(&quot;print&quot;);// 或者Method m1 = clazz.getMethod(&quot;print&quot;, new Class[]{}); // 如果方法没有返回值则返回null；否则返回具体的返回值 Object result1 = m1.invoke(a); // 或者m1.invoke(a, new Object[]{}); System.out.println(&quot;==================&quot;); /** * 调用print(int, int)方法：a.print(10, 20); */ Method m2 = clazz.getMethod(&quot;print&quot;, int.class, int.class); // 或者Method m2 = clazz.getMethod(&quot;print&quot;, new Class[]{int.class, int.class}); Object result2 = m2.invoke(a, 10, 20); // 或者Object o = m2.invoke(a, new Object[]{10, 20}); System.out.println(&quot;==================&quot;); /** * 调用print(String, String)方法：a.print(&quot;hello&quot;, &quot;WORLD&quot;); */ Method m3 = clazz.getMethod(&quot;print&quot;, new Class[]{String.class, String.class}); // 或者Method m3 = clazz.getMethod(&quot;print&quot;, String.class, String.class); Object result3 = m3.invoke(a, &quot;hello&quot;, &quot;WORLD&quot;); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } } class A { public void print() { System.out.println(&quot;hello world&quot;); } public void print(int a, int b) { System.out.println(a + b); } public void print(String a, String b) { System.out.println(a.toUpperCase() + &quot;, &quot; + b.toLowerCase()); } } 5. 泛型 Java中集合的泛型，只在编译阶段有效，运行时被擦除，可以用来防止错误输入 例1： import java.lang.reflect.Method; import java.util.ArrayList; import java.util.List; public class Generic { public static void main(String[] args) { List list1 = new ArrayList(); List&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); list2.add(&quot;hello&quot;); // list2.add(20); 编译错误 Class c1 = list1.getClass(); Class c2 = list2.getClass(); System.out.println(c1 == c2); // 结果为true，说明编译之后集合的泛型被擦除 /* * Java中集合的泛型，只在编译阶段有效，运行时被擦除，可以防止错误输入 * 验证：由于反射的操作都是编译之后的操作，我们可以通过方法的反射操作来绕过编译 */ try { Method m = c2.getMethod(&quot;add&quot;, Object.class); m.invoke(list2, 20); //绕过编译就绕过了泛型 System.out.println(list2.size()); //不能使用如下方式遍历集合 /*for (String string : list1) { System.out.println(string); }*/ System.out.println(list2); } catch (Exception e) { e.printStackTrace(); } } } 具体如何使用反射，请看两篇文章 反射文章1 反射文章2","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"10-网络编程","slug":"10-网络编程","date":"2017-02-22T10:25:25.000Z","updated":"2017-10-21T13:19:21.288Z","comments":true,"path":"2017/02/22/10-网络编程/","link":"","permalink":"https://hepsilion.github.io/2017/02/22/10-网络编程/","excerpt":"网络编程","text":"网络编程 问：Java Socket的几个方法getInetAddress() Returns the address to which the socket is connected. getLocalAddress() Gets the local address to which the socket is bound. getReuseAddress() Tests if SO_RESUSADDR is enabled. getRemotePort() Returns the remote port number to which this socket is connected. 问：基于TCP协议的Socket通信(1) 客户端实现步骤 创建Socket对象，指明需要连接的服务器的地址和端口号 连接建立后，通过输出流想服务器端发送请求信息 通过输入流获取服务器响应的信息 关闭响应资源 实例代码： public static void main(String[] args) { Socket socket=null; PrintWriter pw=null; BufferedReader br=null; try { // 1、创建客户端Socket，指定服务器地址和端口 socket = new Socket(&quot;127.0.0.1&quot;, 6000); // 2、获取输入流，并读取服务器端的响应信息 br = new BufferedReader(new InputStreamReader(socket.getInputStream())); // 3、获取输出流，向服务器端发送信息 pw = new PrintWriter(socket.getOutputStream()); // 4. 通过输入流、输出流通信 }catch (IOException e) { e.printStackTrace(); } finally{ try { // 5、关闭资源 if(br!=null) br.close(); if(pw!=null) pw.close(); if(socket!=null) socket.close(); } catch (IOException e) { e.printStackTrace(); } } } (2) 服务器端实现步骤 创建ServerSocket对象，绑定监听端口 通过accept()方法监听客户端请求 连接建立后，通过输入流读取客户端发送的请求信息 通过输出流向客户端发送乡音信息 关闭相关资源 实例代码： public static void main(String[] args) { ServerSocket serverSocket = null; Socket socket = null; BufferedReader br = null; PrintWriter pw = null; try { // 1、创建一个服务器端Socket，即ServerSocket，指定绑定的端口(1024-65535)，并监听此端口 serverSocket = new ServerSocket(6000); // 2、调用accept()方法开始监听，等待客户端的连接 socket = serverSocket.accept(); // 3、获取输入流，并读取客户端信息 br = new BufferedReader(new InputStreamReader(socket.getInputStream())); // 4、获取输出流，响应客户端的请求 pw = new PrintWriter(socket.getOutputStream()); // 5. 通过输入流、输出流通信 } catch (IOException e) { e.printStackTrace(); } finally { try { // 6、关闭资源 if (br != null) br.close(); if (br != null) pw.close(); if (br != null) socket.close(); if (br != null) serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } 问：基于UDP协议的Socket通信(1) 客户端实现步骤 定义服务器的地址、端口号、数据 创建DatagramPacket，包含将要发送的信息 创建DatagramSocket 向服务器发送数据 实例代码： public static void main(String[] args) { DatagramSocket socket = null; try { // 向服务器端发送数据 // 1、定义服务器的地址、端口号、数据 InetAddress address = InetAddress.getByName(&quot;127.0.0.1&quot;); int port = 10010; byte[] data1 = &quot;Hello Server&quot;.getBytes(); // 2、创建数据报，包含发送的数据信息 DatagramPacket packet1 = new DatagramPacket(data1, data1.length, address, port); // 3、创建DatagramSocket对象 socket = new DatagramSocket(); // 4、向服务器发送数据 socket.send(packet1); // ========================================================= // 接受服务器端响应数据 // 1、创建数据报，用于接受服务器端响应数据 byte[] data2 = new byte[1024]; DatagramPacket packet2 = new DatagramPacket(data2, data2.length); // 2、接受服务器响应的数据 socket.receive(packet2); String str = new String(data2, 0, packet2.getLength()); System.out.println(&quot;I am client, server says：&quot; + str); } catch (IOException e) { e.printStackTrace(); } finally { // 4、关闭资源 if(socket!=null) socket.close(); } } (2) 服务器端实现步骤 创建DatagramSocket，指定端口号 创建DatagramPacket，，用于接受客户端发送的数据 接受客户端发送的数据信息 读取数据 实例代码： public static void main(String[] args) { DatagramSocket socket = null; try { // 接受服务器端数据 // 1、创建服务器端DatagramSocket，指定端口 socket = new DatagramSocket(10010); // 2、创建数据报，用于接受客户端发送的数据 byte[] data1 = new byte[1024];// DatagramPacket packet1 = new DatagramPacket(data1, data1.length); // 3、接受客户端发送的数据 socket.receive(packet1);// 此方法在接受数据报之前会一致阻塞 // 4、读取数据 String info = new String(data1, 0, data1.length); System.out.println(&quot;I am server, client says: &quot; + info); // ========================================================= // 向客户端响应数据 // 1、定义客户端的地址、端口号、数据 InetAddress address = packet1.getAddress(); int port = packet1.getPort(); byte[] data2 = &quot;Welcome!&quot;.getBytes(); // 2、创建数据报，包含响应的数据信息 DatagramPacket packet2 = new DatagramPacket(data2, data2.length, address, port); // 3、响应客户端 socket.send(packet2); } catch (IOException e) { e.printStackTrace(); } finally { // 4、关闭资源 if (socket != null) socket.close(); } }","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"09-多线程","slug":"09-多线程","date":"2017-02-21T10:23:52.000Z","updated":"2018-05-08T13:45:20.015Z","comments":true,"path":"2017/02/21/09-多线程/","link":"","permalink":"https://hepsilion.github.io/2017/02/21/09-多线程/","excerpt":"多线程","text":"多线程 推荐阅读：嘟嘟独立博客 推荐阅读：Java多线程锁机制 推荐阅读：40个Java多线程问题总结 推荐阅读:《Java 多线程编程核心技术》学习笔记及总结 推荐阅读: Java笔试面试题整理第五波 推荐阅读: Java笔试面试题整理第六波（修正版） 问：进程和线程的区别是什么？进程是资源分配的基本单位，而线程是CPU调度的基本单位。 一个进程可以有多个线程，多个线程共享进程的资源，线程又叫做轻量级进程。 问：线程的几种状态 (1) 新建(new)：新创建了一个线程对象。 (2) 可运行(runnable)：线程对象创建后，其他线程(比如main线程)调用了该对象的start()方法，该状态的线程便位于可运行线程池中，等待被线程调度选中，获取cpu的使用权。 (3) 运行(running)：可运行状态(runnable)的线程获得了cpu时间片(timeslice)，执行程序代码。 (4) 阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种： 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。 其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。 当sleep()状态超时、 join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。 (5) 死亡(dead)：线程run()、 main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。 例1：此题有疑问，感觉下面这句话是不对的。 Java线程调度算法是平台独立的。 问：创建线程有几种不同的方式？你喜欢哪一种？为什么？(1) 继承Thread类，重写run()方法 public class ThreadTest1 { public static void main(String[] args){ MyThread thread=new MyThread(&quot;T1&quot;); thread.start(); System.out.println(&quot;The main thread is running.&quot;); } } class MyThread extends Thread{ private String name; public MyThread(String name) { this.name = name; } @Override public void run() { System.out.println(&quot;The thread &quot;+this.name+&quot; is running.&quot;); } } (2) 实现Runnable接口，重写run()方法 public class ThreadTest2 { public static void main(String[] args){ Thread thread=new Thread(new MyThread2(&quot;T2&quot;)); thread.start(); System.out.println(&quot;The main thread is running.&quot;); } } class MyThread2 implements Runnable{ private String name; public MyThread2(String name) { this.name = name; } @Override public void run() { System.out.println(&quot;The thread &quot;+this.name+&quot; is running.&quot;); } } (3) 使用ExecutorService、Callable、Future实现有返回结果的多线程，实现Callable接口时，该接口中的call方法可以在线程执行结束时产生一个返回值。 import java.util.ArrayList; import java.util.List; import java.util.concurrent.Callable; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; public class Main { public static void main(String[] args) throws Exception { List&lt;Future&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); ExecutorService service = Executors.newFixedThreadPool(10); for (int i = 0; i &lt; 10; i++) { list.add(service.submit(new Task((int) (Math.random() * 100)))); } int sum = 0; for (Future&lt;Integer&gt; future : list) { sum += future.get(); } System.out.println(sum); } } class Task implements Callable&lt;Integer&gt; { private int upperBounds; public Task(int upperBounds) { this.upperBounds = upperBounds; } @Override public Integer call() throws Exception { int sum = 0; for (int i = 1; i &lt;= upperBounds; i++) { sum += i; } return sum; } } 例1：例2：注意评论 实现Runnable接口这种方式更受欢迎。在应用设计中线程类已经继承了别的类的情况下，需要多继承，只能实现接口（而Java不支持多继承，却支持实现多个接口），这样就不再需要继承Thread类，避免单继承的局限。同时，线程池也是非常高效的，很容易实现和使用。 问：start()和run()无论是通过继承Thread类还是实现Runnable接口来创建线程，都必须调用start()方法启动线程。线程启动后，线程进入就绪状态，当CPU分配时间给它时，它才开始运行，并不是一调用start()方法线程就立即运行。 run()方法是线程关联的需要执行的代码。直接调用run()方法，就相当于是普通的方法调用，会在主线程中直接运行，此时没有开启一个线程。 问：Java四种线程池的使用请阅读这篇文章 在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。 线程池顾名思义就是事先创建若干个可执行的线程放入一个池(容器)中，需要的时候从池中获取线程而不用自行创建，使用完毕后不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。要配置一个线程池是比较复杂的，尤其是在对线程池的原理不是很清楚的情况下，Java 5后的工具类Executors提供了一些静态工厂方法，可以生成一些常用的线程池。 合理的使用线程池，可以带来很多好处： 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗； 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行； 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 应用程序可以使用Executor/Callable/Future框架来创建线程池。 (1) ExecutorService java.util.concurrent.Executors.newSingleThreadExecutor() 创建一个单线程的线程池，这个线程池只有一个线程执行任务，也就相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 示例代码： import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class NewSingleThreadExecutor { public static void main(String[] args) { ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 10; i++) { final int index = i; singleThreadExecutor.execute(new Runnable() { public void run() { try { System.out.println(index); Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } } }); } } } // 顺序执行各个任务，依次输出结果 (2) ExecutorService java.util.concurrent.Executors.newFixedThreadPool(int nThreads) 创建一个含有固定数量线程的线程池，可控制最大并发任务数，超出的任务会在队列中等待。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变。如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class NewFixedThreadPool { public static void main(String[] args) { ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3); for (int i = 0; i &lt; 10; i++) { final int index = i; fixedThreadPool.execute(new Runnable() { public void run() { try { System.out.println(index); Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } } }); } } } // 因为线程池大小为3，每个线程输出index后sleep 2秒，所以每隔两秒打印3个数字 (3) ExecutorService java.util.concurrent.Executors.newCachedThreadPool() 创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程；当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class ThreadPoolExecutorTest { public static void main(String[] args) { ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) { final int index = i; try { Thread.sleep(index * 1000); } catch (InterruptedException e) { e.printStackTrace(); } cachedThreadPool.execute(new Runnable() { public void run() { System.out.println(index); } }); } } } (4) ScheduledExecutorService java.util.concurrent.Executors.newScheduledThreadPool(int corePoolSize) 创建一个含有固定数量线程的线程池，支持延时任务或周期性任务的执行。 执行延时任务的示例代码： import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class NewScheduledThreadPool1 { public static void main(String[] args) { ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); scheduledThreadPool.schedule(new Runnable() { public void run() { System.out.println(&quot;delay 3 seconds&quot;); } }, 3, TimeUnit.SECONDS); } } // 表示延迟3秒执行任务 执行定期性任务的示例代码： import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class NewScheduledThreadPool2 { public static void main(String[] args) { ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); scheduledThreadPool.scheduleAtFixedRate(new Runnable() { public void run() { System.out.println(&quot;delay 1 seconds, and excute every 3 seconds&quot;); } }, 1, 3, TimeUnit.SECONDS); } } // 表示延迟1秒后，每3秒执行一次任务 问：同步和异步同步：上一段代码没完成，下一段必须等到上一段代码完成后才可以执行。例如：两个线程共享数据，要求一个线程读取另一个线程写的数据，此时必须要求两个线程同步执行。 异步：上一段代码没完成，下一段不必等到上一段代码完成就可以执行。例如：当程序在某一个对象上调用了一个需要很长时间才能执行完的方法，如果我们不希望让程序等待方法的返回，此时可以使用异步编程。 问：synchronized关键字推荐阅读：嘟嘟独立博客 在Java中，每一个对象都拥有一个锁标记，也称为监视器。一旦一个方法或一个代码块被synchronized修饰，那么这个部分就放入了监视器的监视区域，确保在同一时刻最多只有一个线程执行该部分代码，线程在获取锁之前不允许执行该部分的代码。 例1： java实现进程之间的同步执行采用的机制是：监视器 当两个并发线程访问同一个对象的synchronized方法或代码块时，两个线程间是互斥的，在同一时刻只能有一个线程得到执行，另一个线程被阻塞，因为在执行synchronized方法或代码块的线程会锁定当前对象，只有在当前线程执行完这些代码并释放该对象的锁时，下一个线程才能锁定并执行该对象的synchronized方法或代码块。 (1) 当一个线程访问对象的一个synchronized方法或代码块时，另一个线程仍然可以访问该对象的非synchronized方法或代码块。(两个线程使用的是同一个对象) (2) 当一个线程访问对象的一个synchronized方法或代码块时，其他线程对该对象的所有其它synchronized方法或代码块的访问将被阻塞(同上，两个线程使用的是同一个对象)。 例2： 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法? 答： (1) 其它线程可以进入该对象的非synchronized方法； (2) 如果这个synchronized方法内部调用了wait()，则其它线程可以进入此对象的其他synchronized方法； 如果这个synchronized方法内部没有调用wait()，则其它线程不可以进入该对象的其他synchronized方法。 如果其他方法是static方法(当然它不属于对象，而是属于类)，它用的同步锁是当前类的字节码，与非静态的方法不能同步，其它线程可以进入这些方法。 例3：看评论 public class HelloSogou{ public static synchronized void main(String[] a){ Thread t=new Thread(){ public void run(){ Sogou(); } }; t.run(); System.out.print(&quot;Hello&quot;); } static synchronized void Sogou(){ System.out.print(&quot;Sogou&quot;); } } 上面JAVA程序的输出是：SogouHello (3) 如果父类中的某个方法使用了synchronized关键字，而子类中覆盖了这个方法，默认情况下子类中的这个方法并不是同步的，必须显示的在子类的这个方法中加上synchronized关键字之后该方法才同步。当然，也可以在子类中调用父类中相应的方法，这样虽然子类中的方法并不是同步的，但子类调用了父类中的同步方法，也就相当子类方法也同步了。 例4：判断正误 构造方法不需要同步化。(正确) 一个子类不可以覆盖掉父类的同步方法。(错误) 问：同步方法和同步代码块的区别是什么？Java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时(增删改查)，将会导致数据的不准确，相互之间产生冲突。因此加入了同步锁，以避免在该线程没有结束前，其他线程操作该资源变量，从而保证了变量的唯一性，准确性。 Java中每个对象都有一把锁，线程可以通过synchronized关键字来获取对象上的锁。 (1) 同步方法(粗粒度锁)：由synchronized关键字修饰的方法 修饰一般方法:public synchronized void method(){…}，获取的是当前被调用对象的锁修饰静态方法:public static synchronized void method(){…}，获取当前类的字节码对象上的锁 举例：如果一个线程执行一个对象的非static的synchronized方法，另外一个线程执行这个对象所属类的static的synchronized方法，此时不会发生互斥现象，因为访问static的synchronized方法占用的是类的字节码对象锁，而访问非static的synchronized方法占用的是对象锁，所以不存在互斥现象。 public class SychronizedTest { public static void main(String[] args){ SynObj obj=new SynObj(); Thread01 thread01=new Thread01(&quot;Thread01&quot;, obj); Thread01 thread02=new Thread01(&quot;Thread02&quot;, obj); Thread02 thread03=new Thread02(&quot;Thread03&quot;); Thread02 thread04=new Thread02(&quot;Thread04&quot;); thread01.start(); thread02.start(); thread03.start(); thread04.start(); } } class Thread01 extends Thread{ private String threadName; private SynObj obj; public Thread01(String threadName, SynObj obj) { this.threadName=threadName; this.obj = obj; } @Override public void run() { this.obj.run1(this.threadName); } } class Thread02 extends Thread{ private String threadName; public Thread02(String threadName) { this.threadName=threadName; } @Override public void run() { SynObj.run2(this.threadName); } } class SynObj{ // 同步方法 public synchronized void run1(String threadName){ for(int i=0; i&lt;3; i++){ try { Thread.sleep(1000); System.out.println(threadName+&quot; run1 i=&quot;+i); } catch (InterruptedException e) { e.printStackTrace(); } } } // 同步static方法 public static synchronized void run2(String threadName){ for(int i=0; i&lt;3; i++){ try { Thread.sleep(1000); System.out.println(threadName+&quot; run2 i=&quot;+i); } catch (InterruptedException e) { e.printStackTrace(); } } } } Thread01和Thread02之间存在互斥关系，Thread03和Thread03之间存在互斥关系，但是Thread01/Thread02和Thread03/Thread04之间不存在互斥关系。 一种可能的输出： Thread01 run1 i=0 Thread03 run2 i=0 Thread03 run2 i=1 Thread01 run1 i=1 Thread03 run2 i=2 Thread01 run1 i=2 Thread02 run1 i=0 Thread04 run2 i=0 Thread04 run2 i=1 Thread02 run1 i=1 Thread02 run1 i=2 Thread04 run2 i=2 (2) 同步代码块(细粒度锁)：: 由synchronized关键字修饰的语句块，同步代码块可以选择以什么语句块来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法 synchronized(obj) {…}，同步代码块可以指定获取某个对象上的锁。 public class SychronizedTest { public static void main(String[] args){ SynObj synObj1=new SynObj(); SynObj synObj2=new SynObj(); Obj obj1=new Obj(); Obj obj2=new Obj(); Thread01 thread01=new Thread01(&quot;Thread01&quot;, synObj1); Thread01 thread02=new Thread01(&quot;Thread02&quot;, synObj1); Thread01 thread03=new Thread01(&quot;Thread03&quot;, synObj2); Thread02 thread04=new Thread02(&quot;Thread04&quot;, synObj1, obj1); Thread02 thread05=new Thread02(&quot;Thread05&quot;, synObj1, obj1); Thread02 thread06=new Thread02(&quot;Thread06&quot;, synObj2, obj2); thread01.start(); thread02.start(); thread03.start(); thread04.start(); thread05.start(); thread06.start(); } } class Thread01 extends Thread{ private String threadName; private SynObj obj; public Thread01(String threadName, SynObj obj) { this.threadName=threadName; this.obj = obj; } @Override public void run() { this.obj.run1(this.threadName); } } class Thread02 extends Thread{ private String threadName; private SynObj synObj; private Obj obj; public Thread02(String threadName, SynObj synObj, Obj obj) { this.threadName=threadName; this.synObj=synObj; this.obj=obj; } @Override public void run() { this.synObj.run2(this.threadName, this.obj); } } class SynObj{ public void run1(String threadName){ // 同步代码块，锁住的是对象本身 synchronized(this){ for(int i=0; i&lt;3; i++){ try { Thread.sleep(1000); System.out.println(threadName+&quot; run1 i=&quot;+i); } catch (InterruptedException e) { e.printStackTrace(); } } } } public void run2(String threadName, Obj obj){ // 同步代码块，锁住的是对象obj synchronized(obj){ for(int i=0; i&lt;3; i++){ try { Thread.sleep(1000); System.out.println(threadName+&quot; run1 i=&quot;+i); } catch (InterruptedException e) { e.printStackTrace(); } } } } } class Obj{} Thread01和Thread02之间存在互斥关系，但是Thread01/Thread02和Thread03之间不存在互斥关系。 注释掉thread04，thread05和thread06的启动代码 //thread04.start(); //thread05.start(); //thread06.start(); 一种可能的输出： Thread01 run1 i=0 Thread03 run1 i=0 Thread01 run1 i=1 Thread03 run1 i=1 Thread01 run1 i=2 Thread03 run1 i=2 Thread02 run1 i=0 Thread02 run1 i=1 Thread02 run1 i=2 Thread04和Thread05之间存在互斥关系，但是Thread04/Thread05和Thread06之间不存在互斥关系。 注释掉thread01，thread02和thread03的启动代码 //thread01.start(); //thread02.start(); //thread03.start(); 一种可能的输出： Thread04 run1 i=0 Thread06 run1 i=0 Thread06 run1 i=1 Thread04 run1 i=1 Thread04 run1 i=2 Thread06 run1 i=2 Thread05 run1 i=0 Thread05 run1 i=1 Thread05 run1 i=2 将SynObj的run2方法的被锁对象换成obj.getClass()之后，此时Thread04、Thread05和Thread06之间存在互斥关系。因此Synchronized后面括号括起来的部分为synchronized(className.class)，作用的对象是这个类的所有对象 public void run2(String threadName, Obj obj){ // 同步代码块，锁住的是对象obj synchronized(obj.getClass()){ for(int i=0; i&lt;3; i++){ try { Thread.sleep(1000); System.out.println(threadName+&quot; run1 i=&quot;+i); } catch (InterruptedException e) { e.printStackTrace(); } } } } 一种可能的输出为： Thread04 run1 i=0 Thread04 run1 i=1 Thread04 run1 i=2 Thread06 run1 i=0 Thread06 run1 i=1 Thread06 run1 i=2 Thread05 run1 i=0 Thread05 run1 i=1 Thread05 run1 i=2 问：synchronized和java.util.concurrent.locks.Lock的异同Lock是Java 5以后引入的新的API。 相同点：Lock能完成synchronized所实现的所有功能 不同点： Lock有比synchronized更精确的线程语义和更好的性能。 synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。 Lock还有更强大的功能，例如，它的tryLock()方法可以以非阻塞方式去拿锁。 例1：请写出程序，实现如下功能：子线程循环10次，接着主线程循环100，接着又回到子线程循环10次，接着再回到主线程又循环100，如此循环50次。 方法一：使用synchronized public class Test { public static boolean isMain=false; public static void main(String[] args){ Object object=new Object(); Thread thread=new Thread(new Runnable(){ @Override public void run() { for(int i=0; i&lt;50; i++){ synchronized(object){ if(isMain){ try { object.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } for(int k=0; k&lt;10; k++){ System.out.println(Thread.currentThread().getName()+&quot;, i=&quot;+i+&quot;, k=&quot;+k); } isMain=true; object.notify(); } } } }); thread.start(); for(int i=0; i&lt;50; i++){ synchronized (object){ if(!isMain){ try { object.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } for(int j=0; j&lt;100; j++){ System.out.println(Thread.currentThread().getName()+&quot;, i=&quot;+i+&quot;, j=&quot;+j); } isMain=false; object.notify(); } } } } 方法二：使用并发库 import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class Test { private static Lock lock = new ReentrantLock(); private static Condition condition = lock.newCondition(); public static boolean isMain = false; public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i &lt; 50; i++) { lock.lock(); try { if (isMain) { condition.await(); } for (int k = 0; k &lt; 10; k++) { System.out.println(Thread.currentThread().getName() + &quot;, i=&quot; + i + &quot;, k=&quot; + k); } isMain = true; condition.signal(); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } } }); thread.start(); for (int i = 0; i &lt; 50; i++) { lock.lock(); try { if (!isMain) { condition.await(); } for (int j = 0; j &lt; 100; j++) { System.out.println(Thread.currentThread().getName() + &quot;, i=&quot; + i + &quot;, j=&quot; + j); } isMain = false; condition.signal(); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } } } 问：Java支持并发编程的同步机制例1： JDK提供的用于并发编程的同步器有：Semaphore、CyclicBarrier、CountDownLatch 例2： CyclicBarrier让一组线程等待其他线程；CountDownLatch让一组线程等待某个事件发生 Callable类的call()方法可以返回值和抛出异常 线程调用start()方法后进行就绪状态，等待获取CPU的使用权 例3： CopyOnWriteArrayList适合于读操作远远大于写操作的场景里，比如缓存。 ReadWriteLock 当写操作时，其他线程无法读取或写入数据，而当读操作时，其它线程无法写入数据，但却可以读取数据。适用于读取远远大于写入的操作。 ConcurrentHashMap是一个线程安全的HashTable，它的主要功能是提供了一组和HashTable功能相同但是线程安全的方法。 ConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，不用对整个ConcurrentHashMap加锁。 问：wait、notify、notifyAll wait() (1) 该方法用来让当前线程进入休眠状态，直到被唤醒或被中断为止。 (2) 在调用wait()之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait()方法。如果调用wait()时，线程没有持有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch结构。 (3) 进入wait()方法后，当前线程释放锁。在从 wait()返回前，线程与其他线程竞争重新获得锁。 notify() (1) 该方法也要在同步方法或同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁，如果调用notify()时线程没有持有适当的锁，也会抛出IllegalMonitorStateException。 (2) 该方法用来唤醒那些可能等待该对象的对象锁的其他线程。如果有多个线程等待，该方法并不能确切的唤醒某一个等待的线程，线程调度器任意挑选出其中一个wait()状态的线程来发出通知，并使它等待获取该对象的对象锁（notify后，发出通知的当前线程不会马上释放该对象锁，wait所在的线程并不能马上获取该对象锁，要等到程序退出synchronized代码块后，当前线程才会释放锁，wait所在的线程也才可以获取该对象锁），但不惊动其他同样在等待被该对象notify的线程们。 (3) 当第一个获得了该对象锁的wait线程运行完毕以后，它会释放掉该对象锁，此时如果该对象没有再次使用notify 语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，会继续阻塞在wait状态，直到这个对象发出一个notify或notifyAll。这里需要注意：它们等待的是被notify或notifyAll，而不是锁。这与下面的 notifyAll()方法执行后的情况不同。 notifyAll() 该方法与 notify ()方法的工作方式相同，重要的一点差异是：notifyAll 使所有原来在该对象上 wait 的线程统统退出 wait 的状态（即全部被唤醒，不再等待notify或notifyAll，但由于此时还没有获取到该对象锁，因此还不能继续往下执行），开始等待获取该对象上的锁，一旦该对象锁被释放（notifyAll线程退出调用了notifyAll的synchronized代码块的时候），他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出synchronized代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。 总结：如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。 案例：当前线程调用对象的notify后，当前线程不会马上释放该对象锁，wait所在的线程并不能马上获取该对象锁，要等到程序退出synchronized代码块后，当前线程才会释放锁，wait所在的线程也才可以获取该对象锁。 public static void main(String[]args)throws Exception { final Object obj = new Object(); Thread t1 = new Thread() { public void run() { synchronized (obj) { try { obj.wait(); System.out.println(&quot;Thread 1 wake up.&quot;); } catch (InterruptedException e) { } } } }; t1.start(); Thread.sleep(1000);//We assume thread 1 must start up within 1 sec. Thread t2 = new Thread() { public void run() { synchronized (obj) { obj.notifyAll(); System.out.println(&quot;Thread 2 sent notify.&quot;); } } }; t2.start(); } output: Thread 2 sent notify. Thread 1 wake up 例1：找出代码中错误的地方。 void waitForSignal(){ Object obj = new Object(); synchronized(Thread.currentThread()){ obj.wait(); obj.notify(); } } 第一个错误是wait()方法要以try/catch包覆，或是掷出InterruptedException才行 第二个错误是wait或者notify方法被调用的对象必须与synchronized中的对象一致，否则会有IllegalMonitorStateException 例2： 可用来实现线程间通知和唤醒的方式： Object.wait/notify/notifyAll Condition.await/signal/signalAll 问：sleep()方法和wait()方法的区别sleep()：该方法让线程休眠指定的时间，让出CPU，给其他线程执行的机会。当这个时间达到之后，线程会再次醒来，进入就绪状态。它是Thread类一个静态方法，调用此方法需要捕捉InterruptedException异常。 wait()：该方法用来让当前线程进入休眠状态，直到被唤醒或被中断为止。 (1) sleep()是Thread类的方法，wait()是Object类的方法 (2) wait()，notify()和notifyAll()只能在同步方法或同步代码块中使用，而sleep()可以在任何地方使用 (3) 调用sleep()方法后，线程进入睡眠状态，但不会释放对象锁，休眠时间结束后会自动进入就绪状态；调用wait()方法后，线程会释放对象锁，进入此对象的等待池(wait pool)中，让出CPU，给其他线程执行的机会，直到其他线程调用对象的notify()方法(或notifyAll()方法)时才能唤醒等待池中的线程进入等锁池(lock pool)，准备获得对象锁，如果线程重新获得对象的锁就可以进入就绪状态。 例1：sleep()和wait()的对比 问：sleep()方法和yield()方法的区别调用线程yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制交出CPU的具体时间，另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。 注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。 sleep()方法和yield()方法的区别: (1) sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会； (2) 线程执行sleep()方法后转入阻塞(blocked)状态，而执行yield()方法后转入就绪(ready)状态； (3) sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常； (4) sleep()方法比yield()方法(跟操作系统CPU调度相关)具有更好的可移植性。 问：suspend()和resume()方法Java.Thread的方法resume()负责重新开始被以下哪个方法中断的线程的执行（）？ A、stop B、sleep C、wait D、suspend 正确答案：D suspend()和resume()方法：两个方法配套使用，suspend()使线程进入阻塞状态，并且不会自动恢复，必须其对应的resume()被调用，才能使得线程重新进入可执行状态。 问：join()方法方法join()的作用是让调用join()方法的线程等待被调用线程结束，再继续往下执行。 问：共享变量在线程间的可见性要实现共享变量的可见性，必须要保证亮点： 被线程修改后的共享变量的值能够被及时从该线程的工作内存中刷新至主内存中 其他线程能够及时把共享变量的最新值从主内存中更新到自己的工作内存中 问：重排序为了提高程序的性能，编译器或处理器会优化程序的代码，使得代码的书写顺序和实际执行的顺序有所不同，这便是指令重排序。通常存在以下三种重排序： 编译器优化的重排序(编译器优化) 指令级并行重排序(处理器优化) 内存系统的重排序(处理器优化) 问：as-if-serial语义无论编译器或处理器如何对代码重排序，程序执行的结果应该与代码顺序执行的结果一致。(Java编译器和处理器会保证Java在单线程下遵循as-if-serial语义) 问：Java在语言层面实现共享变量在线程间的可见性的方式(1) 导致共享变量在线程间不可见的原因： 线程的交叉执行 重排序 共享变量更新后的值在工作内存和主内存之间没有得到及时更新 (2) Java在语言层面实现共享变量在线程间的可见性的方式 synchronized和volatile (3) synchronized实现共享变量在线程间的可见性 JMM对synchronized的两条规定：(注意：加锁和解锁使用的需要是同一把锁) 线程解锁前，必须把共享变量的最新值刷新到主内存中 线程加锁时，将清空工作内存中共享变量的值，从而在使用共享变量时需要从主内存中重新读取共享变量的最新值 线程解锁前对共享变量的修改在下次加锁时对其他线程可见。 问：volatile关键字推荐阅读：嘟嘟独立博客 volatile是java中的一个关键字，可以用来修饰被不同线程访问和修改的变量。 出于运行速率的考虑，Java编译器会把经常经常访问的变量放到缓存（严格讲应该是工作内存）中，读取变量则从缓存中读。但是在多线程编程中，内存中的值和缓存中的值可能会出现不一致。volatile用于限定变量只能从内存中读取，保证对所有线程而言，值都是一致的。volatile变量在执行写操作时，会在写操作之后加入一条store屏障指令，强制缓存中变量的值立刻被写入到内存中；volatile变量在之心读操作时，会在读操作之前就爱如一条load屏障指令，强制将变量的值从内存中更新到缓存中。但是volatile不能保证原子性，也就不能保证线程安全。 一旦一个共享变量(类的成员变量、类的静态成员变量)被volatile修饰之后，那么就具备了两层语义：1）可见性：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 2）禁止进行指令重排序：volatile只提供了保证访问该变量时，每次都是从内存中读取最新值，并不会使用寄存器缓存该值，每次都会从内存中读取。 volatile实现可见性 线程写volatile变量的过程： (1) 改变线程工作内存中volatile变量副本的值 (2) 将改变后的副本的值从工作内存刷新到主内存 线程读volatile变量的过程： (1) 从主内存中读取volatile变量的最新值到线程的工作内存 (2) 从工作内存中读取volatile变量的副本 volatile不能保证volatile变量相关操作的原子性 volatile的使用场景 要在多线程中安全地使用volatile变量，必须同时满足两个条件： (1) 对变量的写入操作不依赖于其当前值 满足：boolean变量，记录温度变化的变量等 不满足：number++，count=count*5等 (2) 该变量不包含在具有其他volatile变量的不变式中 不满足：不变式low&lt;up，其中up和low为volatile变量 例1，例2 问：保证原子性的方法(1) 使用synchronized关键字 (2) 使用java.util.concurrent.locks包中的ReentrantLock (3) 使用java.util.concurrent.aotmic包中的AtomicInteger 问：ThreadLocalThreadLocal类用于创建一个线程本地变量，让每一个线程都维护自己独有的变量拷贝。 在Thread中有一个成员变量ThreadLocals，该变量的类型是ThreadLocalMap，也就是一个Map，它的键是threadLocal，值为就是变量的副本。ThreadLocal为每一个使用该变量的线程都提供了一个变量值的副本，每一个线程都可以独立地改变自己的副本，是线程隔离的。通过ThreadLocal的get()方法可以获取该线程变量的本地副本，在get方法之前要先set，否则就要重写initialValue()方法。 ThreadLocal不是用来在多线程之间共享数据，而是让变量在每个线程中都有独立拷贝，使得不会出现一个线程读取变量时，该变量而被另一个线程修改的现象。 由于每个线程在访问该变量时，读取和修改的，都是自己独有的那一份变量拷贝，不会被其他线程访问，变量被彻底封闭在每个访问的线程中 例1，例2：这题A答案似乎是错的 问：什么是死锁(deadlock)？两个线程或两个以上线程因争夺资源而都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是若无外力作用，这些线程都陷入了无限的等待中。 问：如何确保N个线程可以访问N个资源同时又不导致死锁？使用多线程的时候，一种非常简单的避免死锁的方式就是：指定访问资源的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。 问：生产者和消费者模型模型描述：有一块缓冲区作为仓库，生产者可以将产品放入仓库，消费者可以从仓库中取走产品。解决生产者和消费者问题的核心在于要保证同一资源被多个线程并发访问时的完整性。一般采用信号量或加锁机制解决。下面介绍Java中解决生产者和消费者问题的三种主要方式： public class ProducerConsumer { public static void main(String[] args) { Storage storage = new Storage(); ExecutorService taskSubmit = Executors.newFixedThreadPool(10); // 给定2个消费者 taskSubmit.submit(new Consumer(&quot;consumer1&quot;, storage, 50)); taskSubmit.submit(new Consumer(&quot;consumer2&quot;, storage, 10)); // 给定3个生产者 taskSubmit.submit(new Producer(&quot;producer1&quot;, storage, 60)); taskSubmit.submit(new Producer(&quot;producer2&quot;, storage, 10)); taskSubmit.submit(new Producer(&quot;producer3&quot;, storage, 20)); } } 生产者线程： class Producer implements Runnable { private String producerName; private Storage storage; private int num;// 每次生产数量 public Producer(String name, Storage storage, int num) { this.producerName = name; this.storage = storage; this.num = num; } @Override public void run() { while(true){ storage.produce(this.producerName, num); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } 消费者线程： class Consumer implements Runnable { private String consumerName; private Storage storage; private int num;// 每次消费数量 public Consumer(String name, Storage storage, int num) { this.consumerName = name; this.storage = storage; this.num = num; } @Override public void run() { while(true){ storage.consume(this.consumerName, num); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } (1) wait()、notify()/notifyAll() class Storage { private static final int MAX_SIZE = 100;// 仓库的最大容量 private List&lt;Object&gt; data = new ArrayList&lt;Object&gt;();// 存储载体 /** * 生产操作 */ public synchronized void produce(String producer, int num) { while (data.size() + num &gt; MAX_SIZE) {// 如果生产这些产品将超出仓库的最大容量，则生产操作阻塞 System.out.println(producer+&quot;生产操作--&gt;数量：&quot; + num + &quot;，超出仓库容量，生产阻塞！------库存：&quot; + data.size()); try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } // 到这里，表示可以正常生产产品 for (int i = 0; i &lt; num; i++) {// 生产num个产品 data.add(new Object()); } System.out.println(producer+&quot;生产操作--&gt;数量：&quot; + num + &quot;，成功入库~------库存：&quot; + data.size()); // 生产完产品后，唤醒其他等待消费的线程 notify(); } /** * 消费操作 */ public synchronized void consume(String consumer, int num) { while (data.size() - num &lt; 0) {// 如果产品数量不足 System.out.println(consumer+&quot;消费操作--&gt;数量：&quot; + num + &quot;，库存不足，消费阻塞！------库存：&quot; + data.size()); try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } // 到这里，表示可以正常消费 for (int i = 0; i &lt; num; i++) {// 消费num个产品 data.remove(0); } System.out.println(consumer+&quot;消费操作--&gt;数量：&quot; + num + &quot;，消费成功~------库存：&quot; + data.size()); // 消费完产品后，唤醒其他等待生产的线程 notify(); } } (2) await()、signal()/signalAll() JDK 1.5之后引入了concurrent包，可以使用await()和signal()方法来做同步，功能和wait()和notify()方法相同，可以完全取代它们，但await()和signal()需要和Lock机制结合使用，更加灵活。和第一种方法类似，可以通过调用Lock的newCondition()方法依次获取两个条件变量，一个针对仓库空的，一个针对仓库满，通过添加变量进行同步控制。 class Storage { private static final int MAX_SIZE = 100;// 仓库的最大容量 private List&lt;Object&gt; data = new ArrayList&lt;Object&gt;();// 存储载体 private Lock lock = new ReentrantLock();// 可重入锁 private Condition full = lock.newCondition();// 仓库满的条件变量 private Condition empty = lock.newCondition();// 仓库空时的条件变量 /** * 生产操作 */ public void produce(String producer, int num) { lock.lock(); // 加锁 while (data.size() + num &gt; MAX_SIZE) {// 如果生产这些产品将超出仓库的最大容量，则生产操作阻塞 System.out.println(producer + &quot;生产操作--&gt;数量：&quot; + num + &quot;，超出仓库容量，生产阻塞！------库存：&quot; + data.size()); try { full.await(); // 阻塞 } catch (InterruptedException e) { e.printStackTrace(); } } // 到这里，表示可以正常生产产品 for (int i = 0; i &lt; num; i++) {// 生产num个产品 data.add(new Object()); } System.out.println(producer + &quot;生产操作--&gt;数量：&quot; + num + &quot;，成功入库~------库存：&quot; + data.size()); // 生产完产品后，唤醒其他等待消费的线程 empty.signalAll(); lock.unlock(); // 释放锁 } /** * 消费操作 */ public void consume(String consumer, int num) { lock.lock(); // 加锁 while (data.size() - num &lt; 0) {// 如果产品数量不足 System.out.println(consumer + &quot;消费操作--&gt;数量：&quot; + num + &quot;，库存不足，消费阻塞！------库存：&quot; + data.size()); try { empty.await(); // 阻塞 } catch (InterruptedException e) { e.printStackTrace(); } } // 到这里，表示可以正常消费 for (int i = 0; i &lt; num; i++) {// 消费num个产品 data.remove(0); } System.out.println(consumer + &quot;消费操作--&gt;数量：&quot; + num + &quot;，消费成功~------库存：&quot; + data.size()); // 消费完产品后，唤醒其他等待生产的线程 full.signalAll(); lock.unlock(); // 释放锁 } } 使用await和signal后，加锁解锁操作就交给了Lock，不用再使用synchronized同步（具体可看前面总结的同步的实现方法），在produce中满仓后阻塞，生产完后唤醒等待的消费线程，consume中库存不足后阻塞，消费完后唤醒等待的生产者线程，表示可以消费了。 (3) BlockingQueue阻塞队列方式 在创建一个线程池如ThreadPoolExecutor时，需要传入一个阻塞任务队列即BlockingQueue用于保存等待执行的任务。可以选择以下几个阻塞队列：ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue。 ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。 LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。 SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。 PriorityBlockingQueue：一个具有优先级的无限阻塞队列。 BlockingQueue的所有实现类都已经实现了同步的队列，实现的方式采用的是上面介绍的第二种await()/signal() + Lock的同步机制。在生成阻塞队列时，可以指定队列大小。用于阻塞操作的方法主要为： put()方法：插入一个元素，如果超过容量则自我阻塞，等待被唤醒； take()方法：取走一个元素，如果容量不足了，自我阻塞，等待被唤醒； put和take内部自己实现了await和signal、lock的机制处理，不再需要我们做相应操作。 class Storage { private static final int MAX_SIZE = 100;// 仓库的最大容量 private BlockingQueue&lt;Object&gt; data = new LinkedBlockingQueue&lt;Object&gt;(MAX_SIZE); // 使用阻塞队列作为存储载体 /** * 生产操作 */ public void produce(String producer, int num) { if (data.size() == MAX_SIZE) {// 如果仓库已达最大容量 System.out.println(&quot;生产操作--&gt;仓库已达最大容量！&quot;); } // 到这里，表示可以正常生产产品 for (int i = 0; i &lt; num; i++) {// 生产num个产品 try { data.put(new Object()); // put内部自动实现了判断，超过最大容量自动阻塞 } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;生产操作--&gt;数量：&quot; + num + &quot;，成功入库~------库存：&quot; + data.size()); } /** * 消费操作 */ public void consume(String consumer, int num) { if (data.size() == 0) {// 如果产品数量不足 System.out.println(&quot;消费操作--库存不足！&quot;); } // 到这里，表示可以正常消费 for (int i = 0; i &lt; num; i++) {// 消费num个产品 try { data.take(); // take内部自动判断，消耗后库存是否充足，不足自我阻塞 } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;消费操作--&gt;数量：&quot; + num + &quot;，消费成功~------库存：&quot; + data.size()); } } 可以看到，Storage中produce和consume方法中我们直接通过put和take方法往容器中添加或移除产品即可，没有进行逻辑控制（其实上面两个方法中if都可以去掉，只是为了打印效果才加上的），这是因为BlockingQueue内部已经实现了，不需要我们再次控制。同时，我们看到打印的库存信息出现了不匹配，这个主要是因为我们的打印语句Systm.out.println()没有被同步导致的，因为同步语句只是在put和take方法内部，而我们打印语句中使用了data这个共享变量。这里因为我们需要看效果，所以才加的打印语句，并不影响我们对BlockingQueue的使用。 因此，在Java中，使用BlockingQueue阻塞队列的方式可以很方便的为我们处理生产者消费则问题，推荐使用。 在我们的编程生涯中，我们自己要去写生产者和消费者问题，多是前面第一种介绍的“类似消费者生产者问题”上。 解决生产者和消费者问题还有管道的方式，即在生产者和消费者之间建立一个管道缓冲区，Java中用PipedInputStream / PipedOutputStream实现，由于这种方式对于传输对象不易封装，因此实用性不高，就不具体介绍了。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"08-流","slug":"08-流","date":"2017-02-20T10:22:25.000Z","updated":"2017-10-21T13:19:21.226Z","comments":true,"path":"2017/02/20/08-流/","link":"","permalink":"https://hepsilion.github.io/2017/02/20/08-流/","excerpt":"流","text":"流 部分内容来自这里 问：Java中有几种类型的流？在Java使用流的机制进行数据的传送，从文件到内存是输入流，从内存到文件是输出流。 Java中有字节流和字符流。字节流继承于InputStream/OutputStream，字符流继承于Reader/Writer。 在java.io包中还有许多其他的流，低层流与高层流，高层流主要是为了提高性能和使用方便。 图 1 问：字符流与字节流要把一片二进制数据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式即为IO流，对应的抽象类为OutputStream和InputStream，它们都是针对字节进行操作的。 在应用中，经常要将完全是字符的一段文本输出去或读进来，直接用字节流可以吗？计算机中的一切最终都是以二进制的字节形式存在。对于“中国”这些字符，首先需要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，人家专门提供了字符流的包装类。 底层设备永远只接受字节数据，有时候要将字符串写到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，它直接接受字符串，内部将字符转换成字节，再写入底层设备，这为我们向IO设备写入或读取字符串提供了一点点方便。 在将字符转换为字节时，需要注意编码问题：因为字符串转换成字节数组，其实是将每个字符转换成某种编码的字节形式，读取也是反之的道理。 例1：字节流和字符流的使用 String str=&quot;Hello World!&quot;; 字节流： FileOutputStream fos=new FileOutputStream(&quot;content.txt&quot;); fos.write(str.getBytes(&quot;UTF-8&quot;)); fos.close(); FileInputStream fis = new FileInputStream(&quot;content.txt&quot;); byte[] buf = new byte[1024]; int len =fis.read(buf); String myStr = new String(buf, 0, len, &quot;UTF-8&quot;); System.out.println(myStr); 字符流： FileWriter fw =new FileWriter(&quot;content.txt&quot;); fw.write(str); fw.close(); FileReader fr =new FileReader(&quot;content.txt&quot;); char[] buf = new char[1024]; int len =fr.read(buf); String myStr = new String(buf, 0, len); System.out.println(myStr); 例2：编程实现文件拷贝 import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.nio.ByteBuffer; import java.nio.channels.FileChannel; public class Main { // 工具类中的方法都是静态方式访问的，因此将构造器设为私有不允许创建对象 private Main() { throw new AssertionError(); } public static void main(String[] args) { fileCopy(&quot;file1.txt&quot;, &quot;file2.txt&quot;); //fileCopyNIO(&quot;file1.txt&quot;, &quot;file2.txt&quot;); } public static void fileCopy(String source, String target) { InputStream in = null; OutputStream out = null; try { in = new FileInputStream(source); out = new FileOutputStream(target); byte[] buffer = new byte[4096]; int bytesToRead; while ((bytesToRead = in.read(buffer)) != -1) { out.write(buffer, 0, bytesToRead); } } catch (IOException e) { } finally { try { if (in != null) in.close(); if (out != null) out.close(); } catch (IOException e) { e.printStackTrace(); } } } public static void fileCopyNIO(String source, String target) { FileInputStream in = null; FileOutputStream out = null; try { in = new FileInputStream(source); out = new FileOutputStream(target); FileChannel inChannel = in.getChannel(); FileChannel outChannel = out.getChannel(); ByteBuffer buffer = ByteBuffer.allocate(4096); while (inChannel.read(buffer) != -1) { buffer.flip(); outChannel.write(buffer); buffer.clear(); } } catch (IOException e) { } } } 问：节点流与处理流流可以分为节点流和处理流： 节点流可以从一个特定的数据源(如文件、内存等)读写数据； 图 1 而处理流则是连接在已存在的节点流或处理流之上，通过对数据的处理为程序提供更强大的读写功能。 图 2 常用的节点流 图 1 常用的处理流 图 2 节点流向处理流转换的实例： FileInputStream(System.in) -&gt; InputSteamReader -&gt; BufferReader OutputSteam(System.out) -&gt; PrintStream FileReader -&gt; BufferedReader FileWriter -&gt; PrintWriter或bufferWriter 例1：处理流的使用 String str=&quot;Hello World!&quot;; PrintWriter pw =new PrintWriter(&quot;content.txt&quot;, &quot;utf-8&quot;); pw.write(str); pw.close(); BufferedReader br =new BufferedReader(new InputStreamReader(new FileInputStream(&quot;content.txt&quot;), &quot;UTF-8&quot;)); String myStr =br.readLine(); br.close(); System.out.println(myStr); 例2：写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数 /** * 统计给定文件中给定字符串的出现次数 * * @param filename 文件名 * @param word 字符串 * @return 字符串在文件中出现的次数 */ public static int countWordInFile(String filename, String word) { BufferedReader br = null; int counter = 0; try { br = new BufferedReader(new FileReader(filename)); String line = null; while ((line = br.readLine()) != null) { int index = -1; while (line.length() &gt;= word.length() &amp;&amp; (index = line.indexOf(word)) &gt;= 0) { counter++; line = line.substring(index + word.length()); } } } catch (Exception ex) { ex.printStackTrace(); } finally { try { if(br!=null) br.close(); } catch (IOException e) { e.printStackTrace(); } } return counter; } 问：IO与NIO推荐阅读：Java IO与NIO 问：序列化序列化是为了解决在对对象流进行读写操作时所引发的问题(如果不进行序列化可能会存在数据乱序的问题)。序列化就是一种用来处理对象流的机制，所谓对象流就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。 Java序列化是指将对象转换为字节序列的过程，而反序列化则是将字节序列转换成目标对象的过程。 我们都知道，在进行浏览器访问的时候，我们看到的文本、图片、音频、视频等都是通过二进制序列进行传输的，那么如果我们需要将Java对象进行传输的时候，是不是也应该先将对象进行序列化？答案是肯定的，我们需要先将Java对象进行序列化，然后通过网络、IO进行传输，当到达目的地之后，再进行反序列化获取到我们想要的对象，最后完成通信。 问：序列化的实现推荐阅读1，推荐阅读2 方式一 (1) 定义类实现Serializable接口，并生成一个版本号 import java.io.Serializable; public class People implements Serializable{ private static final long serialVersionUID = 1942699735300957387L; private transient String id; private String name; private String age; public People(String id, String name, String age) { this.id = id; this.name = name; this.age = age; } public People(){ } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAge() { return age; } public void setAge(String age) { this.age = age; } @Override public String toString() { return &quot;Student{id=&apos;&quot; + id + &quot;\\&apos;, name=&apos;&quot; + name + &quot;\\&apos;, age=&apos;&quot; + age + &quot;\\&apos;}&quot;; } } (2) 使用ObjectOutputStream类中的writeObject()方法将对象进行序列化；使用ObjectInputStream类中的readObject()方法反序列化得到对象 public static void main(String[] args){ File file = new File(&quot;D:/test.txt&quot;); People people = new People(&quot;12&quot;, &quot;齐天大圣&quot;, &quot;500&quot;); try { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file)); oos.writeObject(people); oos.close(); } catch (IOException e) { e.printStackTrace(); } try { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file)); People p = (People) ois.readObject(); System.out.println(p.toString()); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } 注意： Serializable接口中并没有提供任何方法，它只是一个标识性接口，标识这个类的对象需要被序列化，javac编译时会进行特殊处理；然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出(即保存其状态)；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject()方法从流中读取对象。 序列化版本号serialVersionUID的作用是区分我们所编写的类的版本，用于判断反序列化时类的版本是否一致，如果不一致会出现版本不一致异常； 关键字transient用来忽略我们不希望进行序列化的变量，在被反序列化后，transient变量的值被设为初始值，如int型的是0，引用型变量的值是null。 方式二 (1) 定义类实现Externalizable接口，实现接口中的writeExternal()和readExternal()方法实现对象的序列化。Externaliable接口是Serializable的子接口，有着和Serializable接口同样的功能。 import java.io.Externalizable; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInput; import java.io.ObjectInputStream; import java.io.ObjectOutput; import java.io.ObjectOutputStream; public class People implements Externalizable{ private transient String id; private String name; private String age; public People(String id, String name, String age) { this.id = id; this.name = name; this.age = age; } public People(){ } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAge() { return age; } public void setAge(String age) { this.age = age; } @Override public String toString() { return &quot;Student{id=&apos;&quot; + id + &quot;\\&apos;, name=&apos;&quot; + name + &quot;\\&apos;, age=&apos;&quot; + age + &quot;\\&apos;}&quot;; } @Override public void writeExternal(ObjectOutput out) throws IOException { out.writeObject(id); out.writeObject(name); out.writeObject(age); } @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { id = (String) in .readObject(); name = (String) in.readObject(); age = (String) in.readObject(); } } (2) public static void main(String[] args){ File file = new File(&quot;D:/test.txt&quot;); People people = new People(&quot;12&quot;, &quot;齐天大圣&quot;, &quot;500&quot;); try { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file)); people.writeExternal(oos); oos.close(); } catch (IOException e) { e.printStackTrace(); } try { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file)); People p = new People(); p.readExternal(ois); System.out.println(p.toString()); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } 问：transient关键字的作用？如何将transient修饰符修饰的变量序列化？当使用transient关键字修饰一个变量时，这个变量将不会参与序列化过程，也就是说它不会在网络操作时被传输，也不会在本地被存储下来，这对于保护一些敏感字段(如密码等)非常有帮助。 变量被transient关键字修饰后，反序列化后不能获取到该变量的值； transient只能修饰变量，不能修饰方法。修饰我们自定义类的变量时，这个类一定要实现Serializable接口； 由于static修饰的变量是属于类的，而序列化是针对对象的，因此static修饰的变量不能被序列化。 例1：当一个类实现了Serializable接口，这个对象的所有字段就可以被自动序列化。在持久化对象时，我们可能不想让一些特殊字段随着网络传输过去，或者在本地被序列化缓存起来，这时我们就可以在这些字段前加上transient关键字修饰，被transient修饰的变量的值将不会包括在序列化的表示中，也就不会被保存下来。这个字段的生命周期仅存在于调用者的内存中。 import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; class UserBean implements Serializable { private static final long serialVersionUID = 856780694939330811L; private String userName; private transient String password; // 此字段不需要被序列化 public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } public class Main { public static void main(String[] args) { // 序列化 try { UserBean bean = new UserBean(); bean.setUserName(&quot;name&quot;); bean.setPassword(&quot;password&quot;); System.out.println(&quot;序列化前---&gt;userName:&quot; + bean.getUserName() + &quot;，password:&quot; + bean.getPassword()); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;E:/userbean.txt&quot;)); oos.writeObject(bean);// 将对象序列化缓存到本地 oos.flush(); oos.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } // 反序列化 try { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;E:/userbean.txt&quot;)); UserBean bean = (UserBean) ois.readObject(); ois.close(); System.out.println(&quot;反序列化后获取出的数据---&gt;userName:&quot; + bean.getUserName() + &quot;，password:&quot; + bean.getPassword()); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } } //输出： 序列化前---&gt;userName:name，password:password 反序列化后获取出的数据---&gt;userName:name，password:null 注意：如果给password加上static关键字修饰，反序列化后依然能够获取到值，但是这个时候的值是JVM内存中对应的static的值，因为static修饰后，它属于类不属于对象，存放在一块单独的区域，直接通过对象也是可以获取到这个值的。 我们可以通过实现Externalizable接口，实现writeExternal()和readExternal()方法，然后再自定义序列化对象。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"07-集合类","slug":"07-集合类","date":"2017-02-19T10:20:30.000Z","updated":"2017-10-21T13:19:21.195Z","comments":true,"path":"2017/02/19/07-集合类/","link":"","permalink":"https://hepsilion.github.io/2017/02/19/07-集合类/","excerpt":"集合类","text":"集合类 问：Java的集合类框架Java集合类提供了一套设计良好的支持对一组对象(对于基本类型，必须要使用其包装类型)进行操作的接口和类。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和操作(增、删、改、查)。有的集合类允许重复的元素，有些不允许。 Java集合类有两大接口：Collection和Map，一个是元素集合，另一个是键值对集合且键不能重复。 图 1 图 2 Collection以单个对象的形式保存数据。List和Set接口继承了Collection接口。 List是有序元素集合(即每个元素都可以按index访问)，元素可以重复； Set是无序元素集合(即每个元素都不可以按index访问)，元素不可以重复。 ArrayList、LinkedList和Vector实现了List接口，HashSet和TreeSet实现了Set接口，这几个都比较常用； ArrayList和Vector都以数组的方式存储，增、删慢，查、改快；ArrayList:线程不安全，速度快；Vector:线程安全，速度慢； LinkedList: 以双向链表的方式存储，操作慢。 Queue接口继承了Collection接口，模拟了队列先进先出的数据结构 Statck类为Vector的子类，模拟了栈后进先出的数据结构。 Map以键值对的形式保存数据，key不可以重复。 HashMap和HashTable实现了Map接口。HashMap不是线程安全的，HashTable是线程安全的，但是HashMap性能更好； 由于Collection类继承Iterable类，所以，所有Collection的实现类都可以通过foreach的方式进行遍历。 问：List、Set和Map三个接口存取元素时，各有什么特点？List和Set继承自Collection接口，是单列元素集合；Map是双列元素集合，即key/value对集合。 (1) List是有序元素集合(即每个元素都可以按index访问)，元素可以重复； 同一个对象可以被反复存储进List中，每调用一次add方法，这个对象就被插入进集合一次，size()也增大1。其实，并不是把这个对象本身存储进了集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被add多次时，相当于在集合中有多个索引指向了这个对象。 可以使用add(Object obj)方法将元素放到集合的末尾； 可以使用add(int index, Object obj)方法将元素放到集合中的指定位置； 可以使用Iterator接口获得集合中的所有元素，再逐一遍历各个元素； 可以使用get(index i)方法获得集合中指定位置的元素。 (2) Set是无序元素集合(即每个元素都不可以按index访问)，元素不可以重复，元素重复与否是使用equals()方法进行判断的。 可以使用add(Object obj)方法将元素存储进集合。该方法有一个boolean类型的返回值，当集合中没有某个元素时，add方法可以成功加入该元素并且返回true；当集合已经含有与某个元素equals()相等的元素时，此时add方法无法加入该元素并且返回false； 由于Set中元素是无序的，无法按index访问，所以只能用Iterator接口取得所有的元素，再逐一遍历各个元素 (3) Map是key/value对集合，key不可以重复，这个重复的规则是根据equals()方法比较相等的 可以使用put(Object key, Object value)方法存储key/value对，key不可以重复 可以使用get(Object key)方法获得与key相对应的value； 可以使用keySet()方法获得所有key的集合； 可以使用values()方法获得所有value的集合； 可以使用entrySet()方法获得所有key和value组合成的Map.Entry对象的集合。 问：Java语言中的几种数组复制方法效率比较System.arraycopy &gt; clone &gt; Arrays.copyOf &gt; for循环 问：Java集合框架中线程安全的类Vector、Stack(它继承了Vector)、Hashtable、Properties、Enumeration、(非集合类的StringBuffer) 问：ArrayList容量ArrayList的构造函数总共有三个 ArrayList()构造一个初始容量为 10 的空列表，动态增长时，容量增长到当前容量的1.5倍 ArrayList(Collection&lt;? extends E&gt; c)构造一个包含指定collection的元素的列表，这些元素是按照该collection的迭代器返回它们的顺序排列的。 ArrayList(int initialCapacity)构造一个具有指定初始容量的空列表。 问：数组(Array)和列表(ArrayList)的区别？什么时候应该使用Array而不是ArrayList？(1) Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。(但是需要注意的是：Array数组中存放的一定是同种类型的元素；ArrayList就不一定了，因为ArrayList可以存储Object。) (2) Array大小是固定的，ArrayList的大小是动态变化的。 (3) ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。 对于基本类型数据，ArrayList使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。 注意：Arrays.asList()将一个数组转化为一个List对象，这个方法会返回一个ArrayList类型的对象，这个ArrayList类并非java.util.ArrayList类，而是Arrays类的静态内部类！对这个对象进行添加删除更新操作，会报UnsupportedOperationException异常。 问：ArrayList、Vector、LinkedList的异同ArrayList、Vector、LinkedList都实现了List接口，并且三者都可以添加null元素。 public static void main(String[] args) { ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); arrayList.add(null); arrayList.add(null); System.out.println(arrayList.size());//2 LinkedList&lt;String&gt; linkedList = new LinkedList&lt;String&gt;(); linkedList.add(null); linkedList.add(null); System.out.println(linkedList.size());//2 Vector&lt;String&gt; vectorList = new Vector&lt;String&gt;(); vectorList.add(null); vectorList.add(null); System.out.println(vectorList.size());//2 } Vector和ArrayList的异同相同点：两者都实现了List接口，在功能上基本完全相同，其底层都是通过new出的Object[]数组实现。 (1) 由于两者的数据结构为数组，因此都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，可以按位置索引取出某个元素，并且其中的数据是允许重复的。 (2) 由于两者的数据结构为数组，因此当我们能够预估到数组大小的时候，我们可以指定数组的初始大小，这样可以减少后期动态扩充数组大小带来的消耗。 ArrayList&lt;String&gt; arrayList= new ArrayList&lt;String&gt;(20); Vector&lt;String&gt; vector = new Vector&lt;String&gt;(15); (3) 由于两者的数据结构为数组，因此在获取数据方面，即get()时比较高效，而在指定位置add()或remove()时，由于需要移动元素，效率相对不高。 不同点： (1) Vector的大部分方法都加了synchronized，即Vector是同步的，而ArrayList不是同步的。即Vector是线程安全的，而ArrayList是线程不安全的。Vector是Java中的遗留容器。 因此如果只有一个线程会访问集合，最好使用ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问集合，最好使用Vector，因为我们不需要自己去编写和线程安全相关的代码。大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。 (2) 在元素增加，容量需要增长时，Vector容量默认增长原来的一倍，而ArrayList增长原来的50%，这样，ArrayList就有利于节约内存空间。 (3) 如果涉及到堆栈、队列等操作，应该考虑用Vector；如果需要快速随机访问元素，应该使用ArrayList。 例1：如何去掉一个Vector集合中重复的元素？ private Vector&lt;Integer&gt; fun(Vector&lt;Integer&gt; oVector){ Vector&lt;Integer&gt; vector = new Vector&lt;Integer&gt;(); for (int i = 0; i &lt; oVector.size(); i++) { Integer obj = oVector.get(i); if (!vector.contains(obj)) { vector.add(obj); } } return vector; } 或者 private Vector&lt;Integer&gt; fun(Vector&lt;Integer&gt; oVector){ Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(oVector); Vector&lt;Integer&gt; vector=new Vector&lt;Integer&gt;(set); return vector; } ArrayList和LinkedList的区别ArrayList和LinkedList都实现了List接口，两者都是线程不安全的，他们有以下的不同点： (1) ArrayList是基于索引的数据结构，它的底层是数组，它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以双向链表的形式存储数据的，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。 (2) 相对于ArrayList，LinkedList的插入、删除时不需要移动元素，不需要像数组那样重新计算大小或者是更新索引，操作速度更快。 (3) LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。 (4) LinkedList提供了一些方法，使得LinkedList可以被当作堆栈和队列来使用。 使用选择 LinkedList适合于有大量的增加/删除操作和较少随机读取操作； ArrayList适合于大规模随机读取数据，而较少插入和删除元素情景下使用；Vector在要求线程安全的情况下使用。 Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用。但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。 问：什么是Java优先级队列(Priority Queue)？PriorityQueue是一个基于堆排序的无界队列，此队列按照在构造时所指定的顺序对元素排序，既可以根据元素的自然顺序来指定排序，也可以给它提供一个负责给元素排序的比较器来指定，这取决于使用哪种构造方法。 PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。 最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。 问：什么是迭代器(Iterator)？Iterator接口提供了很多对集合中元素进行迭代的方法，每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的remove(Object Obj)删除，可以通过迭代器的remove()方法删除。 问：Enumeration接口和Iterator接口的区别有哪些？(1) Enumeration速度是Iterator的2倍，同时占用更少的内存。 (2) 但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。 (3) 同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。 例1：list是一个ArrayList的对象，为了能够在Iterator遍历的过程中正确并安全的删除一个list中保存的对象，//todo delete处可以可以填写什么代码？ Iterator it = list.iterator(); int index = 0; while (it.hasNext()){ Object obj = it.next(); if (needDelete(obj)){//needDelete返回boolean，决定是否要删除 //todo delete } index ++; } 正确答案：it.remove(); 问：Iterator和ListIterator的区别是什么？(1) Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 (2) Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 (3) ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。 问：快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个ConcurrentModification异常。 安全失败：你在迭代的时候会对底层集合做一个拷贝，所以有另一个线程在修改上层集合的时候，访问是不会受影响的，不会抛出ConcurrentModification异常。 迭代器的安全失败是基于对底层集合做拷贝，因此，它不受原集合上修改的影响。 java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。 快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。 问：List遍历过程中删除元素List遍历过程中删除元素的推荐做法：在遍历的同时，使用Iterator删除底层集合里面的元素 import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class Main { public static void main(String[] args) { List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1);list.add(2);list.add(2);list.add(3);list.add(4); System.out.println(&quot;size of list is &quot;+list.size()); Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext()){ Integer num = iterator.next(); if (num==2) { iterator.remove(); } } System.out.println(list.toString()); // 输出： [1, 3, 4] } } 注意： 对于iterator的remove()方法，也有需要我们注意的地方： 每调用一次iterator.next()方法，只能调用一次remove()方法； 调用remove()方法前，必须调用过一次next()方法； 会报错的删除方式(1) 使用Iterator遍历list时，使用list.remove()方法删除元素 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1);list.add(2);list.add(2);list.add(3);list.add(4); Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext()){ Integer value=iterator.next(); list.remove(value); //报错！！！ } (2) 使用foreach遍历list时，使用list.remove()方法删除元素 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1);list.add(2);list.add(2);list.add(3);list.add(4); for(Integer value : list){ list.remove(value); //报错！！！ } 上面两种情况都会报java.util.ConcurrentModificationException异常：Iterator是快速失败的迭代器，foreach实际上使用的是iterator进行遍历的。 通过索引下标的方式删除：不会报错，但是可能漏删或不能完全删除的方式使用索引下标调用list.remove(index)方法后，list.size()一直在减少，同时后面的元素会往前移动，这样会导致list中的索引index指向的数据发生变化，导致删除的数据不是目标数据。 (1) 漏删 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1);list.add(2);list.add(2);list.add(3);list.add(4); for (int i = 0; i &lt; list.size(); i++) { if (list.get(i)==2) { list.remove(i); } } System.out.println(list.toString()); //输出： [1, 2, 3, 4] 只删除了一个2，另一个没有被删除，原因是：删除了第一个2后，集合里的元素个数减1，后面的元素往前移了1位，此时，第二个2已经移到了索引index=1的位置，而此时i马上i++了，list.get(i)获得的是数据3。 (2) 不能完全删除数据 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1);list.add(2);list.add(2);list.add(3);list.add(4); for (int i = 0; i &lt; list.size(); i++) { list.remove(i); } System.out.println(list.toString()); // 输出： [2, 3] 从结果可以看出，使用索引方式删除并没有把所有数据都删除干净。原因是：在list.remove之后，list的大小发生了变化，也就是list.size()一直在变小，而i却一直在加大，当i=3时，list.size()=2，此时循环的判断条件不满足，退出了程序。 问：HashMap和Hashtable有什么区别？HashMap和Hashtable都实现了Map接口，因此很多特性非常相似，里面存放的元素不保证有序，并且不存在相同元素。但是，他们有以下不同点： (1) HashMap允许键和值是null（但是最多只能有一个键为null，可以有一个或多个键所对应的值都为null。当get()方法返回null值时，既可以表示HashMap中没有该键，又可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键，而应该用containsKey()方法来判断）；而Hashtable不允许键或者值是null。 (2) Hashtable是同步的(使用synchronized)，而HashMap不是，即HashMap是非线程安全的，HashTable是线程安全的。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。因为线程安全的问题，HashMap效率比HashTable的要高。 (3) HashMap提供了可供应用于迭代键的Iterator，因此，HashMap是快速失败的。Hashtable也使用了Iterator，另一方面，由于历史原因，Hashtable还提供了对键的Enumeration，是安全失败的。 (4) 哈希值的使用不同，HashTable直接使用对象的hashCode，而HashMap重新计算hash值。 (5) Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式不同。HashTable中hash数组默认大小是11，增加的方式是old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数 一般现在不建议用HashTable： (1) HashTable是遗留类，内部实现很多没优化和冗余。 (2) 即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。 例1，例2，看两道题的评论 注意： (1) 影响HashMap(或HashTable)性能的因素有两个：初始容量和load factor； 当Hash表中数据记录的大小超过当前容量，Hash表会进行rehash操作，也就是自动扩容，这种操作一般比较耗时。所以当我们能够预估Hash表大小时，尽量在初始化的时候就指定初始容量，避免中途Hash表重新扩容操作。(类似可以指定容量的还有ArrayList、Vector) (2) 在使用选择上，当我们需要保证线程安全时，优先选择HashTable；当我们程序本身就线程安全时，优先选择HashMap。 其实HashTable也只是保证在数据结构层面上的同步，对于整个程序还是需要进行多线程并发控制；在JDK后期版本中，对于HashMap，可以通过Collections获得同步的HashMap： Map m = Collections.synchronizedMap(new HashMap(...)); //这种方式就可以获得具有同步能力的HashMap (3) 在JDK1.5以后，出现了ConcurrentHashMap，它可以很好地解决在并发程序中使用HashMap的问题，ConcurrentHashMap和HashTable功能很像，不允许为null的key或value，但它不是通过给方法加synchronized进行并发控制的。 ConcurrentHashMap中使用分段(Segment)锁技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一段数据的时候，其他段的数据也能被其他线程访问，实现真正的并发访问，效率比HashTable好很多。 拓展：TreeMap和LinkedHashMap HashMap、TreeMap、LinkedHashMap都是Map的一些具体实现类 TreeMap实现了SortedMap接口，它保存的记录是根据键值key排序的，默认是按key升序排列。也可以指定排序的Comparator LinkedHashMap保存了数据的插入顺序，底层是通过一个双向链表的数据结构来维持插入顺序的。key和value都可以为null 问：Java中的HashMap的工作原理是什么？Java中的HashMap是以键值对(key-value)的形式存储元素的。 HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。 HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。 HashMap中解决哈希冲突的方法是链地址法。HashMap的底层结构是一个数组，数组中的每一项是一条链表。 例1 HashMap的遍历方式(1) 推荐方式：foreach 通过map.entrySet()方式获取Entry集合，然后通过foreach方式进行遍历。 public static void main(String[] args) { Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(20); map.put(&quot;key1&quot;, 1); map.put(&quot;key2&quot;, 2); map.put(&quot;key3&quot;, 3); for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) { // 直接遍历出Entry System.out.println(&quot;key--&gt;&quot; + entry.getKey() + &quot;, value--&gt;&quot; + map.get(entry.getKey())); } } (2) 普通方式：iterator public static void main(String[] args) { Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(20); map.put(&quot;key1&quot;, 1); map.put(&quot;key2&quot;, 2); map.put(&quot;key3&quot;, 3); Iterator&lt;String&gt; keySet = map.keySet().iterator(); while(keySet.hasNext()){ Object key = keySet .next(); System.out.println(&quot;key--&gt;&quot; + key + &quot;, value--&gt;&quot; + map.get(key)); } } 问：HashSetHashSet子类依靠hashCode()和equal()方法来区分重复元素 HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值前，会去判断当前Map中是否含有该key对象，内部是先通过key的hashCode，确定有相同的hashCode之后，再通过equals方法判断是否相同。 例1 问：HashSet和TreeSet有什么区别？HashSet的底层是由哈希表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。 TreeSet的底层是由红黑树来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。 问：TreeMap和TreeSet在排序时如何比较元素？TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。 TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。 import java.util.Set; import java.util.TreeSet; public class Main { public static void main(String[] args) { Set&lt;Student&gt; set = new TreeSet&lt;Student&gt;(); set.add(new Student(&quot;Hao LUO&quot;, 33)); set.add(new Student(&quot;XJ WANG&quot;, 32)); set.add(new Student(&quot;Bruce LEE&quot;, 60)); set.add(new Student(&quot;Bob YANG&quot;, 22)); for (Student stu : set) { System.out.println(stu); } } } class Student implements Comparable&lt;Student&gt; { private String name; private int age; public Student(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; } public int compareTo(Student o) { return this.age - o.age; } } 输出： Student [name=Bob YANG, age=22] Student [name=XJ WANG, age=32] Student [name=Hao LUO, age=33] Student [name=Bruce LEE, age=60] 问：HashMap、Hashtable、HashSet和ConcurrentHashMap的比较 ConcurrentHashMap使用segment来分段和管理锁，而不是用synchronized 推荐阅读 问：Set中的元素不可重复Set中的元素是不允许重复的。因此Set再插入或删除元素时，需要对两个元素进行比较。比较时，Set会先调用hashCode方法，判断两个元素是否有相同的hashCode，如果不相同，证明不相等；如果hashcode相同，再调用equals方法，如果equals方法判断返回true，则两个元素是相同的，否则两个元素不相同。 判断Set中是否包含某一个元素是通过contains来判断的。 问：hashCode()和equals()方法在HashMap的重要性体现在什么地方？推荐阅读：浅谈Java中的hashcode方法 Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。 (1) 没有重写hashCode()时会出什么问题hashCode()方法的返回值一般是对象的存储地址或与对象存储地址相关联的hash散列值。 class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public boolean equals(Object obj) { return this.name.equals(((Person) obj).name) &amp;&amp; this.age == ((Person) obj).age; } } Person类重写了equals()方法，但是没有重写hashCode()方法，如果我们按平常的方式调用equals()方法来判断元素是否相等并不会出什么问题，如： public static void main(String[] args) { Person p1 = new Person(&quot;p&quot;, 18); Person p2 = new Person(&quot;p&quot;, 18); System.out.println(p1.equals(p2));//输出：true } 但是当我们使用HashMap来保存Person对象的时候就会出问题了，如下： public static void main(String[] args) { HashMap&lt;Person, Integer&gt; hashMap = new HashMap&lt;Person, Integer&gt;(); Person p1 = new Person(&quot;p1&quot;, 18); hashMap.put(p1, 1); System.out.println(hashMap.get(new Person(&quot;p1&quot;, 18)));//输出：null } 这是因为，我们没有重写Person的hashCode()方法，此时的Person对象调用的hashCode()方法还是父类的默认实现，即返回的是和对象内存地址相关的int值，这个时候，p1对象和new Person(“p1”,18);对象因为内存地址不一致，所以其hashCode()返回值也是不同的。故HashMap会认为这是两个不同的key，故返回null。 所以，我们想要正确的结果，只需要重写hashCode()方法，让equals()方法和hashCode()方法始终在逻辑上保持一致性。 (2) hashCode()方法设计原则设计hashCode()时需要注意的问题：无论何时，对同一个对象调用hashCode()都应该产生同样的值。如果用put()将一个对象添加进HashMap时产生一个hashCode值，而用get()取出时却产生了另一个hashCode值，那么就无法获取该对象了。所以如果你的hashCode()方法依赖于对象中易变的数据，那么就需要当心了，因为此数据发生变化时，hashCode()方法就会生成一个不同的hashCode值。 import java.util.HashMap; public class Main { public static void main(String[] args) { Person p1 = new Person(&quot;p1&quot;, 18); System.out.println(&quot;before update: &quot;+p1.hashCode()); HashMap&lt;Person, Integer&gt; hashMap = new HashMap&lt;Person, Integer&gt;(); hashMap.put(p1, 1); p1.setAge(13);// 改变依赖的一个值 System.out.println(&quot;after update: &quot;+p1.hashCode()); System.out.println(hashMap.get(p1)); // 此时还是返回为null,这是因为我们p1的hashCode值已经改变了 } } class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public int hashCode() { return name.hashCode() * 37 + age; // hashCode的返回值依赖于对象中的易变数据 } @Override public boolean equals(Object obj) { return this.name.equals(((Person) obj).name) &amp;&amp; this.age == ((Person) obj).age; } } (3) hashCode()和equals()应该满足的关系在HashMap中判断两个对象是否相同取决于equals()方法，而两个对象的hashCode值是否相等是两个对象是否相同的必要条件。所以有以下结论： (1) 如果两个对象的hashCode值不等，那么这两个对象一定不是同一个对象，即他们的equals()方法一定要返回false； (2) 如果两个对象的hashCode值相等，这两个对象也不一定是同一个对象，即他们的equals()方法返回值不确定； 反过来， (1) 如果equals()方法返回true，两个对象是同一个对象，它们的hashCode值一定相等； (2) 如果equals()方法返回false，hashCode值也不一定不相等，即是不确定的； 例1：两个对象值相同(x.equals(y)==true)，但却可以有不同的hashcode，这句话对不对? 对。 如果对象保存在HashSet或HashMap中，它们equals()相等，那么它们的hashcode值就必须相等。 如果对象不是保存在HashSet或HashMap，则equals()与hashcode就没有什么关系了，这时候hashcode不相等也是可以的。例如ArrayList中存储的对象就不用实现hashcode()方法，当然，我们没有理由不实现，通常都会去实现的。 问：Comparable和Comparator接口是干什么的？列出它们的区别。Java提供了只包含一个compareTo()方法的Comparable接口。 这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。 Java提供了包含compare()和equals()两个方法的Comparator接口。 compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。 equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。 (1) Comparable和Comparator都是用来实现集合中元素的比较、排序的，只是Comparable是在集合内部定义方法实现排序，Comparator是在集合外部定义方法实现排序，所以，如果想要实现对集合中元素的排序，就需要在集合外定义实现Comparator接口的方法或在集合内实现Comparable接口的方法compareTo()。Comparator位于包java.util下，而Comparable位于包java.lang下。 (2) Comparable是一个对象本身就已经支持自比较所需要实现的接口（如 String、Integer自己就可以完成比较大小操作，已经实现了Comparable接口），自定义的类要在加入list容器中后能够排序，可以实现Comparable接口，在用Collections类的sort方法排序时，如果不指定Comparator，那么就以自然顺序排序，这里的自然顺序就是实现Comparable接口设定的排序方式。 (3) Comparator是一个专用的比较器，当这个对象不支持自比较或者自比较函数不能满足你的要求时，你可以写一个比较器来完成两个对象之间大小的比较。 例1：Collections工具类中的sort()方法如何比较元素？ Collections工具类的sort方法有两种重载的形式： (1) 第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较； (2) 第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java中对函数式编程的支持）。 import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List; public class Main { public static void main(String[] args) { List&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student(&quot;Hao LUO&quot;, 33)); list.add(new Student(&quot;XJ WANG&quot;, 32)); list.add(new Student(&quot;Bruce LEE&quot;, 60)); list.add(new Student(&quot;Bob YANG&quot;, 22)); Collections.sort(list, new Comparator&lt;Student&gt; () { public int compare(Student o1, Student o2) { return o1.getName().compareTo(o2.getName()); } }); for(Student stu : list) { System.out.println(stu); } } } class Student { private String name; private int age; public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } @Override public String toString() { return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; } } 输出： Student [name=Bob YANG, age=22] Student [name=Bruce LEE, age=60] Student [name=Hao LUO, age=33] Student [name=XJ WANG, age=32] 问：Collection和CollectionsCollection是java.util下的接口，它是各种集合类的父接口，继承于它的接口有set及list Collections是java.util下的类，是针对集合类的一个帮助类，它提供了一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。 问：Java集合类框架的最佳实践有哪些？根据应用的需要正确选择要使用的集合的类型对性能非常重要 (1) 假如元素的大小是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。 (2) 有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。 (3) 为了类型安全、可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。 (4) 使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。 (5) 编程的时候接口优先于实现。 (6) 底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。 问：为什么集合类没有实现Cloneable和Serializable接口？克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的，因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。 问：泛型来源：Java笔试面试题整理第八波 泛型在集合中使用广泛，在JDK1.5之后集合框架就全部加入了泛型支持。泛型在编译时期进行严格的类型检查，消除了绝大多数的类型转换。在没有使用泛型之前，我们可以往List集合中添加任何类型的元素数据，因为此时List集合默认的元素类型为Object，而在我们使用的时候需要进行强制类型转换，这个时候如果我们往List中加入了不同类型的元素，很容易导致类型转换异常。 例如： public static void main(String[] args) { List list = new ArrayList(); list.add(18); list.add(&quot;str&quot;); for(Object obj : list){ int i = (int) obj;//此处运行后，将会报错 } } 上面代码在编译时不会出错，但在将”str”转换成int类型时，会报ClassCastException (运行时异常，也即非检查性异常)。 泛型允许我们在创建集合时就可以指定元素类型，当加入其他数据类型时，编译不能通过。在我们使用泛型之后，可以避免不必要的转型，以及避免可能出现的ClassCastException。例如： public static void main(String[] args) { List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(18); list.add(&quot;str&quot;); //此时，编译就不能通过，报错！！！ } 类型擦除 泛型只作用于编译阶段，在编译阶段严格检查类型是否匹配，类型检查通过后，JVM会将泛型的相关信息擦出掉(即泛型擦除)，也就是说，成功编译过后的class文件中是不包含任何泛型信息的，泛型信息不会进入到运行时阶段。 class Person&lt;T&gt; { private T character;// 人物特征 public Person(T character) { this.character = character; } public T getCharacter() { return character; } public void setCharacter(T character) { this.character = character; } } public static void main(String[] args) { Person&lt;String&gt; p1 = new Person&lt;String&gt;(&quot;nice&quot;); Person&lt;Integer&gt; p2 = new Person&lt;Integer&gt;(18); System.out.println(&quot;p1---&gt;&quot; + p1.getClass()); System.out.println(&quot;p2---&gt;&quot; + p2.getClass()); } // 输出： p1---&gt;class Person p2---&gt;class Person 虽然我们传入了两种数据类型，但是在编译时并没有生成这两种类型，而都是Person类型，这正是因为我们上面所说的，泛型在编译通过后，确保了类型正确，此后就擦除了相关泛型信息，把所有元素都作为Person数据类型。也就是说，泛型类型在逻辑上我们可以看成是多个不同的数据类型，但是在本质上它只是同一种数据类型。 类型通配符 泛型在编译成功后，泛型信息就会被擦除，变成了同一种类型。那么该如何区分原本具有父子关系的泛型类型呢？ 例如： public static void main(String[] args) { Person&lt;Number&gt; p1 = new Person&lt;Number&gt;(12); Person&lt;Integer&gt; p2 = new Person&lt;Integer&gt;(18); getCharacter(p1); getCharacter(p2);// 报错！！！编译不能通过，提示参数类型不符合 } public static void getCharacter(Person&lt;Number&gt; person) { System.out.println(person.getCharacter()); } Integer是继承自Number的，按照我们的想法，根据Java的多态特性，我们调用getCharacter(p2)应该是没有问题的，但是因为泛型擦除的特点，泛型在编译通过后被擦除了泛型类型，在运行时，JVM根本不知道有Number和Integer这两个类型存在，内存中只会有Person对象存在。这也正是上面不能编译通过的原因。 为了解决这个问题，也就是在使用泛型的时候为了能够体现出父子关系(或者说兼容多态特性)，提出了类型通配符的概念。类型通配符用?来代替参数类型，代表任何类型的父类。例如Person&lt;?&gt;就是Person和Person的父类，而Person和Person是体现不出父类关系的，现在就可以继续使用多态特性了。 public static void main(String[] args) { Person&lt;Number&gt; p1 = new Person&lt;Number&gt;(12); Person&lt;Integer&gt; p2 = new Person&lt;Integer&gt;(18); getCharacter(p1); getCharacter(p2); } //将参数类型改成通配符之后，我们调用getCharacter(p2)就不会出错了 public static void getCharacter(Person&lt;?&gt; person) { System.out.println(person.getCharacter()); } 类型通配符上界 在上面的例子中，我们的本意是getCharacter方法中只能传入数字类型的参数，也就是说希望传入的类型参数是Number类型或它的子类，类型通配符上界提供了这种约束。 定义：Person&lt;? extends Number&gt;，表示我们的参数类型最大是Number类型或者它的子类。 public static void main(String[] args) { Person&lt;Number&gt; p1 = new Person&lt;Number&gt;(12); Person&lt;Integer&gt; p2 = new Person&lt;Integer&gt;(18); Person&lt;String&gt; p3 = new Person&lt;String&gt;(&quot;nice&quot;); getCharacter(p1); getCharacter(p2); getCharacter(p3); //报错！！！编译不通过，提示参数类型不符合 } public static void getCharacter(Person&lt;? extends Number&gt; person) { System.out.println(person.getCharacter()); } 因为String不是Number的子类，因此上面也就不能编译通过了。 类型通配符下界 定义：Person&lt;? super Number&gt;，表示我们的参数类型最小是Number类型，或者是它的超类类型。 例1：重要的题目 class A {} class B extends A {} class C extends A {} class D extends B {} Which four statements are true? (A) The type List&lt;A&gt; is assignable to List. (B) The type List&lt;B&gt; is assignable to List&lt;A&gt;. (C) The type List&lt;Object&gt; is assignable to List&lt;?&gt;. (D) The type List&lt;D&gt; is assignable to List&lt;?extends B&gt;. (E) The type List&lt;?extends A&gt; is assignable to List&lt;A&gt;. (F) The type List&lt;Object&gt; is assignable to any List reference. (G) The type List&lt;?extends B&gt; is assignable to List&lt;?extends A&gt;. 正确答案：ACDG A正确: 任何使用了泛型的数据类型，都可以赋值给没有使用泛型的数据类型，此时数据类型相当于是Object。例如下面代码可以通过。 public static void main(String[] args) { Person&lt;Number&gt; p1 = new Person&lt;Number&gt;(12); Person&lt;Integer&gt; p2 = new Person&lt;Integer&gt;(18); Person&lt;String&gt; p3 = new Person&lt;String&gt;(&quot;nice&quot;); getCharacter(p1); getCharacter(p2); getCharacter(p3); } public static void getCharacter(Person person) { System.out.println(person.getCharacter()); } BE错误，CDG正确：由于使用泛型之后，父子关系必须要使用通配符来解决。 F错误：和B一样的错误，虽然Object是任何类型的父类(需要跟A区别开来，A是用没用泛型的比较，这里是都用了泛型之后的比较)，但是使用了泛型后，父子关系要有通配符来体现，例如List&lt;String&gt;不能转化为List&lt;Object&gt;。 问：JDK7中泛型JDK1.7以后，泛型实例的创建可以通过类型推断来简化 可以去掉new后面部分的泛型类型，只需要用&lt;&gt;就可以了。 例如： 一般情况下，泛型按如下方式使用： List&lt;String&gt; strList = new ArrayList&lt;String&gt;(); 在JDK7及以后，可以简化成如下： List&lt;String&gt; strList = new ArrayList&lt;&gt;();","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"06-常用类","slug":"06-常用类","date":"2017-02-18T10:19:20.000Z","updated":"2017-10-21T13:19:21.179Z","comments":true,"path":"2017/02/18/06-常用类/","link":"","permalink":"https://hepsilion.github.io/2017/02/18/06-常用类/","excerpt":"常用类","text":"常用类 问：String、StringBuffer和StringBuilder(1) String：不可变的字符序列 String类不是基本数据类型，是引用数据类型 String是被final修饰的类，因此一旦一个String对象被创建并初始化后，包含在这个对象里的字符序列是不可改变的，直到这个对象被销毁，即本身的内容不可改变、长度不可改变； String类不可以被继承； String变量作为参数时相当于基本数据类型的值传递 对String对象的任何改变都不影响到原对象，每次操作都会生成新的String对象，然后将引用指向新的String对象，因此不推荐频繁改变String内容，会增加内存压力。为了提高效率节省空间，我们应该用StringBuffer类 当多个String对象用+运算符联合时，其本质是先创建StringBuilder对象再进行append操作，然后将拼接后的StringBuilder对象用toString()方法转换成String对象，速度较慢。 例如：String a = “abc”; String b = “def”; String c = a + b; 这种情况下是使用concatenation操作符(+)，内部是新创建StringBuffer或StringBuilder对象，利用其append方法进行字符串追加，然后利用toString方法返回String串。所以此时的效率也不高。 例1：定义String的两种方式 方式1：双引号引起的数据都是字符串对象，存放在常量池中。str指向的内存中只有一个对象，在常量池中。 String str=&quot;abc&quot;; //这种方式创建的String对象&quot;abc&quot;是存放在字符串常量池中的 //创建过程是：首先在字符串常量池中查找有没有&quot;abc&quot;对象，如果有则直接将str指向它；如果没有，就在字符串常量池中创建出&quot;abc&quot;，然后将str指向它。 //通过这种方式创建的字符串在字符串常量池中是可共享的，同时也是不可更改的。 方式2：str指向的内存中有两个对象，分别在常量池中和堆内存中。 String str=new String(&quot;abc&quot;); //这种方式在内存中生成两个对象，&quot;abc&quot;存放在常量池中，new String()存放在堆内存中。 //创建过程是：这种方式首先在常量池中创建&quot;abc&quot;，然后在堆内存中new出一个String对象，将str指向该堆内存地址，新new出的String对象的内容是在字符串常量池中找到的&quot;abc&quot;对象。 //通过这种方式创建对象，实际上创建了两个对象。 例2：Java中的字符串都是常量，存放在方法区中的常量池中，可以实现共享。 String s1=&quot;abc&quot;; String s2=new String(&quot;abc&quot;); String s3=&quot;abc&quot;; /*&quot;abc&quot;是字符串常量，被存在堆区的常量池中，当定义String s3=&quot;abc&quot;时，不会马上创建字符串&quot;abc&quot;对象，而是会先查找常量池中是否存在相同常量，如果有，则s3指向同一内存空间，否则创建新的字符串对象。*/ System.out.println(s1==s2); //false System.out.println(s1==s3); //true //String类重写了Object类的equals()方法，使其由比较引用变为了比较引用所指向的字符串内容是否一样。 System.out.println(s1.equals(s2)); //true 例3：Java中的字符串都是常量，字符串一旦被初始化，就不可以被改变。 String str1 = &quot;abc&quot;; String str2 = str1 + &quot;def&quot;; System.out.println(str1==str2); //false //此时，字符串常量池中存在了两个对象&quot;abc&quot;和&quot;abcdef&quot;。 例4：String s=”a”+”b”+”c”+”d”;这条语句一共创建了多少个对象？ String s1 = &quot;a&quot;; String s2 = s1 + &quot;b&quot;; String s3 = &quot;a&quot; + &quot;b&quot;; System.out.println(s2 == &quot;ab&quot;); System.out.println(s3 == &quot;ab&quot;); 第一条语句打印的结果为false，第二条语句打印的结果为true 这说明Java可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。 因此String s=&quot;a&quot;+&quot;b&quot;+&quot;c&quot;+&quot;d&quot;;只创建了一个String对象 例5，例6，例7，例8：编译器优化 (2) StringBuffer：线程安全的可变字符序列 对StringBuffer对象进行操作都是对其本身的字符序列进行操作，而不是生成新的对象。因此StringBuffer对象内容可变、长度可变，可以将多个字符串值直接联合，效率高 String覆盖了equals方法和hashCode方法，而StringBuffer没有覆盖equals方法和hashCode方法，所以，将StringBuffer对象存储进Java集合类中时会出现问题。 例1 定义有StringBuffer s1=new StringBuffer(10);s1.append(&quot;1234&quot;)则s1.length()和s1.capacity()分别是：4和10 (3) StringBuilder：非线程安全的可变字符序列 注意：StringBuffer和StringBuilder在功能上基本完全相同，它们都继承自AbstractStringBuilder，而AbstractStringBuilder是使用非final修饰的字符数组实现的，如：char[] value; 所以可以对StringBuffer和StringBuilder对象进行改变，每次改变都是在原来的对象上发生的，不会重新new出新的StringBuffer或StringBuilder对象。所以，当我们需要频繁修改字符串内容的时候，使用StringBuffer和StringBuilder是很好地选择。两者的核心操作都是append和insert，append是直接在字符串的末尾追加，而insert(int index,String str)是在指定位置出插入字符串。 StringBuffer和StringBuilder的最主要区别就是线程安全方面，由于在StringBuffer内大部分方法都添加了synchronized同步，所以StringBuffer是线程安全的，而StringBuilder不是线程安全的。因此，当我们处于多线程的环境下时，我们需要使用StringBuffer，如果我们的程序是线程安全的使用StringBuilder在性能上就会更优一点。 问：数组有没有length()方法? String有没有length()方法？数组没有length()方法，但有length属性；String有length()方法。 问：String的几个方法例1：易错的题目：replaceAll()方法 public static void main (String[] args) { String classFile = &quot;com.jd.&quot;. replaceAll(&quot;.&quot;, &quot;/&quot;) + &quot;MyClass.class&quot;; System.out.println(classFile); } 输出为：/////////MyClass.class replaceAll方法的第一个参数是一个正则表达式，而&quot;.&quot;在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成&quot;/&quot;。 如果想替换的只是&quot;.&quot;的话，正则表达式那里就要写成&quot;\\\\.&quot;或者是&quot;[.]&quot;。前者将&quot;.&quot;转义为&quot;.&quot;这个具体字符，后者则匹配&quot;[]&quot;中的任意字符。 例2：易错的题目：split()方法 当直接以”.”为参数时，结果错误： public static void main(String[] args) { String str = &quot;12.03&quot;; String[] res = str.split(&quot;.&quot;); for(int i=0; i&lt;res.length; i++){ System.out.println(res[i]); } } 输出为空 String的split(String regex)是根据给定的正则表达式来拆分字符串的 &quot;.&quot;是正则表达式中的关键字，没有经过转义split会把它当作一个正则表达式来处理的，需要写成str.split(&quot;\\\\.&quot;)进行转义处理。 例3：字符串分割，如何把一段逗号分割的字符串转换成一个数组？ 方法一：使用正则表达式 String str=&quot;abc,edg,efd,adfa&quot;; String [] result = str.split(&quot;,&quot;); 方法二：使用StingTokenizer String str=&quot;abc,edg,efd,adfa&quot;; StringTokenizer tokener = new StringTokenizer(str, &quot;,&quot;); int length=tokener.countTokens(); String [] result =new String[length]; for(int i=0; i&lt;length; i++){ result[i]=tokener.nextToken(); } 例3：如何实现字符串的反转？ 示例：递归实现字符串反转 public String reverse(String originStr) { if (originStr == null || originStr.length() &lt;= 1) return originStr; return reverse(originStr.substring(1)) + originStr.charAt(0); } 问：String的编码转换编码转换，实现将GB2312编码的字符串转换为ISO-8859-1编码的字符串： String str=&quot;中&quot; String a=new String(str.getBytes(&quot;gb2312&quot;), &quot;iso-8859-1&quot;); 编码转换，实现将GBK编码字节流转换为UTF-8编码字节流： byte[] src, dst; dst=new String (src, &quot;GBK&quot;).getbytes(&quot;UTF-8&quot;); 问：Math类(1) Math.floor(a) 求小于或等于a的最大整数，返回double类型。 Math.floor(11.6)=11.0; Math.floor(-11.3)=-12.0; // 如果参数值总是等于某个整数，那么结果与该参数相同 Math.floor(1)=1.0 // 如果参数是NaN、无穷、正0、负0，那么结果与参数相同 Math.floor(Double.NaN)=Double.NaN Math.floor(Double.POSITIVE_INFINITY)=Double.POSITIVE_INFINITY Math.floor(Double.NEGATIVE_INFINITY)=Double.NEGATIVE_INFINITY Math.floor(0.0)=0.0 Math.floor(-0.0)=-0.0 (2) Math.ceil(a) 求大于或等于a的最小整数，返回double类型。 Math.ceil(11.3)=12.0 Math.ceil(-11.3)=-11.0; // 如果参数值总是等于某个整数，那么结果与该参数相同 Math.ceil(1)=1.0 // 如果参数是NaN、无穷、正0、负0，那么结果与参数相同 Math.ceil(Double.NaN)=Double.NaN Math.ceil(Double.POSITIVE_INFINITY)=Double.POSITIVE_INFINITY Math.ceil(Double.NEGATIVE_INFINITY)=Double.NEGATIVE_INFINITY Math.ceil(0.0)=0.0 Math.ceil(-0.0)=-0.0 //如果参数小于0但大于-1.0，那么结果为-0.0(重要) Math.ceil(-0.5)=-0.0 (3) Math.round(a)=(long)floor(a+0.5d)；将原来的数字加上0.5后再向下取整，返回long类型，注意向下取整是指小于或等于它的最大整数。 Math.round(6.4)=(long)floor(6.4+0.5d)=(long)floor(6.9)=6 Math.round(6.9)=(long)floor(6.9+0.5d)=(long)floor(7.4)=7 Math.round(6.5)=(long)floor(6.5+0.5d)=(long)floor(7.0)=7 Math.round(-6.4)=(long)floor(-6.4+0.5d)=(long)floor(-5.9)=-6 Math.round(-6.9)=(long)floor(-6.9+0.5d)=(long)floor(-6.4)=-7 Math.round(-6.5)=(long)floor(-6.5+0.5d)=(long)floor(-6.0)=-6 // 了解 Math.round(NaN)=0 Math.round(Math.round(Double.NEGATIVE_INFINITY或&lt;=Long.MIN_VALUE))=Long.MIN_VALUE Math.round(Math.round(Double.POSITIVE_INFINITY或&gt;=Long.MAX_VALUE))=Long.MAX_VALUE 问：枚举类型Java中定义枚举类型要使用enum关键字，所有的枚举值对象都默认为static (1) 枚举值对象可以用中文字符，枚举值组成可以由字母、下划线组成，但不能单独使用数字。 例1：带中文枚举值对象的枚举类型 public class Main { public static void main(String[] args) { System.out.println(Genders.男); System.out.println(Genders.女); System.out.println(Genders.MAN); System.out.println(Genders.WOWAM); } } enum Genders { 男, 女, MAN, WOWAM } 输出： 男 WOWAM (2) 带有构造方法的枚举类型 枚举类型的构造方法访问控制符只能为private(且默认为private)； 在初始化时会对所有的枚举值对象调用一次构造函数进行初始化； 含带参构造方法的枚举类型中的枚举值对象必须初始化； 枚举类型中含有其他属性或方法时，枚举值对象必须定义在最前面，且需要在最后一个枚举值对象后面加分号”;” (3) 枚举类型都继承了Enum类，因为枚举类型都不能再继承其他类了，但是可以实现其他接口 public class Main { public static void main(String[] args) { System.out.println(&quot;吉普信息：&quot;+Cars.JEEP.getName() + &quot;\\t&quot; +Cars.JEEP.getPrice()); Car mini=Cars.MINI; mini.setCarName(&quot;mini2&quot;); System.out.println(&quot;Mini新名字\\t&quot;+Cars.MINI.getName()); for(Cars car : Cars.values()){ System.out.println(car.getName() + &quot;\\t&quot; + car.getPrice()); } } } interface Car{ public void setCarName(String name); } enum Cars implements Car { BMW(&quot;宝马&quot;, 1000000), JEEP(&quot;吉普&quot;, 800000), MINI(&quot;mini&quot;, 200000); private String name; /** * 从这里可以看出虽然枚举值不能直接由数字组成，但是我们可以给该枚举类添加一个int类型的值，通过构造方法给其赋值，相当于间接的可以使用数值 */ private int price; private Cars(String name, int price) { this.name = name; this.price = price; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getPrice() { return price; } public void setPrice(int price) { this.price = price; } @Override public void setCarName(String name) { this.name = name; } } 输出如下： 吉普信息：吉普 800000 宝马 1000000 吉普 800000 mini 200000 Mini新名字 mini2 例1： enum AccountType{ SAVING, FIXED, CURRENT; private AccountType(){ System.out.println(&quot;It is a account type&quot;); } } class EnumOne{ public static void main(String[]args){ System.out.println(AccountType.FIXED); } } 程序输出如下： It is a account type It is a account type It is a account type FIXED 问：基本数据类型的包装类Java语言是一个面向对象的语言，但Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，即包装类。 Java为每个基本数据类型提供了包装类型： 基本数据类型: byte，short，int，long，float，double，char，boolean 包装数据类型：Byte，Short，Integer，Long，Float，Double，Character，Boolean 例1： class Two{ Byte x; } class PassO{ public static void main(String[] args){ PassO p=new PassO(); p.start(); } void start(){ Two t=new Two(); System.out.print(t.x+””); Two t2=fix(t); System.out.print(t.x+” ” +t2.x); } Two fix(Two tt){ tt.x=42; return tt; } } 上面代码的输出为：null 42 42 基本数据类型的包装类型，属于引用类型。如果包装类成员变量没有显示初始化，那么Java默认初始化为null。 例2:下面哪些类可以被继承? A、Thread B、Number C、Double D、Math E、ClassLoader 正确答案：ABE (1) 我们可以通过继承Thread类来创建线程； (2) Byte、Short、Integer、Long、Float、Double这几个数字类型都继承自Number； (3) Byte、Short、Integer、Long、Float、Double、Boolean、Character这几个基本数据类型的包装类，以及String、Math等都被定义为public final class，因此这几个都不能被继承； (4) 我们可以自定义类加载器来实现加载功能，因此ClassLoader是可以被继承的。 问：装箱与拆箱从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。自动装箱是Java编译器在基本数据类型和对应的包装类型之间做的一个转化，例如把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。 装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf()。 public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } /** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size&gt;} option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */ private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; } private IntegerCache() {} } 如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象。 问：装箱与拆箱中的==和equals()下面的规则基本意思是对的，但语言尚不严格正确 (1) 基本数据类型变量和基本数据类型包装类对象进行”==”运算符的比较，基本数据类型封装类对象将会自动拆箱变为基本数据类型后再进行比较。例如Integer(0)和0比较时，Integer(0)会自动拆箱为int类型再进行比较。 (2) 两个Integer类型变量进行”==”比较，如果这两个对象的值在-128至127且值相等，那么返回true，否则返回false，这跟Integer.valueOf()方法的缓冲对象有关。请看这篇文章 (3) (4) 两个基本数据类型封装类变量进行equals()比较，equals()会首先比较对象的类型，如果类型相同，继续比较值，如果值也相同，返回true，否则返回false。 (5) 基本数据类型封装类对象调用equals()，但是参数是基本数据类型变量，这时候，基本数据类型变量会先进行自动装箱转换为其封装类型对象，再进行4中的比较。 例1： int a=257; Integer b1=257; //Integer b1=257会先调用Integer.valueOf()方法将257转化为new Integer(257)对象 Integer b2=57; //Integer b2=57会先调用Integer.valueOf()方法返回缓存中的57 Integer b3=257; Integer b4=57; Integer c=new Integer(257); Integer d=new Integer(257); Integer e1=Integer.valueOf(257); //Integer.valueOf()方法将257转化为new Integer(257)对象 Integer e2=Integer.valueOf(57); //Integer.valueOf()方法返回缓存中的57 // int和Integer(无论new否)比，都为true System.out.println(a==b1); // true，规则(1) System.out.println(a==c); // true，规则(1) // 两个都是非new出来的Integer，如果数在-128到127之间，则是true，否则为false System.out.println(b1==b3); // false，规则(2) System.out.println(b2==b4); // true，规则(2) System.out.println(b1==e1); // false，规则(3) System.out.println(b2==e2); // true，规则(3) // Integer与new Integer比较，结果为false；两个都是new出来的,都为false System.out.println(b1==c); // false，规则(3) System.out.println(c==d); // false，规则(3) //System.out.println(a.equals(b1)); 编译出错，基本型不能调用equals() System.out.println(b1.equals(b3)); // true，规则(4) System.out.println(c.equals(d)); // true，规则(4) System.out.println(b1.equals(257.0)); // false，规则(5)，257.0先封装成Double对象再进行比较 例2： public static void main(String[] args){ Boolean flag=false;//先调用Boolean.valueOf(boolean b)返回false对应的Boolean对象Boolean.FALSE，然后赋值给flag，flag值为Boolean.FALSE /* 先赋值，遇到if条件表达式自动拆箱 * 1. 先调用Boolean.valueOf(boolean b)返回true对应的Boolean对象Boolean.TRUE，然后赋值给flag，flag值为Boolean.TRUE * 2. 调用booleanValue()返回flag值对应的基础数据类型值true * 3. 结果输出true */ if (flag=true){ System.out.println(&quot;true&quot;); }else{ System.out.println(&quot;false&quot;); } } 例3，例4，例5，例6：重要的题目 问：如何将数值型字符串转换为对应类型的数字？例1： Integer.parseInt(&quot;1234&quot;); Double.parseDouble(&quot;123.2&quot;); 问：File类例1：编程列出一个目录下所有的文件 (1) 如果只要求列出当前文件夹下的文件，代码如下所示 public static void main(String[] args) { File file = new File(&quot;C:/Users/Hepsilion/Desktop&quot;); for(File f : file.listFiles()) { if(f.isFile()) { System.out.println(f.getName()); } } } (2) 如果需要对文件夹继续展开，代码如下所示 public static void main(String[] args) { showDirectory(new File(&quot;C:/Users/Hepsilion/Desktop&quot;), 0); } private static void showDirectory(File file, int level) { if (file.isDirectory()) { for (File f : file.listFiles()) { showDirectory(f, level + 1); } } else { for (int i = 0; i &lt; level - 1; i++) { System.out.print(&quot;\\t&quot;); } System.out.println(file.getName()); } } 在Java 7中可以使用NIO.2的API来做同样的事情 import java.io.IOException; import java.nio.file.FileVisitResult; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.nio.file.SimpleFileVisitor; import java.nio.file.attribute.BasicFileAttributes; public class Main { public static void main(String[] args) throws IOException { Path initPath = Paths.get(&quot;C:/Users/Hepsilion/Desktop&quot;); Files.walkFileTree(initPath, new SimpleFileVisitor&lt;Path&gt;() { @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { System.out.println(file.getFileName().toString()); return FileVisitResult.CONTINUE; } }); } } 问：日期类例1： 使用Java编程，打印昨天的当前时刻 public class YesterdayCurrent{ public static void main(String[] args){ Calendar cal = Calendar.getInstance(); cal.add(Calendar.DAY_OF_MONTH, -1);//从当前日期减去一天 System.out.println(cal.getTime()); } } 例2： 如何获取当前时间对应的年月日时分秒? public class CurrentTime{ public static void main(String[] args){ Calendar c=Calendar.getInstance(); System.out.print(c.get(Calendar.YEAR)+&quot;年&quot;+(c.get(Calendar.MONTH)+1)+&quot;月&quot;+c.get(Calendar.DAY_OF_MONTH)+&quot;日, &quot;; System.out.println(c.get(Calendar.HOUR_OF_DAY)+&quot;:&quot;+c.get(Calendar.MINUTE)+&quot;:&quot;+c.get(Calendar.SECOND)); } } 或 public class CurrentTime{ public static void main(String[] args){ Date date=new Date(); System.out.println(date); } } 例3： 如何取得从1970年到现在的毫秒数 public static void main(String[] args){ System.out.println(System.currentTimeMillis()); } 例4： 如何格式化日期？SimpleDateFormat public static void main(String[] args){ SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); Date date=new Date(); String dateStr=sdf.format(date);//把日期按指定格式转化为字符串 System.out.println(dateStr); } 例5： Java 8中的Date API Java 8中在java.time包下包含了一组全新的时间日期API，新的日期API和开源的Joda-Time库差不多，但又不完全一样，这组新API里最重要的一些部分是Clock时钟，Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代System.currentTimeMillis()来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。 public static void main(String[] args) { Clock clock = Clock.systemDefaultZone(); long millis = clock.millis(); Instant instant = clock.instant(); Date date = Date.from(instant); System.out.println(millis); System.out.println(instant); System.out.println(date); } //输出： 1504834478293 2017-09-08T01:34:38.293Z Fri Sep 08 09:34:38 CST 2017","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"05-数组","slug":"05-数组","date":"2017-02-17T10:18:25.000Z","updated":"2017-10-21T13:19:21.164Z","comments":true,"path":"2017/02/17/05-数组/","link":"","permalink":"https://hepsilion.github.io/2017/02/17/05-数组/","excerpt":"数组","text":"数组","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"04-异常处理","slug":"04-异常处理","date":"2017-02-16T10:15:57.000Z","updated":"2017-10-21T13:19:21.101Z","comments":true,"path":"2017/02/16/04-异常处理/","link":"","permalink":"https://hepsilion.github.io/2017/02/16/04-异常处理/","excerpt":"异常处理","text":"异常处理 问：Java中的两种异常类型是什么？他们有什么区别？Throwable包含了错误(Error)和异常(Excetion)两类。 图 1 (1) Error：由Java虚拟机生成并抛出，属于JVM底层或者运行时环境的错误，程序无法预测和捕获处理，如OutOfMemoryError，如果出现Error，Java虚拟机会终止执行。 例1：选择题 If a process reports a stack overflow run-time error, what’s the most possible cause? a. lack of memory; b. write on an invalid memory space; c. recursive function calling; d. array index out of boundary 答案：c 如果写了不能迅速收敛的递归，则很有可能引发栈溢出的错误，如下所示 public class Main { public static void main(String[] args) { main(null); } } (2) Exception: 用户程序可以捕获的异常情况，Java中有两种异常，分别为运行时异常(RuntimeException, 又叫非检查异常)和非运行时异常(又叫检查异常)。 运行时异常 (不处理，编译可以通过，如果有异常则直接抛到控制台)：RuntimeException类及其子类，如ArithmeticException、NullPointerException、IndexOutOfBoundsException、ClassCastException、BufferOverflowException、ConcurrentModificationException、IllegalArgumentException、NoSuchElementException、UnsupportedOperationException等，这类异常是在程序运行的时候可能会发生的，Java编译器不去检查它，也就是说，当程序中可能出现这类异常时，即使没有用try…catch语句捕获它，也没有用throws子句声明抛出它，还是会编译通过。所以程序可以捕捉，也可以不捕捉。这些异常一般是由程序的逻辑错误引起的，其产生频繁，处理麻烦，若显示申明或者捕获将会对程序的可读性和运行效率影响很大，建议不要用try…catch…捕获处理，程序应该在开发调试的过程中从逻辑角度去尽量避免，例如：空值处理。 非运行时异常 (不处理，编译不能通过)：运行时异常以外的异常，也是Exception及其子类，这些异常从程序的角度来说是必须经过捕捉检查处理的(要么用 try…catch捕获处理，要么用throws语句声明抛出)，否则不能通过编译。如IOException、SQLException、NoSuchMetodException、ClassNotFoundException、FileNotFoundException等。 问：异常处理语句的语法规则 try是用于检测被包住的语句块是否出现异常，如果有异常，则抛出异常，并执行catch语句 cacth用于捕获从try中抛出的异常并作出处理 finally语句块是不管有没有出现异常都要执行的内容 throw用于抛出异常 throws关键字可以在方法上声明该方法要抛出的异常 (1) try代码块中包含可能产生异常的代码，其后跟一个或多个catch代码块，每个catch代码块用于捕获并处理一种特定类型的异常。 (2) 当try代码块中产生异常时，程序会终止当前的执行流程，Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个catch代码块，然后其他的catch代码块将不会再执行，即一个异常只能被一个catch代码块捕获执行。如果try代码块没有异常产生，所有的catch代码块将跳过不执行。 (3) catch代码块后可以跟finally代码块，无论try代码块中是否抛出异常，finally代码块都会被执行，因此finally代码块为异常处理提供一个统一的出口，使得在控制流程跳转到程序的其他部分之前，能够对程序的状态作统一的管理。通常在finally代码块中可以进行资源的清除工作。 (4) try代码块后基类异常的捕获语句不可以写在子类异常捕获语句的上面。 例1：判断程序输出 public class Main { public static void main(String[] args) throws Exception { try { try { throw new Sneeze(); } catch (Annoyance a) { System.out.println(&quot;Caught Annoyance&quot;); throw a; } } catch (Sneeze s) { System.out.println(&quot;Caught Sneeze&quot;); return; } finally { System.out.println(&quot;Hello World!&quot;); } } } class Annoyance extends Exception { } class Sneeze extends Annoyance { } 输出： Caught Annoyance Caught Sneeze Hello World! 例2：类ExampleA继承Exception，类ExampleB继承ExampleA，执行下面这段代码的输出是什么？ try { throw new ExampleB(&quot;b&quot;) } catch（ExampleA e）{ System.out.println(&quot;ExampleA&quot;); } catch（Exception e）{ System.out.println(&quot;Exception&quot;); } //输出：ExampleA (5) 在try-catch-finally结构中，可重新抛出异常。 (6) try-catch-finally结构可嵌套。 (7) try不必一定有catch，只要catch和finally有一个存在就行，但是catch和finally不可以同时省略 (8) 自定义异常要继承Exception或Exception的子类。 问：异常处理完成以后，Exception对象会发生什么变化？Exception对象会在下一个垃圾回收过程中被回收掉。 问：throw和throws有什么区别？ throw关键字用来在方法内部明确地抛出异常，后面跟的是要抛出的异常对象且只能跟一个异常对象； throws关键字用在声明方法上，表示该方法可能要抛出的、该方法不能处理的异常，后面跟的是异常类名，可以有多个，用逗号隔开，这样方法的调用者才能够确保处理可能发生的异常。 问：finallyfinally作为异常处理的一部分，只能用在try/catch语句块后，无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。 特例：如果try或catch代码块中有exit(0就不会再执行finally代码块了。 例1：当程序执行到try{}语句中的return方法时，它将要返回的结果存储到一个临时栈中，然后程序不会立即返回，而是去执行finally{}中的代码，在执行a = 2时，程序仅仅是覆盖了a的值，但不会去更新临时栈中的那个要返回的值。finally{}执行完之后，程序就会将临时栈中的值取出来返回。 public abstract class Test { public static void main(String[] args) { System.out.println(beforeFinally()); // output: 1 } public static int beforeFinally(){ int a = 0; try{ a = 1; return a; }finally{ a = 2; } } } 例2：这里finally{}里也有一个return，那么在执行这个return时，就会更新临时栈中的值。同样，在执行完finally之后，程序将临时栈中的值取出来返回，即返回值是2. public abstract class Test { public static void main(String[] args) { System.out.println(beforeFinally()); //output: 2 } public static int beforeFinally(){ int a = 0; try{ a = 1; return a; }finally{ a = 2; return a; } } } 例3：try/catch可以捕获并处理异常，异常被捕获后程序可以继续向后执行 public class Test { public static void main(String[] args) { try { int i = 100 / 0; System.out.print(i); } catch (Exception e) { System.out.print(1); } finally { System.out.print(2); } System.out.print(3); } } // output: 123 例4：catch语句块里面，打印完1之后，又抛出了一个RuntimeException，程序并没有处理它，而是直接抛出，因此执行完finally语句块之后，程序便不往下执行直接终止了 public class Test { public static void main(String[] args) { try { int i = 100 / 0; System.out.print(i); } catch (Exception e) { System.out.print(1); throw new RuntimeException(); } finally { System.out.print(2); } System.out.print(3); } } // output: 12 例5：catch语句块里面，打印完1之后，程序先执行完finally语句块，然后return。 public class Test { public static void main(String[] args) { try { int i = 100 / 0; System.out.print(i); } catch (Exception e) { System.out.print(1); return; } finally { System.out.print(2); } System.out.print(3); } } // output: 12 注意：平常我们在使用一些资源时，一般会在finally中进行资源的释放，如下形式： BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.readLine(); } finally { br.close(); } JDK1.7之后我们可以使用如下形式： try (BufferedReader br = new BufferedReader(new FileReader(path)) { return br.readLine(); } 直接在try中进行声明，跟在finally里面的关闭资源类似； 按照声明逆序关闭资源； 这些资源都必须实现java.lang.AutoCloseable接口。 问：final关键字、finally代码块和finalize()方法有什么区别？ final关键字用于声明变量、方法和类，分别表示变量的值不可被修改、方法不可被重写、类不可被继承。 finally作为异常处理的一部分，只能用在try/catch语句块后，无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。 finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由垃圾收集器来调用的。可以覆盖此方法在垃圾收集时的进行其他资源回收，例如关闭文件等。但是JVM不保证此方法总会被调用。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"03-面向对象编程","slug":"03-面向对象编程","date":"2017-02-15T10:14:04.000Z","updated":"2017-10-21T13:19:21.070Z","comments":true,"path":"2017/02/15/03-面向对象编程/","link":"","permalink":"https://hepsilion.github.io/2017/02/15/03-面向对象编程/","excerpt":"面向对象编程","text":"面向对象编程 问：面向对象的基本特征(1) 封装：利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过其对外已授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外提供的接口来访问该对象。 (2) 继承：继承是使用已存在的类作为基础定义新类，新类的定义可以增加新的数据或新的操作，也可以复用父类的操作，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。 (3) 多态：多态就是指程序中定义的引用变量所指向的对象的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。 问：类例1 问：new关键字例1 问：访问控制符Java类的成员没有写任何访问修饰符时，表示friendly访问权限，后面写作default。 图 1 访问权限大小：public&gt;protected&gt;default&gt;private 注意： 对于有继承关系的两个类，例如class B extends A，如果A和B在不同的包中，那么子类不能通过父类的实例访问父类的protected成员，但可以直接使用从父类继承的protected成员 例1： 父类： package p1; public class Father{ public int field1=1; protected int field2=2; int field3=3; private int field4=4; } 子类： package p2; import p1.Father; public class Child extends Father{ public void fun() { System.out.println(field1); System.out.println(field2); System.out.println(field3); // 错误 System.out.println(field4); // 错误 Father f = new Father(); System.out.println(f.field1); System.out.println(f.field2); // 错误：不同包下的子类不能通过父类实例访问protected成员 System.out.println(f.field3); // 错误 System.out.println(f.field4); // 错误 } } 如果将Child类也放在p1包中，则： package p1; import p1.Father; public class Child extends Father{ public void fun() { System.out.println(field1); System.out.println(field2); System.out.println(field3); System.out.println(field4); // 错误 Father f = new Father(); System.out.println(f.field1); System.out.println(f.field2); System.out.println(f.field3); System.out.println(f.field4); // 错误 } } Java中，外部类的访问修饰符只能是public或default，类成员(包括内部类)的修饰符可以是以上四种。 例2：分析下面代码的运行结果 class Person{ private String name = &quot;Person&quot;; int age=0; } public class Child extends Person{ public String grade; public static void main(String[] args){ Person p = new Child(); System.out.println(p.name); } } 答案：程序编译错误。子类无法访问父类的私有成员。 例2：Java代码查错 public class Something { void doSomething() { private String s = &quot;&quot;; int l = s.length(); } } 局部变量前不能放置任何访问修饰符(private，public和protected)。final可以用来修饰局部变量 问：Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？Java中每一个类都有构造方法，当使用关键字new实例化一个对象时，类的构造方法就会被自动调用，完成对象的初始化工作。 构造方法是一种特殊的方法，具有以下特点: (1) 构造方法的方法名必须与类名相同； (2) 构造方法没有返回值类型，也不能定义为void； (3) 构造方法不能被static、final、synchronized、abstract、native等关键字修饰，但可以被public、private、protected修饰 (4) 一个类可以定义多个构造方法，如果在定义类时没有定义构造方法，则编译系统会自动插入一个无参数的默认构造方法，这个构造器不执行任何代码； (5) 构造方法可以被重载，以参数的个数、类型、顺序进行区分； (6) 构造方法不能被继承，因此不能被重写，子类使用父类的构造方法需要使用super关键字 例1： Java中构造方法重载和方法重载很相似，可以为一个类创建多个构造方法，每一个构造方法必须有它自己唯一的参数列表。 Java不支持像C++中那样的复制构造方法，但是这并不代表Java中没有这种机制，Java中Object类的clone()方法就是这种机制的体现。 问：static关键字“static”关键字可以用于修饰类的成员变量和成员方法，被其修饰的成员变量被称为类变量，被其修饰的成员方法称为类方法，它们随着类的加载而加载，使得这些变量和方法可以在类没有被实例化的情况下直接通过类名进行访问。 (1) 被static修饰的成员方法只能访问static成员，不可以访问非static成员 Java中,非static成员是与对象关联在一起的，必须创建一个对象后，才可以访问该对象的方法或属性；而被static修饰的变量和方法是属于类的，它们随着类的加载而加载，同时对static变量进行初始化并执行static代码块。如果static环境中的代码尝试访问非static的变量，编译器会报错，因为类的加载先于变量的创建，类加载的时候这些变量还没有被创建出来，例如，在static方法中访问某对象的非static方法，此时尚不能保证对象已经被实例化。因此在static环境中不能访问非static变量。 例1 package NowCoder; class Test { public static void hello() { System.out.println(&quot;hello&quot;); } } public class MyApplication { public static void main(String[] args) { Test test=null; test.hello(); } } 上述代码：能编译通过，并正确运行 (2) Java中静态变量只能在类主体中定义，不能在方法中定义。 静态变量属于类所有而不属于方法所有。静态变量是在方法之前被加载的，在static加载时，对象还没有创建，方法也还没有分配空间。所以static变量只能是类成员变量，而不能是局部变量。 例1：分析下面代码的执行结果。 public class Test { public int aMethod() { static int i = 0; i++; return i; } public static void main (String args[]) { Test test = new Test(); test.aMethod(); int j = test.aMethod(); System.out.println(j); } } 答案：程序编译失败 问：局部变量、静态变量和实例变量Java中主要存在如下几种类型的变量： 局部变量 静态变量(类变量)：属于类，被static修饰符修饰的变量，也称为类变量，它属于类、而不属于类的任何一个对象。一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝。静态变量可以让多个对象实现共享内存。 实例变量(成员变量/非静态变量)：属于对象，必须依存于某一实例，即需要先创建对象然后才能通过对象访问到它。 例1：分析下面代码的执行结果。 public class Main { static { int x = 5; } static int x, y; public static void main(String args[]) { x--; myMethod(); System.out.println(x + y + ++x); } public static void myMethod() { y = x++ + ++x; } } A、compiletime error B、prints:1 C、prints:2 D、prints:3 E、prints:7 F、prints:8 答案：D 注意静态代码块中的语句声明，重新定义了一个局部变量int x = 5，执行完静态代码块后，局部变量就被销毁。 此时全局变量x 还是默认值0，执行到打印语句时，x=1，y=0，对于打印语句System.out.println(x+y+ ++x)中的x+y+ ++x由于+是左结合的，因此x+y+ ++x，即1+0+(++x)=3. 问：继承继承时类的实例化问题：在实例化一个类时，一定是先创建其父类对象，即先执行父类的构造函数，然后再创建当前类对象。如果子类没有显示地调用父类的构造函数，编译器会自动加入父类的无参的构造函数super()(这也要求父类要有无参数的构造函数，否咋将出现编译出错)。 例1： package test; class FatherClass { public FatherClass() { System.out.println(&quot;FatherClass Create&quot;); } } class ChildClass extends FatherClass { public ChildClass() { System.out.println(&quot;ChildClass Create&quot;); } public static void main(String[] args) { FatherClass fc = new FatherClass(); ChildClass cc = new ChildClass(); } } 程序的输出结果如下： FatherClass Create FatherClass Create ChildClass Create 例2 问：Java支持多继承么？Java中的类不支持多继承，只支持单继承(即一个类只有一个父类)。 但是Java中的接口支持多继承，即一个子接口可以有多个父接口。(接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能)。 问：super和thisthis代表当前类对象，super代表当前类对象的父类对象。 在子类构造方法中，使用super()调用的是其父类的构造方法，而使用this()调用的是同一个类中重载的构造方法 super关键字 在Java中super指代父类对象，通过它可以访问父类对象中非private修饰的成员变量和方法。 (1) Java中子类不能继承父类的构造方法，只能调用父类构造方法； (2) 子类的构造方法可以显示地使用super调用父类构造方法； (3) 当子类构造方法中没有显示地使用super来调用父类构造方法时，系统会默认采用super()调用父类的无参构造方法，这时父类必须提供无参构造方法，否则编译出错。 例1：下面程序的输出结果是多少？ class A { public String name = &quot;llyA&quot;; public void getName() { System.out.println(&quot;父类getName-&gt;&quot; + name); } } class B extends A { public String name = &quot;llyB&quot;; @Override public void getName() { System.out.println(&quot;子类getName-&gt;&quot; + name); super.getName(); } } public class Main { public static void main(String[] args) { B b = new B(); b.getName(); } } // 输出： 子类getName-&gt;llyB 父类getName-&gt;llyA 例2，例3，例4，例5 例6：下面程序的输出结果是多少？ import java.util.Date; public class Test extends Date{ public static void main(String[] args) { new Test().test(); } public void test(){ System.out.println(super.getClass().getName()); } } 在test方法中其实在调用从父类继承的getClass()方法 输出为: Test 如果想得到父类的名称，应该使用：getClass().getSuperClass().getName(); this关键字 注意： (1) 使用super()或this()时，它们必须放在构造方法的第一行，否则编译通不过。 (2) 由于this()调用的构造函数默认调用super()方法，所以规定this()和super()不能同时出现在一个构造函数中。 (3) static环境，包括static方法和static语句块，在执行时还没有构造对象实例，因此不能在static环境中使用this和super 问：Java中的方法重写(或覆盖，Overriding)和方法重载(Overloading)是什么意思？方法重写和方法重载都是Java多态性的不同表现(动态绑定 dynamic binding) (1) 方法重载是一个类中多态性的一种表现，发生在同一个类里面两个或多个方法的方法名相同但是参数列表不同的情况。 函数名必须相同； 函数参数列表必须不相同：可以是参数个数、参数类型或者参数顺序不同； 函数的返回值类型、访问权限、异常类型可以相同，也可以不相同。即不能通过返回值类型、访问权限和异常类型对方法进行重载。 例1：为什么不能通过返回值类型进行方法重载？ 因为我们有时候调用一个方法时可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用map.remove(key)方法时，虽然remove方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，java就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。所以，重载的方法是可以改变返回值的类型；只能通过不同的参数个数、不同的参数类型或不同的参数顺序来实现重载。 (2) 方法重写是父类与子类之间多态性的一种表现，是说子类重新定义了父类的方法；方法的重写满足两同两小一大原则 方法名相同，参数列表相同 子类方法返回值类型小于或等于父类方法返回值类型； 子类方法抛出的异常类型小于或等于父类方法抛出的异常类型 (小于：子类方法抛出的异常时父类方法抛出异常的子类)； 子类方法访问权限大于或等于父类方法访问权限 (public&gt;protected&gt;defualt(默认修饰符)&gt;private)。如果父类的方法是private访问权限，则子类并没有重写父类的方法，只是在子类中定义了一个全新的方法。 注意：Java不支持运算符重载。 例1 问：Java中是否可以覆盖(override)一个被private或static修饰的方法？private修饰的方法不能被覆盖，因为被private修饰的父类方法在子类中是不可见的。 Java中静态方法在形式上可以被重写，即子类中可以重写父类中静态的方法。但是实际上从内存的角度上静态方法不可以被重写，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。 问：final关键字final关键字可以用于修饰类、变量和方法。 (1) final修饰的类不可被继承(因此一个类不能同时被final和abstract关键字修饰)； (2) final修饰的方法不可被重写； (3) final修饰的变量的值不可被修改，一旦获得初始值，该变量就不能被重新赋值。 例1： 使用final关键字修饰一个引用变量时，引用变量的值不可被修改，但引用变量所指向的对象的内容是可以改变的。例如: final StringBuffer sb=new StringBuffer(&quot;immutable&quot;); 当执行sb.append(&quot; broken!&quot;)；时，编译正确； 但是当执行sb=new StringBuffer(&quot;&quot;);时，将报告编译错误。 例2，例3，例4 (4) 形式参数只能用final修饰符，任何其它修饰符都会引起编译错误。但是用这个修饰符也有一定的限制，就是在方法中不能修改参数的值(但是从上面例1可以看出，参数引用的对象仍然是可以修改的)。不过在一般情况下，一个方法的形参不用final修饰。只有在特殊情况下：方法内部类，一个方法的内部类如果使用了这个方法的参数或局部变量，这个参数或局部变量应该是final。 (5) final修饰的成员变量既可以在定义时显示地初始化，也可以先声明而不初始化，这种成员变量称为blank final，此时可以在构造代码块或构造函数中对其赋初值，(必须在constructor结束之前，如果类中有多个构造方法，则每个构造方法中都需要进行一次初始化)，否则使用未赋初值的final变量时编译会报错。 注意：对于非final修饰的类的成员变量(包括static和非static)，如果开发者没有给其赋初值，在编译时，JVM自动会给非final修饰的成员变量赋初值，我们在类的成员方法中就可以直接使用、运算了。 (6) 当方法中的局部变量用final修饰时，不一定要在定义的时候就初始化，只需要在使用前保证初始化就可以，但必须要在开始使用这个变量前初始化。 例1： class Foo { final int i; int j; public void doSomething() { System.out.println(++j + i); // 编译出错，因为final成员变量在使用前没有赋初值 } } 例2：这一题解释尚不明确，不知道final方法在子类中继承了没有。 public class Car extends Vehicle{ public static void main(String[] args){ new Car().run(); //输出：Car } private final void run(){ System.out.println(&quot;Car&quot;); } } class Vehicle{ private final void run(){ System.out.println(&quot;Vehicle&quot;); } } 问题已解决：子类会继承父类的所有属性和方法，或者说子类拥有父类的所有属性和方法，但是子类无法直接访问父类的私有属性和私有方法。 这里由于子类无法访问父类的run()方法，因此子类并没有重写父类的run()方法，而是自己重新定义了run()方法。 (6) 被fianl修饰的变量是常量，参与运算时在编译时就计算出结果，不会自动改变类型；当2个final修饰的变量相操作时，结果会根据左边变量的类型进行转化 例1： byte b1=1,b2=2,b3,b6,b8; final byte b4=4,b5=6,b7; b3=(b1+b2); /*语句1*/ b6=b4+b5; /*语句2*/ b8=(b1+b4); /*语句3*/ b7=(b2+b5); /*语句4*/ System.out.println(b3+b6); 代码片段中，存在编辑错误的语句是：语句1、语句3和语句4 语句1错误：b3=(b1+b2);自动转为int，所以正确写法为b3=(byte)(b1+b2);或者将b3定义为int； 语句2正确：b6=b4+b5;b4、b5为final类型，在编译时就已经变为b6=10，不会自动提升，计算结果任然是byte类型，然后结果的类型视左边变量类型而定，即b6可以是任意数值类型； 语句3错误：b8=(b1+b4);虽然b4不会自动提升，但b1仍会自动提升，所以结果需要强转，b8=(byte)(b1+b4); 语句4错误：b7=(b2+b5); 同上。同时注意b7是final修饰，即只可赋值一次，便不可再改变。 问：Object类Java中Object是所有类的祖先类，Object类中包含如下方法： 图 1 例1：重写clone()方法时，通常都会有一行代码，是什么？ super.clone(); 重写clone()方法时，首先要把父类中成员复制到位，然后才是复制子类的成员。 问：如何实现对象克隆有两种方式可以实现对象克隆： (1) 实现Cloneable接口并重写Object类中的clone()方法； (2) 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆 import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; public class Main { public static void main(String[] args) { try { Person p1 = new Person(&quot;Bob&quot;, 33, new Car(&quot;Benz&quot;, 300)); ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bout); oos.writeObject(p1); ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bin); Person p2 = (Person) ois.readObject(); p2.getCar().setBrand(&quot;BYD&quot;); System.out.println(&quot;Person 1---&gt;&quot; + p1);//Person 1---&gt;Person [name=Bob, age=33, car=Car [brand=Benz, maxSpeed=300]] System.out.println(&quot;Person 1---&gt;&quot; + p2);//Person 1---&gt;Person [name=Bob, age=33, car=Car [brand=BYD, maxSpeed=300]] } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } } class Person implements Serializable { private static final long serialVersionUID = -9102017020286042305L; private String name; // 姓名 private int age; // 年龄 private Car car; // 座驾 public Person(String name, int age, Car car) { this.name = name; this.age = age; this.car = car; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Car getCar() { return car; } public void setCar(Car car) { this.car = car; } @Override public String toString() { return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;, car=&quot; + car + &quot;]&quot;; } } class Car implements Serializable { private static final long serialVersionUID = -5713945027627603702L; private String brand; // 品牌 private int maxSpeed; // 最高时速 public Car(String brand, int maxSpeed) { this.brand = brand; this.maxSpeed = maxSpeed; } public String getBrand() { return brand; } public void setBrand(String brand) { this.brand = brand; } public int getMaxSpeed() { return maxSpeed; } public void setMaxSpeed(int maxSpeed) { this.maxSpeed = maxSpeed; } @Override public String toString() { return &quot;Car [brand=&quot; + brand + &quot;, maxSpeed=&quot; + maxSpeed + &quot;]&quot;; } } 问：equals()方法和==的区别(1) ==运算符：比较两个变量的值是否相等，也就是两个变量所对应的内存中存储的数值是否相同，即栈中的内容是否相同。 对于基本数据类型变量比较的是两个变量的值是否相等；如果是不同的基本数据类型之间进行比较，则遵循基本数据类型间运算的转换原则: 如果两个操作数其中有一个是double类型，另一个操作数将会转换为double类型； 否则，如果其中一个操作数是float类型，另一个操作数将会转换为float类型； 否则，如果其中一个操作数是long类型，另一个操作数会转换为long类型； 否则，两个操作数都转换为int类型。 对于引用型变量表示的是两个变量指向的对象在堆中存储的地址是否相同，即两个变量是否指向同一个对象 例1： public static void main(String[] args){ int i=42; double d=42.0000; long l=42; float f=42.0f; float f2=42.00f; System.out.println(d==i); //true System.out.println(f==i); //true System.out.println(f==f2); //true System.out.println(l==i); //true System.out.println(l==f); //true System.out.println(d==f); //true } (2) equals()方法：继承自Object类，默认调用==进行比较。通常比较两个对象的内容是否相同，判断两个对象是否相等需要覆盖equals()方法和hashcode()方法。 注意：对于基本数据类型来说，使用equals方法时需要用该基本类型对应的包装类，因为equals()方法是针对对象来使用的！ 例1： String a=new String(&quot;foo&quot;); String b=new String(&quot;foo&quot;); System.out.println(a==b); //false System.out.println(a.equals(b)); //true 例2：寻找代码错误 if(username.equals(&quot;zhangsan&quot;)){ } username可能为null，此时编译器会报告空指针异常，因此需要改为&quot;zhangsan&quot;.equals(username) 问：finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？finalize()是Object类的一个方法，垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法。 但是很不幸的是，在Java中，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说finalize()可能永远不会被执行，显然指望它做收尾工作是靠不住的。 那么finalize()究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。 问：多态的实现方式(1) 静态的多态/编译时的多态性：方法重载 (2) 动态的多态/运行时的多态性：子类覆盖父类的方法，将子类的实例赋值给父类的引用，此时调用的是子类的方法；实现接口的实例赋值给接口的引用，此时调用的实现类的方法。 例1：判断对错 在java的多态调用中，new的是哪一个类就是调用的哪个类的方法。 答案：错误。 没看懂题目后面的评论，不知道跟重载有什么关系。目前我觉得下面例子是一个反例。 class Father { public static void run(){ System.out.println(&quot;Father run&quot;); } } public class Child extends Father { public static void run(){ System.out.println(&quot;Child run&quot;); } public static void main(String[] args) { Person p = new Child(); p.run(); //这里调用的实际上是父类的run()方法 } } 问：抽象类和接口的区别Java提供和支持创建抽象类和接口。 (1) 抽象类：含有abstract修饰符的class即为抽象类，abstract类不能创建类的实例对象。 含有abstract方法的类必须定义为abstract class 抽象类中的抽象方法，需要由子类实现，如果子类不实现所有抽象方法，则子类也需要定义为抽象类； 抽象方法既不能是static的，也不能是native的，还不能是synchronized的 构造方法和静态方法不可以为抽象的。 (2) 接口：接口(interface)可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。 接口中的方法默认定义为public abstract类型，接口中的成员变量默认为public static final 接口中定义的方法都需要由实现类来实现，如果实现类不能实现接口中的所有方法，则实现类需要定义为抽象类 他们的共同点在于： 抽象类和接口都不可以被实例化 类可以不实现抽象类和接口中声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的 它们的不同点在于：从设计层面来说，抽象是对类的抽象，是一种模板设计；接口是行为的抽象，是一种行为的规范。 抽象类中可以有构造方法，其作用是初始化抽象类的成员；接口中不能有构造方法 抽象类中可以有普通成员变量；而接口中没有普通成员变量，只能有静态成员变量 抽象类中可以包含静态方法；而接口中不能包含静态方法(Java8开始接口可以有静态方法) 抽象类中可以同时包含抽象方法和非抽象方法，也可以没有抽象方法，但如果一个类中有一个抽象方法，那么当前类一定是抽象类；而接口中只有方法的声明、没有方法体，即接口中的所有方法必须都是抽象的，不能有非抽象的普通方法(Java8中接口可以有非抽象的default方法) 抽象类和接口中都可以包含静态成员变量。抽象类中静态成员变量的访问类型可以任意；而接口中声明的成员变量默认为public static final类型，且只能是public static final类型 抽象类中的普通成员方法的访问类型可以为public、protected和private，抽象方法必须为public或protected；而接口中的成员方法的访问类型默认为public abstract类型，且只能是public abstract 一个类最多只能继承一个类，但一个类可以实现多个接口 抽象类可以implements接口，抽象类可以继承具体类也可以继承抽象类；接口可以继承接口，并且接口可以实现多继承(一个接口可以继承多个接口) 例1，例2，例3，例4 例5：Java代码查错 abstract class Something { private abstract String doSomething(); } 编译错误：abstract修饰的方法需要由子类实现，不能用private修饰。 同理，abstract方法前不能加final。 例6：Java代码查错 interface A { int x = 0; } class B { int x = 1; } class C extends B implements A { public void fun() { System.out.println(x); } public static void main(String[] args) { new C().fun(); } } 编译错误：未明确的x调用 例7： class Toy{ } interface Rollable { Toy toy = new Toy(); void play(); } class Ball implements Rollable { public void play() { toy = new Toy(); } } 编译错误：任何在interface里声明的interface variable默认为public static final，不能被重新赋值。 例8： 接口可以继承接口；抽象类可以实现接口；抽象类可以继承具体类；抽象类中可以有静态的main方法。 例9：JDK1.8中允许接口定义默认非抽象的方法 Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字即可，这个特征又叫做扩展方法。 interface Formula { double calculate(int a); default double sqrt(int a) { return Math.sqrt(a); } } Formula接口在定义calculate方法的同时还定义了sqrt方法，实现Formula接口的子类只需要实现calculate方法，默认方法sqrt将在子类中可以直接使用。 Formula formula = new Formula() { @Override public double calculate(int a) { return sqrt(a * 100); } }; formula.calculate(100); // 100.0 formula.sqrt(16); // 4.0 问：instanceof关键字instanceof前一个参数通常是一个引用类型变量，后一个操作数通常是一个类（也可以是一个接口）。它用于判断前面的变量引用的对象是否是后面的类(也可以是一个接口)或者其子类的实例。 例1： public static void main(String args[]) { List Listlist1 = new ArrayList(); Listlist1.add(0); List Listlist2 = Listlist1; System.out.println(Listlist1.get(0) instanceof Integer); System.out.println(Listlist2.get(0) instanceof Integer); } 上面代码将输出：true true Collection类型的集合（ArrayList,LinkedList）只能装入对象类型的数据 该题中需要装入0，是一个基本类型，但是JDK5以后提供了自动装箱与自动拆箱，所以int类型自动装箱变为了Integer类型。 List没有使用泛型，因此使用get(0)取出的元素的编译类型是Object型的，但运行时类型是Integer，所以打印true，这里体现了多态的应用。 而Listlist1把引用赋给了Listlist2，说明两个指向同一个对象，因此第二个打印的也是true。 问：内部类内部类就是在一个类的内部定义的类。 内部类中不能定义静态成员 内部类可以直接访问外部类中的成员 内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中 例1：内部类中可以访问外部类的成员？有没有什么限制？ 如果内部类不是静态嵌套类，则内部类可以直接访问外部类的成员； 但是如果把静态嵌套类当作内部类的一种特例，则它不可以直接访问外部类的普通成员，只能访问外部类中的静态成员。 例2：内部类中是否一定不可以定义静态成员？ 同样的，静态嵌套类可以定义静态成员 内部类分类，来自例2中评论部分BlueFish的总结。 (1) 成员内部类 public class Outer{ private String name=&quot;Outer&quot;; private int age=99; public static void main(String[] args){ Outer outer=new Outer(); Inner inner=outer.new Inner(); inner.show(); } private class Inner{ private String name=&quot;Inner&quot;; private final int num=10; public void show(){ System.out.println(Outer.this.name); System.out.println(this.name); System.out.println(age); } } } Inner类定义在Outer类的内部(相当于Outer类的一个成员变量的位置处)，Inner类可以使用任意访问控制符，如public、protected、private或default等，跟成员变量有4种访问权限一样； Inner 类中定义的show()方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问Outer类中的私有属性age； 定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去new一个内部类对象，即：内部类 对象名=外部类对象.new 内部类(); 编译上面的程序后，会发现产生了两个.class文件: Outer.class和Outer$Inner.class 成员内部类中不能存在任何static的变量和方法，但可以定义常量: 因为非静态内部类的存在是依赖于外部类的实例的，而静态变量和方法是不依赖于对象的，仅与类相关。而在加载静态域时，根本没有外部类实例，所在在非静态内部类中不能定义静态变量或方法，编译不通过;非静态内部类的作用域是实例级别 常量是在编译器时确定的，放到所谓的常量池了，因此可以定义常量。 注意： 外部类是不能直接使用内部类的成员和方法的，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法； 如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用this关键字，如:Outer.this.name (2) 方法内部类，访问仅限于方法内或者该作用域内 public class Outer { public static void main(String[] args) { Outer outer = new Outer(); outer.print(); } public void print() { final int a = 25; class Inner { private int c = 2; public void show() { System.out.println(a); System.out.println(c); } } Inner inner = new Inner(); inner.show(); } } 方法内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的；但这种内部类的前面可以使用final或abstract修饰符。 方法内部类对其他外部类是不可见的 方法内部类不能修改方法中定义的局部变量(解释看原评论，原评论这部分，我测试有点问题，大概原因是内部类访问方法局部变量时会拷贝局部变量，对局部变量修改会造成拷贝的局部变量值与方法中局部变量值不一致，为了保持局部变量值的一致性，可以将被内部类访问的局部变量声明为final) (3) 匿名内部类：定义某一接口的实现类或定义某一类的子类的同时，还创建了该实现类或子类的实例对象，且没有为该实现类或子类定义名称 public class Outer{ public static void main(String[] args){ Outer outer=new Outer(); InnerClass inner=outer.getInnerClass(2, &quot;inner&quot;); System.out.println(inner.getNumber()); } public InnerClass getInnerClass(int num, String str){ return new InnerClass(){ int count; int number=num+1; { count=100; } @Override public int getNumber() { return number; } }; } private interface InnerClass{ int getNumber(); } } 匿名内部类是直接使用 new 来生成一个对象的引用； 对于匿名内部类的使用，它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用； 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，即只能继承一个类或者实现一个接口； 匿名内部类中是不能定义构造函数的，匿名内部类中不能存在任何的静态成员变量和静态方法； 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法； 匿名内部类初始化:使用构造代码块! 利用构造代码块能够达到为匿名内部类创建一个构造器的效果 内部类的作用 隐藏内部操作细节 解决多重继承的问题 第二点作用是使用内部类最吸引人的原因，它的存在使得Java的继承机制更加完善。众所周知，Java中的类只能继承一个类，它的多重继承在我们没有学习内部类之前是用接口来实现的，但是使用接口会存在很多不方便的地方，比如我们实现一个接口就必须实现它里面的所有方法；而有了内部类情况就不一样了，它可以让我们的类间接地继承多个抽象类或具体类：我们可以在外部类中定义多个内部类，每个内部类都可以独立地继承一个抽象类或具体类，然后再外部类中创建内部类的对象，并使用内部类的方法，这样就可以变相地实现了多继承。 例如我们有两个类Class1和Class2: class Class1{ public void fun1(){ System.out.println(&quot;Class1 fun1()&quot;); } } class Class2{ public void fun2(){ System.out.println(&quot;Class2 fun2()&quot;); } } 如果我们想要类Test既有Class1的特性，又有Class2的特性，就必须让Test类既继承Class1，又继承Class2，可是这在Java的单继承使得这种方式不可实现。那又怎么办呢？我们可以在Test中实现两个内部类InnerClass1和InnerClass2，让他们分别继承Class1和Class2，然后在Test中创建InnerClass1和InnerClass2的对象，通过这些对象调用Class1和Class2的方法，间接实现多继承。 public class Test { public void fun1(){ new InnerClass1().fun1(); } public void fun2(){ new InnerClass2().fun2(); } class InnerClass1 extends Class1{ } class InnerClass2 extends Class2{ } } 使用内部类还能够为我们带来如下特性: 内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立； 在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类； 创建内部类对象的时刻并不依赖于外围类对象的创建； 内部类并没有令人迷惑的”is-a”关系，他就是一个独立的实体； 内部类提供了更好的封装，除了该外围类，其他类都不能访问。 说实话，上面的特性没读懂，为了保持内容完整性，姑且放在这里吧。 例1： 重要 非静态内部类是属于对象的，所以初始化时需要先初始化一个外部类实例对象，然后使用此对象调用内部类的构造方法。静态内部类属于类本身，初始化时直接使用外部类调用静态内部类的构造方法即可 public class Test{ public static void main(String[] args){ EnclosingOne.InsideOne obj1=new EnclosingOne().new InsideOne(); //非静态内部类 EnclosingOne.InsideTwo obj2=new EnclosingOne.InsideTwo(); //静态内部类 } } class EnclosingOne { //非静态内部类 public class InsideOne { } //静态内部类 public static class InsideTwo{ } } 例2：往OuterClass类的代码段中插入内部类声明，哪一个是错误的？ public class OuterClass{ private float f=1.0f; //插入代码到这里 } A. class InnerClass{ public static float func(){ return f; } } B. abstract class InnerClass{ public abstract float func(){} } C. static class InnerClass{ protected static float func(){ return f; } } D. public class InnerClass{ static float func(){ return f; } } 答案：ABCD 例3 例4：代码检查 class Outer { class Inner {} public static void foo() { new Inner(); } public void bar() { new Inner(); } public static void main(String[] args) { new Inner(); } } 编译错误：Java中非静态内部类对象的创建要依赖其外部类对象， 上面的面试题中foo和main方法都是静态方法，静态方法中没有this，也就是说没有所谓的外部类对象，因此无法创建内部类对象。 如果要在静态方法中创建内部类对象，可以这样做：new Outer().new Inner(); 问：Static Nested Class和Inner Class的不同？在方法外部定义的内部类前面加上static关键字，成为static Nested Class，它不再具备内部类的特性，侠义上讲，它不是内部类。它与普通类在运行时的行为和功能没有什么区别，只是编程引用时的语法有一些区别。 public class Outer{ private static String name=&quot;Outer&quot;; private static String tag=&quot;tag&quot;; private int age=99; public static void main(String[] args){ Inner inner=new Inner(); inner.show(); } private static class Inner{ private String name=&quot;Inner&quot;; public void show(){ System.out.println(Outer.name); System.out.println(this.name); System.out.println(tag); System.out.println(new Outer().age); } } } 静态内部类不能直接访问外部类的非静态成员，但可以通过new 外部类().成员的方式访问 如果外部类的静态成员与内部类的成员名称相同，可通过类名.静态成员的方式访问外部类的静态成员； 如果外部类的静态成员与内部类的成员名称不相同，则可通过成员名直接调用外部类的静态成员； 创建静态内部类的对象时，不需要外部类的对象，可以直接创建内部类 对象名=new 内部类(); (1) Static Nested Class可以定义为public、protected、default和private (2) Static Nested Class可以不依赖于外部类实例被实例化，而通常的内部类需要在外部类实例化后才能实例化。 在外部类的外面引用Static Nested Class的方式为”外部类名.内部类名”，即在外部类的外面不需要创建外部类的实例对象，就可以直接创建Static Nested Class的实例。例如，假设Inner是定义在Outer类中的Static Nested Class，那么可以使用如下语句创建Inner类的实例：Outer.Inner inner = new Outer.Inner(); static Nested Class能访问外部类的非static成员变量(不能直接访问，需要创建外部类实例才能访问非静态变量)。 (3) 当在外部类中访问Static Nested Class时，可以直接使用Static Nested Class的名字，而不需要加上外部类的名字了，在Static Nested Class中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字。 (4) 在静态方法中定义的内部类也是Static Nested Class，这时候不能在类前面加static关键字，静态方法中的Static Nested Class与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的static的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加final修饰符。 问：Lambda表达式在老版本的Java中，排列字符串一般按如下方式处理： List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;); Collections.sort(names, new Comparator&lt;String&gt;() { @Override public int compare(String a, String b) { return b.compareTo(a); } }); 我们需要给静态方法Collections.sort()传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。 在Java 8中我们就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法：lambda表达式。使用lambda表达式的写法如下： Collections.sort(names, (String a, String b) -&gt; { return b.compareTo(a); }); 对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，因此上面代码可以重写成如下： Collections.sort(names, (String a, String b) -&gt; b.compareTo(a)); Java编译器可以自动推导出参数类型，代码可以进一步简写成如下： Collections.sort(names, (a, b) -&gt; b.compareTo(a)); 问：JNI(Java Native Interface) (没怎么遇到过，暂时保留)Java的不足除了体现在运行速度上要比传统的C++慢许多之外，还体现在Java无法直接访问底层操作系统（如系统硬件等)，为此Java使用native方法来扩展Java程序的功能。 native是方法修饰符，native方法是由另外一种语言（如C/C++,汇编等）实现的本地方法，因为在外部实现了方法，所以在java代码中，就不需要声明了，有点类似于接口中的抽象方法。其实现步骤为： 在Java中声明native()方法，然后编译； 用javah产生一个.h文件； 写一个.cpp文件实现native导出方法，其中需要包含第二步产生的.h文件（注意其中又包含了JDK带的jni.h文件）； 将第三步的.cpp文件编译成动态链接库文件； 在Java中用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问了。 例1：以下声明合法的是： A. default String s B. public final static native int w() C. abstract double d D. abstract final double hyperbolicCosine() 答案：B native可以和任何修饰符连用，abstract除外。因为native暗示这个方法时有实现体的，而abstract却显式指明了这个方法没有实现体。 例2：Which of the following can be applied to constructors? A. final B. static C. synchronized D. native E. None of these. 答案：E abstract方法和native方法都是方法的声明，一个把方法实现移交给子类，另一个移交给本地操作系统。 如果同时出现，就相当于既把实现移交给子类，又把实现移交给本地操作系统，那就会产生混乱。 Java构造方法可以有任何访问的修饰：public，protected，private或者没有修饰。 但是不能有以下非访问性质的修饰：abstract，final，native，static，或者synchronized。 例3：abstract方法是否可以同时是static的，是否可以同时是native方法，是否可以同时被synchronized修饰？ 都不能。 抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。 本地方法是由本地代码(如C代码)实现的方法，而抽象方法是没有实现的，也是矛盾的。 synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"02-基础语法","slug":"02-基础语法","date":"2017-02-14T09:26:00.000Z","updated":"2017-10-21T13:19:21.021Z","comments":true,"path":"2017/02/14/02-基础语法/","link":"","permalink":"https://hepsilion.github.io/2017/02/14/02-基础语法/","excerpt":"基础语法","text":"基础语法 问：关键字和保留字(1) Java关键字列表(依字母排序共50组) abstract, assert, boolean, break, byte, case, catch, char, class, const(保留关键字), continue, default, do, double, else, enum, extends, final, finally, float, for, goto(保留关键字), if, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while (2) 保留字列表(依字母排序共14组)，Java保留字是指现有Java版本尚未使用，但以后版本可能会作为关键字使用 byValue, cast, false, future, generic, inner, operator, outer, rest, true, var, goto(保留关键字), const(保留关键字), null 注意： (1) const和goto既是保留字又是关键字 (2) 除了const和goto，其余保留字和关键字是严格区分开的。 问：Java支持的数据类型有哪些？Java语言支持8种基本数据类型是：byte、short、int、long、float、double、boolean、char；支持3种引用数据类型：类、接口、枚举和数组。 (1) Java中整数值默认为int型，如果要指定整数为long型需要加L；浮点数值默认为double型，如果要指定浮点数为float型需要加F。 float f=3.4; //错误，3.4默认为double型。 float f=3.4F; //正确 float f=3; //正确 (2) Java中在定义类的成员变量时可以对其初始化，如果不对其初始化，Java使用默认值对其初始化；而局部变量在使用前则必须进行初始化，JVM不会进行默认值初始化。 (3) Java中基本数据类型变量默认初始化值如表所示，引用变量默认初始化值为null。 图 2 例1： int类型变量的默认值为0；Integer类型变量的默认值为null。 问：类型转换(1) 各数据类型按容量大小(表数范围大小)由小到大排列为：byte\\char\\short -&gt; int -&gt; long -&gt; float -&gt; double (2) 低级向高级是隐式类型转换；高级向低级必须强制类型转换，且可能丢失精度 例1： double f = 1.2; int value = (int)f; //结果为1，丢失了小数点部分 例2： 对于java类型变量char c，short s，float f，double d，表达式c*s+f+d的结果类型为double (3) Java中char、byte、short之间不会发生隐式类型转换(需要强制转换)；如果碰到char、byte和short参与运算时，会自动将这些值转换为int类型值然后再进行运算。 例1： short s1 = 1; s1 = s1 + 1; // 编译错误：由于s+1运算结果为int型，再赋值给short类型s，编译器会报告需要强制类型转换的错误。 short s1 = 1; s1 += 1; //编译正确：Java编译器会对+=特殊处理 short s = 16; byte a2 = s; //错误 问：Java中的中文字符Java语言中，中文字符所占的字节数取决于字符的编码方式，默认使用GBK编码方式。 当采用ISO8859-1编码方式时，一个中文字符占1个字节； 当采用GB2312或GBK编码方式时，一个中文字符占2个字节； 当采用UTF-8编码方式时，一个中文字符会占3个字节。 Java字符默认使用unicode编码，每个字符占用两个字节，所以char型变量可以存放一个中文字符。 Unicode字符编码标准是固定长度的字符编码方案。Unicode根据要编码的数据类型使用两种编码格式：8 位和16位。缺省编码格式是16位，即每个字符是16位(两个字节)宽。 注意：char与byte在Java和C++中的区别： 在C++中，char是基础数据类型，占1个字节；byte不是基础数据类型，一般定义为typedef unsigned char byte;也就是说，byte其实是unsigned char类型，那么也是占1个字节。不同的是，char可以表示的范围是-128-127，而byte可以表示的范围是0-255。 在java中，char和byte都是基础数据类型，其中的byte占1个字节，可以表示的范围是-128-127。而char占2个字节，可以表示的范围是’\\u0000’-‘\\uFFFF’。 例1： Java中实现国际化应用常用的手段是利用ResourceBundle类。 这个题目解答没看懂 问：进制表示 八进制： 012 十六进制：0x12 问：源码、反码和补码例1： 变量a是一个64位有符号的整数，初始值用16进制表示为：0Xf000000000000000； 变量b是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF。 则a-b的结果用10进制表示为多少？ 计算机是用补码进行存储和计算的，因此a和b的初始值即为a和b在计算机中的补码形式，即：a的补码为0Xf000000000000000，b的补码为0x7FFFFFFFFFFFFFFF 0Xf000000000000000=1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x7FFFFFFFFFFFFFFF=0111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 a-b=a+(-b) 由于b是正数，原码与其补码相同，都为0x7FFFFFFFFFFFFFFF，则-b的原码为0xFFFFFFFFFFFFFFFF，是负数 现在求-b的补码，先对它的原码(除符号位外)各位取反得到-b的反码，然后反码尾部加1得到-b的补码，为 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001 所以a-b=a+(-b)= 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000+ 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001= 10111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001(最高位溢出，舍去，结果变成了正数) 则结果为0111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001=2^62+2^61+2^60+1 例2： 变量a是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF; 变量b是一个64位有符号的整数，初始值用16进制表示为：0x8000000000000000。 则a+b的结果用10进制表示为多少？ 计算机中是以补码形式存储数据，则a和b的初始值即为a和b在计算机中的补码形式。 0x7FFFFFFFFFFFFFFF+0x8000000000000000=0xFFFFFFFFFFFFFFFF 结果最高位符号位为1，说明结果为负数，现在求结果的原码值。 保持符号位不变，补码减1，得到结果的反码；保持符号位不变，反码取反，得到结果的原码：-1 例3： short a=128； byte b=(byte)a; 此时，变量a，b的值分别为128和-128 计算机是用补码进行存储和计算的，Java中short占2个字节，16位，因此a在内存中补码形式为0000 0000 1000 0000 Java中byte占1个字节，8位。将short变量强制类型转换时会截断前8位，得到1000 0000，即为b的补码形式。 现在已知a的补码为10000000，求原码。因为最高位表示符号位，所以首先这个数为负数。 保持符号位不变，补码减1，得到结果的反码1111 1111；保持符号位不变，反码取反，得到结果的原码1 0000 0000：-128 问：常见的运算符 +，%，~，三目运算符，++，&amp;&amp;和&amp;，&gt;&gt;和&gt;&gt;&gt; +： 例1： public class Test { public static void main(String args[]) { System.out.println(8+8+&quot;88&quot;+8+8); //168888 } } 例2： 若有定义语句：int a=10; double b=3.14;则表达式&apos;A&apos;+a+b 值的类型是double 例3： 假定x和y为double型，则表达式x=2，y=x+3/2的输出为3.000000 %：取模运算符，要求操作数为整型。 ~：按位取反运算符 例1： 若int j = 10; 则~j为多少？ 计算机是用补码进行存储和计算的，因此10在计算机中补码存储为：00000000 00000000 00000000 00001010 ~j操作是对j的补码取反，然后得到结果即为~j的补码： 11111111 11111111 11111111 11110101 现在通过~j的补码反推出~j的原码，~j最高位符号位为1，表明它是一个负数 保持符号位不变，补码减1，得到~j的反码： 11111111 11111111 11111111 11110100 保持符号位不变，反码取反，得到~j的原码： 10000000 00000000 00000000 00001011 换算为整数，~j大小为-11 公式：-n=~n+1，可以推出~n=-n-1，所以~10=-11 三目运算符 例1： boolean b=true?false:true==true?false:true; System.out.println(b); //false 例2：下列代码输出是什么？ public static void main(String[] args){ boolean result1=true1()?true2():true3()==true4()?false1():true5(); System.out.println(result1); boolean result2=false1()?true2():true3()==true4()?false2():true5(); System.out.println(result2); } public static boolean true1(){ System.out.print(&quot;true1 &quot;); return true; } public static boolean true2(){ System.out.print(&quot;true2 &quot;); return true; } public static boolean true3(){ System.out.print(&quot;true3 &quot;); return true; } public static boolean true4(){ System.out.print(&quot;true4 &quot;); return true; } public static boolean true5(){ System.out.print(&quot;true5 &quot;); return true; } public static boolean false1(){ System.out.print(&quot;false1 &quot;); return false; } public static boolean false2(){ System.out.print(&quot;false2 &quot;); return false; } 输出如下： true1 true2 true false1 true3 true4 false2 false 从输出结果可以看出例1中b=true?false:true...，true成立使得结果b为false，表达式返回，后面的表达式不再执行。 结论：(1) ==优先级大于三目运算符 (2) 写复杂表达式时，请记得加括号，便于阅读 ++ i=i++问题 Java使用了中间缓存变量机制，JVM运行这条语句时过程如下： 步骤1 JVM把i值拷贝到临时变量区； 步骤2 i值加1； 步骤3 返回临时变量区的值，注意这个值步骤1中没修改过的i值。 步骤4 返回值赋值给i，此时count值被重置成原来的值。 例1： package algorithms.com.guan.javajicu; public class Inc { public static void main(String[] args) { Inc inc = new Inc(); int i = 0; inc.fermin(i); i= i ++; System.out.println(i); } void fermin(int i){ i++; } } 程序输出结果为0 例3： public class Test2{ public void add(Byte b){ b = b++; } public void test(){ Byte a = 127; Byte b = 127; add(++a); System.out.print(a + &quot; &quot;); add(b); System.out.print(b + &quot;&quot;); } } 执行test()函数后，程序输出为：-128 127 &amp;&amp;和&amp; 两者都可以用作逻辑与运算符。当运算符两边的表达式都为true时，整个运算结果才为true；否则只要有一边表达式为false，则运算结果为false。 两者的区别如下： (1) &amp;&amp;具有短路的功能，若该运算符左边为false，运算符右边表达式不执行；而&amp;作为逻辑与运算符时不具备短路功能，若该运算符左边为false，运算符右边表达式还会继续执行。 (2) &amp;还可以作为按位与运算符，当&amp;运算符两边的表达式是int类型时，&amp;表示按位与操作。例如 0x31 &amp; 0x0f = 0x01。 很多时候我们可能都需要使用&amp;&amp;而不是&amp;。 例如在用户登录时验证用户名不是null且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(&quot;&quot;)，二者的顺序不能交换，更不能用&amp;运算符。 因为如果第一个条件不成立，根本不能进行字符串的equals比较，否则会报NullPointerException异常。 注意：运算符 | 和运算符 || 的差别也是如此。 &lt;&lt; 将一个数左移n位，相当于这个数乘以2的n次方 2 &lt;&lt; 3 = 16 >>和&gt;&gt;&gt; >&gt; 表示带符号右移，正数结果为正，高位补0；负数结果为负，高位补1 int x1=5&gt;&gt;2; int x2=-5&gt;&gt;2; 5在计算机中补码表示为： 0 0000000 00000000 00000000 00000101 5为正数，5&gt;&gt;2，高位补0： 0 0000000 00000000 00000000 00000001，5为正数，符号位保留为0，结果x1=1 -5在计算机中补码表示为： 1 1111111 11111111 11111111 11111011 -5为正数，-5&gt;&gt;2，高位补1：1 1111111 11111111 11111111 11111110，-5为负数，符号位保留位1，结果x2=-2 >&gt;&gt; 表示无符号右移，左边空出的位以0填充 int y1=5&gt;&gt;&gt;2; int y2=-5&gt;&gt;&gt;2; 5在计算机中补码表示为： 00000000 00000000 00000000 00000101 5&gt;&gt;&gt;2，左边空出的位补0： 00000000 00000000 00000000 00000001，结果y1=1 -5在计算机中补码表示为： 11111111 11111111 11111111 11111011 -5&gt;&gt;&gt;2，左边空出的位补0：00111111 11111111 11111111 11111110，结果为y2=1073741822 问：switchswitch(expr)中，expr是一个整数表达式，因此传递给switch和case语句的参数应该是byte、short、int、char或者其对应的封装类以及Enum类型(byte，short，char都可以隐式转换为int，因此也可以作为expr)，long和String(在Java7中，也支持了String类型)都不能用于swtich表达式。 enum Var { LEFT, RIGHT } public static void main(String[] args) { Var e = Var.LEFT; switch (e) { case LEFT: System.out.println(&quot;----left-----&quot;); break; case RIGHT: System.out.println(&quot;----right-----&quot;); break; default: System.out.println(&quot;----stay around-----&quot;); break; } } 在switch语句中，表达式的值不能是null，否则会在运行时抛出NullPointerException。在case子句中也不能使用null，否则会出现编译错误。 问：switch与breakswitch结构中匹配的case子句中如果没有break跳出执行，那么程序执行完case子句后不会跳出，将会继续执行后续的case子句，直到遇到break跳出switch；如果一直没有遇到break，程序将一直执行到整个结构结束。 例1： public class SwitchTest{//1 public static void main(String[] args) { System.out.println(switchit(4)); } public static int switchit(int x) { int j=1; switch (x) { case 1:j++; case 2:j++; case 3:j++; case 4:j++; case 5:j++; default:j++; } return j+x; } } 程序将会输出8 例2： public static int getValue(int i) { int result = 0; switch (i) { case 1: result = result + i; case 2: result = result + i * 2; case 3: result = result + i * 3; } return result; } 调用getValue(2)将返回10 问：值传递和引用传递？java内的传递都是值传递。 (1) 对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。 (2) 对引用型变量而言的，传递的是该对象地址的一个副本，所以对引用型变量进行操作会同时改变原对象。 例1： public class Tester{ public static void main(String[] args){ Integer var1=new Integer(1); Integer var2=var1; doSomething(var2); System.out.println(var1.intValue()); System.out.println(var1==var2); } public static void doSomething(Integer integer){ integer=new Integer(2); } } 程序运行输出如下： 1 true 例2：注意下一评论 问：可变参数JDK 1.5开始，Java支持给一个方法传递同类型的可变参数，且只能指定一个可变参数。可变参数必须是方法的最后一个参数，任何普通参数必须在可变参数之前声明。 public void fun(int len, String ...str) { }","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]},{"title":"01-Java概述","slug":"01-Java概述","date":"2017-02-13T09:22:19.000Z","updated":"2017-10-21T13:19:20.990Z","comments":true,"path":"2017/02/13/01-Java概述/","link":"","permalink":"https://hepsilion.github.io/2017/02/13/01-Java概述/","excerpt":"Java概述","text":"Java概述 推荐阅读：近5年133个Java面试问题列表 推荐阅读：Java笔试面试题整理第一波，第二波，第三波，第四波，第五波已包含大部分，第六波（修正版）线程池未包含，第七波NIO和IO未包含，第八波 问：什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？Java源文件被javac编译成能被Java虚拟机执行的.class字节码文件，Java虚拟机是一个可以执行Java字节码的虚拟机进程，它拥有自己完善的硬件架构，如堆栈、寄存器，还具有相应的指令系统。 Java虚拟机对开发者屏蔽了与具体操作系统平台相关的信息，使得Java源文件只需要被编译成可以在JVM上运行的字节码文件，就可以由相应平台的虚拟机在具体平台上解释运行，从而实现一次编译，处处执行。这样，Java被设计成允许应用程序可以运行在任意的平台上，而不需要程序员为每一个平台单独重写或者是重新编译。 问：动态语言和静态语言动态语言：运行时执行类型检查，如PHP、Ruby、Python等。 静态语言：编译时执行类型检查，如C、C++、Java和C#等。 例1：比较一下Java和JavaSciprt Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言 问：编译型语言和解释型语言例1 问：JDK和JRE的区别是什么？Java运行时环境(JRE)包括Java虚拟机、Java核心类库和支持文件，JVM对Java字节码文件进行解释执行。只有JRE只能执行Java程序，不能进行java程序的开发。 Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。 例1： JRE判断程序是否执行结束的标准是：所有的前台线程执行完毕 问：一个”.java”源文件中是否可以包含多个类(不是内部类)？有什么限制？一个”.java”源文件中可以包含多个类，但最多只能有一个public类。如果某一个类的修饰符是public，其类名与文件名必须相同。 例1：Java代码查错 Something类的文件名叫OtherThing.java，其中定义的代码如下： class Something { public static void main(String[] args) { System.out.println(&quot;Do something ...&quot;); } } 正确。Java中Class名字不一定要和其文件名相同，但public class的名字必须和文件名相同。 但是这里的main方法不是程序的入口，只能被Something对象调用。 问：javac例1：下列说法正确的有哪些？ A. 环境变量可在编译source code时指定 B. 在编译程序时，所能指定的环境变量不包括class path C. javac一次可同时编译数个Java源文件 D. javac.exe能指定编译结果要置于哪个目录（directory） 答案：A C D 问：JAVA的事件委托机制和垃圾回收机制Java事件委托机制：一个源产生一个事件并将它送到一个或多个监听器那里。在这种方案中，监听器简单的等待，直到它收到一个事件。一旦事件被接受，监听器将处理这个事件，然后返回。 垃圾回收机制：垃圾收集是将分配给对象但不再使用的内存回收或释放的过程。如果一个对象没有指向它的引用或者其赋值为null，则此对象适合进行垃圾回收。 问：assertion(断言)assertion(断言)是软件开发中常用的一种调试方式，很多开发语言都支持这种机制。 在实现中，assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，assert将给出警告或退出。 一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启；为了提高性能，在软件发布后，assertion检查通常是关闭的。 例1： public class Test { public static void main(String[] args) throws Exception { int i = 0; for (i = 0; i &lt; 5; i++) { System.out.println(i); } // 假设程序不小心多了一句--i; --i; assert i == 5; } } 运行：Run --&gt; Run Configurations... --&gt; 选择Arguments选项卡 --&gt; 在VM arguments文本框中输入：-ea 注意：中间没有空格，如果输入 -da 表示禁止断言。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hepsilion.github.io/tags/Java/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://hepsilion.github.io/categories/Java基础/"}]}]}